MODULE PCS;
	IMPORT Streams, Texts, UTF8Strings, StringPool, PCM;
CONST 
	Trace = FALSE; 
	MaxStrLen* = 256; 
	MaxIdLen = 32; 
	Eot* = 0X; 
	ObjectMarker = 20X; 
	char* = 1; 
	integer* = 2; 
	longinteger* = 3; 
	real* = 4; 
	longreal* = 5; 
	null* = 0; 
	times* = 1; 
	slash* = 2; 
	div* = 3; 
	mod* = 4; 
	and* = 5; 
	plus* = 6; 
	minus* = 7; 
	or* = 8; 
	eql* = 9; 
	neq* = 10; 
	lss* = 11; 
	leq* = 12; 
	gtr* = 13; 
	geq* = 14; 
	in* = 15; 
	is* = 16; 
	arrow* = 17; 
	period* = 18; 
	comma* = 19; 
	colon* = 20; 
	upto* = 21; 
	rparen* = 22; 
	rbrak* = 23; 
	rbrace* = 24; 
	of* = 25; 
	then* = 26; 
	do* = 27; 
	to* = 28; 
	by* = 29; 
	lparen* = 30; 
	lbrak* = 31; 
	lbrace* = 32; 
	not* = 33; 
	becomes* = 34; 
	number* = 35; 
	nil* = 36; 
	true* = 37; 
	false* = 38; 
	string* = 39; 
	ident* = 40; 
	semicolon* = 41; 
	bar* = 42; 
	end* = 43; 
	else* = 44; 
	elsif* = 45; 
	until* = 46; 
	if* = 47; 
	case* = 48; 
	while* = 49; 
	repeat* = 50; 
	for* = 51; 
	loop* = 52; 
	with* = 53; 
	exit* = 54; 
	passivate* = 55; 
	return* = 56; 
	refines* = 57; 
	implements* = 58; 
	array* = 59; 
	definition* = 60; 
	object* = 61; 
	record* = 62; 
	pointer* = 63; 
	begin* = 64; 
	code* = 65; 
	const* = 66; 
	type* = 67; 
	var* = 68; 
	procedure* = 69; 
	import* = 70; 
	module* = 71; 
	eof* = 72; 
	finally* = 73; 
	backslash* = 74; 
	scalarproduct* = 75; 
	elementproduct* = 76; 
	elementquotient* = 77; 
	dtimes* = 78; 
	transpose* = 79; 
	eeql* = 80; 
	eneq* = 81; 
	elss* = 82; 
	eleq* = 83; 
	egtr* = 84; 
	egeq* = 85; 
	qmark* = 86; 
TYPE 
	Name* = StringPool.Index; 

	String* = ARRAY MaxStrLen OF CHAR; 

	Buffer = POINTER TO ARRAY OF CHAR; 

	Token* = SHORTINT; 

	Scanner* = OBJECT 
	VAR 
		buffer: Buffer; 
		pos: LONGINT; 
		ch-: CHAR; 
		name-: Name; 
		str*: String; 
		numtyp-: INTEGER; 
		intval-: LONGINT; 
		longintval-: HUGEINT; 
		realval-: REAL; 
		lrlval-: LONGREAL; 
		numStartPos, numEndPos: LONGINT; 
		curpos-, errpos-: LONGINT; 
		isNummer: BOOLEAN; 
		lcase-, ucase-: BOOLEAN; 
		firstId: BOOLEAN; 
		n1: CHAR; 

		PROCEDURE ^ err(n: INTEGER); 
		PROCEDURE ^ NextChar*; 
		PROCEDURE ^ SkipUntilNextEnd*(VAR sym: SHORTINT); 
		PROCEDURE ^ Str(VAR sym: SHORTINT); 
		PROCEDURE ^ Identifier(VAR sym: SHORTINT; check: BOOLEAN); 
		PROCEDURE ^ Number; 
		PROCEDURE ^ GetNumAsString*(VAR val: ARRAY OF CHAR); 
		PROCEDURE ^ Get*(VAR s: SHORTINT); 
		PROCEDURE ^ IsOperatorValid*(): BOOLEAN; 
	END Scanner; 
VAR 
	opTable: ARRAY 86 OF Name; 
	reservedChar-, newChar: ARRAY 256 OF BOOLEAN; 

	PROCEDURE ^ GetOpName*(op: SHORTINT; VAR name: Name); 
	PROCEDURE ^ ForkScanner*(s: Scanner): Scanner; 
	PROCEDURE ^ NewScanner(b: Buffer; pos, curpos: LONGINT): Scanner; 
	PROCEDURE ^ InitWithText*(t: Texts.Text; pos: LONGINT): Scanner; 
	PROCEDURE ^ ExpandBuf(VAR oldBuf: Buffer; newSize: LONGINT); 
	PROCEDURE ^ InitWithReader*(r: Streams.Reader; size, pos: LONGINT): Scanner; 
	PROCEDURE ^ InitReservedChars; 
	PROCEDURE ^ InitNewChar; 
	PROCEDURE ^ CreateOperatorTable; 
BEGIN
END PCS.
