MODULE FoxIntermediateBackend;
	IMPORT Basic := FoxBasic, SyntaxTree := FoxSyntaxTree, SemanticChecker := FoxSemanticChecker, Backend := FoxBackend, Global := FoxGlobal, Scanner := FoxScanner, IntermediateCode := FoxIntermediateCode, Sections := FoxSections, BinaryCode := FoxBinaryCode, Printout := FoxPrintout, SYSTEM, Strings, Options, Streams, Compiler, Formats := FoxFormats, SymbolFileFormat := FoxTextualSymbolFile, D := Debugging, Fingerprinter := FoxFingerprinter, StringPool, CRC;
CONST 
	ModeUndefined = 0; 
	ModeReference = 1; 
	ModeValue = 2; 
	ArrayDimTable = 2; 
	MathPtrOffset = 0; 
	MathAdrOffset = 1; 
	MathFlagsOffset = 2; 
	MathDimOffset = 3; 
	MathElementSizeOffset = 4; 
	MathLenOffset = 5; 
	MathIncrOffset = 6; 
	TensorFlag* = 0; 
	RangeFlag* = 1; 
	StackFlag* = 2; 
	StaticFlag* = 1; 
	WithTrap* = 1; 
	CaseTrap* = 2; 
	ReturnTrap* = 3; 
	TypeEqualTrap* = 5; 
	TypeCheckTrap* = 6; 
	IndexCheckTrap* = 7; 
	AssertTrap* = 8; 
	ArraySizeTrap* = 9; 
	ArrayFormTrap* = 10; 
	SetElementTrap* = 11; 
	NegativeDivisorTrap* = 12; 
	NoReturnTrap* = 16; 
	NilPointerTrap* = 17; 
	RethrowTrap* = 18; 
	Trace = FALSE; 
	TraceRegisterUsageCount = TRUE; 
	ArrayAlignment = (8 * 8); 
	NumberSystemCalls* = 12; 
	SysNewRec* = 0; 
	SysNewArr* = 1; 
	SysNewSys* = 2; 
	SysCaseTable* = 3; 
	SysProcAddr* = 4; 
	SysLock* = 5; 
	SysUnlock* = 6; 
	SysStart* = 7; 
	SysAwait* = 8; 
	SysInterfaceLookup* = 9; 
	SysRegisterInterface* = 10; 
	SysGetProcedure* = 11; 
	DefaultBuiltinsModuleName = \"Builtins"\; 
	DefaultTraceModuleName = \"KernelLog"\; 
	ChannelModuleName = \"Channels"\; 
	NonPointer =  -1; 
	NoType = 0; 
	LhsIsPointer = 0; 
	RhsIsPointer = 1; 
	BasePointerTypeSize = 5; 
	BaseArrayTypeSize = (BasePointerTypeSize + 3); 
	LengthOffset = (BasePointerTypeSize + 0); 
	DataOffset = (BasePointerTypeSize + 1); 
	DescriptorOffset = (BasePointerTypeSize + 2); 
	BaseRecordTypeSize = (BasePointerTypeSize + 2); 
	ActionOffset = (BasePointerTypeSize + 0); 
	MonitorOffset = (BasePointerTypeSize + 1); 
	BaseObjectTypeSize = BaseRecordTypeSize; 
	ActionTypeSize = 3; 
	MonitorTypeSize = 7; 
	ProcessorOffset = (BaseObjectTypeSize + 1); 
	StackLimitOffset* = (BaseObjectTypeSize + 3); 
	QuantumOffset = (BaseObjectTypeSize + 4); 
	SmallMatrixFlag = 3; 
	SmallVectorFlag = 3; 
	Size2Flag = 4; 
	Size3Flag = 5; 
	Size4Flag = 6; 
	Size5Flag = 7; 
	Size6Flag = 8; 
	Size7Flag = 9; 
	Size8Flag = 10; 
	ReflectionSupport = TRUE; 
	ProtectModulesPointers = FALSE; 
	CreateProcedureDescInfo = TRUE; 
	WarningDynamicLoading = FALSE; 
	SysvABI = {SyntaxTree.CCallingConvention}; 
	SysvABIorWINAPI = {SyntaxTree.CCallingConvention, SyntaxTree.WinAPICallingConvention}; 
TYPE 
	Position = SyntaxTree.Position; 

	SupportedInstructionProcedure* = PROCEDURE {DELEGATE}(CONST instr: IntermediateCode.Instruction; VAR moduleName, procedureName: ARRAY OF CHAR):BOOLEAN; 

	SupportedImmediateProcedure* = PROCEDURE {DELEGATE}(CONST op: IntermediateCode.Operand):BOOLEAN; 

	WriteBackCall = POINTER TO RECORD 
		call: SyntaxTree.ProcedureCallDesignator; 
		next: WriteBackCall; 
	END; 

	Operand = RECORD 
		mode: SIGNED8; 
		op: IntermediateCode.Operand; 
		tag: IntermediateCode.Operand; 
		extra: IntermediateCode.Operand; 
		dimOffset: SIZE; 
		availability: INTEGER; 
	END; 

	Fixup = POINTER TO RECORD 
		pc: SIZE; 
		nextFixup: Fixup; 
	END; 

	Label = OBJECT 
	VAR 
		fixups: Fixup; 
		section: IntermediateCode.Section; 
		pc: SIZE; 

		PROCEDURE ^  & InitLabel(section: IntermediateCode.Section); 
		PROCEDURE ^ Resolve(pc: SIZE); 
		PROCEDURE ^ AddFixup(at: SIZE); 
	END Label; 

	ConditionalBranch = PROCEDURE {DELEGATE}(label: Label; op1, op2: IntermediateCode.Operand); 

	DeclarationEmitter = OBJECT 
	VAR 
		backend: IntermediateBackend; 
		implementationEmitter: ImplementationEmitter; 
		meta: MetaDataGenerator; 
		system: Global.System; 
		currentScope: SyntaxTree.Scope; 
		module: Sections.Module; 
		moduleSelf: SyntaxTree.Variable; 
		dump: BOOLEAN; 
		forceModuleBody: BOOLEAN; 
		addressType: IntermediateCode.Type; 

		PROCEDURE ^  & Init(system: Global.System; implementationEmitter: ImplementationEmitter; backend: IntermediateBackend; forceModuleBody, dump: BOOLEAN); 
		PROCEDURE ^ Error(position: Position; CONST s: ARRAY OF CHAR); 
		PROCEDURE ^ Type(x: SyntaxTree.Type); 
		PROCEDURE ^ QualifiedType(x: SyntaxTree.QualifiedType); 
		PROCEDURE ^ RecordType(x: SyntaxTree.RecordType); 
		PROCEDURE ^ CellType(x: SyntaxTree.CellType); 
		PROCEDURE ^ Variable(x: SyntaxTree.Variable); 
		PROCEDURE ^ Parameter(x: SyntaxTree.Parameter); 
		PROCEDURE ^ TypeDeclaration(x: SyntaxTree.TypeDeclaration); 
		PROCEDURE ^ Constant(x: SyntaxTree.Constant); 
		PROCEDURE ^ Scope(x: SyntaxTree.Scope); 
		PROCEDURE ^ Parameters(first: SyntaxTree.Parameter); 
		PROCEDURE ^ Procedure(x: SyntaxTree.Procedure); 
		PROCEDURE ^ AddBodyCallStub(bodyProcedure: SyntaxTree.Procedure); 
		PROCEDURE ^ AddStackAllocation(symbol: SyntaxTree.Symbol; initStack: Basic.Integer); 
		PROCEDURE ^ Module(x: SyntaxTree.Module; module: Sections.Module); 
	END DeclarationEmitter; 

	UsedArray = POINTER TO ARRAY OF RECORD 
		count: SIZE; 
		map: SIZE; 
		type: IntermediateCode.Type; 
		class: IntermediateCode.RegisterClass; 
	END; 

	RegisterUsageCount = OBJECT 
	VAR 
		used: UsedArray; 
		count: SIZE; 

		PROCEDURE ^  & Init; 
		PROCEDURE ^ Grow; 
		PROCEDURE ^ Next(type: IntermediateCode.Type; class: IntermediateCode.RegisterClass): SIZE; 
		PROCEDURE ^ IncUse(register: SIZE); 
		PROCEDURE ^ DecUse(register: SIZE); 
		PROCEDURE ^ Map(register: SIZE): SIZE; 
		PROCEDURE ^ Use(register: SIZE): SIZE; 
	END RegisterUsageCount; 

	RegisterEntry = POINTER TO RECORD 
		prev, next: RegisterEntry; 
		register: SIZE; 
		registerClass: IntermediateCode.RegisterClass; 
		type: IntermediateCode.Type; 
	END; 

	VariableUse = ARRAY 32 OF SET; 

	Variables = OBJECT (Basic.List)
	VAR 
		inUse: VariableUse; 
		registerIndex: SIGNED32; 
		nameIndex: SIGNED32; 

		PROCEDURE ^  & Init; 
		PROCEDURE ^ Clear*; 
		PROCEDURE ^ GetUID(): SyntaxTree.Identifier; 
		PROCEDURE ^ GetUsage(VAR use: VariableUse); 
		PROCEDURE ^ SetUsage(CONST use: VariableUse); 
		PROCEDURE ^ GetVariable(i: SIZE): SyntaxTree.Variable; 
		PROCEDURE ^ SetVariable(pos: SIZE; v: SyntaxTree.Variable); 
		PROCEDURE ^ Occupy(pos: SIZE); 
		PROCEDURE ^ Occupied(pos: SIZE): BOOLEAN; 
		PROCEDURE ^ AddVariable(v: SyntaxTree.Variable); 
		PROCEDURE ^ CompatibleType(t1, t2: SyntaxTree.Type): BOOLEAN; 
		PROCEDURE ^ GetFreeVariable(type: SyntaxTree.Type; untraced: BOOLEAN; VAR pos: SIZE): SyntaxTree.Variable; 
	END Variables; 

	ImplementationEmitter = OBJECT 
	TYPE 
		Context = RECORD 
			section: IntermediateCode.Section; 
			registerUsageCount: RegisterUsageCount; 
			usedRegisters: RegisterEntry; 
			temporaries: Variables; 
		END; 

		; 
	VAR 
		system: Global.System; 
		section: IntermediateCode.Section; 
		module: Sections.Module; 
		moduleScope: SyntaxTree.ModuleScope; 
		awaitProcCounter, labelId, constId, caseId: SIGNED32; 
		hiddenPointerType: SyntaxTree.RecordType; 
		delegatePointerType: SyntaxTree.RecordType; 
		checker: SemanticChecker.Checker; 
		backend: IntermediateBackend; 
		meta: MetaDataGenerator; 
		position: Position; 
		moduleSelf: SyntaxTree.Variable; 
		currentScope: SyntaxTree.Scope; 
		destination: IntermediateCode.Operand; 
		arrayDestinationTag: IntermediateCode.Operand; 
		arrayDestinationDimension: SIZE; 
		currentLoop: Label; 
		exitLabel: Label; 
		locked: BOOLEAN; 
		registerUsageCount: RegisterUsageCount; 
		usedRegisters: RegisterEntry; 
		nil, one, fp, sp, ap, lr, true, false: IntermediateCode.Operand; 
		booleanType, addressType, setType, sizeType, byteType, characterType, signed32, signed64: IntermediateCode.Type; 
		commentPrintout: Printout.Printer; 
		dump: Streams.Writer; 
		tagsAvailable: BOOLEAN; 
		supportedInstruction: SupportedInstructionProcedure; 
		supportedImmediate: SupportedImmediateProcedure; 
		inData: BOOLEAN; 
		emitLabels: BOOLEAN; 
		builtinsModuleName: SyntaxTree.IdentifierString; 
		indexCounter: SIGNED32; 
		profile: BOOLEAN; 
		profileId, profileInit: IntermediateCode.Section; 
		profileInitPatchPosition: SIZE; 
		numberProcedures: SIGNED32; 
		procedureResultDesignator: SyntaxTree.Designator; 
		operatorInitializationCodeSection: IntermediateCode.Section; 
		fingerprinter: Fingerprinter.Fingerprinter; 
		temporaries: Variables; 
		canBeLoaded: BOOLEAN; 
		currentIsInline: BOOLEAN; 
		currentInlineExit: Label; 
		moduleBodySection: IntermediateCode.Section; 
		NeedDescriptor: BOOLEAN; 
		cooperativeSwitches: BOOLEAN; 
		lastSwitchPC: SIZE; 
		isUnchecked: BOOLEAN; 
		isUntracked: BOOLEAN; 
		availableSymbols: ARRAY 1024 OF RECORD 
			symbol: SyntaxTree.Symbol; 
			inMemory, inRegister: BOOLEAN; 
			register: IntermediateCode.Operand; 
			memory: IntermediateCode.Operand; 
		END; 
		modifyAssignmentCounter := 0: SIGNED32; 

		PROCEDURE ^  & Init(system: Global.System; checker: SemanticChecker.Checker; supportedInstructionProcedure: SupportedInstructionProcedure; supportedImmediateProcedure: SupportedImmediateProcedure; emitLabels: BOOLEAN; CONST runtime: SyntaxTree.IdentifierString; backend: IntermediateBackend); 
		PROCEDURE ^ SwitchContext(new: IntermediateCode.Section): Context; 
		PROCEDURE ^ ReturnToContext(context: Context); 
		PROCEDURE ^ NewSection(list: Sections.SectionList; type: SIGNED8; CONST name: Basic.SegmentedName; syntaxTreeSymbol: SyntaxTree.Symbol; dump: BOOLEAN): IntermediateCode.Section; 
		PROCEDURE ^ AcquireRegister(CONST type: IntermediateCode.Type; class: IntermediateCode.RegisterClass): SIZE; 
		PROCEDURE ^ GetFingerprintString(symbol: SyntaxTree.Symbol; VAR string: ARRAY OF CHAR); 
		PROCEDURE ^ GetCodeSectionNameForSymbol(symbol: SyntaxTree.Symbol; VAR name: Basic.SegmentedName); 
		PROCEDURE ^ TraceEnter(CONST s: ARRAY OF CHAR); 
		PROCEDURE ^ TraceExit(CONST s: ARRAY OF CHAR); 
		PROCEDURE ^ Emit(instruction: IntermediateCode.Instruction); 
		PROCEDURE ^ EmitTrap(position: Position; trapNo: SIGNED64); 
		PROCEDURE ^ EmitEnter(section: IntermediateCode.Section; position: Position; procedure: SyntaxTree.Procedure; callconv: SIGNED32; varSize: SIGNED32); 
		PROCEDURE ^ Enter(position: Position; callconv: SIGNED32; varSize: SIGNED32): IntermediateCode.Instruction; 
		PROCEDURE ^ Leave(position: Position; callconv: SIGNED32): IntermediateCode.Instruction; 
		PROCEDURE ^ EmitLeave(section: IntermediateCode.Section; position: Basic.Position; procedure: SyntaxTree.Procedure; callconv: SIGNED32); 
		PROCEDURE ^ Statement(x: SyntaxTree.Statement); 
		PROCEDURE ^ MakeMemory(VAR res: IntermediateCode.Operand; op: IntermediateCode.Operand; type: IntermediateCode.Type; offset: SIZE); 
		PROCEDURE ^ ToMemory(VAR res: IntermediateCode.Operand; type: IntermediateCode.Type; offset: SIZE); 
		PROCEDURE ^ LoadValue(VAR operand: Operand; type: SyntaxTree.Type); 
		PROCEDURE ^ Evaluate(CONST x: SyntaxTree.Expression; VAR result: Operand); 
		PROCEDURE ^ Designate(x: SyntaxTree.Expression; VAR result: Operand); 
		PROCEDURE ^ DesignateAndLoad(x: SyntaxTree.Expression; VAR result: Operand); 
		PROCEDURE ^ Condition(CONST x: SyntaxTree.Expression; label: Label; reason: BOOLEAN); 
		PROCEDURE ^ EvaluateUnaryExpression(x: SyntaxTree.UnaryExpression; VAR result: Operand); 
		PROCEDURE ^ EvaluateBinaryExpression(x: SyntaxTree.BinaryExpression; VAR result: Operand); 
		PROCEDURE ^ EvaluateSet(x: SyntaxTree.Set; VAR result: Operand); 
		PROCEDURE ^ NewRegisterOperand(type: IntermediateCode.Type): IntermediateCode.Operand; 
		PROCEDURE ^ UnuseRegister(register: SIZE); 
		PROCEDURE ^ UseRegister(register: SIZE); 
		PROCEDURE ^ ReleaseIntermediateOperand(CONST op: IntermediateCode.Operand); 
		PROCEDURE ^ UseIntermediateOperand(CONST op: IntermediateCode.Operand); 
		PROCEDURE ^ ReleaseOperand(CONST op: Operand); 
		PROCEDURE ^ SaveRegisters; 
		PROCEDURE ^ ReleaseUsedRegisters(VAR saved: RegisterEntry); 
		PROCEDURE ^ ReleaseParameterRegisters; 
		PROCEDURE ^ RestoreRegisters(CONST saved: RegisterEntry); 
		PROCEDURE ^ RestoreRegisterUse(CONST saved: RegisterEntry); 
		PROCEDURE ^ CheckRegistersFree; 
		PROCEDURE ^ Reuse2(VAR result: IntermediateCode.Operand; src1, src2: IntermediateCode.Operand); 
		PROCEDURE ^ Reuse2a(VAR result: IntermediateCode.Operand; src1, src2: IntermediateCode.Operand; VAR alternative: IntermediateCode.Operand); 
		PROCEDURE ^ Reuse1(VAR result: IntermediateCode.Operand; src1: IntermediateCode.Operand); 
		PROCEDURE ^ Reuse1a(VAR result: IntermediateCode.Operand; src1: IntermediateCode.Operand; VAR alternative: IntermediateCode.Operand); 
		PROCEDURE ^ ReuseCopy(VAR result: IntermediateCode.Operand; src1: IntermediateCode.Operand); 
		PROCEDURE ^ TransferToRegister(VAR result: IntermediateCode.Operand; src: IntermediateCode.Operand); 
		PROCEDURE ^ NewLabel(): Label; 
		PROCEDURE ^ EndBasicBlock; 
		PROCEDURE ^ BeginBasicBlock; 
		PROCEDURE ^ SetLabel(label: Label); 
		PROCEDURE ^ LabelOperand(label: Label): IntermediateCode.Operand; 
		PROCEDURE ^ BrL(label: Label); 
		PROCEDURE ^ BrgeL(label: Label; left, right: IntermediateCode.Operand); 
		PROCEDURE ^ BrltL(label: Label; left, right: IntermediateCode.Operand); 
		PROCEDURE ^ BreqL(label: Label; left, right: IntermediateCode.Operand); 
		PROCEDURE ^ BrneL(label: Label; left, right: IntermediateCode.Operand); 
		PROCEDURE ^ Convert(VAR operand: IntermediateCode.Operand; type: IntermediateCode.Type); 
		PROCEDURE ^ TrapC(br: ConditionalBranch; left, right: IntermediateCode.Operand; trapNo: SIGNED64); 
		PROCEDURE ^ CheckSetElement(o: IntermediateCode.Operand); 
		PROCEDURE ^ SetFromRange(x: SyntaxTree.RangeExpression): IntermediateCode.Operand; 
		PROCEDURE ^ DesignateMathArrayExpression(x: SyntaxTree.MathArrayExpression; VAR result: Operand); 
		PROCEDURE ^ TypeTest(tag: IntermediateCode.Operand; type: SyntaxTree.Type; label: Label; reason: BOOLEAN; withPart: BOOLEAN); 
		PROCEDURE ^ Error(position: Position; CONST s: ARRAY OF CHAR); 
		PROCEDURE ^ Warning(position: Position; CONST s: ARRAY OF CHAR); 
		PROCEDURE ^ CreateTraceModuleMethod(mod: SyntaxTree.Module); 
		PROCEDURE ^ CallAssignPointer(CONST dst, src: IntermediateCode.Operand); 
		PROCEDURE ^ CallAssignMethod(CONST dst, src: IntermediateCode.Operand; type: SyntaxTree.Type); 
		PROCEDURE ^ CreateAssignProcedure(recordType: SyntaxTree.RecordType); 
		PROCEDURE ^ CallTraceMethod(CONST register: IntermediateCode.Operand; type: SyntaxTree.Type); 
		PROCEDURE ^ CreateTraceMethod(recordType: SyntaxTree.RecordType); 
		PROCEDURE ^ CreateResetProcedure(recordType: SyntaxTree.RecordType); 
		PROCEDURE ^ CreateResetMethod(scope: SyntaxTree.ProcedureScope); 
		PROCEDURE ^ CallResetProcedure(dest, tag: IntermediateCode.Operand; type: SyntaxTree.Type); 
		PROCEDURE ^ ResetVariables(scope: SyntaxTree.ProcedureScope); 
		PROCEDURE ^ CreateProcedureDescriptor(procedure: SyntaxTree.Procedure); 
		PROCEDURE ^ AddImport(CONST moduleName: ARRAY OF CHAR; VAR module: SyntaxTree.Module; force: BOOLEAN): BOOLEAN; 
		PROCEDURE ^ EnsureSymbol(CONST moduleName, procedureName: SyntaxTree.IdentifierString); 
		PROCEDURE ^ ConditionValue(x: SyntaxTree.Expression): Operand; 
		PROCEDURE ^ GetDynamicSize(type: SyntaxTree.Type; tag: IntermediateCode.Operand): IntermediateCode.Operand; 
		PROCEDURE ^ GetArrayLength(type: SyntaxTree.Type; tag: IntermediateCode.Operand): IntermediateCode.Operand; 
		PROCEDURE ^ GetSizeFromTag(tag: IntermediateCode.Operand): IntermediateCode.Operand; 
		PROCEDURE ^ GetArrayOfBytesSize(e: SyntaxTree.Expression; tag: IntermediateCode.Operand): IntermediateCode.Operand; 
		PROCEDURE ^ GetRuntimeProcedure(CONST moduleName, procedureName: ARRAY OF CHAR; VAR procedure: SyntaxTree.Procedure; force: BOOLEAN): BOOLEAN; 
		PROCEDURE ^ GetTypeDescriptor(CONST moduleName, typeName: ARRAY OF CHAR; VAR name: Basic.SegmentedName): SyntaxTree.Symbol; 
		PROCEDURE ^ CallThisChecked(position: Position; CONST moduleName, procedureName: ARRAY OF CHAR; numberParameters: SIGNED32; checkNumParameters: BOOLEAN); 
		PROCEDURE ^ CallThis(position: Position; CONST moduleName, procedureName: ARRAY OF CHAR; numberParameters: SIGNED32); 
		PROCEDURE ^ CompareString(br: ConditionalBranch; label: Label; leftExpression, rightExpression: SyntaxTree.Expression); 
		PROCEDURE ^ CopyString(leftExpression, rightExpression: SyntaxTree.Expression); 
		PROCEDURE ^ DesignateConversion(x: SyntaxTree.Conversion; VAR result: Operand); 
		PROCEDURE ^ DesignateSymbolDesignator(x: SyntaxTree.SymbolDesignator; VAR result: Operand); 
		PROCEDURE ^ BoundCheck(index, length: IntermediateCode.Operand); 
		PROCEDURE ^ DimensionCheck(type: SyntaxTree.MathArrayType; base, dim: IntermediateCode.Operand; op: ConditionalBranch); 
		PROCEDURE ^ MathIndexDesignator(x: SyntaxTree.IndexDesignator; VAR result: Operand); 
		PROCEDURE ^ ArrayLength(type: SyntaxTree.Type; dim: SIZE; tag: IntermediateCode.Operand): IntermediateCode.Operand; 
		PROCEDURE ^ CopyInt(VAR res: IntermediateCode.Operand; x: IntermediateCode.Operand); 
		PROCEDURE ^ AddInt(VAR res: IntermediateCode.Operand; x, y: IntermediateCode.Operand); 
		PROCEDURE ^ MulInt(VAR res: IntermediateCode.Operand; x, y: IntermediateCode.Operand); 
		PROCEDURE ^ DivInt(VAR res: IntermediateCode.Operand; x, y: IntermediateCode.Operand); 
		PROCEDURE ^ IndexDesignator(x: SyntaxTree.IndexDesignator; VAR result: Operand); 
		PROCEDURE ^ DesignateIndexDesignator(x: SyntaxTree.IndexDesignator; VAR result: Operand); 
		PROCEDURE ^ PrepareTensorDescriptor(expression: SyntaxTree.IndexDesignator): SyntaxTree.Variable; 
		PROCEDURE ^ PushParameter(expression: SyntaxTree.Expression; parameter: SyntaxTree.Parameter; callingConvention: SIGNED32; needsParameterBackup: BOOLEAN; VAR parameterBackup: IntermediateCode.Operand; register: INTEGER); 
		PROCEDURE ^ DesignateInlineCallDesignator(x: SyntaxTree.InlineCallDesignator; VAR result: Operand); 
		PROCEDURE ^ DesignateProcedureCallDesignator(x: SyntaxTree.ProcedureCallDesignator; VAR result: Operand); 
		PROCEDURE ^ TypeDescriptorAdr(t: SyntaxTree.Type): IntermediateCode.Operand; 
		PROCEDURE ^ ProfilerInit; 
		PROCEDURE ^ ProfilerEnterExit(procedureNumber: SIGNED32; enter: BOOLEAN); 
		PROCEDURE ^ ProfilerAddProcedure(procedureNumber: SIGNED32; CONST name: ARRAY OF CHAR); 
		PROCEDURE ^ ProfilerAddModule(CONST name: ARRAY OF CHAR); 
		PROCEDURE ^ ProfilerPatchInit; 
		PROCEDURE ^ RegisterDynamicOperator(operator: SyntaxTree.Operator); 
		PROCEDURE ^ SystemTrace(x: SyntaxTree.ExpressionList; pos: Position); 
		PROCEDURE ^ InitFields(type: SyntaxTree.Type; CONST adr: IntermediateCode.Operand; offset: SIZE; initStatic: BOOLEAN); 
		PROCEDURE ^ InitVariable(VAR variable: SyntaxTree.Variable; initStatic, temporary: BOOLEAN); 
		PROCEDURE ^ MathArrayDim(type: SyntaxTree.MathArrayType; CONST base: IntermediateCode.Operand; VAR result: Operand); 
		PROCEDURE ^ PutMathArrayField(base, value: IntermediateCode.Operand; fieldOffset: SIZE); 
		PROCEDURE ^ PutMathArrayFieldOffset(base, value: IntermediateCode.Operand; fieldOffset, offset: SIZE); 
		PROCEDURE ^ GetMathArrayField(VAR value: IntermediateCode.Operand; base: IntermediateCode.Operand; offset: SIZE); 
		PROCEDURE ^ PutMathArrayLenOrIncr(CONST base, value, dim: IntermediateCode.Operand; incr: BOOLEAN); 
		PROCEDURE ^ PutMathArrayLength(base, value: IntermediateCode.Operand; dim: SIZE); 
		PROCEDURE ^ PutMathArrayIncrement(base, value: IntermediateCode.Operand; dim: SIZE); 
		PROCEDURE ^ GetMathArrayIncrement(type: SyntaxTree.MathArrayType; CONST operand: Operand; VAR dim: IntermediateCode.Operand; check: BOOLEAN; VAR result: Operand); 
		PROCEDURE ^ GetMathArrayLength(type: SyntaxTree.MathArrayType; CONST operand: Operand; VAR dim: IntermediateCode.Operand; check: BOOLEAN; VAR result: Operand); 
		PROCEDURE ^ GetMathArrayLengthAt(type: SyntaxTree.MathArrayType; CONST operand: Operand; dim: SIZE; check: BOOLEAN; VAR result: Operand); 
		PROCEDURE ^ GetMathArrayIncrementAt(type: SyntaxTree.MathArrayType; CONST operand: Operand; dim: SIZE; check: BOOLEAN; VAR result: Operand); 
		PROCEDURE ^ MathArrayLenOrIncr(type: SyntaxTree.MathArrayType; CONST operand: Operand; VAR dim: IntermediateCode.Operand; increment: BOOLEAN; check: BOOLEAN; VAR result: Operand); 
		PROCEDURE ^ ArrayLen(type: SyntaxTree.ArrayType; VAR operand: Operand; VAR dim: IntermediateCode.Operand; VAR result: Operand); 
		PROCEDURE ^ GetTemporaryVariable(type: SyntaxTree.Type; register: BOOLEAN; untraced: BOOLEAN): SyntaxTree.Variable; 
		PROCEDURE ^ GetMathArrayDescriptorType(dimensions: SIZE): SyntaxTree.Type; 
		PROCEDURE ^ PushConstString(CONST s: ARRAY OF CHAR); 
		PROCEDURE ^ PushConstBoolean(b: BOOLEAN); 
		PROCEDURE ^ PushConstSet(v: SET); 
		PROCEDURE ^ PushConstInteger(v: SIZE); 
		PROCEDURE ^ OpenInitializer(symbol: SyntaxTree.Symbol; scope: SyntaxTree.Scope): IntermediateCode.Section; 
		PROCEDURE ^ CloseInitializer(prev: IntermediateCode.Section); 
		PROCEDURE ^ AddPorts(cell: SyntaxTree.Symbol; x: SyntaxTree.CellType); 
		PROCEDURE ^ AddProperty(cellType: SyntaxTree.CellType; cell: SyntaxTree.Symbol; property: SyntaxTree.Property; value: SyntaxTree.Expression); 
		PROCEDURE ^ AddModifiers(cellType: SyntaxTree.CellType; cell: SyntaxTree.Symbol; modifier: SyntaxTree.Modifier); 
		PROCEDURE ^ AppendModifier(VAR to: SyntaxTree.Modifier; this: SyntaxTree.Modifier); 
		PROCEDURE ^ AppendModifiers(VAR to: SyntaxTree.Modifier; this: SyntaxTree.Modifier); 
		PROCEDURE ^ AppendCellTypeModifiers(VAR to: SyntaxTree.Modifier; c: SyntaxTree.CellType); 
		PROCEDURE ^ AddPortProperty(modifier: SyntaxTree.Modifier; value: SyntaxTree.Expression); 
		PROCEDURE ^ AddPortProperties(modifier: SyntaxTree.Modifier); 
		PROCEDURE ^ PushPort(p: SyntaxTree.Expression); 
		PROCEDURE ^ PushString(op: Operand; actualType: SyntaxTree.Type); 
		PROCEDURE ^ Allocate(x: SyntaxTree.BuiltinCallDesignator; VAR result: Operand); 
		PROCEDURE ^ IfMarking(): Label; 
		PROCEDURE ^ MarkPointer(CONST op: IntermediateCode.Operand); 
		PROCEDURE ^ MarkRecord(CONST op, tag: IntermediateCode.Operand); 
		PROCEDURE ^ MarkArray(CONST adr, tag, size: IntermediateCode.Operand); 
		PROCEDURE ^ DesignateBuiltinCallDesignator(x: SyntaxTree.BuiltinCallDesignator; VAR result: Operand); 
		PROCEDURE ^ EvaluateBuiltinCallDesignator(x: SyntaxTree.BuiltinCallDesignator; VAR result: Operand); 
		PROCEDURE ^ DesignateTypeGuardDesignator(x: SyntaxTree.TypeGuardDesignator; VAR result: Operand); 
		PROCEDURE ^ Dereference(VAR operand: Operand; type: SyntaxTree.Type; isUnsafe: BOOLEAN); 
		PROCEDURE ^ DesignateDereferenceDesignator(x: SyntaxTree.DereferenceDesignator; VAR result: Operand); 
		PROCEDURE ^ DesignateSupercallDesignator(x: SyntaxTree.SupercallDesignator; VAR result: Operand); 
		PROCEDURE ^ DesignateSelfDesignator(x: SyntaxTree.SelfDesignator; VAR result: Operand); 
		PROCEDURE ^ DesignateResultDesignator(x: SyntaxTree.ResultDesignator; VAR result: Operand); 
		PROCEDURE ^ GetDataSection(): IntermediateCode.Section; 
		PROCEDURE ^ GetImmediateMem(VAR vop: IntermediateCode.Operand); 
		PROCEDURE ^ DesignateMathArrayValue(x: SyntaxTree.MathArrayValue; VAR result: Operand); 
		PROCEDURE ^ DesignateStringValue(x: SyntaxTree.StringValue; VAR result: Operand); 
		PROCEDURE ^ GetBaseRegister(VAR result: IntermediateCode.Operand; scope, baseScope: SyntaxTree.Scope); 
		PROCEDURE ^ GetAvailability(x: SyntaxTree.Variable): INTEGER; 
		PROCEDURE ^ DesignateVariable(x: SyntaxTree.Variable; VAR result: Operand); 
		PROCEDURE ^ DesignateParameter(x: SyntaxTree.Parameter; VAR result: Operand); 
		PROCEDURE ^ DynamicCallOperand(x: SyntaxTree.Procedure; VAR operand: Operand); 
		PROCEDURE ^ StaticCallOperand(x: SyntaxTree.Procedure; VAR operand: Operand); 
		PROCEDURE ^ DesignateProcedure(x: SyntaxTree.Procedure; VAR result: Operand); 
		PROCEDURE ^ Symbol(x: SyntaxTree.Symbol; VAR result: Operand); 
		PROCEDURE ^ AssignMathArray(left, right: SyntaxTree.Expression); 
		PROCEDURE ^ ModifyAssignments(CONST value: IntermediateCode.Operand); 
		PROCEDURE ^ CopySize(left: SyntaxTree.Expression; tag: IntermediateCode.Operand): IntermediateCode.Operand; 
		PROCEDURE ^ AssignReference(left, right: SyntaxTree.Expression); 
		PROCEDURE ^ Assign(left, right: SyntaxTree.Expression); 
		PROCEDURE ^ EmitCooperativeSwitch; 
		PROCEDURE ^ DeclarationStatement(x: SyntaxTree.DeclarationStatement); 
		PROCEDURE ^ CommunicationStatement(communication: SyntaxTree.CommunicationStatement); 
		PROCEDURE ^ IfStatement(x: SyntaxTree.IfStatement); 
		PROCEDURE ^ BrWithPart(CONST tag: IntermediateCode.Operand; x: SyntaxTree.WithPart; VAR trueL: Label); 
		PROCEDURE ^ EmitWithPart(x: SyntaxTree.WithPart); 
		PROCEDURE ^ WithStatement(x: SyntaxTree.WithStatement); 
		PROCEDURE ^ CaseStatement(x: SyntaxTree.CaseStatement); 
		PROCEDURE ^ WhileStatement(x: SyntaxTree.WhileStatement); 
		PROCEDURE ^ RepeatStatement(x: SyntaxTree.RepeatStatement); 
		PROCEDURE ^ ForStatement(x: SyntaxTree.ForStatement); 
		PROCEDURE ^ ExitableBlock(x: SyntaxTree.ExitableBlock); 
		PROCEDURE ^ LoopStatement(x: SyntaxTree.LoopStatement); 
		PROCEDURE ^ ExitStatement(x: SyntaxTree.ExitStatement); 
		PROCEDURE ^ ReturnStatement(x: SyntaxTree.ReturnStatement); 
		PROCEDURE ^ AwaitStatement(x: SyntaxTree.AwaitStatement); 
		PROCEDURE ^ StatementSequence(x: SyntaxTree.StatementSequence); 
		PROCEDURE ^ PushSelfPointer; 
		PROCEDURE ^ Lock(lock: BOOLEAN); 
		PROCEDURE ^ StatementBlock(x: SyntaxTree.StatementBlock); 
		PROCEDURE ^ Code(x: SyntaxTree.Code); 
		PROCEDURE ^ ProcParametersSize(procedure: SyntaxTree.Procedure): SIGNED32; 
		PROCEDURE ^ ParameterCopies(x: SyntaxTree.ProcedureType); 
		PROCEDURE ^ InitVariables(scope: SyntaxTree.Scope); 
		PROCEDURE ^ GetFingerprint(symbol: SyntaxTree.Symbol): Basic.Fingerprint; 
		PROCEDURE ^ Body(x: SyntaxTree.Body; scope: SyntaxTree.Scope; ir: IntermediateCode.Section; moduleBody: BOOLEAN); 
	END ImplementationEmitter; 

	MetaDataGenerator = OBJECT 
	CONST 
		EmptyBlockOffset = 2; 
	VAR 
		implementationEmitter: ImplementationEmitter; 
		declarationEmitter: DeclarationEmitter; 
		module: Sections.Module; 
		moduleName: ARRAY 128 OF CHAR; 
		moduleNamePool: Basic.HashTableInt; 
		moduleNamePoolSection: IntermediateCode.Section; 
		modulePointerSection: IntermediateCode.Section; 
		modulePointerSizePC: SIZE; 
		modulePointerSectionOffset: SIZE; 
		modulePointers: SIZE; 
		simple: BOOLEAN; 
		RecordBaseOffset: SIGNED32; 
		MethodTableOffset: SIGNED32; 
		BaseTypesTableOffset: SIGNED32; 
		TypeTags: SIGNED32; 
		TypeRecordBaseOffset: SIGNED32; 
		patchInfoPC: SIZE; 
		patchCRC: SIZE; 

		PROCEDURE ^  & InitMetaDataGenerator(implementationEmitter: ImplementationEmitter; declarationEmitter: DeclarationEmitter; simple: BOOLEAN); 
		PROCEDURE ^ SetModule(module: Sections.Module); 
		PROCEDURE ^ AddPointer(section: IntermediateCode.Section; offset: SIZE); 
		PROCEDURE ^ GetTypeRecordBaseOffset(numberMethods: SIZE): SIZE; 
		PROCEDURE ^ HeapBlock(CONST moduleName, typeName: ARRAY OF CHAR; section: IntermediateCode.Section; dataAdrOffset: SIGNED32); 
		PROCEDURE ^ ProtectedHeapBlock(CONST moduleName, typeName: ARRAY OF CHAR; section: IntermediateCode.Section; dataAdrOffset: SIGNED32); 
		PROCEDURE ^ Info(section: IntermediateCode.Section; CONST s: ARRAY OF CHAR); 
		PROCEDURE ^ Address(section: IntermediateCode.Section; value: ADDRESS); 
		PROCEDURE ^ Size(section: IntermediateCode.Section; value: SIZE); 
		PROCEDURE ^ Set(section: IntermediateCode.Section; value: Basic.Set); 
		PROCEDURE ^ Signed32(section: IntermediateCode.Section; value: SIGNED32); 
		PROCEDURE ^ Signed64(section: IntermediateCode.Section; value: SIGNED64); 
		PROCEDURE ^ PatchSize(section: IntermediateCode.Section; pc: SIZE; value: SIZE); 
		PROCEDURE ^ PatchSigned32(section: IntermediateCode.Section; pc: SIZE; value: SIGNED32); 
		PROCEDURE ^ PatchSymbol(section: IntermediateCode.Section; pc: SIZE; name: Basic.SegmentedName; symbol: SyntaxTree.Symbol; virtualOffset: SIZE; realOffset: SIGNED32); 
		PROCEDURE ^ Boolean(section: IntermediateCode.Section; value: BOOLEAN); 
		PROCEDURE ^ Char(section: IntermediateCode.Section; char: CHAR); 
		PROCEDURE ^ String(section: IntermediateCode.Section; CONST str: ARRAY OF CHAR); 
		PROCEDURE ^ String0(section: IntermediateCode.Section; str: StringPool.Index); 
		PROCEDURE ^ NamedSymbol(section: IntermediateCode.Section; name: Basic.SegmentedName; symbol: SyntaxTree.Symbol; virtualOffset: SIZE; realOffset: SIGNED32); 
		PROCEDURE ^ NamedSymbolAt(section: IntermediateCode.Section; pc: SIZE; name: Basic.SegmentedName; symbol: SyntaxTree.Symbol; virtualOffset: SIZE; realOffset: SIGNED32); 
		PROCEDURE ^ Symbol(section: IntermediateCode.Section; symbol: Sections.Section; virtualOffset: SIZE; realOffset: SIGNED32); 
		PROCEDURE ^ Pointers(offset: SIGNED32; symbol: Sections.Section; section: IntermediateCode.Section; type: SyntaxTree.Type; VAR numberPointers: SIZE); 
		PROCEDURE ^ EnterDynamicName(source: IntermediateCode.Section; CONST name: ARRAY OF CHAR; index: StringPool.Index; pool: Basic.HashTableInt): SIZE; 
		PROCEDURE ^ DynamicName(source: IntermediateCode.Section; index: StringPool.Index; pool: Basic.HashTableInt): SIZE; 
		PROCEDURE ^ NamedBlock(CONST mName, typeName: ARRAY OF CHAR; name: Basic.SegmentedName; VAR offset: SIZE): IntermediateCode.Section; 
		PROCEDURE ^ Block(CONST mName, typeName, suffix: ARRAY OF CHAR; VAR offset: SIZE): IntermediateCode.Section; 
		PROCEDURE ^ ArrayBlock(source: IntermediateCode.Section; VAR sizePC: SIZE; CONST baseType: ARRAY OF CHAR; hasPointer: BOOLEAN); 
		PROCEDURE ^ PatchArray(section: IntermediateCode.Section; pc: SIZE; size: SIZE); 
		PROCEDURE ^ ExportDesc(source: IntermediateCode.Section); 
		PROCEDURE ^ ExceptionArray(source: IntermediateCode.Section); 
		PROCEDURE ^ Name(section: IntermediateCode.Section; CONST name: ARRAY OF CHAR); 
		PROCEDURE ^ References(section: IntermediateCode.Section); 
		PROCEDURE ^ CommandArray(source: IntermediateCode.Section); 
		PROCEDURE ^ IsFirstDirectOccurence(import: SyntaxTree.Import): BOOLEAN; 
		PROCEDURE ^ ImportsArray(source: IntermediateCode.Section); 
		PROCEDURE ^ TypeInfoSection(source: IntermediateCode.Section); 
		PROCEDURE ^ ProcedureDescriptor(section: IntermediateCode.Section; procedureSection: IntermediateCode.Section); 
		PROCEDURE ^ MakeProcedureDescriptorTag(procedureSection: IntermediateCode.Section): IntermediateCode.Section; 
		PROCEDURE ^ ProcedureDescriptorPointer(section: IntermediateCode.Section; procedureSection: IntermediateCode.Section); 
		PROCEDURE ^ ProcedureDescriptorArray(section: IntermediateCode.Section; VAR numberProcs: SIZE); 
		PROCEDURE ^ BasePointer(section: IntermediateCode.Section); 
		PROCEDURE ^ BaseObject(section: IntermediateCode.Section); 
		PROCEDURE ^ BaseRecord(section: IntermediateCode.Section); 
		PROCEDURE ^ ModuleDescriptor(section: IntermediateCode.Section); 
		PROCEDURE ^ ModuleSection(): IntermediateCode.Section; 
		PROCEDURE ^ NewModuleInfo; 
		PROCEDURE ^ Module(bodyProc: IntermediateCode.Section); 
		PROCEDURE ^ PatchCRC(crc: SIGNED32); 
		PROCEDURE ^ PointerArray(source: IntermediateCode.Section; scope: SyntaxTree.Scope; VAR numberPointers: SIZE); 
		PROCEDURE ^ CheckTypeDeclaration(x: SyntaxTree.Type); 
	END MetaDataGenerator; 

	IntermediateBackend* = OBJECT (IntermediateCode.IntermediateBackend)
	VAR 
		trace-: BOOLEAN; 
		traceString-: SyntaxTree.IdentifierString; 
		traceModuleName-: SyntaxTree.IdentifierString; 
		profile-: BOOLEAN; 
		noRuntimeChecks: BOOLEAN; 
		simpleMetaData-: BOOLEAN; 
		noAsserts: BOOLEAN; 
		optimize-: BOOLEAN; 
		cooperative-: BOOLEAN; 
		preregisterStatic-: BOOLEAN; 
		dump-: Basic.Writer; 
		cellsAreObjects: BOOLEAN; 
		preciseGC-, trackLeave, writeBarriers: BOOLEAN; 
		experiment: BOOLEAN; 

		PROCEDURE ^  & InitIntermediateBackend*; 
		PROCEDURE ^ GetParameterRegister*(callingConvention: SyntaxTree.CallingConvention; type: IntermediateCode.Type; VAR register: INTEGER): BOOLEAN; 
		PROCEDURE ^ ResetParameterRegisters*; 
		PROCEDURE ^ GenerateIntermediate*(x: SyntaxTree.Module; supportedInstruction: SupportedInstructionProcedure; supportedImmediate: SupportedImmediateProcedure): Sections.Module; 
		PROCEDURE ^ SupportedImmediate*(CONST op: IntermediateCode.Operand): BOOLEAN; 
		PROCEDURE ^ ProcessSyntaxTreeModule*(syntaxTreeModule: SyntaxTree.Module): Formats.GeneratedModule; 
		PROCEDURE ^ ProcessIntermediateCodeModule*(intermediateCodeModule: Formats.GeneratedModule): Formats.GeneratedModule; 
		PROCEDURE ^ GetDescription*(VAR instructionSet: ARRAY OF CHAR); 
		PROCEDURE ^ SetSimpleMetaData*(simpleMetaData: BOOLEAN); 
		PROCEDURE ^ SetTraceModuleName(CONST name: ARRAY OF CHAR); 
		PROCEDURE ^ DefineOptions*(options: Options.Options); 
		PROCEDURE ^ GetOptions*(options: Options.Options); 
		PROCEDURE ^ DefaultSymbolFileFormat*(): Formats.SymbolFileFormat; 
	END IntermediateBackend; 

	; 
VAR 
	int8-, int16-, int32-, int64-, uint8-, uint16-, uint32-, uint64-, float32-, float64-: IntermediateCode.Type; 
	emptyOperand: IntermediateCode.Operand; 
	systemCalls: ARRAY NumberSystemCalls OF SyntaxTree.Symbol; 
	statCoopResetVariables: SIZE; 
	statCoopModifyAssignments: SIZE; 
	modifyAssignmentsPC: SIZE; 
	statCoopNilCheck: SIZE; 
	statCoopSwitch: SIZE; 
	statCoopAssignProcedure: SIZE; 
	statCoopTraceMethod: SIZE; 
	statCoopResetProcedure: SIZE; 
	statCoopTraceModule: SIZE; 
	ResultDesignatorName: SyntaxTree.Identifier; 

	PROCEDURE ^ ResetStatistics*; 
	PROCEDURE ^ Statistics*; 
	PROCEDURE ^ HasFlag(modifiers: SyntaxTree.Modifier; CONST name: ARRAY OF CHAR): BOOLEAN; 
	PROCEDURE ^ GCD(a, b: SIZE): SIZE; 
	PROCEDURE ^ SCM(a, b: SIZE): SIZE; 
	PROCEDURE ^ CommonAlignment(a, b: SIZE): SIZE; 
	PROCEDURE ^ PassBySingleReference(parameter: SyntaxTree.Parameter; callingConvention: SyntaxTree.CallingConvention): BOOLEAN; 
	PROCEDURE ^ PassInRegister(parameter: SyntaxTree.Parameter; callingConvention: SyntaxTree.CallingConvention): BOOLEAN; 
	PROCEDURE ^ AddRegisterEntry(VAR queue: RegisterEntry; register: SIZE; class: IntermediateCode.RegisterClass; type: IntermediateCode.Type); 
	PROCEDURE ^ RemoveRegisterEntry(VAR queue: RegisterEntry; register: SIZE): BOOLEAN; 
	PROCEDURE ^ Assert(cond: BOOLEAN; CONST reason: ARRAY OF CHAR); 
	PROCEDURE ^ ReusableRegister(op: IntermediateCode.Operand): BOOLEAN; 
	PROCEDURE ^ EnsureBodyProcedure(moduleScope: SyntaxTree.ModuleScope); 
	PROCEDURE ^ GetSymbol*(scope: SyntaxTree.ModuleScope; CONST moduleName, symbolName: ARRAY OF CHAR): SyntaxTree.Symbol; 
	PROCEDURE ^ InitOperand(VAR op: Operand; mode: SIGNED8); 
	PROCEDURE ^ GetType*(system: Global.System; type: SyntaxTree.Type): IntermediateCode.Type; 
	PROCEDURE ^ FindConstant(module: SyntaxTree.Module; value: SyntaxTree.Value): SyntaxTree.Constant; 
	PROCEDURE ^ BuildConstant(module: SyntaxTree.Module; value: SyntaxTree.Value; VAR adr: SIGNED32): SyntaxTree.Constant; 
	PROCEDURE ^ HasPointers(scope: SyntaxTree.ProcedureScope): BOOLEAN; 
	PROCEDURE ^ IsVariableParameter(parameter: SyntaxTree.Parameter): BOOLEAN; 
	PROCEDURE ^ HasVariableParameters(scope: SyntaxTree.ProcedureScope): BOOLEAN; 
	PROCEDURE ^ HasExplicitTraceMethod(recordType: SyntaxTree.RecordType): BOOLEAN; 
	PROCEDURE ^ IsIntegerConstant(expression: SyntaxTree.Expression; VAR val: SIGNED64): BOOLEAN; 
	PROCEDURE ^ PowerOf2*(val: SIGNED64; VAR exp: SIGNED32): BOOLEAN; 
	PROCEDURE ^ GetConstructor(record: SyntaxTree.RecordType): SyntaxTree.Procedure; 
	PROCEDURE ^ IsIntegerImmediate(CONST op: IntermediateCode.Operand; VAR value: Basic.Integer): BOOLEAN; 
	PROCEDURE ^ IsStrictlyPointerToRecord(type: SyntaxTree.Type): BOOLEAN; 
	PROCEDURE ^ IsUnsafePointer(type: SyntaxTree.Type): BOOLEAN; 
	PROCEDURE ^ IsPointerToRecord(type: SyntaxTree.Type; VAR recordType: SyntaxTree.RecordType): BOOLEAN; 
	PROCEDURE ^ IsArrayOfSystemByte(type: SyntaxTree.Type): BOOLEAN; 
	PROCEDURE ^ IsOpenArray(type: SyntaxTree.Type): BOOLEAN; 
	PROCEDURE ^ IsSemiDynamicArray(type: SyntaxTree.Type): BOOLEAN; 
	PROCEDURE ^ IsStaticArray(type: SyntaxTree.Type): BOOLEAN; 
	PROCEDURE ^ StaticArrayNumElements(type: SyntaxTree.Type): SIGNED32; 
	PROCEDURE ^ StaticArrayBaseType(type: SyntaxTree.Type): SyntaxTree.Type; 
	PROCEDURE ^ ArrayBaseType(type: SyntaxTree.Type): SyntaxTree.Type; 
	PROCEDURE ^ IsDelegate(type: SyntaxTree.Type): BOOLEAN; 
	PROCEDURE ^ DynamicDim(type: SyntaxTree.Type): SIGNED32; 
	PROCEDURE ^ StaticSize(system: Global.System; type: SyntaxTree.Type): SIGNED32; 
	PROCEDURE ^ IsImmediate(x: IntermediateCode.Operand): BOOLEAN; 
	PROCEDURE ^ IsAddress(x: IntermediateCode.Operand): BOOLEAN; 
	PROCEDURE ^ IsRegister(x: IntermediateCode.Operand): BOOLEAN; 
	PROCEDURE ^ GetRecordTypeName(recordType: SyntaxTree.RecordType; VAR name: Basic.SegmentedName); 
	PROCEDURE ^ ParametersSize(system: Global.System; procedureType: SyntaxTree.ProcedureType; isNested: BOOLEAN): SIGNED32; 
	PROCEDURE ^ IsNested(procedure: SyntaxTree.Procedure): BOOLEAN; 
	PROCEDURE ^ InCellScope(scope: SyntaxTree.Scope): BOOLEAN; 
	PROCEDURE ^ ProcedureParametersSize*(system: Global.System; procedure: SyntaxTree.Procedure): SIGNED32; 
	PROCEDURE ^ ToMemoryUnits*(system: Global.System; size: SIZE): SIGNED32; 
	PROCEDURE ^ Get*(): Backend.Backend; 
	PROCEDURE ^ Nop(position: Basic.Position): IntermediateCode.Instruction; 
	PROCEDURE ^ Use(position: Basic.Position; reg: IntermediateCode.Operand): IntermediateCode.Instruction; 
	PROCEDURE ^ Mov(position: Basic.Position; dest, src: IntermediateCode.Operand): IntermediateCode.Instruction; 
	PROCEDURE ^ MovReplace(position: Basic.Position; dest, src: IntermediateCode.Operand): IntermediateCode.Instruction; 
	PROCEDURE ^ Conv(position: Basic.Position; dest, src: IntermediateCode.Operand): IntermediateCode.Instruction; 
	PROCEDURE ^ Call*(position: Basic.Position; op: IntermediateCode.Operand; parSize: SIZE): IntermediateCode.Instruction; 
	PROCEDURE ^ Exit(position: Basic.Position; pcOffset: SIZE; callingConvention, unwind: SIGNED32): IntermediateCode.Instruction; 
	PROCEDURE ^ Return(position: Basic.Position; res: IntermediateCode.Operand): IntermediateCode.Instruction; 
	PROCEDURE ^ Result*(position: Basic.Position; res: IntermediateCode.Operand): IntermediateCode.Instruction; 
	PROCEDURE ^ Trap(position: Basic.Position; nr: SIGNED64): IntermediateCode.Instruction; 
	PROCEDURE ^ Br(position: Basic.Position; dest: IntermediateCode.Operand): IntermediateCode.Instruction; 
	PROCEDURE ^ Breq(position: Basic.Position; dest, left, right: IntermediateCode.Operand): IntermediateCode.Instruction; 
	PROCEDURE ^ Brne(position: Basic.Position; dest, left, right: IntermediateCode.Operand): IntermediateCode.Instruction; 
	PROCEDURE ^ Brge(position: Basic.Position; dest, left, right: IntermediateCode.Operand): IntermediateCode.Instruction; 
	PROCEDURE ^ Brlt(position: Basic.Position; dest, left, right: IntermediateCode.Operand): IntermediateCode.Instruction; 
	PROCEDURE ^ Pop*(position: Basic.Position; op: IntermediateCode.Operand): IntermediateCode.Instruction; 
	PROCEDURE ^ Push*(position: Basic.Position; op: IntermediateCode.Operand): IntermediateCode.Instruction; 
	PROCEDURE ^ Neg(position: Basic.Position; dest, src: IntermediateCode.Operand): IntermediateCode.Instruction; 
	PROCEDURE ^ Not(position: Basic.Position; dest, src: IntermediateCode.Operand): IntermediateCode.Instruction; 
	PROCEDURE ^ Abs(position: Basic.Position; dest, src: IntermediateCode.Operand): IntermediateCode.Instruction; 
	PROCEDURE ^ Mul(position: Basic.Position; dest, left, right: IntermediateCode.Operand): IntermediateCode.Instruction; 
	PROCEDURE ^ Div(position: Basic.Position; dest, left, right: IntermediateCode.Operand): IntermediateCode.Instruction; 
	PROCEDURE ^ Mod(position: Basic.Position; dest, left, right: IntermediateCode.Operand): IntermediateCode.Instruction; 
	PROCEDURE ^ Sub(position: Basic.Position; dest: IntermediateCode.Operand; left, right: IntermediateCode.Operand): IntermediateCode.Instruction; 
	PROCEDURE ^ Add(position: Basic.Position; dest: IntermediateCode.Operand; left, right: IntermediateCode.Operand): IntermediateCode.Instruction; 
	PROCEDURE ^ And(position: Basic.Position; dest, left, right: IntermediateCode.Operand): IntermediateCode.Instruction; 
	PROCEDURE ^ Or(position: Basic.Position; dest, left, right: IntermediateCode.Operand): IntermediateCode.Instruction; 
	PROCEDURE ^ Xor(position: Basic.Position; dest, left, right: IntermediateCode.Operand): IntermediateCode.Instruction; 
	PROCEDURE ^ Shl(position: Basic.Position; dest, left, right: IntermediateCode.Operand): IntermediateCode.Instruction; 
	PROCEDURE ^ Shr(position: Basic.Position; dest, left, right: IntermediateCode.Operand): IntermediateCode.Instruction; 
	PROCEDURE ^ Rol(position: Basic.Position; dest, left, right: IntermediateCode.Operand): IntermediateCode.Instruction; 
	PROCEDURE ^ Ror(position: Basic.Position; dest, left, right: IntermediateCode.Operand): IntermediateCode.Instruction; 
	PROCEDURE ^ Cas(position: Basic.Position; dest, src, size: IntermediateCode.Operand): IntermediateCode.Instruction; 
	PROCEDURE ^ Copy(position: Basic.Position; dest, src, size: IntermediateCode.Operand): IntermediateCode.Instruction; 
	PROCEDURE ^ Fill(position: Basic.Position; dest, size, value: IntermediateCode.Operand): IntermediateCode.Instruction; 
	PROCEDURE ^ Asm(position: Basic.Position; s: SyntaxTree.SourceCode; scope: SyntaxTree.Scope): IntermediateCode.Instruction; 
	PROCEDURE ^ Data*(position: Basic.Position; op: IntermediateCode.Operand): IntermediateCode.Instruction; 
	PROCEDURE ^ SpecialInstruction(position: Basic.Position; subtype: SIGNED8; op1, op2, op3: IntermediateCode.Operand): IntermediateCode.Instruction; 
	PROCEDURE ^ Reserve(position: Basic.Position; units: SIZE): IntermediateCode.Instruction; 
	PROCEDURE ^ LabelInstruction(position: Basic.Position): IntermediateCode.Instruction; 
	PROCEDURE ^ EnterImmediate*(data: IntermediateCode.Section; CONST vop: IntermediateCode.Operand): SIGNED32; 
	PROCEDURE ^ Init; 
	PROCEDURE ^ IsExported(symbol: SyntaxTree.Symbol): BOOLEAN; 
	PROCEDURE ^ InThisModule(scope: SyntaxTree.Scope; module: SyntaxTree.Module): BOOLEAN; 
BEGIN
END FoxIntermediateBackend.
