MODULE Watson IN Oberon;
	IMPORT Files, Modules, Objects, Fonts, Display, Texts, Oberon, Gadgets, TextGadgets0, TextGadgets, Documents, TextDocs, Desktops, Watson0, Compress, Attributes;
CONST 
	Version = \"1.7"\; 
	defFileExt = \".Def"\; 
	tutFileExt = \".Book"\; 
	tutDelimiter = \" "\; 
	titleExt = \".Def"\; 
	htmlExt = \".Def.html"\; 
	htmlBookExt = \".html"\; 
	DefaultOrder = \"DMSCT"\; 
	DocNrAttr = \"WDocNumber"\; 
	orderObj = \"Watson.Order"\; 
	tutorialObj = \"Watson.TutorialText"\; 
	archiveObj = \"Watson.DefArchive"\; 
	modfileObj = \"Watson.ModFile"\; 
	UndefTyp = 0; 
	ModTyp = 1; 
	DefTyp = 2; 
	SymTyp = 3; 
	CmdTyp = 4; 
	TutTyp = 5; 
	DefCTyp = 12; 
	BookCmd = \"Desktops.OpenDoc "\; 
	GotoCmd = \"Watson.Goto "\; 
	ObjCmd = \"Watson.ShowObj "\; 
	ModCmd = \"Watson.ShowDef "\; 
	Menu = \"Desktops.Copy[Copy] TextDocs.Search[Search] Watson.Back[Back] Desktops.StoreDoc[Store]"\; 
	TextCol = 15; 
	LinkCol = 3; 
	DocuCol = 8; 
	ImportCol = 1; 
	MaxIdLen = 64; 
	MaxMods = 32; 
	TAB = 9X; 
	CR = 0DX; 
	errMod = 0; 
	errImp = 1; 
	errConst = 2; 
	errType = 3; 
	errVar = 4; 
	errProc = 5; 
	errModEnd = 6; 
	errProcEnd = 7; 
	errSym = 8; 
	errTypeDef = 9; 
	errIdent = 10; 
	errNum = 11; 
	errComment = 12; 
	times = 0; 
	and = 1; 
	plus = 2; 
	minus = 3; 
	eql = 4; 
	arrow = 5; 
	period = 6; 
	comma = 7; 
	colon = 8; 
	upto = 9; 
	rparen = 10; 
	rbrak = 11; 
	rbrace = 12; 
	of = 13; 
	to = 14; 
	lparen = 15; 
	lbrak = 16; 
	lbrace = 17; 
	becomes = 18; 
	number = 19; 
	string = 20; 
	ident = 21; 
	assert = 22; 
	semicolon = 23; 
	end = 24; 
	if = 25; 
	case = 26; 
	while = 27; 
	for = 28; 
	loop = 29; 
	with = 30; 
	array = 31; 
	object = 32; 
	record = 33; 
	pointer = 34; 
	begin = 35; 
	code = 36; 
	const = 37; 
	type = 38; 
	var = 39; 
	proc = 40; 
	import = 41; 
	module = 42; 
	eot = 43; 
	none = 99; 
	internal = 0; 
	external = 1; 
	externalR = 2; 
TYPE 
	Name = ARRAY MaxIdLen OF CHAR; 

	Cmnt = POINTER TO CmntDesc; 

	CmntDesc = RECORD 
		next: Cmnt; 
		wPos, bPos, ePos, insert: LONGINT; 
		cnt: INTEGER; 
		ln: BOOLEAN; 
	END; 

	ModItem = RECORD 
		real, alias: Name; 
		exp, ln: BOOLEAN; 
		cmnts: Cmnt; 
	END; 

	LocalIdent = POINTER TO IdentDesc; 

	IdentDesc = RECORD 
		next: LocalIdent; 
		name: Name; 
		beg, end: LONGINT; 
		class: INTEGER; 
	END; 

	Fixup = POINTER TO FixupDesc; 

	FixupDesc = RECORD 
		next: Fixup; 
		insert: LONGINT; 
		name: Name; 
		qualified: BOOLEAN; 
	END; 

	History = POINTER TO HistoryDesc; 

	HistoryDesc = RECORD 
		next, succ: History; 
		nr: LONGINT; 
		cmd: ARRAY 64 OF CHAR; 
	END; 
VAR 
	W: Texts.Writer; 
	history: History; 
	lastHistNr: LONGINT; 
	oObj: Objects.Object; 
	linkText: Texts.Text; 
	aObj: Objects.Object; 
	mObj: Objects.Object; 
	order: ARRAY 8 OF CHAR; 
	defName: ARRAY 32 OF CHAR; 
	defFound: BOOLEAN; 
	msgPrinted: BOOLEAN; 
	mods: INTEGER; 
	mod: ARRAY MaxMods OF ModItem; 
	options: ARRAY 12 OF CHAR; 
	localIds: IdentDesc; 
	fixups: FixupDesc; 
	cmnts: CmntDesc; 
	ModT: Texts.Text; 
	R: Texts.Reader; 
	id, label: Name; 
	num: LONGINT; 
	begPos, wPos: LONGINT; 
	numLines, lines: INTEGER; 
	level, recLevel: INTEGER; 
	wasRecord: BOOLEAN; 
	newLine: BOOLEAN; 
	ch: CHAR; 
	sym: SHORTINT; 
	OutT: Texts.Text; 
	italic: Fonts.Font; 
	lastPos, importPos: LONGINT; 
	noerr: BOOLEAN; 
	curErr: SHORTINT; 
	doItalic: BOOLEAN; 

	PROCEDURE ^ Append(VAR d: ARRAY OF CHAR; s: ARRAY OF CHAR); 
	PROCEDURE ^ AppendCh(VAR d: ARRAY OF CHAR; ch: CHAR); 
	PROCEDURE ^ QualIdent(VAR qualifier, identifier: ARRAY OF CHAR); 
	PROCEDURE ^ SetColor(col: SHORTINT); 
	PROCEDURE ^ Char(ch: CHAR); 
	PROCEDURE ^ Str(str: ARRAY OF CHAR); 
	PROCEDURE ^ Int(i: LONGINT); 
	PROCEDURE ^ Indent(i: INTEGER); 
	PROCEDURE ^ Ln; 
	PROCEDURE ^ Object(obj: Objects.Object); 
	PROCEDURE ^ ToLog; 
	PROCEDURE ^ PrintMsg; 
	PROCEDURE ^ AddDocToHistory(oldNr: LONGINT): History; 
	PROCEDURE ^ GetDocSucc(nr: LONGINT): History; 
	PROCEDURE ^ MakeHistoryCmd(h: History; cmd, mod, obj: ARRAY OF CHAR); 
	PROCEDURE ^ DocHandler(D: Objects.Object; VAR M: Objects.ObjMsg); 
	PROCEDURE ^ OpenDef(T: Texts.Text; mod: ARRAY OF CHAR; compressed: BOOLEAN); 
	PROCEDURE ^ OpenTut(this: ARRAY OF CHAR); 
	PROCEDURE ^ FindIdent(VAR name: Name): LocalIdent; 
	PROCEDURE ^ InsertIdent(VAR name: Name; class: INTEGER; VAR obj: LocalIdent); 
	PROCEDURE ^ NeedsLn(): BOOLEAN; 
	PROCEDURE ^ Copy(beg, end: LONGINT); 
	PROCEDURE ^ Pos(): LONGINT; 
	PROCEDURE ^ err(n: SHORTINT); 
	PROCEDURE ^ Control(name, cmd, par: ARRAY OF CHAR); 
	PROCEDURE ^ Identifier(name: ARRAY OF CHAR); 
	PROCEDURE ^ Keywords(VAR last: Cmnt; word: ARRAY OF CHAR; ln, indent: BOOLEAN); 
	PROCEDURE ^ Cmnts(offset: LONGINT); 
	PROCEDURE ^ Imports; 
	PROCEDURE ^ Link(VAR name: Name; qualified: BOOLEAN); 
	PROCEDURE ^ Fixups(offset: LONGINT); 
	PROCEDURE ^ GetCh; 
	PROCEDURE ^ Ident; 
	PROCEDURE ^ String(ch0: CHAR); 
	PROCEDURE ^ Number(ch0: CHAR); 
	PROCEDURE ^ Comment(VAR oLine: INTEGER); 
	PROCEDURE ^ Sym; 
	PROCEDURE ^ FindMod(VAR name: Name): BOOLEAN; 
	PROCEDURE ^ CheckSym(s: INTEGER); 
	PROCEDURE ^ CheckMark(VAR vis: SHORTINT); 
	PROCEDURE ^ qualident(VAR end: LONGINT); 
	PROCEDURE ^ ConstExpression; 
	PROCEDURE ^ ConstDef; 
	PROCEDURE ^ SysFlags(VAR flag: Name); 
	PROCEDURE ^ RecordType; 
	PROCEDURE ^ ArrayType; 
	PROCEDURE ^ PointerType; 
	PROCEDURE ^ FormalParameters(resync: BOOLEAN); 
	PROCEDURE ^ SkipFormalParameters(resync: BOOLEAN); 
	PROCEDURE ^ ShowType(resync: BOOLEAN); 
	PROCEDURE ^ SkipType(resync: BOOLEAN); 
	PROCEDURE ^ TypeDef; 
	PROCEDURE ^ VarDef; 
	PROCEDURE ^ ProcedureDeclaration(blockvis: BOOLEAN); 
	PROCEDURE ^ Assert; 
	PROCEDURE ^ Block(blockId: Name; vis: BOOLEAN); 
	PROCEDURE ^ ImportBlock; 
	PROCEDURE ^ Module(VAR modName: Name); 
	PROCEDURE ^ GetText(): Texts.Text; 
	PROCEDURE ^ MakeDef*(VAR mod: ARRAY OF CHAR; T: Texts.Text); 
	PROCEDURE ^ Convert2HTML(in, out: Texts.Text); 
	PROCEDURE ^ GetArgs(VAR S: Texts.Scanner; VAR name: ARRAY OF CHAR); 
	PROCEDURE ^ CheckDefName(h: Compress.Header; VAR stop: BOOLEAN); 
	PROCEDURE ^ Which(VAR mod: ARRAY OF CHAR; VAR typ: INTEGER); 
	PROCEDURE ^ JumpTo(F: TextGadgets.Frame; pos: LONGINT); 
	PROCEDURE ^ FindMarker(T: Texts.Text; name: ARRAY OF CHAR): LONGINT; 
	PROCEDURE ^ Open(mod: ARRAY OF CHAR; T: Texts.Text; pos: LONGINT): History; 
	PROCEDURE ^ StoreAscii(T: Texts.Text; name: ARRAY OF CHAR); 
	PROCEDURE ^ Back*; 
	PROCEDURE ^ Goto*; 
	PROCEDURE ^ ShowDef*; 
	PROCEDURE ^ ShowObj*; 
	PROCEDURE ^ LookupObj*; 
	PROCEDURE ^ MakeDefs*; 
	PROCEDURE ^ ConvertDefs*; 
	PROCEDURE ^ GetPublicObjects; 
BEGIN
END Watson.
