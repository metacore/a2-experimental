MODULE Vinci IN Oberon;
	IMPORT Modules, Math IN A2, MathL IN A2, Display, Objects, Texts, Oberon, Strings, Scheme, Ops := SchemeOps, Images, PictImages, GfxMatrix, GfxImages, GfxPaths, GfxFonts, Gfx, Leonardo, LeoPens;
CONST 
	newline = Scheme.newline; 
	errdist = 10; 
	invalid = 0; 
	ident = 1; 
	literal = 2; 
	equal = 3; 
	nequal = 4; 
	less = 5; 
	lessEq = 6; 
	greater = 7; 
	greaterEq = 8; 
	plus = 9; 
	concat = 10; 
	minus = 11; 
	mult = 12; 
	fdiv = 13; 
	and = 14; 
	not = 15; 
	dot = 16; 
	comma = 17; 
	lpar = 18; 
	rpar = 19; 
	semicolon = 20; 
	eof = 21; 
	inPen = (Gfx.InSubpath + 1); 
	inSubpen = (inPen + 1); 
TYPE 
	Object = Scheme.Object; 

	Scanner = RECORD 
		ctxt: Scheme.Context; 
		ch: CHAR; 
		token: INTEGER; 
		errors: INTEGER; 
		obj: Object; 
		pos, prev: LONGINT; 
	END; 

	Context* = POINTER TO ContextDesc; 

	ContextDesc* = RECORD (Scheme.ContextDesc)
		gc*: Gfx.Context; 
		pen: LeoPens.Pen; 
		mode: SET; 
		evenodd: BOOLEAN; 
		x, y: REAL; 
	END; 

	Package = POINTER TO RECORD 
		next: Package; 
		name: Object; 
		env: Scheme.Environment; 
	END; 
VAR 
	globals*: Scheme.Environment; 
	Err: Texts.Text; 
	Packages: Package; 
	first: Object; 
	opeq, opneq, oplt, opleq, opplus, opminus, opmul, opdiv, div, mod, opquot, opand, opnot, or, opconcat, begin, define, if, lambda, let, quote, toinexact, above, as, at, below, by, const, do, else, elsif, end, in, left, lower, of, over, restore, right, rotated, upper, then, times, for, repeat, clip, draw, fill, record, stroke, endpath, enter, exit, from, to, close, arc, curve, corner, text, label, savectm, saveclip, with, import, qualify, module, strokecol, fillcol, color, strokepat, fillpat, pattern, width, dash, phase, cap, join, limit, flatness, font, size, evenodd, pen: Object; 

	PROCEDURE ^ ScanCh(VAR s: Scanner); 
	PROCEDURE ^ Scan(VAR s: Scanner); 
	PROCEDURE ^ Msg(VAR s: Scanner; msg: ARRAY OF CHAR); 
	PROCEDURE ^ Str(VAR s: Scanner; str: ARRAY OF CHAR); 
	PROCEDURE ^ Obj(VAR s: Scanner; obj: Object); 
	PROCEDURE ^ Ln(VAR s: Scanner); 
	PROCEDURE ^ Pair(car, cdr: Object): Object; 
	PROCEDURE ^ Quote(obj: Object): Object; 
	PROCEDURE ^ Append(VAR last: Object; obj: Object); 
	PROCEDURE ^ CheckEq(VAR s: Scanner); 
	PROCEDURE ^ CheckComma(VAR s: Scanner); 
	PROCEDURE ^ CheckLPar(VAR s: Scanner); 
	PROCEDURE ^ CheckRPar(VAR s: Scanner); 
	PROCEDURE ^ CheckAt(VAR s: Scanner); 
	PROCEDURE ^ CheckDo(VAR s: Scanner); 
	PROCEDURE ^ CheckEnd(VAR s: Scanner); 
	PROCEDURE ^ CheckTo(VAR s: Scanner); 
	PROCEDURE ^ Ident(VAR s: Scanner; VAR name: Object); 
	PROCEDURE ^ Qualident(VAR s: Scanner; VAR x: Object); 
	PROCEDURE ^ Factor(VAR s: Scanner; VAR x: Object); 
	PROCEDURE ^ Term(VAR s: Scanner; VAR x: Object); 
	PROCEDURE ^ SimpleExpr(VAR s: Scanner; VAR x: Object); 
	PROCEDURE ^ Expr(VAR s: Scanner; VAR x: Object); 
	PROCEDURE ^ If(VAR s: Scanner; VAR sseq: Object); 
	PROCEDURE ^ Repeat(VAR s: Scanner; VAR sseq: Object); 
	PROCEDURE ^ For(VAR s: Scanner; VAR sseq: Object); 
	PROCEDURE ^ Let(VAR s: Scanner; VAR sseq: Object); 
	PROCEDURE ^ Coord(VAR s: Scanner; VAR x, y: Object); 
	PROCEDURE ^ Text(VAR s: Scanner; VAR sseq: Object); 
	PROCEDURE ^ From(VAR s: Scanner; VAR sseq: Object); 
	PROCEDURE ^ Enter(VAR s: Scanner; VAR sseq: Object); 
	PROCEDURE ^ To(VAR s: Scanner; VAR sseq: Object); 
	PROCEDURE ^ Arc(VAR s: Scanner; VAR sseq: Object); 
	PROCEDURE ^ Curve(VAR s: Scanner; VAR sseq: Object); 
	PROCEDURE ^ Corner(VAR s: Scanner; VAR sseq: Object); 
	PROCEDURE ^ Exit(VAR s: Scanner; VAR sseq: Object); 
	PROCEDURE ^ Elements(VAR s: Scanner; VAR sseq: Object); 
	PROCEDURE ^ DrawStatement(VAR s: Scanner; VAR sseq: Object); 
	PROCEDURE ^ Draw(VAR s: Scanner; VAR sseq: Object); 
	PROCEDURE ^ Label(VAR s: Scanner; VAR sseq: Object); 
	PROCEDURE ^ With(VAR s: Scanner; VAR sseq: Object); 
	PROCEDURE ^ Save(VAR s: Scanner; VAR sseq: Object); 
	PROCEDURE ^ Const(VAR s: Scanner; VAR sseq: Object); 
	PROCEDURE ^ Define(VAR s: Scanner; VAR sseq: Object); 
	PROCEDURE ^ Statement(VAR s: Scanner; VAR seq: Object); 
	PROCEDURE ^ Sequence(VAR s: Scanner; VAR seq: Object); 
	PROCEDURE ^ Program(VAR s: Scanner; VAR body: Object); 
	PROCEDURE ^ Parse*(ctxt: Scheme.Context; VAR body: Object); 
	PROCEDURE ^ FindPackage(name: Object): Package; 
	PROCEDURE ^ FindSymbol(ctxt: Scheme.Context; pack: Package; name: Object): Object; 
	PROCEDURE ^ ImportText(ctxt: Context; name: Object; text: Texts.Text); 
	PROCEDURE ^ ImportModule(name: Object): BOOLEAN; 
	PROCEDURE ^ Import*(ctxt: Context; name: Object); 
	PROCEDURE ^ InitContext*(ctxt: Context; in, out, err: Scheme.Object; gc: Gfx.Context); 
	PROCEDURE ^ MakeContext*(ctxt: Context; in: Object; gc: Gfx.Context); 
	PROCEDURE ^ ShowError*; 
	PROCEDURE ^ NumVal(ctxt: Scheme.Context; VAR args: Object): REAL; 
	PROCEDURE ^ PenVal*(ctxt: Scheme.Context; VAR args: Object): LeoPens.Pen; 
	PROCEDURE ^ GetColorVal*(ctxt: Scheme.Context; VAR args: Object; VAR col: Gfx.Color); 
	PROCEDURE ^ GetPatternVal*(ctxt: Scheme.Context; VAR args: Object; VAR img: Images.Image; VAR px, py: REAL); 
	PROCEDURE ^ GetDashVal*(ctxt: Scheme.Context; VAR args: Object; VAR on, off: ARRAY OF REAL; VAR n: LONGINT); 
	PROCEDURE ^ CapVal*(ctxt: Scheme.Context; VAR args: Object): Gfx.CapStyle; 
	PROCEDURE ^ JoinVal*(ctxt: Scheme.Context; VAR args: Object): Gfx.JoinStyle; 
	PROCEDURE ^ GetMatrixVal*(ctxt: Scheme.Context; VAR args: Object; VAR m: GfxMatrix.Matrix); 
	PROCEDURE ^ FailGC(ctxt: Scheme.Context); 
	PROCEDURE ^ EvalRepeat(ctxt: Scheme.Context; args: Object; VAR res: Object); 
	PROCEDURE ^ EvalFor(ctxt: Scheme.Context; args: Object; VAR res: Object); 
	PROCEDURE ^ BeginPath(ctxt: Scheme.Context; args: Object; mode: SET); 
	PROCEDURE ^ EndPath(ctxt: Scheme.Context; args: Object; VAR res: Object); 
	PROCEDURE ^ EvalDraw(ctxt: Scheme.Context; args: Object; VAR res: Object); 
	PROCEDURE ^ EvalStroke(ctxt: Scheme.Context; args: Object; VAR res: Object); 
	PROCEDURE ^ EvalFill(ctxt: Scheme.Context; args: Object; VAR res: Object); 
	PROCEDURE ^ EvalClip(ctxt: Scheme.Context; args: Object; VAR res: Object); 
	PROCEDURE ^ EvalRecord(ctxt: Scheme.Context; args: Object; VAR res: Object); 
	PROCEDURE ^ EvalEnter(ctxt: Scheme.Context; args: Object; VAR res: Object); 
	PROCEDURE ^ EvalExit(ctxt: Scheme.Context; args: Object; VAR res: Object); 
	PROCEDURE ^ EvalFrom(ctxt: Scheme.Context; args: Object; VAR res: Object); 
	PROCEDURE ^ EvalTo(ctxt: Scheme.Context; args: Object; VAR res: Object); 
	PROCEDURE ^ EvalClose(ctxt: Scheme.Context; args: Object; VAR res: Object); 
	PROCEDURE ^ EvalArc(ctxt: Scheme.Context; args: Object; VAR res: Object); 
	PROCEDURE ^ EvalCurve(ctxt: Scheme.Context; args: Object; VAR res: Object); 
	PROCEDURE ^ EvalCorner(ctxt: Scheme.Context; args: Object; VAR res: Object); 
	PROCEDURE ^ EvalText(ctxt: Scheme.Context; args: Object; VAR res: Object); 
	PROCEDURE ^ EvalLabel(ctxt: Scheme.Context; args: Object; VAR res: Object); 
	PROCEDURE ^ EvalSaveCTM(ctxt: Scheme.Context; args: Object; VAR res: Object); 
	PROCEDURE ^ EvalSaveClip(ctxt: Scheme.Context; args: Object; VAR res: Object); 
	PROCEDURE ^ EvalWith(ctxt: Scheme.Context; args: Object; VAR res: Object); 
	PROCEDURE ^ EvalImport(ctxt: Scheme.Context; args: Object; VAR res: Object); 
	PROCEDURE ^ EvalQualify(ctxt: Scheme.Context; args: Object; VAR res: Object); 
	PROCEDURE ^ EvalModule(ctxt: Scheme.Context; args: Object; VAR res: Object); 
	PROCEDURE ^ MakeMatrix(VAR m: GfxMatrix.Matrix): Object; 
	PROCEDURE ^ EvalCTM(ctxt: Scheme.Context; args: Object; VAR res: Object); 
	PROCEDURE ^ EvalTranslate(ctxt: Scheme.Context; args: Object; VAR res: Object); 
	PROCEDURE ^ EvalScale(ctxt: Scheme.Context; args: Object; VAR res: Object); 
	PROCEDURE ^ EvalRotate(ctxt: Scheme.Context; args: Object; VAR res: Object); 
	PROCEDURE ^ EvalRad(ctxt: Scheme.Context; args: Object; VAR res: Object); 
	PROCEDURE ^ EvalConcat(ctxt: Scheme.Context; args: Object; VAR res: Object); 
	PROCEDURE ^ EvalSetCTM(ctxt: Scheme.Context; args: Object; VAR res: Object); 
	PROCEDURE ^ EvalClipRect(ctxt: Scheme.Context; args: Object; VAR res: Object); 
	PROCEDURE ^ EvalShape(ctxt: Scheme.Context; args: Object; VAR res: Object); 
	PROCEDURE ^ MakeColor(r, g, b: LONGINT): Object; 
	PROCEDURE ^ EvalColorsRGB(c: Scheme.Context; args: Object; VAR res: Object); 
	PROCEDURE ^ EvalColorsGray(c: Scheme.Context; args: Object; VAR res: Object); 
	PROCEDURE ^ EvalColorsIndex(c: Scheme.Context; args: Object; VAR res: Object); 
	PROCEDURE ^ EvalColorsRed(c: Scheme.Context; args: Object; VAR res: Object); 
	PROCEDURE ^ EvalColorsGreen(c: Scheme.Context; args: Object; VAR res: Object); 
	PROCEDURE ^ EvalColorsBlue(c: Scheme.Context; args: Object; VAR res: Object); 
	PROCEDURE ^ EvalMatrixInit(c: Scheme.Context; args: Object; VAR res: Object); 
	PROCEDURE ^ EvalMatrixInvert(c: Scheme.Context; args: Object; VAR res: Object); 
	PROCEDURE ^ EvalMatrixTranslate(c: Scheme.Context; args: Object; VAR res: Object); 
	PROCEDURE ^ EvalMatrixScale(c: Scheme.Context; args: Object; VAR res: Object); 
	PROCEDURE ^ EvalMatrixRotate(c: Scheme.Context; args: Object; VAR res: Object); 
	PROCEDURE ^ EvalMatrixConcat(c: Scheme.Context; args: Object; VAR res: Object); 
	PROCEDURE ^ EvalImagesLoad(c: Scheme.Context; args: Object; VAR res: Object); 
	PROCEDURE ^ EvalImagesPrintpattern(c: Scheme.Context; args: Object; VAR res: Object); 
	PROCEDURE ^ EvalImagesNewpattern(c: Scheme.Context; args: Object; VAR res: Object); 
	PROCEDURE ^ EvalImagesDraw(ctxt: Scheme.Context; args: Object; VAR res: Object); 
	PROCEDURE ^ EvalImagesCrop(c: Scheme.Context; args: Object; VAR res: Object); 
	PROCEDURE ^ Def*(name: ARRAY OF CHAR; eval: Scheme.PrimEval); 
	PROCEDURE ^ ODef*(p, s: ARRAY OF CHAR; obj: Object); 
	PROCEDURE ^ PDef*(p, s: ARRAY OF CHAR; eval: Scheme.PrimEval); 
	PROCEDURE ^ Init; 
BEGIN
END Vinci.
