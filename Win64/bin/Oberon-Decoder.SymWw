MODULE Decoder IN Oberon;
	IMPORT SYSTEM, Modules, Files, Fonts, Texts, Objects, Display, Oberon, Strings, Out;
CONST 
	pCS = 46; 
	pDS = 62; 
	pES = 38; 
	pFS = 100; 
	pGS = 101; 
	pSS = 54; 
	AdrSize = 103; 
	OpSize = 102; 
	none =  -1; 
	PCpos = 0; 
	HexPos = 7; 
	OpPosC = 43; 
	RMPosC = 52; 
	Pos1 = 4; 
	OffPos = 35; 
	Reg = 0; 
	Mem1 = 1; 
	Mem2 = 2; 
	RegImm = 3; 
	MemImm = 4; 
	MemFull = 5; 
	EAX = 0; 
	ECX = 1; 
	EDX = 2; 
	EBX = 3; 
	ESP = 4; 
	EBP = 5; 
	ESI = 6; 
	EDI = 7; 
	AX = 0; 
	CX = 1; 
	DX = 2; 
	BX = 3; 
	SP = 4; 
	BP = 5; 
	SI = 6; 
	DI = 7; 
	AL = 0; 
	CL = 1; 
	DL = 2; 
	BL = 3; 
	AH = 4; 
	CH = 5; 
	DH = 6; 
	BH = 7; 
	ES = 20; 
	CS = 21; 
	SS = 22; 
	DS = 23; 
	FS = 24; 
	GS = 25; 
	CR = 0; 
	DR = 8; 
	TR = 16; 
	SReal = 0; 
	LReal = 1; 
	EReal = 2; 
	WInt = 3; 
	SInt = 4; 
	LInt = 5; 
	Byte14 = 6; 
	Byte28 = 7; 
	Byte94 = 8; 
	Byte108 = 9; 
	Decimal = 10; 
	nothing = 11; 
	Byte = 0; 
	SignExt = 1; 
	BUG = 40; 
	VarEntriesStr = \"VarEntries:"\; 
	EntriesStr = \"Entries:"\; 
	CommandsStr = \"Commands:"\; 
	PointersStr = \"Pointers:"\; 
	DataStr = \"Data:"\; 
	ConstStr = \"Const:     "\; 
	CodeStr = \"Code:     "\; 
	nofEntriesStr = \"  nofEntries:      "\; 
	nofCmdsStr = \"  nofCmds:         "\; 
	nofPtrsStr = \"  nofPtrs:         "\; 
	nofTypesStr = \"  nofTds:          "\; 
	nofImpsStr = \"  nofImps:         "\; 
	dataSizeStr = \"  dataSize:        "\; 
	constSizeStr = \"  conSize:         "\; 
	codeSizeStr = \"  codeSize:        "\; 
	refSizeStr = \"  refSize:         "\; 
	exTableSizeStr = \"  exTableSize:      "\; 
	Priv = 16; 
	i486 = 1; 
	Pentium = 2; 
	PPro = 3; 
TYPE 
	ProcEntry* = RECORD 
		name*: ARRAY 64 OF CHAR; 
		point*: LONGINT; 
	END; 

	ProcArray* = POINTER TO ARRAY OF ProcEntry; 

	EntryArray = POINTER TO ARRAY OF LONGINT; 

	DecodeHandler* = PROCEDURE (VAR pc: LONGINT; VAR r: Files.Rider; VAR w: Texts.Writer); 

	HeaderCallback* = PROCEDURE (VAR dataSize, constSize, codeSize: LONGINT); 
VAR 
	R: Files.Rider; 
	W: Texts.Writer; 
	pc, breakpos: LONGINT; 
	column: INTEGER; 
	prefix, w: INTEGER; 
	adrPrefix, opPrefix: BOOLEAN; 
	defaultFont, titleFont: Fonts.Font; 
	PE*: ProcArray; 
	nofPE*: LONGINT; 
	memory, compilable, raw, suppressOut, suppressH, noOutput: BOOLEAN; 
	ReadAdr: ADDRESS; 
	target: SET; 
	objSuffix: ARRAY 8 OF CHAR; 
	OpPos, RMPos: SHORTINT; 
	decoder: DecodeHandler; 
	headerCallback: HeaderCallback; 
	addressFactor: LONGINT; 

	PROCEDURE ^ Bug(no: INTEGER); 
	PROCEDURE ^ Next(VAR ch: CHAR); 
	PROCEDURE ^ GetByte(VAR b: INTEGER); 
	PROCEDURE ^ GetWord(VAR w: LONGINT); 
	PROCEDURE ^ GetDWord(VAR dw: LONGINT); 
	PROCEDURE ^ GetNum(VAR x: LONGINT); 
	PROCEDURE ^ WriteLn; 
	PROCEDURE ^ WriteString(str: ARRAY OF CHAR); 
	PROCEDURE ^ Write(ch: CHAR); 
	PROCEDURE ^ WriteInt(x: LONGINT); 
	PROCEDURE ^ WriteByte(byte: INTEGER); 
	PROCEDURE ^ WriteWord(word: LONGINT); 
	PROCEDURE ^ WriteDWord(dword: LONGINT); 
	PROCEDURE ^ WriteWHex(word: LONGINT); 
	PROCEDURE ^ WriteDWHex(dword: LONGINT); 
	PROCEDURE ^ WriteDisp(disp: LONGINT); 
	PROCEDURE ^ Tab(pos: INTEGER); 
	PROCEDURE ^ WriteOp(opStr: ARRAY OF CHAR); 
	PROCEDURE ^ WriteReg(reg: INTEGER); 
	PROCEDURE ^ WriteAdrReg(reg: INTEGER); 
	PROCEDURE ^ WriteSpecialReg(reg: INTEGER); 
	PROCEDURE ^ WritePrefix(prefix: INTEGER); 
	PROCEDURE ^ WriteRegReg(d, reg1, reg2: INTEGER); 
	PROCEDURE ^ WriteMem(base, inx, scale: INTEGER; disp: LONGINT); 
	PROCEDURE ^ WriteMem1(d, reg, base: INTEGER; disp: LONGINT); 
	PROCEDURE ^ WriteMem2(d, reg, base, inx: INTEGER; scale: SHORTINT; disp: LONGINT); 
	PROCEDURE ^ WriteRegImm(reg: INTEGER; imm: LONGINT; hex: BOOLEAN); 
	PROCEDURE ^ WriteMemImm(reg, base, inx: INTEGER; scale: SHORTINT; disp, imm: LONGINT; hex: BOOLEAN); 
	PROCEDURE ^ WriteRM(mode: SHORTINT; d, reg, base, inx, scale: INTEGER; disp, imm: LONGINT; hex: BOOLEAN); 
	PROCEDURE ^ GetImm(w: INTEGER; VAR imm: LONGINT); 
	PROCEDURE ^ ModRm(VAR mode: SHORTINT; VAR reg, base, inx: INTEGER; VAR scale: SHORTINT; VAR disp: LONGINT); 
	PROCEDURE ^ Type1(op: INTEGER; VAR mode: SHORTINT; VAR d, reg, base, inx: INTEGER; VAR scale: SHORTINT; VAR disp, imm: LONGINT); 
	PROCEDURE ^ Add(op: INTEGER); 
	PROCEDURE ^ Push(op: INTEGER); 
	PROCEDURE ^ Push2(op: INTEGER); 
	PROCEDURE ^ Pop(op: INTEGER); 
	PROCEDURE ^ Pop2(op: INTEGER); 
	PROCEDURE ^ Or(op: INTEGER); 
	PROCEDURE ^ Adc(op: INTEGER); 
	PROCEDURE ^ Sbb(op: INTEGER); 
	PROCEDURE ^ And(op: INTEGER); 
	PROCEDURE ^ Sub(op: INTEGER); 
	PROCEDURE ^ Xor(op: INTEGER); 
	PROCEDURE ^ Cmp(op: INTEGER); 
	PROCEDURE ^ Inc(op: INTEGER); 
	PROCEDURE ^ Dec(op: INTEGER); 
	PROCEDURE ^ Bound(op: INTEGER); 
	PROCEDURE ^ Imul(op: INTEGER); 
	PROCEDURE ^ Imul2(op: INTEGER); 
	PROCEDURE ^ Ins(op: INTEGER); 
	PROCEDURE ^ Outs(op: INTEGER); 
	PROCEDURE ^ Jcc(op: INTEGER); 
	PROCEDURE ^ Jcc2(op: INTEGER); 
	PROCEDURE ^ Test(op: INTEGER); 
	PROCEDURE ^ Xchg(op: INTEGER); 
	PROCEDURE ^ Mov(op: INTEGER); 
	PROCEDURE ^ Mov2(op: INTEGER); 
	PROCEDURE ^ Movx(op: INTEGER); 
	PROCEDURE ^ Lea(op: INTEGER); 
	PROCEDURE ^ Call(op: INTEGER); 
	PROCEDURE ^ Movs(op: INTEGER); 
	PROCEDURE ^ Cmps(op: INTEGER); 
	PROCEDURE ^ Stos(op: INTEGER); 
	PROCEDURE ^ Lods(op: INTEGER); 
	PROCEDURE ^ Scas(op: INTEGER); 
	PROCEDURE ^ Ret(op: INTEGER); 
	PROCEDURE ^ Enter(op: INTEGER); 
	PROCEDURE ^ Les(op: INTEGER); 
	PROCEDURE ^ Lds(op: INTEGER); 
	PROCEDURE ^ Ldseg(op: INTEGER); 
	PROCEDURE ^ Int(op: INTEGER); 
	PROCEDURE ^ Loop(op: INTEGER); 
	PROCEDURE ^ InOut(op: INTEGER); 
	PROCEDURE ^ Jmp(op: INTEGER); 
	PROCEDURE ^ Lar(op: INTEGER); 
	PROCEDURE ^ Lsl(op: INTEGER); 
	PROCEDURE ^ Setcc(op: INTEGER); 
	PROCEDURE ^ Bit(op: INTEGER); 
	PROCEDURE ^ Shift(op: INTEGER); 
	PROCEDURE ^ Bswap(op: INTEGER); 
	PROCEDURE ^ Xadd(op: INTEGER); 
	PROCEDURE ^ Cmpxchg(op: INTEGER); 
	PROCEDURE ^ Cmov(op: INTEGER); 
	PROCEDURE ^ Grp1(op: INTEGER); 
	PROCEDURE ^ Grp2(op: INTEGER); 
	PROCEDURE ^ Grp3(op: INTEGER); 
	PROCEDURE ^ Grp4(op: INTEGER); 
	PROCEDURE ^ Grp5(op: INTEGER); 
	PROCEDURE ^ Grp6(op: INTEGER); 
	PROCEDURE ^ Grp7(op: INTEGER); 
	PROCEDURE ^ Grp8(op: INTEGER); 
	PROCEDURE ^ Grp9(op: INTEGER); 
	PROCEDURE ^ Escape(op: INTEGER); 
	PROCEDURE ^ WriteFReg(freg: INTEGER); 
	PROCEDURE ^ WriteFloat(form: SHORTINT; base, inx: INTEGER; scale: SHORTINT; disp: LONGINT); 
	PROCEDURE ^ Float0(op: INTEGER); 
	PROCEDURE ^ Float1(op: INTEGER); 
	PROCEDURE ^ Float2(op: INTEGER); 
	PROCEDURE ^ Float3(op: INTEGER); 
	PROCEDURE ^ Float4(op: INTEGER); 
	PROCEDURE ^ Float5(op: INTEGER); 
	PROCEDURE ^ Float6(op: INTEGER); 
	PROCEDURE ^ Float7(op: INTEGER); 
	PROCEDURE ^ Prefix(VAR op: INTEGER); 
	PROCEDURE ^ IA32Decoder(VAR PC: LONGINT; VAR r: Files.Rider; VAR w: Texts.Writer); 
	PROCEDURE ^ Dump(size: SIZE); 
	PROCEDURE ^ Reference(size: LONGINT); 
	PROCEDURE ^ Check(ch: CHAR; str: ARRAY OF CHAR); 
	PROCEDURE ^ DumpData(VAR a: ARRAY OF CHAR; len: LONGINT); 
	PROCEDURE ^ ReadExport; 
	PROCEDURE ^ ReadUse; 
	PROCEDURE ^ WriteProc(pc: LONGINT); 
	PROCEDURE ^ DecodeObjFile*(objName: ARRAY OF CHAR; VAR T: Texts.Text); 
	PROCEDURE ^ Decode*; 
	PROCEDURE ^ DecodeThis*(dest: Texts.Text; VAR code: ARRAY OF CHAR); 
	PROCEDURE ^ ThisFrame(X, Y: INTEGER; VAR F: Display.Frame); 
	PROCEDURE ^ GetText(VAR par: Display.Frame): Texts.Text; 
	PROCEDURE ^ Locate(F: Display.Frame; T: Texts.Text; pos: LONGINT); 
	PROCEDURE ^ Scan(s: ARRAY OF CHAR): LONGINT; 
	PROCEDURE ^ GetLine(VAR r: Texts.Reader; VAR buf: ARRAY OF CHAR); 
	PROCEDURE ^ Find*; 
	PROCEDURE ^ SetObjSuffix*(suffix: ARRAY OF CHAR); 
	PROCEDURE ^ SetSuffix*; 
	PROCEDURE ^ InstallDecoder*(decodeHandler: DecodeHandler; suffix: ARRAY OF CHAR; adrFactor: LONGINT); 
	PROCEDURE ^ InstallHeaderCallback*(hdrCallback: HeaderCallback); 
	PROCEDURE ^ ActiveDecoder*(): DecodeHandler; 
	PROCEDURE ^ InstallIA32Decoder*; 
BEGIN
END Decoder.
