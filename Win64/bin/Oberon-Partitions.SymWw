MODULE Partitions IN Oberon;
	IMPORT Kernel, Modules, Disks, Files, Fonts, Texts, Input, Oberon, In;
CONST 
	Trace = TRUE; 
	ShowReserved = FALSE; 
	BS = 512; 
	BootLoaderName = \"OBL.Bin"\; 
	BootFileName = \"IDE.Bin"\; 
	MinPartSize = 64; 
	N2KSS = 2048; 
	N2KBPS = (N2KSS DIV BS); 
	N2KDirMark = SIGNED32(2602476429); 
	AosSSLog2 = 12; 
	AosSS = ASH(1, AosSSLog2); 
	AosBPS = (AosSS DIV BS); 
	AosSF = 29; 
	AosSTS = 128; 
	AosXS = (AosSS DIV 4); 
	AosHS = 568; 
	AosDirMark = SIGNED32(2602476429); 
	AosType = 76; 
	NativeType1 = 79; 
	NativeType2 = 80; 
	FSID = 559107905; 
	FSID0 = 1380270671; 
	FSIDOBL = 1145652297; 
	FSVer = 2; 
	FSRes = ((640 * 1024) DIV BS); 
	LoaderSize = 4; 
	Read = Disks.Read; 
	Write = Disks.Write; 
	Ok = Disks.Ok; 
	NumFlop = 2; 
	MaxConfig = 2000; 
	WholeDisk = 256; 
	FreeSpace =  -1; 
	ReservedSpace =  -2; 
	NoSpaceAvailable = 9001; 
	CoreMismatch = 9002; 
	CoreChecksumError = 9003; 
	OutOfSlots = 9004; 
	PartitionTooSmall = 9005; 
	Interrupted = MAX(SIGNED32); 
	DisketteLimit = 2880; 
TYPE 
	ConfigTable = POINTER TO ARRAY OF CHAR; 
VAR 
	w: Texts.Writer; 
	hex: ARRAY 17 OF CHAR; 
	safe: BOOLEAN; 

	PROCEDURE ^ WriteType(VAR w: Texts.Writer; type: SIGNED32); 
	PROCEDURE ^ WriteErrorMsg(VAR w: Texts.Writer; res: INTEGER); 
	PROCEDURE ^ WriteTransferError(VAR w: Texts.Writer; dev: Disks.Device; op, start, res: SIGNED32); 
	PROCEDURE ^ IsDOS(type: SIGNED32): BOOLEAN; 
	PROCEDURE ^ WriteK(VAR W: Texts.Writer; k: SIGNED32); 
	PROCEDURE ^ Progress(t: Texts.Text; now, max: SIGNED32; VAR next: SIGNED32); 
	PROCEDURE ^ UserInterrupt(VAR ch: CHAR): BOOLEAN; 
	PROCEDURE ^ ShowDevice(VAR w: Texts.Writer; d: Disks.Device; verbose: BOOLEAN; VAR res: INTEGER); 
	PROCEDURE ^ WritePart(VAR w: Texts.Writer; dev: Disks.Device; part: SIGNED32); 
	PROCEDURE ^ WriteTable(VAR w: Texts.Writer; d: Disks.Device; table: Disks.PartitionTable; verbose: BOOLEAN; VAR dosnum: SIGNED32); 
	PROCEDURE ^ GetTableGeometry(dev: Disks.Device; VAR hds, spt: SIGNED32): BOOLEAN; 
	PROCEDURE ^ GetGeometry(dev: Disks.Device; VAR geo: Disks.GetGeometryMsg; VAR res: INTEGER); 
	PROCEDURE ^ Extended(type: SIGNED32): BOOLEAN; 
	PROCEDURE ^ NewFree(type: SIGNED32; VAR table: Disks.PartitionTable; start, size, ptblock: SIGNED32; flags: SET); 
	PROCEDURE ^ FindFreePrimary(VAR table: Disks.PartitionTable; spt, hds: SIGNED32); 
	PROCEDURE ^ FindFreeExtended(VAR table: Disks.PartitionTable; spt, hds: SIGNED32); 
	PROCEDURE ^ FindReserved(VAR table: Disks.PartitionTable); 
	PROCEDURE ^ Contains(table: Disks.PartitionTable; i, x: SIGNED32): BOOLEAN; 
	PROCEDURE ^ PartitionsOverlap(table: Disks.PartitionTable; i, j: SIGNED32): BOOLEAN; 
	PROCEDURE ^ CheckTable(dev: Disks.Device; table: Disks.PartitionTable): BOOLEAN; 
	PROCEDURE ^ FindFreeSpace(dev: Disks.Device; VAR table: Disks.PartitionTable; spt, hds: SIGNED32); 
	PROCEDURE ^ Show*; 
	PROCEDURE ^ Put2(VAR b: ARRAY OF CHAR; i, val: SIGNED32); 
	PROCEDURE ^ Put4(VAR b: ARRAY OF CHAR; i, val: SIGNED32); 
	PROCEDURE ^ Get2(VAR b: ARRAY OF CHAR; i: SIGNED32): SIGNED32; 
	PROCEDURE ^ Get4(VAR b: ARRAY OF CHAR; i: SIGNED32): SIGNED32; 
	PROCEDURE ^ GetDriveNum(dev: Disks.Device): CHAR; 
	PROCEDURE ^ InitOBL(dev: Disks.Device; part, flag: SIGNED32; VAR res: INTEGER); 
	PROCEDURE ^ InitAosFS(dev: Disks.Device; part, fsres, flag: SIGNED32; VAR res: INTEGER); 
	PROCEDURE ^ InitNativeFS(dev: Disks.Device; part, fsres, flag: SIGNED32; VAR res: INTEGER); 
	PROCEDURE ^ DetectFS(dev: Disks.Device; part: SIGNED32): SIGNED32; 
	PROCEDURE ^ CheckDiskette(name: ARRAY OF CHAR); 
	PROCEDURE ^ ScanOpenPart(VAR dev: Disks.Device; check: BOOLEAN; VAR part: SIGNED32); 
	PROCEDURE ^ Random(VAR seed: SIGNED32; N: SIGNED32): SIGNED32; 
	PROCEDURE ^ CheckPartition(dev: Disks.Device; part: SIGNED32; VAR res: INTEGER); 
	PROCEDURE ^ GetVars(dev: Disks.Device; part: SIGNED32; VAR tsize, reserved, fsOfs, res: SIGNED32); 
	PROCEDURE ^ GetTable(dev: Disks.Device; part: SIGNED32; VAR table: ConfigTable; VAR res: INTEGER); 
	PROCEDURE ^ PutTable(dev: Disks.Device; part: SIGNED32; table: ConfigTable; VAR res: INTEGER); 
	PROCEDURE ^ FindEntry(table: ConfigTable; i, type: SIGNED32): SIGNED32; 
	PROCEDURE ^ AddEntry(table: ConfigTable; type, dsize: SIGNED32; VAR data: ARRAY OF CHAR); 
	PROCEDURE ^ DeleteEntry(table: ConfigTable; i: SIGNED32); 
	PROCEDURE ^ WriteFile(f: Files.File; dev: Disks.Device; pos: SIGNED32; VAR sum, res: SIGNED32); 
	PROCEDURE ^ CheckFile(f: Files.File; dev: Disks.Device; pos: SIGNED32; sum: SIGNED32; VAR res: INTEGER); 
	PROCEDURE ^ InitBootFile(dev: Disks.Device; part: SIGNED32; f: Files.File; VAR res: INTEGER); 
	PROCEDURE ^ NativeType(type: SIGNED32): BOOLEAN; 
	PROCEDURE ^ Format*; 
	PROCEDURE ^ UpdateBootFile*; 
	PROCEDURE ^ GetConfig*; 
	PROCEDURE ^ IsHex(ch: CHAR): BOOLEAN; 
	PROCEDURE ^ HexVal(ch: CHAR): SIGNED32; 
	PROCEDURE ^ UnQuote(VAR config: ARRAY OF CHAR; VAR len: SIGNED32); 
	PROCEDURE ^ ParseConfig(table: ConfigTable): BOOLEAN; 
	PROCEDURE ^ SetConfig*; 
	PROCEDURE ^ Check*; 
	PROCEDURE ^ ChangePartType(dev: Disks.Device; part: SIGNED32; oldtype, newtype: SIGNED32; VAR res: INTEGER); 
	PROCEDURE ^ ChangeType*; 
	PROCEDURE ^ DeletePrimary(dev: Disks.Device; part: SIGNED32; type: SIGNED32; VAR res: INTEGER); 
	PROCEDURE ^ Delete*; 
	PROCEDURE ^ CreatePrimary(dev: Disks.Device; table: Disks.PartitionTable; part, size, spt, hds, type: SIGNED32; VAR res: INTEGER); 
	PROCEDURE ^ Create*; 
	PROCEDURE ^ SetFlag(on: BOOLEAN); 
	PROCEDURE ^ Activate*; 
	PROCEDURE ^ Deactivate*; 
	PROCEDURE ^ FileToPartition*; 
	PROCEDURE ^ PartitionToFile*; 
	PROCEDURE ^ WriteMBR*; 
	PROCEDURE ^ UpdateOBL(dev: Disks.Device; part: SIGNED32; f: Files.File; VAR res: INTEGER); 
	PROCEDURE ^ UpdateBootLoader*; 
	PROCEDURE ^ WriteHex(VAR wr: Texts.Writer; x, w: SIGNED32); 
	PROCEDURE ^ WriteHexDump(VAR w: Texts.Writer; VAR buf: ARRAY OF CHAR; ofs, size, base: SIGNED32); 
	PROCEDURE ^ ShowBlocks*; 
	PROCEDURE ^ Unsafe*; 
	PROCEDURE ^ Safe*; 
	PROCEDURE ^ ShowAosFSLimits*; 
	PROCEDURE ^ Eject*; 
BEGIN
END Partitions.
