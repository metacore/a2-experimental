## Описание языка программирования ETH Oberon 2019

*Феликс Фридрих, Флориан Негель, 31 октября 2019*

*Модификация для ЯОС и перевод - Николай Кондрин, Денис Будяк, 2020*

**Предисловие**

Это описание содержит синтаксис и семантику языка программирования Активный Оберон, поддерживаемого компилятором Фокс Оберон в 2019 году. Оно основано на предыдущих описаниях Оберона, сделанных Феликсом Фридрихом, Юргом Гуткнехтом, Ханспетером Мёссенбёком, Флорианом Негелем, Патриком Рейли, Никлаусом Виртом.

При переводе внесены минимальные изменения с учётом специфики ЯОС (ищи слово "ЯОС" в этом документе):
- описана поддержка кириллицы в именах 
- инициализация переменных нулями 

**О терминологии**

CHAR (буква, литера, символ) мы *называем* знаком. 

**Содержание**

[1 Синтаксис и обозначения в настоящем описании](#1-синтаксис-и-обозначения-в-настоящем-описании)

[2 Словарь и представление](#2-словарь-и-представление)

Дальше оглавление руками не делаем, потом сгенерируем.

### 1 Синтаксис и обозначения в настоящем описании

Мы описываем синтаксис активного Оберона в расширенной форме Бэкуса — Наура (EBNF). Представляем элементы описания (синтаксические выражения) как уравнения с одним знаком равенства =. В левой части продукции находится определенный нетерминальный символ, справа - правило замены, заканчивающееся точкой. Терминальные символы заключаются в одинарные или двойные кавычки `(например,':=', "'" и 'BEGIN')`. Альтернатива обозначается вертикальной чертой `|`. Квадратные скобки `[` и `]` означают необязательность заключенного в них выражения, а фигурные скобки `{` и `}` - его повторение (возможно 0 раз). Кроме того, круглые скобки  `(` и `)` используются для обозначения приоритета выражения. Синтаксис языка Оберон приведен в приложении B.

### 2 Словарь и представление

Представление терминальных символов по соглашениям определяется с помощью набора знаков ASCII, расширенного русской кириллицей. Символы - это идентификаторы, числа, строки, операторы и разделители. Применяется следующее правило: пробелы, знаки табуляции и разрывы строк не должны встречаться в символах (за исключением комментариев и строковых литералов). Кроме того, что пробелы, знаки табуляции и переносы строк служат разделителями соседних символов, они игнорируются. Прописные и строчные буквы считаются различными.

#### 2.1 Идентификаторы

Идентификаторы - это последовательность букв, цифр и специальных знаков. Первый знак должен быть буквой:
```
Идентификатор = Буква {Буква | Цифра | ’_’ }.
Буква = ’A’ | ’B’ | .. |’Z’ | ’a’ | ’b’ | .. | ’z’  | ’А’ | ’Б’ | .. |’Я’ | ’а’ | ’б’ | .. | ’я’
Цифра = ’0’ | ’1’ | ’2’ | ’3’ | ’4’ | ’5’ | ’6’ | ’7’ | ’8’ | ’9’.
```

##### 2.1.1 Примеры

Примеры правильных идентификаторов:
```
KernelLog
Abc013
Trace_me
Привет
```

#### 2.2 Числовые константы

Числа - это (возможно, беззнаковые) целые или вещественные константы. Тип целочисленной константы - это минимальный тип, к которому принадлежит значение константы. Компилятор представляет константы с наибольшим доступным размером таким образом, что при свертке констант значение определяет тип (а не тип свертываемых аргументов).

Целое число может начинаться с префикса, который определяет его (шестнадцатеричное или двоичное) представление. Если число без префикса заканчивается буквой `H`, то представление будет шестнадцатеричным, в противном случае - десятичным.

Вещественное число всегда содержит десятичную точку. Как вариант, оно также может содержать десятичный масштабный коэффициент. Буквы `E` и `D` означают "умножить на десять в степени".

Вещественное число имеет тип FLOAT32 (совместим с любой переменной с плавающей точкой), но представляется компилятором как FLOAT64. Это означает, что  свертка констант применяется с максимально возможной точностью и преобразование в FLOAT64 происходит тоже с максимально возможной точностью.

```
Число = Целое | Вещественное.
Целое = Цифра {["’"]Цифра} | Цифра {["’"]Шестнадцатиричная цифра} ’H’
        | ’0x’ {["’"]Шестнадцатиричная цифра} | ’0b’ {["’"]Двоичная цифра}.
Вещественное = Цифра {["’"]Цифра} ’.’ {Цифра} [Масштабный коэффициент].
Масштабный коэффициент = (’E’ | ’D’) [’+’ | ’-’] Цифра {Цифра}.
Шестнадцатиричная цифра = Цифра | ’A’ | ’B’ | ’C’ | ’D’ | ’E’ | ’F’
                                | ’a’ | ’b’ | ’c’ | ’d’ | ’e’ | ’f’ .
```

##### 2.2.1 Примеры
```
CONST
a = 42 ;
b = 0ABH ;
c = 13H ;
d = 0xAFFE ;
e = 0b100 ;
f = 0b1000’0010’1000 ;
g = 3. ;
h = 3.82 ;
i = 3.82E+20 ;
Рис. 2.2: Примеры числовых констант в объявлении
```
##### 2.2.2  Отличия от оригинальной версии Оберона

Были добавлены шестнадцатеричные числа формата 0x123abc и двоичные числа формата 0b1001h.

Для всех чисел знак одинарной кавычки `’` может использоваться как разделитель. Между ними может быть не более одной кавычки `’`. Фиксированное расстояние между разделителями не обязательно должно соблюдаться. Разделитель игнорируется компилятором.

Использование масштабирующего знака `D` не рекомендуется. В оригинальной версии Оберона можно было указать константы типов REAL и LONGREAL. Это считается ненужным, так как свертка констант теперь всегда выполняется с самой высокой доступной точностью. При необходимости константа может быть преобразована в FLOAT32 явно.

#### 2.3 Константы типа знак

Константы типа знак (буква) обозначаются порядковым номером знака в шестнадцатеричном представлении, за которым следует буква X, или самим знаком, заключенным в одиночные кавычками.

---
Знак = Цифра {Шестнадцатиричная цифра} ’X’ | "’" Знак "’".

---

##### 2.3.1 Примеры

```
CONST
a = ’A’ ;
b = 13X ;
```

#### 2.4 Строковые литералы

Строковые литералы - это последовательности знаков, заключенные в двойные ( `"` ),  одинарные ( `'` ) кавычки или пару ограничителей (`\"` ... `"\`). Строки длиной 2 могут использоваться везде, где разрешена знаковая константа, и наоборот.

Строка длиной 1 может использоваться везде, где разрешена знаковая константа, и наоборот.

Если в строке необходимо использовать двойные и одинарные кавычки или многострочную часть, то доступен формат с обратной косой чертой. Строка, начинающаяся на `\"` и заканчивающаяся на `"\`, может содержать разрывы строк и управляющие знаки, такие как `\n` (новая строка) или `\t` (табуляция). В такой строке двойная обратная косая черта `\\` используется для обозначения одной обратной косой черты.

```
Строка = ’"’ {Знак} ’"’ | "’" {Знак} "’" | ’\"’ {Знак} ’"\’.
```

##### 2.4.1 Примеры

Примеры строковых констант в объявлении
```
CONST
а = "Привет, ETH!" ;
б = 'эта строка содержит  "двойные кавычки"' ;
в = \"В строке, ограниченной обратной косой, \n превращается в знак конца строки"\ ;
г = \"Строки с обратной косой
могут распологаться на нескольких
строках исходного текста"\ ;
```

#### 2.5 Литералы множеств

Литерал множества пишется следующим образом:

```
Множество = "{" [Элемент {"," Элемент}] "}".
Элемент = ВыражениеДиапазона.
```

Элементы множества должны быть константными выражениями.
##### 2.5.1 Примеры

```
CONST
а = {1,2,16};
б = {0..10, 20};
в = {MIN(SET), MAX(SET)};
```

#### 2.6 Литералы массивов

Литералы массива пишутся так:

```
Массив = ’[’ Выражение {’,’ Выражение} ’]’.
```
Выражения в литерале массива должны быть выражениями-константами. В частности, они также могут быть литералами массивов.

Для правильного литерала массива `A` должен существовать _базовый тип_ `T`, такой, что тип `t` каждого выражения в `A` должен быть совместим по присваиванию с `T`. Мы обозначаем совместимость по присваиванию так: t <= T. Тип литерала массива - это статический «математический массив» с длиной, равной длине A и наименьшим возможным базовым типом массива T (т. е. не должно существовать другого T' <= T, чтобы для любого элемента массива было t <= T').

##### 2.6.1 Примеры

```
CONST
A = [1,2,3]; (* ARRAY [3] OF SIGNED8 *)
B = [A, [2,5,7], [10,100,MAX(SIGNED32)]]; (* ARRAY [3,2] OF SIGNED32) *)
C = [1.0, 3, 8]; (* ARRAY [3] OF FLOAT32 *)
D = [REAL(2.0), 4, 10]; (* ARRAY [3] OF REAL *)
```

#### 2.7 Ключевые слова, операции, разделители

Операторы и разделители - это специальные знаки, строки или зарезервированные слова, перечисленные ниже. Зарезервированные слова не могут использоваться в качестве идентификаторов. На следующем рисунке перечислены все зарезервированные ключевые слова и знаки операций, которые непосредственно распознаются сканером.

```
AWAIT BEGIN BY CONST CASE CELL CELLNET CODE DO DIV END ENUM ELSE ELSIF EXIT EXTERN FALSE FOR FINALLY IF IGNORE IMAG IN IS IMPORT LOOP MODULE MOD NIL OF OR OUT OPERATOR PORCEDURE PORT REPEAT RETURN SELF NEW RESULT THEN TRUE TO TYPE UNTIL VAR WHILE WITH ARRAY OBJECT POINTER RECORD ADDRESS SIZE ALIAS
( ) [ ] { } |
" ' , . .. : ;
& ~ ^ ?
# .# = .= < .< <= .<= > .> >= .>=
+ +* - * .* ** / ./ \ `
```

Кроме того, существуют следующие зарезервированные слова, используемые для встроенных процедур и типов. Эти имена также недоступны в качестве идентификаторов в модулях.

```
ABS ADDRESS ADDRESSOF ALL ANY ASH ASSERT BOOLEAN CAP CAS CHAR CHR COMPLEX COMPLEX32 COMPLEX64 COPY DEC DECMUL DIM ENTIER ENTIERH EXCL FIRST FLOAT32 FLOAT64 FLOOR HALT IM INC INCL INCMUL INCR INTEGER INTEGERSET LAST LEN LONG LONGINTEGER LSH MAX MIN OBJECT ODD RANGE RE REAL RESHAPE ROL ROR ROT SET SET8 SET16 SET32 SET64 SHL SHORT SHR SIGNED8 SIGNED16 SIGNED32 SIGNED64 SIZE SIZEOF STEP SUM UNSIGNED8 UNSIGNED16 UNSIGNED32 UNSIGNED32 UNSIGNED64
```

**Замечание 1**

*Следует отметить, что можно изменить EBNF, представленный в этом описании, таким образом, чтобы некоторые из  зарезервированных выше слов стали ключевыми словами (появились в EBNF) без изменения семантики представленного языка. С точки зрения разработчика компилятора это означает, что некоторые зарезервированные слова переходят из фазы проверки в фазу синтаксического анализа многоступенчатого компилятора.*

Есть еще несколько встроенных процедур и типов, которые играют особую роль в языке программирования "Активный Оберон". Они привязаны к специальному модулю под названием SYSTEM и не мешают использованию идентификаторов. Для полноты картины, однако, мы также перечислим их ниже.

```
SYSTEM.BYTE SYSTEM.GET SYSTEM.PUT SYSTEM.PUT8 SYSTEM.PUT16 SYSTEM.PUT32 SYSTEM.PUT64 SYSTEM.GET8 SYSTEM.GET16 SYSTEM.GET32 SYSTEM.GET64 SYSTEM.VAL SYSTEM.MOVE SYSTEM.REF SYSTEM.NEW SYSTEM.TYPECODE SYSTEM.HALT SYSTEM.SIZE SYSTEM.ADR SYSTEM.MSK SYSTEM.BIT SYSTEM.Time SYSTEM.Date SYSTEM.GetStackPointer SYSTEM.SetStackPointer SYSTEM.GetFramePointer SYSTEM.SetFramePointer SYSTEM.GetActivity SYSTEM.SetActivity
```

**Замечание 2**

*Встроенные процедуры отличаются от обычных тем, что они не обязательно соответствуют определенному интерфейсу процедуры (т. е. определенному списку формальных параметров). В Обероне нет концепции перегрузки (кроме той, что для операций), следовательно, некоторые встроенные процедуры не могут быть реализованы как обычные процедуры в каком-то отдельном модуле.*

#### 2.8 Комментарии

Комментарии могут быть вставлены между любыми двумя символами программы. Они представляют собой произвольные последовательности знаков, начинающихся с `(*` и заканчивающихся `*)`, и игнорируются программой. Комментарии могут быть вложенными.

##### 2.8.1 Примеры

```
(* Это комментарий *)
MODULE Тест;
CONST a (* константа a *) = 3 * (* раза *) 5 (* по пять *);
(* вложенные комментарии
	(* возможны
		"строки также игнорируются"
	*)
*)
END Тест.
```
**Замечание 3**

*В комментариях для целей документирования есть специальные обозначения. Они также не влияют на смысл программы (игнорируются), но полезны для автоматической генерации документации по исходному коду.*

#### 2.9 Условная компиляция

Программа может содержать произвольные блоки кода, которые компилируются условно. Такие блоки представляются знаком `#` в начале строки, за которым следует либо `if`, либо `elsif`, либо `else` в соответствии со следующим синтаксисом:

```
Block = ’#’ ’if’ Выражение ’then’ Block
	  { ’#’ ’elsif’ Выражение ’then’ Block }
	  [ ’#’ ’else’ Block]
		’#’ ’end’
	  | любой знак до следующего знака новой строки
```

Логическое выражение может состоять из идентификаторов и логических операций. Любой идентификатор в таких выражениях называется определением и оценивается либо как `TRUE`, либо как `FALSE` в зависимости от того, было ли определение предоставлено текущему вызову компилятора. Код внутри условного блока становится частью скомпилированной программы, только если выражение принимает значение `TRUE` и полностью игнорируется в противном случае. Условные блоки могут быть вложенными, но должны быть завершены с помощью `#end`.

### 3 Объявление и область его действия (правила видимости)

Каждый идентификатор, встречающийся в программе, должен быть объявлен, если только он не является предварительно объявленным (предопределенным) идентификатором. Объявления также определяют некоторые постоянные свойства элемента, например, определяют, является ли он константой, типом, переменной или процедурой. Затем идентификатор используется для ссылки на соответствующий элемент. Далее мы называем объявленный идентификатор *символом*.

*Области действия*  представляют из себя контексты, в которых символы могут быть объявлены и где можно на символы ссылаться  . В активном Обероне области могут быть вложенными. Область действия элемента x - это самый младший в иерархии вложенности блок (модуль, процедура, запись или объект), в котором элемент x объявлен. Элемент является локальным для этой области.

Правила примнения:

1. Ни один идентификатор не может обозначать более одного элемента в пределах данной области.

2. На элемент можно ссылаться непосредственно только в пределах его области действия.

3. Порядок объявления в пределах области действия не  влияет на смысл программы.

За идентификатором, объявленным в блоке модуля,  в его объявлении может следовать экспортная метка (`*`или `-`), чтобы указать, что он экспортируется. Идентификатор x, экспортируемый модулем M, может быть использован в других модулях, если они импортируют M. Идентификатор затем обозначается как M.x и называется составным идентификатором. Идентификатор, отмеченный знаком ` - ` в объявлении, доступен только для чтения в импортирующих  модулях.

```
Составной идентификатор = Идентификатор [’.’ Идентификатор].
Определение идентификатора = Идентификатор [ ’*’ | ’-’ ].
```
#### 3.1 Отличия от оригинальной версии Оберона

Правила для области действия (видимости) отличаются от правил оригинального языка Оберона, обоснование приводим ниже.

В оригинальном описании языка Оберон-2 область видимости начиналась с объявления элемента и заканчивались в конце блока, в котором они были объявлены. При такой конструкции переадресация была формально невозможна, что было решено явным допуском указателей на типы, определённые ниже по тексту. С появлением объектов в языке широко использовалась эта неявная ссылка  на будущее определение вместе со специальными правилами доступа к (глобальным) переменным из объектов, объявленных до объявления переменных.

С помощью многоступенчатого компилятора вполне возможно разрешить ссылки во всех направлениях (если только нет циклических зависимостей, которые не могут быть разрешены). Таким образом, правила для области видимости были расширены.

Для старого определения действителен следующий пример кода:

```
TYPE A = INTEGER;
PROCEDURE P;
VAR
b:A;
A: INTEGER;
BEGIN (* ... *)
END P;
```

в то время как следующий код был некорректным:

```
TYPE A = INTEGER;
PROCEDURE P;
VAR
A: INTEGER;
b:A;
BEGIN (* ... *)
END P;
```

Следующий пример также был формально некорректным (но все же принят всеми известными нам компиляторами):

```
TYPE A = INTEGER;
PROCEDURE P;
VAR A:A;
BEGIN (* ... *)
END P;
```
При новом определении все три примера являются недопустимыми (и не принимаются компилятором).

### 4 Последовательность объявлений

Последовательность объявлений - это последовательность объявлений констант, типов, переменных, процедур или операций. В отличие от предыдущих реализаций Оберона,  различные типы объявлений могут идти в произвольном порядке. 

```
ПоследовательностьОбъявлений = {
’CONST’ [ОбъявлениеКонстанты] {’;’ [ОбъявлениеКонстанты]}
|’TYPE’ [ОбъявлениеТипа] {’;’ [ОбъявлениеТипа]}
|’VAR’ [ОбъявлениеПеременной] {’;’ [ОбъявлениеПеременной]}
| ОбъявлениеПроцедуры
| ОбъявлениеОперации
| ’;’
}
```

Различные формы объявлений описаны ниже.

##### 4.0.1 Примеры

```
CONST (* объявления констант *)
UARTBufLen* = 3000;

TYPE (* объявления типа *)
UARTBuffer = ARRAY UARTBufLen OF SYSTEM.BYTE;
UartDesc* = RECORD (Device.DeviceDesc)
id: INTEGER;
in, out, oin, oout: SIZE;
open: BOOLEAN;
inbuffer, outbuffer: UARTBuffer
END;
Uart* = POINTER TO UartDesc;

VAR (* объявления переменных *)
uarts: ARRAY Platform.NUMCOMPORTS OF Uart;

(* объявления процедур *)
PROCEDURE Close( dev: Device.Device );
BEGIN
IF dev( Uart ).open = TRUE THEN
Platform.ClearBits(Platform.UART_CR, {Platform.UARTEN});
Kernel.EnableIRQ( Platform.UartInstallIrq, FALSE );
dev( Uart ).open := FALSE;
END;
END Close;

PROCEDURE Available( dev: Device.Device ): SIZE;
BEGIN
RETURN (dev( Uart ).in ? dev( Uart ).out) MOD UARTBufLen
END Available;
```

### 5 Модули

Модуль-это единица компиляции Оберона, и в то же время он составляет (одиночный) объект, предоставляющий (глобальные) данные и код. В дополнение к классическому модулю Оберона, модуль также может быть шаблонным модулем, который параметризуем.

```
Модуль = ’MODULE’ [ПараметрыШаблона] Идентификатор [’IN’ Идентификатор] ’;’
		{СписокИмпорта} ПоследовательностьОбъявлений [Тело]
		’END’ Идентификатор ’.’.

ПараметрыШаблона = ’(’ ПараметрШаблона {’,’ ПараметрШаблона} ’)’.

ПараметрШаблона = (’CONST’ | ’TYPE’) Идентификатор.

СписокИмпорта = ’IMPORT’ Импорт { ’,’ Импорт } ’;’.

Импорт = Идентификатор [’:=’ Идентификатор] [’(’ СписокВыражений ’)’ ]
		[’IN’ Идентификатор].
```

##### 5.0.1 Примеры

```
MODULE SPI; (* Raspberry Pi 2 SPI Interface -- Bitbanging *)
IMPORT Platform, Kernel;

CONST HalfClock = 100; (* микросекунды -- очень консервативны *)

PROCEDURE SetGPIOs;
BEGIN
Platform.ClearAndSetBits(Platform.GPFSEL0, {21..29},{21,24});
Platform.ClearAndSetBits(Platform.GPFSEL1, {0..5},{0,3});
END SetGPIOs;

PROCEDURE Write* (CONST a: ARRAY OF CHAR);
VAR i: SIZE;
BEGIN
Kernel.MicroWait(HalfClock);
Platform.WriteBits(Platform.GPCLR0, SELECT); (* Выбор сигнала *)
Kernel.MicroWait(HalfClock);
FOR i := 0 TO LEN(a)-1 DO
WriteByte(a[i]); ( запись данных, переключение часов *)
END;
Kernel.MicroWait(HalfClock);
Platform.WriteBits(Platform.GPSET0, SELECT); (* отмена выбора сигнала *)
END Write;
...

BEGIN
SetGPIOs;
END SPI;
```

#### 5.1 Отличия от оригинальной версии Оберона

##### 5.1.1 Контексты

Исходный код текущей системы А2 состоит из более чем тысячи модулей, из которых одна треть принадлежит унаследованной подсистеме Оберона. Чтобы отличить их принадлежность, некоторые имена модулей, принадлежащих к более новой системе A2, были помечены префиксом "Aos" (ее предыдущее название). К сожалению это соглашение об именовании имеет несколько недостатков:

* на первый взгляд принадлежность модулей с именами без префиксов не распознается и сбивает с толку новых пользователей.
* существующие префиксы не отражают и даже не отменяют предполагаемый приоритет модулей в системе.
* Новые модули должны иметь префиксы, так как большинство имен уже заняты модулями, принадлежащими Оберону. Поскольку система AOS в настоящее время переименована в A2, модули должны быть снова переименованы. Поэтому мы ввели более общую концепцию, которая позволяет избежать всех этих недостатков.

Контекст действует как одноуровневое пространство имен для модулей. Это позволяет модулям с одинаковыми именами сосуществовать в разных контекстах. Каждый модуль принадлежит ровно одному контексту. Псевдо-модуль `SYSTEM` доступен во всех контекстах, но не принадлежит ни к одному из них. В настоящее время пользователю доступны два контекста: Oberon и A2.

**Расширение языка.** Поскольку модули должны иметь возможность импортировать другие модули из разных контекстов одновременно, классификации, основанные на  опциях компилятора или различных именах файлов исходного кода, недостаточны. Поэтому программист должен уметь задавать контекст модуля в его коде. Необязательный идентификатор после ключевого слова `IN` указывает имя контекста, к которому принадлежит модуль. Контекст по умолчанию равен A2, если он опущен. Мы также добавили расширение синтаксиса для раздела импорта модуля: необязательная спецификация контекста сообщает компилятору, в каком контексте искать модули для импорта. Это позволяет использовать модули А2 внутри Оберона и наоборот. Контекст по умолчанию соответствует контексту модуля, если он опущен программистом.

**Соглашения об именах.** Имена файлов модулей и соответствующих им объектных файлов начинаются с префикса - имени их контекста, за которым следует точка. Поскольку большинство файлов будет принадлежать контексту A2 по умолчанию, этот префикс должен быть опущен для  лучшей читабельности. Использование префиксов для файлов модулей помогает программисту различать членство  в контексте, глядя на имя файла вместо того, чтобы просматривать его содержимое. Префикс для имен объектных файлов необходим компилятору и системе выполнения для динамической загрузки правильных модулей.

**Расширение среды выполнения.** Для выполнения команд среда выполнения неявно задает правильный контекст. Команда поиска и выполнение действуют только для модулей из одного контекста. Это также позволяет избежать раздражающей проблемы загрузки полной системы Oberon, когда на каком-то тексте, отображаемом в A2,  случайно нажали средней клавишей мыши.

**Простота.** Ввод понятия контекста потребовал лишь нескольких и очень простых доработок языка, компилятора и системы выполнения, и полностью обратно совместим с предыдущим решением. Он даже предлагает более общее решение фактической проблемы, которое напрашивалось. Поэтому его   в долгосрочной перспективе можно было бы использовать даже для сборки других больших программных пакетов, таких как графические приложения и библиотеки.

#### 5.2 Шаблоны

### 6 Объявление констант

Объявление константы связывает идентификатор со значением константы. Синтаксически объявление константы состоит из определения идентификатора и выражения.

```
ОбъявлениеКонстанты = [ОбъявлениеИдентификатора ’=’ ВыражениеКонстанты].
ВыражениеКонстанты = Выражение.
```

Семантически выражение константы должно быть выражением, которое может быть вычислено простым текстовым сканированием плюс сверткой константы, без фактического выполнения программы. Его операнды являются константами или предопределенными функциями, которые могут быть вычислены во время компиляции.

##### 6.0.1 Примеры

```
CONST
N = 320; (* Имя константы N, связанное со значением 320 *)
b* = 300; (* экспортированное имя константы b, связанное со значением 300 *)
c* = "A string"; (* имя константы c, связанное со строкой *)
limit = 2*a-1;
fullset = {MIN(SET) .. MAX(SET)}
```

### 7 Объявления типов

Тип данных определяет набор значений, который могут принимать переменные этого типа, и соответствующие операции. Объявление типа связывает идентификатор с типом. В случае структурированных типов (массивы, математические массивы, записи и объекты) оно также определяет структуру этого типа.

```
ОбъявлениеТипа = ОбъявлениеИдентификатора ’=’ Тип ’;’.
Тип = ТипМассив | ТипМатематическийМассив | ТипЗапись
	| ТипУказатель | ТипОбъект | ТипПроцедура
    | ТипПеречисление | СоставнойИдентификатор
	| ТипЯчейка | ТипСетьЯчеек | ТипПорт.
```

##### 7.0.1 Примеры

```
TYPE
Count = UNSIGNE64;
Pair = RECORD
first, second: Count;
END;
Table = ARRAY N OF REAL
Tree = POINTER TO Node
Node = RECORD
key : INTEGER;
left, right: Tree
END
CenterTree = POINTER TO CenterNode
CenterNode = RECORD (Node)
width: INTEGER;
subnode: Tree
END
Function = PROCEDURE(x: INTEGER): INTEGER
```

#### 7.1 Категории типов

Язык "Активный Оберон" включает следующие классы типов:

1. Базовые типы
2. Типы массив и математический массив
3. Тип запись
4. Тип указатель
5. Тип объект
6. Тип процедура
7. Тип перечисление
8. Тип порт, Тип ячейка и Тип сеть ячеек

##### 7.1.1 Базовые типы

Базовые типы предопределены языком Оберон и могут быть адресованы соответствующими предопределенными идентификаторами.

Некоторые типы, показанные в Таблице 1, представлены с фиксированным размером, который не зависит от целевой платформы. За исключением CHAR и BOOLEAN, фиксированная битовая длина обозначается суффиксом в типе (например, SET16 предусматривает 16 бит).

Кроме того, существуют зависимые от платформы типы, показанные в таблице 2, которые увеличиваются или уменьшаются в зависимости от целевой платформы. Платформенно-зависимые типы предоставлены путем неявных объявлений, в которых каждое имя является алиасом (псевдонимом) некоторого типа фиксированного размера. 

Существует еще один тип с фиксированной длиной, объявленный в (псевдо-)модуле SYSTEM, тип Байт SYSTEM.BYTE. Кроме того, строго говоря, существует также тип Строка, который неявно связан со строковыми литералами и не доступен в качестве явного типа в объявлениях.

Таблица 1: Базовые типы фиксированного размера

|Имя типа|Размер|Допустимые значения|
|-|-|-|
|BOOLEAN|1 byte|TRUE or FALSE|    
|CHAR|1 byte|Знаки расширенного набора ASCII (0X. . . 0FFX)|
|SIGNED8|1 byte|Целые между -2↑7 и 2↑7 - 1|
|SIGNED16|2 bytes|Целые между -2↑15 и 2↑15 - 1|
|SIGNED32|4 bytes|Целые между -2↑31 и 2↑31 - 1|
|SIGNED64|8 bytes|Целые между -2↑63 и 2↑63 - 1|
|UNSIGNED8|1 byte|Целые между 0 и 2↑8 - 1|
|UNSIGNED16|2 bytes|Целые между 0 и 2↑16 - 1|
|UNSIGNED32|4 bytes|Целые между 0 и 2↑32 - 1|
|UNSIGNED64|8 bytes|Целые между 0 и 2↑64 - 1|
|FLOAT32|4 bytes|Число с плавающей точкой между -3.4028↑38 и +3.4028↑38|
|FLOAT64|8 bytes|Число с плавающей точкой между -1.7976↑308 и +1.7976↑308|
|SET8|1 byte|любое целое от 0 до 7|
|SET16|2 bytes|любое целое от 0 до 15|
|SET32|4 bytes|любое целое от 0 до 31|
|SET64|8 bytes|любое целое от 0 до 63|

Table 2: Платформенно-зависимые базовые типы

|Имя типа|Размер|Допустимые значения|
|-|-|-|
|REAL||тип с плавающей точкой по умолчанию, соответствует `double` в C|
|INTEGER|машинное слово|целые числа со знаком размером в машинное слово, соответствует `int` в C|
|ADDRESS|длина адреса|целые числа без знака в адресном диапазоне|
|SIZE|длина адреса|целые числа со знаком в адресном диапазоне|
|SET|длина адреса|множество с длиной адреса|

На схеме ниже показана (неявная) совместимость целочисленных типов. Стрелка от А до В означает: переменная типа А может быть присвоена переменной типа В.

```
SIGNED8 → 	SIGNED16 → 	SIGNED32   →   SIGNED64
		   ◄			◄			  ◄
	↓	  /		↓	   /	↓		 /	  ↓
   		 /			  /				/
UNSIGNED8 → UNSIGNED16 → UNSIGNED32 → UNSIGNED64
```

Диапазон большего типа включает в себя диапазоны меньших типов. Говорят, что меньший тип совместим с большим в том смысле, что он может быть преобразован без опасности потери начальных цифр. В присваиваниях и расширениях преобразование внутренних представлений происходит автоматически.

Целые без знака совместимы с целыми со знаком или без знака того же или меньшего размера. Это означает, что присваивание целого со знаком целому без знака того же размера считается нормальным. Обратное направление не работает.

Хотя тип SIZE - со знаком, а ADDRESS - без знака, эти типы считаются совместимыми по присваиванию в обоих направлениях.

Кроме того, типы целого совместимы с типами чисел с плавающей точкой, то есть любой целый тип может быть присвоен FLOAT32 или FLOAT64, а FLOAT32 совместим с FLOAT64. Обратите внимание, что при преобразовании целых чисел в числа с плавающей точкой может происходить потеря точности, в т.ч. два различных целых числа могут превратиться в одно и то же число с плавающей точкой. В будущем планируется запретить неявные преобразования из целых в плавающие. 

Там, где нет неявной совместимости между типами, они могут быть преобразованы с помощью явного преобразования. Для преобразования  может быть использовано само имя типа.

##### 7.1.2 Примеры
```
VAR
s8: SIGNED8; s16: SIGNED16; s64: SIGNED64;
u8: UNSIGNED8; u16: UNSIGNED16; u64: UNSIGNED64;
adr: ADDRESS; size: SIZE;
BEGIN
s16 := s8; (* правильно *)
u16 := s8; (* правильно *)
s16 := u8; (* правильно *)
u16 := s16; (* правильно *)
adr := size; (* правильно *)
size := adr; (* правильно *)

s16 := u16; (* ошибка *)
s16 := SIGNED16(u16); (* правильно *)
```

##### 7.1.3 Отличия от оригинальной версии Оберона

Базовые типы оригинала Оберона состояли из четырех типов целого `SHORTINT`, `INTEGER`, `LONGINT` и `HUGEINT`.

На заре истории Оберона многие разработчики считали, что размеры типов будут увеличиваться вместе с совершенствованием оборудования. Однако фактически типы были зафиксированы в размерах 8, 16, 32 и 64 бит, поскольку в значительном количестве библиотек размеры типов были заданы именно так, и изменение размеров сделало бы их непригодными.

К сожалению, типы, которые выражают аппаратно-зависимые свойства, такие как длина адреса, не были включены, что затрудняло перенос Оберона, например, в 64-битные архитектуры. Адреса в старших 2Gb 32-битных системах уже создавали проблемы, поскольку они были представлены с помощью `LONGINT`, целого 32-битного типа со знаком.

Мы решили сделать радикальный шаг и полностью отказаться от старых имен типов и ввести типы с именами, которые четко указывают, что они либо привязаны к определенной битовой длине, либо к особенностям оборудования.

Мы ввели типы целого без знака, поскольку они могут принести пользу и потому что они действуют по-разному в таких базовых операциях, как сдвиги или сравнения.

**Когда использовать `SIZE`.** Тип `SIZE` является знаковым аналогом типа `ADDRESS`. В то время как тип `ADDRESS` в основном предназначен для низкоуровневого программирования, тип `SIZE` имеет высокую актуальность во всех видах программ.

`SIZE` должен использоваться, когда любая часть памяти или интервал адресуется (неявно). Это подразумевает использование для указания длины массива, повторения или подсчета элементов массива, а также повторения или подсчета элементов в других динамических структурах данных.

**Когда использовать `INTEGER`.** Тип `INTEGER`представляет длину слова базовой архитектуры. Таким образом, никаких предположений о битовой длине этого типа делать не следует. Существуют платформы с довольно большой разницей между длиной адреса и оптимальной длиной для целочисленных вычислений. Например, для AMD 64 размер машинного слова определяется как 32-разрядный.

Программист обычно должен обращать внимание на некоторые аспекты внутреннего представления типа, даже если это только некоторое интуитивное представление о типах, которые он или она используют.

Программист может надеяться, что размер машинного слова соответствует типичной области приложения ("полезен") для целых чисел «общего назначения», которые не представляют собой адреса или разницы адресов. Это относится к "int" в C, и это необходимо и, вероятно, будет сделано для `INTEGER` в этой версии Оберона.

Однако мы считаем, что использование `INTEGER` весьма ограничено. Это, безусловно, полезно в обучении, для быстрого создания прототипов или для любого случая, когда программист ожидает, что результат вычислений будет достаточно мал для типичной области применения на данной машине. Во всех остальных случаях программист должен использовать тип с гарантиями размера (например, `SIGNED64`), тип `SIZE` или использовать объявленный тип для гибкости.

**Используйте объявления типа.** Мы вообще считаем, что хорошая практика применения содержательных (длинных) имен переменных также подходит для использования объявленных типов с содержательными именами (такими как, "скорость", "сумма" или "битовая длина") и обеспечивает хороший способ для понимания предполагаемого назначения типа.

**Различные типы целых.** Запись с одним полем целочисленного типа идентична этому целочисленному типу по размещению в памяти. Массив таких записей в памяти размещается так же, как и массив чисел. Поэтому, если нужно создать несовместимые между собой по присваиванию типы целых чисел, можно для этой цели использовать записи с одним полем. Если для таких «псевдо-чисел» нужны операции, скажем, сложения, их можно определить с помощью переопределения операций. Для преобразования таких «псевдо-чисел» в обычные числа можно сделать поле доступным для чтения. Для преобразования чисел в «псевдо-числа» придётся написать функцию и понести накладные расходы во время выполнения на её вызов. 

#### 7.2 Тип Массив

Массив - это структура, состоящая из нескольких элементов, которые все имеют один и тот же тип, называемый типом элемента. Число элементов массива называется его длиной. Элементы массива обозначаются индексами, представляющими собой целые числа от 0 до N-1, где N - длина массива.

Массивы объявляются следующим образом:

```
ТипМассив = ’ARRAY’ [Выражение {’,’ Выражение}] ’OF’ Тип.
```

Возможны два вида массивов:

1. Статические массивы объявляются как `ARRAY x OF type`, где x должно быть выражением константы,

2. Открытые массивы объявляются как "ARRAY OF тип". Открытые массивы могут применяться в следующих случаях:
    - как базовый тип (тип указуемого) для указателя
    - как тип элемента для другого типа открытого массива
    - как формальный параметр

Выражение `ARRAY x,y OF тип` является сокращенным обозначением для `ARRAY x OF ARRAY y OF тип`.

Семантические правила:

* Статические массивы открытых массивов не допускаются.
* Массивы математических массивов не допускаются.
* Выражение длины x в `ARRAY x OF тип` должно быть константой, положительным целым числом или нулем.

```
TYPE
  Vector = ARRAY 4 OF REAL;
  Matrix = ARRAY 4,4 OF REAL;
VAR
  buffer: ARRAY 16 OF SIZE;

PROCEDURE Print(CONST x: ARRAY OF CHAR)
```

#### 7.3 Математические Массивы

Специальные математические типы были добавлены в язык "Оберон" недавно. Они объявляются так:

```
ТипМатематическийМассив = ’ARRAY’ ’[’ РазмерМатематическогоМассива {’,’ РазмерМатематическогоМассива} ’]’ ’OF’ Тип.
РазмерМатематическогоМассива = Выражение | ’*’ | ’?’.
```

Возможны три вида математических массивов:

1. Статические математические массивы объявляются как `ARRAY [x] OF Тип`, где `x` должен быть константой.
2. Открытые математические массивы объявляются как `ARRAY [*] OF Тип`.
3. Тензоры объявляются как `ARRAY [?] OF type`.

Опять же, выражение `ARRAY [x,y] OF Тип` - это сокращенная запись для `ARRAY [x] OF ARRAY [y] OF Тип`.

Семантические правила:

* Математические массивы (обычных) массивов не допускаются.
* Массивы тензоров и тензоры массивов не допускаются.
* Статические математические массивы открытых математических массивов или статические математические массивы тензоров не допускаются.
* Выражение длины `x` в `ARRAY [x] OF Тип` должно быть константой, положительным целым числом или нулем.

Математические массивы считаются типами значений. Это означает, что в присваивании `a := b` данные из `b` копируются в `a`. Если `a` - открытый математический массив, то память будет выделена автоматически. Таким образом, математические массивы также могут использоваться для объявления открытых массивов. Открытый математический массив всегда инициализируется с нулевыми длинами. Тензор - это математический массив, который не только имеет переменную длину, но возможна даже переменная размерность. Он инициализируется с размерностью 0. Длины и размерность математических массивов можно определить с помощью встроенных функций `LEN` и `DIM`. Длина и размерность математического массива могут быть заданы с помощью операции `NEW`.

##### 7.3.1 Примеры

```
VAR
x: ARRAY [*] OF REAL;
vec: ARRAY [4] OF REAL;
matrix: ARRAY [*,*] OF REAL;
array3: ARRAY [*,3] OF REAL;
tensor: ARRAY [?] OF FLOAT32;
BEGIN
NEW(x,5); (* x теперь имеет длину 5 *)
vec := x[0..3]; (* vec теперь имеет содержимое x *)
matrix := [x,x]; (* матрица размером 2 x 5 *)
tensor := FLOAT32(matrix); (* тензор имеет размерность 2 *)
```

#### 7.4 Тип Запись

Тип запись - это структура, состоящая из фиксированного числа элементов, называемых полями, с возможными различными типами. В объявлении типа запись указываются имя и тип каждого поля. Область действия идентификаторов полей простирается от момента их объявления до конца типа запись, но они также видны в именующих выражениях, ссылающихся на элементы переменных записи. Если тип запись экспортируется, то должны быть отмечены идентификаторы полей, которые будут видимы за пределами объявления модуля. Они называются публичными полями; не отмеченные элементы называются частными (приватными) полями.

```
ТипЗапись = ’RECORD’ [’(’ СоставнойИдентификатор ’)’]
		[ОбъявлениеПеременной {’;’ ОбъявлениеПеременной}]
		{ОбъявлениеПроцедуры [’;’]| ОбъявлениеОперации [’;’]}
		’END’.
```

##### 7.4.1 Примеры

```
TYPE
	Date = RECORD
		day*, month*, year*: INTEGER
	END
VAR
	x: RECORD
		name, firstname: ARRAY 32 OF CHAR;
		age: INTEGER;
		salary: REAL
	END
```

Типы "запись" являются расширяемыми, то есть тип записи может быть объявлен как расширение другого типа записи. Например:

```
T0 = RECORD x: INTEGER END
T1 = RECORD (T0) y: REAL END
```

T1 - это (прямое) расширение T0, а T0 - это (прямой) базовый тип для T1. Расширенный тип T1 состоит из полей его базового типа и полей, объявленных в T1. Все идентификаторы, объявленные в расширенной записи, должны отличаться от идентификаторов, объявленных в записях базового типа.

Семантические правила:

* Если запись определена в виде `T1 = RECORD (T0) ... END`, T0 должен быть записью.
* Если тип T1 определяется как указатель на запись в виде `T1 = POINTER TO RECORD (T0) ... END`, тогда T0 может быть записью или указателем на запись.

Запись может быть помечена модификатором `FINAL` и в этом случае не может быть расширена:

##### 7.4.2 Примеры

```
TYPE
Date = RECORD {FINAL}
day, month, year: INTEGER;
END
```

#### 7.5 Тип указатель

Формально указатели могут определяться в виде:

```
ТипУказатель = ’POINTER’ [Флаги] ’TO’ Тип.
```

Переменные типа указатель `P` принимают в качестве значений указатели на переменные некоторого типа `T`. Этот тип называется базовым типом указателя (типом указуемого) для `P` и должен быть типа запись или массив, если только `P` не является небезопасным указателем (см. ниже). Типы указатель наследуют отношение расширения у своих типов указуемых: если тип `T1` является расширением `T`, а `P1` - типом `POINTER TO T1`, то `P1` также является расширением `P`.

Таким образом, в языке активный Оберон реально возможны два вида (безопасных) указателей:

1. Указатель на массив объявляется как `POINTER TO` типа массив
2. Указатель на запись объявляется как `POINTER TO` типа запись

Если `p` является переменной типа `P = POINTER TO T`, то вызов встроенной процедуры процедуры `NEW (p)` распределяет переменную типа T на куче. Если `T` имеет тип запись или тип массив с фиксированной длиной, то распределение должно быть выполнено с помощью `NEW(p)`; если `T`- это n-мерный тип открытого массива, то распределение должно быть выполнено с помощью `NEW (p, e0,..., en-1)`, где `T` распределяется с длинами, определенными выражениями e0,..., en-1. В любом случае указатель на выделенную переменную присваивается `p`. `p` относится к типу `P`. Ссылочная переменная `p^` (произносится как p-ссылочная) относится к типу T.

Любая переменная-указатель может принимать значение `NIL`, которое указывает на отсутствие переменной вообще. Все переменные-указатели являются расширениями базового типа `ANY` и инициализируются значением `NIL`.

Для системного программирования: язык Оберон, обсуждаемый здесь, содержит небезопасные указатели. Небезопасный указатель  совместим по присваиванию с типом `ADDRESS`, и разрешены арифметические действия с указателем.

##### 7.5.1 Примеры

```
CONST
GPIO = 03F200000H;
VAR
gpio*: POINTER {UNSAFE} TO RECORD
GPFSEL: ARRAY 6 OF SET32;
reserved: ADDRESS;
GPFSET: ARRAY 2 OF SET32;
GPFCLR: ARRAY 2 OF SET32;
END;

BEGIN
gpio := GPIO;
```

#### 7.6 Тип процедура

Переменные типа процедура `T` принимают значение процедура (или `NIL`). Если процедура `P` присваивается переменной типа `T`, то списки формальных параметров `P` и `T` должны совпадать. `P` не должна быть локальна для другой процедуры. Если `P` - это тип процедуры, связанной с типом (метод), то `T` должена быть помечена как делегат.

```
ТипПроцедура = ’PROCEDURE’ [Флаги] [ФормальныеПараметры].
```

##### 7.6.1 Примеры

```
TYPE
 Sender* = PROCEDURE {DELEGATE} ( CONST buf: ARRAY OF CHAR; ofs, len: SIZE);
VAR
 Available*: PROCEDURE ( dev: Device ): LONGINT;
```

#### 7.7 Тип объект

Объекты - это в своей основе указатели на записи, к которым могут прилагаться процедуры. Процедуры в объекте являются методами: они находятся в области видимости объекта и имеют доступ к переменным объекта. На экземпляр объекта можно ссылаться в его методе с помощью идентификатора `SELF`.

Метод с префиксом амперсанда`&` называется инициализатором объекта. Этот метод автоматически вызывается, когда экземпляр объекта создается, и обрабатывается до того, как становится общедоступным. Объект может иметь не более одного инициализатора. Если инициализатор отсутствует, он наследуется из базового типа. Инициализаторы могут быть вызваны как методы.

Объекты могут иметь тело. Это тело выполняется после инициализатора. Тело объекта может быть активным, и в этом случае оно выполняется в отдельном (логическом) потоке выполнения.

##### 7.7.1 Примеры

```
ТипОбъект = ’OBJECT’
			| ’OBJECT’ [Флаги] [’(’ СоставнойИндентификатор ’)’]
			  ПоследовательностьОбъявлений
			[Тело]
			’END’ [Идентификатор].
```

#### 7.8 Тип перечисление

Тип `ENUM` объявляет множество значений констант, называемых элементами перечисления и видимых в области видимости этого типа. Использование типа перечисление обеспечивает безопасность типов, гарантируя, что недопустимые значения не могут быть использованы для любой переменной или параметра типа перечисление, включающего операции с переменными этого типа.

Тип элемента перечисления - это перечисление, в котором он объявлен. Тип перечисления поддерживает присваивание и отношения упорядочивания (`<`, `>` и т.п.). Перечисление может быть расширено, в этом случае все элементы этого перечисления становятся совместимыми по присваиванию и сравнению с элементами расширенного перечисления. Чтобы обратиться к элементу перечисления, его нужно квалифицировать именем типа перечисления, т.е. `МоёПеречисление.КакойТоЭлемент`. 

Каждый элемент перечисления имеет порядковый номер, который может быть задан явно с помощью произвольного целочисленного выражения. Если этот параметр опущен, то порядковвй номер элемента перечисления соответствует номеру его предыдущего элемента, увеличенному на единицу. Неявный порядковый номер первого элемента равен нулю или наибольшему порядковому номеру всех базовых перечислений, в случае, если данное перечисление расширяет другое, увеличенному на единицу. Фактическое значение элемента или переменной перечисления может быть получено с помощью операции `ORD`, которая дает наименьший целочисленный тип, способный представлять все порядковые номера соответствующего перечисления.

Отдельные идентификаторы списка типа `ENUM` можно экспортировать, пометив их знаком `*`.

```
ТипПеречисление = ’ENUM’ [’(’СоставнойИдентификатор’)’]
				ОпределениеИдентификатора [’=’ Выражение]
				{’,’ ОпределениеИдентификатора [’=’ Выражение]}
				’END’.
```

Тип `ENUM` может быть определен как расширение существующего объявления типа `ENUM` путем включения идентификатора базового типа в определение расширяемого типа  в скобках, подобно записям. Все перечисленные значения базового типа становятся допустимыми значениями нового типа. Но обратите внимание, что базовый тип совместим только "вниз" с любыми расширенными типами, производными от него, расширения не совместимы "вверх" с их базовым типом. Это ограничение существует потому, что любое значение базового типа всегда является допустимым значением любого расширенного типа, производного от него, однако не каждое значение расширенного типа также является допустимым значением базового.

##### 7.9 Примеры

Предположим, что переменная типа перечисление типа экспортируется из модуля.

```
MODULE Graphics;
TYPE
  Monochrome* = ENUM
	black*, white* (* ORD(black) имеет значение 0 *)
  END;
VAR
  pixel* : Monochrome; (* pixel экспортируется *)
```

После импорта переменной ее можно использовать.

```
MODULE Application;
IMPORT Graphics;
VAR pixel: Graphics.Monochrome;
BEGIN
  pixel := Monochrome.white; (* Определено *)
```

И тип перечисление может быть расширен, основываясь на исходном типе.

```
TYPE
Monochrome = Graphics.Monochrome;
ColourRGB = ENUM (Monochrome)
  red, blue, green
END;
ColourCYM = ENUM (Monochrome)
  cyan, yellow, magenta
END;
VAR a:Monochrome; b,d: ColourRGB, c: ColourCYM;
  BEGIN
	(* следующие значения допустимы, совместимы по присваиванию *)
	a:= ColourRGB.white;
	b:= ColourRGB.blue;
	c:= ColourRGB.yellow;
	b:= a (*допустимо - значение b теперь - white *);
	d:= b (*допустимо - значение d теперь - blue *);
	(* следующие значения недопустимы из-за несоответствия типов *)
	a:= b (*недопустимо*)
	b:= c (*недопустимо*)
```

##### 7.9.1 Сравнение с оригинальной версией Оберона

В оригинальном Обероне вообще не было типов перечисление, и они были добавлены в язык.

Ранее были выдвинуты два основных возражения против типа перечисление: потенциальная неоднозначность именования при импорте типа перечисление из другого модуля и отсутствие расширяемости типов. Чтобы обеспечить простое решение проблемы потенциальной неоднозначности, все идентификаторы перечисления считаются идентификаторами типа. Максимальное число идентификаторов в перечислении и значение, которое может быть им присвоено, зависит от реализации.

В языке без типов перечисление или с типами "квазиперечисление"  программисты должны вручную проверить, что значения не выходят за пределы диапазона, но для больших программ это становится практически невозможным, даже для небольших программ это трудно. Например, код системы Oberon засорен группами объявлений CONST, которые обеспечивают безтиповую и подверженную ошибкам замену для типов перечисление.

#### 7.10 Активные ячейки: Тип ячейка, тип сеть ячеек и тип порт

```
ТипЯчейка = (’CELL’ | ’CELLNET’) [Флаги] [СписокПортов] [’;’] {СписокИмпорта}
			ПоследовательностьОбъявлений
			[Тело] ’END’ [Идентификатор].
            
СписокПортов = [ОбъявлениеПорта {’;’ ОбъявлениеПорта}].

ОбъявлениеПорта = Идентификатор [Флаги] {’,’ Идентификатор [Флаги]}’:’ ТипПорт.

ТипПорт = ’PORT’ (’IN’|’OUT’) [’(’ Выражение ’)’].
```

### 8 Объявления переменных

Объявления переменных устанавливают переменные, определяя для них идентификатор и тип данных. Переменные могут быть инициализированы со значением. Если значение не задано, то для указателей гарантируется инициализация с нулевым значением, а в других случаях она зависит от реализации компилятора.

*В A2 и ЯОС под Intel 86 любая переменная забивается нулями, если у неё нет инициализатора. Во всяком случае, мы на это надеемся. В A2 для ARM 
есть ключ, позволяющий отключить заполнение нулями, но в состав ЯОС поддержка ARM не включена* 

```
ОбъявлениеПеременной = СписокИменПеременных [’:’ Тип].
СписокИменПеременных = ИмяПеременной {"," ИмяПеременной}.
ИмяПеременной = ОпределениеИдентификатора [Флаги]
			[’:=’ Выражение | ’EXTERN’ Выражение].
Флаги = ’{’ [ Флаг {’,’ Флаг} ] ’}’.
Флаг = Идентификатор [’(’ Выражение ’)’ | ’=’ Выражение].
```

Переменные могут быть помечены как `EXTERN`, и в этом случае их идентификатор является просто псевдонимом для фиксированной области памяти. Этот адрес может быть задан выражением константы или строковым литералом, ссылающимся на объект, который определен в другом месте. Поскольку внешние переменные просто ссылаются на некоторые другие данные, они не могут быть инициализированы.

Типы в объявляемых переменных могут быть опущены при наличии инициализаторов, и тип переменной должен быть определен из типа выражения.

##### 8.0.1 Инициализация переменных

Переменные с инициализатором инициируются до того, как их можно будет использовать. Обычно это означает, что инициализация выполняется в начале соответствующей секции кода:

* Если переменная является полем в объекте, она инициализируется после размещения объекта, но до вызова инициализатора объекта.
* Если переменная является полем в записи, она инициализируется при инициализации записи.
* Если переменная объявлена в области действия процедуры, она инициализируется в начале тела процедуры.
* Если переменная объявлена в области видимости модуля и инициализатор не является константным выражением, она инициализируется в начале тела модуля. Если переменная объявлена в области видимости модуля и если инициализатор является константным выражением, то переменная инициализируется в объектном файле модуля. Это может быть важно для низкоуровневого системного модуля, где код (например, процедуры с флагами `OPENING`) может быть выполнен до тела модуля.

##### 8.0.2 Примеры

```
VAR
a : REAL;
b := 10, c : INTEGER;
c* {UNTRACED} : POINTER TO ARRAY OF CHAR;
d EXTERN "BaseTypes.Pointer" : ADDRESS;
e := SomeProc(); (* type inferred *)
```

##### 8.0.3 Отличия от оригинальной версии Оберона
Флаг `EXTERN` не присутствовал в оригинальном Обероне. Кроме того, мы добавили инициализаторы переменных и определение типа переменной по типу выражения.

### 9 Объявления процедур

Объявление процедуры состоит из заголовка процедуры и тела процедуры. Заголовок задает идентификатор процедуры и формальные параметры. Для процедур, связанных с типом, в нем также указывается параметр-приемник. Тело содержит объявления и операторы. Идентификатор процедуры повторяется в конце объявления процедуры.

Существует два вида процедур: собственно процедуры и процедуры-функции. Последние активируются именующим выражением, указывающим на эту функцию, в составе некоего выражения, и возвращают результат, который становится операндом выражения. Собственно процедуры активируются вызовом процедуры. Процедура является процедурой-функцией, если в строке ее формальных параметров задан тип результата. Тело процедуры-функции должно содержать оператор `RETURN`, который определяет ее результат.

Результат процедуры-функции может быть проигнорирован с помощью оператора `IGNORE Выражение` (который нигде отдельно не описан - это упущение).

Все константы, переменные, типы и процедуры, объявленные в теле процедуры, являются локальными для процедуры. Поскольку процедуры могут быть объявлены как локальные объекты, объявления процедур могут быть вложенными. Вызов процедуры в рамках ее объявления подразумевает рекурсивную активацию.

В добавок к ее формальным параметрам и локально объявленным объектам, в процедуре также видимы объекты, объявленные в ее окружении (за исключением тех объектов, которые имеют такое же имя, как и у объекта, объявленного локально).

```
ОбъявлениеПроцедуры = ’PROCEDURE’ [’^’|’&’|’~’|’-’|Флаги [’-’]]
					[’(’ ОбъявлениеПараметра ’)’]
					ОпределениеИдентификатора [ФормальныеПараметры]
					[’EXTERN’ Выражение ’;’ | ’;’
					ПоследовательностьОбъявлений [Тело]
					’END’ Идентификатор].

ФормальныеПараметры = ’(’ [ОбъявлениеПараметра {’;’ ОбъявлениеПараметра}] ’)’
					[’:’ [Флаги] Тип].

ОбъявлениеПараметра = [’VAR’|’CONST’] Идентификатор [Флаги] [’=’ Выражение]
			{’,’ Идентификатор [Флаги] [’=’ Выражение]} ’:’ Тип.

Тело = ’BEGIN’ [Флаги] ПоследовательностьОператоров [’FINALLY’ ПоследовательностьОператоров]
		| ’CODE’ Код.
```

Процедуры могут быть помечены как `EXTERN`, и в этом случае их идентификатор является просто псевдонимом для фиксированной области памяти (где находится исполняемый код). Этот адрес может быть задан выражением константы или строковым литералом, ссылающимся на объект, который определен в другом месте. Поскольку внешние процедуры просто ссылаются на некий другой код, они не имеют тела.

##### 9.0.1 Примеры

Ниже приведены некоторые примеры объявления процедуры. Последним (самым правым) формальным параметрам процедуры могут быть заданы значения по умолчанию. Впоследствии процедура может быть вызвана с меньшим количеством фактических параметров, а неуказанные параметры принимают значения по умолчанию. 

```
PROCEDURE Send*(CONST data: ARRAY OF CHAR; ofs,len: SIZE;VAR res: INTEGER );
BEGIN (* ... *)
END Send;

PROCEDURE & Init*(scanner: Scanner.Scanner; diagnostics: Diagnostics);
BEGIN (* ... *)
END Init;

PROCEDURE Float*(x: FLOAT64; n := 4, f := 3, d := 0: INTEGER);
BEGIN
Commands.GetContext().out.FloatFix(x,n,f,d);
END Float;
```
Если в объявлении процедуры указан параметр-приемник, процедура считается связанной с типом (здесь: тип Student), см. [Процедуры, связанные с типом](#процедуры-связанные-с-типом)
```
PROCEDURE (CONST s: Student) GetGrade(Subject: INTEGER): REAL;
BEGIN (* ... *)
END GetGrade;
```

#### 9.1 Формальные параметры

Формальные параметры - это идентификаторы, объявленные в списке формальных параметров процедуры. Они соответствуют фактическим параметрам, указанным в вызове процедуры. Соответствие между формальными и фактическими параметрами устанавливается при вызове процедуры. Существует два вида параметров по способу передачи - параметры-значения и параметры-переменные. Параметры-переменные отличаются тем, что перед именем параметра присутствует ключевое слов `VAR` или `CONST`. В случае наличия слова `CONST` параметр может использоваться процедурой только для чтения, то же относится к его членам (полям или элементам массива). Параметр-значение - это локальная переменная, которой в качестве начального присваивается копия значения соответствующего фактического параметра. При передаче параметра-переменной по сути передаётся только адрес переменной. Любые изменения членов переданного значения мгновенно отражаются на переданном объекте. Если в качестве параметра-переменной указано имя переменной или член составного объекта, а в вызванной процедуре было произведено присваивание значения соответствующему параметру, то это изменение мгновенно отражается на значении формального параметра, т.е. значение переменной или значение члена составного объекта изменится. 

*Здесь возможна путаница со ссылочными типами, такими, как объекты или указатели на записи. Значение ссылочного типа - это не сам объект, а лишь адрес того места в памяти, где размещается объект. Поэтому при передаче ссылочного типа по значению копируется только адрес, а сам объект остаётся прежним. Изменение любого члена объекта внутри процедуры мгновенно отражается на объекте. Однако, присваивание значения формальному параметру в теле вызываемой процедуры не оказывает на переданный объект, или на переменную, в которую он записан, никакого воздействия. Оно действует только внутри процедуры и смысл действия в том, что в локальную переменную, порождённую данным формальным параметром, записан другой объект. Если же значение ссылочного типа передано как параметр-переменная, то присваивание значения этому параметру внутри процедуры приведёт к тому, что оригинальная переменная в вызывающей процедуре начнёт указывать на другой объект.*

*Данное наложение понятий достаточно неприятно, но оно встречается во многих языках программирования и к нему придётся привыкнуть. В программировании мы зачастую имеем дело не самим составным объектом (например, записью), а с цепочкой указателей, которые указывают друг на друга и лишь последний из них содержит адрес собственно объекта. Эта цепочка указателей имеет переменную длину: для ссылочных типов она увеличивается на единицу, и для VAR параметров - тоже. Проблема в том, что эти промежуточные указатели не записаны явным образом в исходном тексте программы - нам приходится их воображать и помнить, какая операция действует на какой из них. Если бы мы даже попытались сделать эти указатели явными (подобно тому, как это сделано в Си), это помогло бы не на долго: можно определять новые типы и скрывать за этими определениями факт существования указателей, в результате чего посчитать их количество в цепочке в общем случае может оказаться нелегко.*

Процедура-функция без параметров должна иметь пустой список параметров. Он должен быть вызван именующим выражением, фактический список параметров которого также пуст. Тип результата процедуры не может быть ни записью, ни массивом.

Пусть `Tf` - тип формального параметра `f`, а `Ta` - тип соответствующего фактического параметра `a`. При вызовах процедуры `a` должен быть совместим с `f`. Правила совместимости определены в разделе [добавь-ссылку!](добавь-ссылку!)14.8.

#### Процедуры, связанные с типом

Глобально объявленные процедуры могут быть связаны с типом запись, объявленным в том же модуле. В этом случае говорят, что процедуры связаны с типом запись. Связь выражается типом приемника в заголовке объявления процедуры. Приемником может быть либо переменная, либо параметр-константа записи типа `T`, либо параметр-значение типа `POINTER TO T` (где `T` - тип запись). Процедура привязана к типу `T` и считается локальной для него.

Если процедура `P` связана с типом `T0`, она также неявно связана с любым типом `T1`, который является расширением `T0`. Однако процедура `P'` (с тем же именем, что и `P`) может быть явно связана с `T1`, и в этом случае она переопределяет связывание с `P`. `P'` считается переопределением `P` для `T1`. Сигнатуры `P` и `P'` должны совпадать (см. 14.2). Если `P` и `T1` экспортируются, то `P'` тоже должна экспортироваться.


ПРАВЬМЯ!!! Ввести понятие место и везде его использовать. 

Если `v` - именующее выражение, а `P` - связанная процедура, то `v.P` обозначает процедуру `P`, связанную с динамическим типом `v`. Обратите внимание, что это может быть процедура отличная от той, которая связана со статическим типом `v`. `v` передается приемнику `P` в соответствии с правилами передачи параметров, указанными в разделе 9.1.

Если `r` - параметр-приемник, объявленный с типом `T`, то `r.P^` обозначает (переопределенную) процедуру `P`, связанную с базовым типом `T`. Cигнатура обоих объявлений должна совпадать (14.2).

##### 9.2.1 Примеры

```
PROCEDURE (t: Tree) Insert (node: Tree);
  VAR p, father: Tree;
BEGIN p := t;
  REPEAT father := p;
	IF node.key = p.key THEN RETURN END;
	IF node.key < p.key THEN
	  p := p.left
	ELSE
	  p := p.right
    END
  UNTIL p = NIL;
  IF node.key < father.key THEN
	father.left := node
  ELSE
	father.right := node
  END;
  node.left := NIL; node.right := NIL
END Insert;

PROCEDURE (t: CenterTree) Insert (node: Tree); (* переопределение *)
BEGIN
  WriteInt(node(CenterTree).width);
  t.Insert^ (node) (* вызывает процедуру Insert, связанную с Tree *)
END Insert;

PROCEDURE (t: TreeNodePointer) Copy (): TreeNodePointer; (
VAR c: TreeNodePointer;
BEGIN
NEW(c); (* ... *)
RETURN c;
END Copy;

PROCEDURE (t: CenterTreeNodePointer) Copy (): TreeNodePointer; (
VAR c: CenterTreeNodePointer;
BEGIN
NEW(c); (* ... *)
RETURN c;
END Copy;
```

**Remark 4** *Обратите внимание, что тип параметра-приемника может определять динамическую природу объекта, который может принимать вызов процедуры. Если тип приемника является типом указателя, то процедура может быть вызвана только для объекта на куче. Если приемник является типом записи, то процедура может быть вызвана как для кучи, так и для стека, и невозможно, чтобы указатель кучи ускользал из этого типа.*

*Константность записей: естественно, если переменная типа запись - константа, то только приемники с параметром-константой могут принимать вызов. Это гарантирует, что свойство константности записи не может быть нарушено вызовом связанной с типом процедуры.*

#### 9.3 Оберон-2

Явный приемник для процедур с привязкой к типу позволяет отличать процедуры, изменяющие соответствующий объект, и процедуры, оставляющие его неизменным. В C++ это решается путем добавления модификатора `const` в функции-члены:

```
class Counter {
private:
  unsigned int value = 0;
public:
  void increment (unsigned by){
	value += by;
  }
  unsigned current() const {
	return value;
  }
}
```

С помощью процедур, привязанных к типу, один и тот же вид семантики может быть очень естественно обозначен модификаторами `var / const` параметра-приемника:

```
TYPE Counter* = RECORD value: UNSIGNED64 END;

PROCEDURE (VAR c: Counter) Increment (by: UNSIGNED64);
BEGIN
INC(c.value, by);
END Increment;

PROCEDURE (CONST c: Counter) Current (): UNSIGNED64;
BEGIN
RETURN c.value;
END Increment;
```

Более того, данная номенклатура очень естественно описывает то, что происходит во время вызова методов, а именно, что объект приемник передается в качестве неявного параметра процедуре.

```
VAR c: Counter;
c.Increment(10); // с передается в качестве параметра-переменной
...
ASSERT(c.Current()>=10); // c передается как параметр-константа
```

Классы в C++ обычно являются типами значений, и они могут быть выделены в куче (с помощью `new`) или стеке (неявно). Указатель на структуры / классы может указывать на кучу или стек. Указатели в этом смысле не защищены.

В Обероне (безопасные) указатели, по определению, ограничены кучей. Невозможно создать указатель на объект, находящийся на стеке. Это подразумевает ограничение: типы запись не могут быть преобразованы в указатель. Для того чтобы создать сложные структуры данных объектов, реализуемые с использованием объектно-ориентированного подхода, в активном Обероне было введено понятие `OBJECT`. Объекты неизменно живут в куче. Синтаксически методы для объектов были определены в области видимости объекта. Очень похоже на то, как это делается на языке Java. Мы выявили большой недостаток этого подхода: каждый объект должен быть размещен в куче, даже если срок его использования очень ограничен. Это, в свою очередь, создает высокую нагрузку на сборщик мусора и затрудняет создание системы без сбора мусора вообще. Одна идея (только на синтаксическом уровне) состояла в том, чтобы заменить `OBJECT` на `RECORD` и разрешить размещение связанных с типом процедур внутри записи. Таким методам по умолчанию будет разрешено изменять содержимое объекта, то есть они будут реализованы с помощью неявного приемника `VAR`:

Код...

```
TYPE
Counter* = RECORD
  value: UNSIGNED64

  PROCEDURE Increment (by: UNSIGNED64);
  BEGIN
    INC(value, by);
  END Increment;

  PROCEDURE Current (): UNSIGNED64;
  BEGIN
    RETURN value;
 END Increment;
END;
```

...будет реализован неявно следующим образом:

```
TYPE Counter* = RECORD value: UNSIGNED64 END;

PROCEDURE (VAR SELF: Counter) Increment (by: UNSIGNED64);
BEGIN
  INC(value, by);
END Increment;

PROCEDURE (VAR SELF: Counter) Current (): UNSIGNED64;
BEGIN
  RETURN value;
END Increment;
```

Конечно, можно было бы добавить ключевое слово `CONST` где-нибудь в определении записи точно так же, как это делается в C++, чтобы провести разницу между модифицирующим и не модифицирующим кодом. Однако есть еще одна очень важная причина остаться с элегантным и естественным объявлением связанных с типом процедур Оберона-2: можно написать связанные с типом процедуры, которые могут действовать на переменную типа запись (находящуюся в куче или в стеке), и написать связанные с типом процедуры, которые могут действовать на переменную типа указателя (находящуюся исключительно в куче). Последнее позволяет явно отличать код, который может быть вызван по указателю (и может возвращать указатель), от кода, который может быть вызван только по записи.

```
TYPE Expression = RECORD END;
TYPE PExpression = POINTER TO Expression;

(* каждое выражение может быть вычислено *)
PROCEDURE (e: Expression) Evaluate(): Value; (* ... *)

(* могут быть зарегистрированы только выражения указателей *)
PROCEDURE (e: PExpression) Register (); (*...*)
```

#### 9.4 Объявление операций

Активный Оберон поддерживает перегрузку операций. Операции могут быть объявлены следующим образом.

```
ОбъявлениеОперации = ’OPERATOR’ [Флаги] [’-’] Строка [’*’|’-’] ФормальныеПараметры ’;’
					ПоследовательностьОбъявлений
					[Тело]
				  ’END’ Строка.
```

По крайней мере один из задействованных параметров должен быть определен в модуле определения операции. Перегруженные операции ищутся во всех прямо или косвенно загруженных (??? или импортированных??? выяснить!) модулях. Чтобы найти перегруженную операцию для выражения, для каждой операции вычисляется расстояние. Из операций с минимальным расстоянием выбирается первая попавшаяся. Если существуют несколько объявлений с одинаковым минимальным расстоянием для выражения, то результат не определяется однозначно.

### 10 Выражения

#### 10.1 Выражения

Выражения имеют следующий вид:

```
Выражение = ВыражениеДиапазона [ОперацияОтношения ВыражениеДиапазона].
ОперацияОтношения = ’=’ | ’#’ | ’<’ | ’<=’ | ’>’ | ’>=’ | ’IN’ | ’IS’
					| ’.=’ | ’.#’ | ’.<’ | ’.<=’ | ’.>’ ’.>=’
					| ’??’ | ’!!’ | ’<<?’ | ’>>?’.
```

Операторы во второй и третьей строке `ОперацияОтношения` определены специально для математических массивов и подмножества активных ячеек языка, соответственно.

#### 10.2 Диапазон выражений

Выражения диапазона определяются следующим образом:

```
ВыражениеДиапазона = ПростоеВыражение
		| [ПростоеВыражение] ’..’ [ПростоеВыражение][’by’ ПростоеВыражение]
		| ’*’ .
```

##### 10.2.1 Отличия от оригинальной версии Оберона

Было введено понятие выражений диапазона, и таким образом диапазоны, используемые в типах множеств, были расширены до выражений, чтобы иметь возможность представлять срезы в Математическом Обероне.

#### 10.3 Простые выражения

```
ПростоеВыражение = Слагаемое {ОперацияСложения Слагаемое}.
ОперацияСложения = ’+’ | ’-’ | ’or’.
```

>##### 10.3.1 Отличия от оригинальной версии Оберона
>
>Унарные операторы " - " и " + " первоначально содержались здесь в простом выражении. Мы переместили их на `Множитель`, так как считаем, что он должен иметь более высокий приоритет, подобно логической операции `not`.
>
>Мы нашли пример утверждения (в коде, который был результативным):
>
>утверждение...
>
>```
>assert(-1 MOD 3 = -1); (* в других Оберонах не падал, но падает в АО *)
>```
>
>...было использовано для того, чтобы определить, что `a MOD 3` будет отрицательным для a < 0, что действительно неверно для Оберона. На самом деле, `(-1) MOD 3 = 2`! Это утверждение было истинным, потому что `-1 MOD 3` раньше было `-(1 MOD 3)`.

10.4 Слагаемые

```
Слагаемое = Множитель {ОперацияУмножения Множитель}.
ОперацияУмножения = ’*’ | ’/’ | ’DIV’ | ’MOD’ | ’&’
				   | ’.*’ | ’./’ | ’\’ | ’**’ | ’+*’ .
```

Операции, указанные во второй строке `ОперацияУмножения`, определены специально для математических массивов.

#### 10.5 Множители

Множители определяются следующим образом

```
Множитель = УнарноеВыражение | УнарнаяОперация Множитель.
УнарнаяОперация = ’~’ | ’+’ | ’-’.
```

##### 10.5.1 Отличия от оригинальной версии Оберона

Исходная спецификация Оберона содержала ключевые слова, литералы и именующие выражения как части множителя. Мы перенесли их в отдельные конструкции: унарные и первичные выражения, чтобы избежать двусмысленностей в синтаксисе.


#### 10.6 Унарные и первичные выражения

Первичные выражения представляют собой выражения, которые не объединяются с помощью свободно стоящих двоичных или префиксных операций, а скорее формируются с помощью именующего выражения, литерала, ключевого слова или специального структурного выражения, которое может предварять следующие операции, такие как вызов процедуры, индексная операция, восходящий вызов или операция разыменования, или селектор.

Первичные выражения могут предоставлять выражение с адресом (которое, например, может стоять в левой части присваивания) или выражение, которое является значением.

```
УнарноеВыражение = ПервичноеВыражение [ОперацииИменующегоВыражения] [Флаги].

ПервичноеВыражение = Число | Знак | Строка | Множество | Массив
		| ’NIL’ | ’IMAG’ | ’TRUE’ | ’FALSE’ |
		| ’SELF’ | ’RESULT’ | ’ADDRESS’ | ’SIZE’
		| ’SIZE’ ’OF’ Множитель | ’ADDRESS’ ’OF’ Множитель
		| ’ALIAS’ OF Множитель
		| ’NEW’ УнарноеВыражение
		| ’(’ Выражение ’)’
		| Идентификатор.

ОперацииИменующегоВыражения = { "(" [СписокВыражений] ")"
				| "." Идентификатор
				| ’[’ СписокИндексов ’]’
				| ’^’
				| ’‘’
				} .

СписокВыражений = Выражение { ’,’ Выражение }.

СписокИндексов = ’?’ [’,’ СписокВыражений]
			| СписокВыражений [’,’ ’?’ [’,’ СписокВыражений] ]
```

Операция суффикса " ` " определена специально для математических массивов.

##### 10.6.1 Примеры

Пример именующих выражений:

```
a[10]
P(3,5).GetArray[5].CallMe()
myVariable(Type)
```

Именующее выражение `RESULT` может использоваться для доступа к (неявному) возвращаемому параметру процедуры, возвращающей значение. Эта функция была реализована для того, чтобы уменьшить нагрузку на память во избежание перераспределения уже выделенных возвращаемых параметров. Оператор `RETURN RESULT;` только возвращает из процедуры без записи результата. Последний также может быть использован, когда возвращаемое значение процедуры уже записано во встроенном ассемблерном коде.

```
PROCEDURE ReturnLargeArray(): ARRAY[*] OF REAL;
BEGIN
IF LEN(RESULT) < LargeSize THEN
NEW(RESULT, LargeSize)
END;
...
RETURN RESULT;
END ReturnLargeArray;
```

##### 10.6.2 Отличия от оригинальной версии Оберона

Понятие именующего выражения, как оно присутствовало в предыдущих описаниях языка, было заменено первичным выражением. Из-за более свободной обработки связанных выражений, подобных приведенному ниже примеру, различие между выражениями, которые могут быть использованы в левой части оператора присваивания, и выражениями, которые представляют только значение, больше не может быть столь очевидным.

```
expression(BinaryExpression).left.CompatibleTo(x)
```

Кроме того, чтобы избежать двусмысленностей в EBNF и разрешить другие функции, такие как тип охранник типов значений (например, литеральных чисел), мы решили объединить такие выражения и назвать их первичными.

Был введен тип охранник по числам. Охраняемое число преобразуется в заданный тип тогда и только тогда, когда его значение не изменяется. В случае неудачи (то есть когда фактическое значение числа несовместимо с типом / не может быть представлено им), возникает прерывание.

В язык были добавлены комплексные числа. Поэтому введен литерал `IMAG`.

Поскольку `SIZE` and `ADDRESS` - типы, значения `SIZE(x)` и `ADDRESS(y)` (формально `SYSTEM.SIZE(x)` and `SYSTEM.ADDRESS(x)`) изменены. Поэтому были введены формы `ADDRESS OF` и `SIZE OF`.

Аналогично был введен `ALIAS OF` для математических массивов.

Для математических массивов были введены различные операторы, в том числе оператор преобразования суффикса `'`.

В отличие от исходного оператора `NEW`, форма именующего выражения `NEW Type(параметры)` была введена для того, чтобы иметь возможность распределять тип и сразу же присваивать его указателю на базовый тип.

```
VAR
x: Expression;
BEGIN
x := NEW BinaryExpression(left, right);
```

Кроме того, теперь можно инициализировать указатель на запись вызовом процедуры, возвращающей запись в виде `NEW Procedure(parameters)`. Также указатели из типа запись могут быть представлены в виде `NEW RecordType;`

```
TYPE
  Student = RECORD
  name: ARRAY 32 OF CHAR;
  age: INTEGER
  END;
  
  PROCEDURE StudentInstance(CONST name: ARRAY OF CHAR;
										age: INTEGER): Student;
  BEGIN
    COPY(name, RESULT.name);
	RESULT.age := age;
	RETURN RESULT;
  END StudentInstance;
  
(* Указатель на Student *)
VAR student1 := NEW Student;
VAR student2 := NEW StudentInstance("Niklas",6);
(* Student *)
VAR student3 := StudentInstance("Hannes",9);
```

Большая часть ограничений на именующие выражения была снята. Например, именующие выражения могут быть произвольно связаны, а ссылки, возвращаемые после вызова процедур, могут прикрепляться к постоянным параметрам.

Пример синтаксически верного именующего выражения:

```
P(3)[10].p(Q());
```

#### 10.7 Таблица операций

Для данной операции типы ее операндов совместимы с выражением, если они соответствуют следующей таблице (которая также показывает тип результата выражения). Ниже мы подоазумеваем, что T1 является расширением T0.

|Операция|Первый операнд|Второй операнд|Тип результата|
|-|-|-|-|
|+, -, *|числовой|числовой|наименьший числовой тип, включающий оба операнда|
|/|числовой|числовой|наименьший `FLOAT`-тип, включающий оба операнда|
|+, -, *, /|`SET`n|`SET`m|наименьший `SET`-тип, включающий оба операнда|
|DIV, MOD|Целый|Целый|наименьший целый тип, включающий оба операнда|
|OR, &, ~|Логический|Логический|Логический|
|=, #, <, <=, >, >=|числовой|числовой|Логический|
||Знак|Знак|Логический|
||Массив знаков|Массив знаков|Логический|
||Строка|Строка||
|=, #|Логический|Логический|Логический|
||Множество|Множество|Логический|
||NIL, Тип указателя T0 или T1|NIL, Тип указателя T0 или T1|Логический|
||Тип процедуры T, NIL|Тип процедуры T, NIL|Логический|
|IN|Целый|Множество|Логический|
|IS|T0|Тип T1|Логический|

### 11 Операторы

```
Оператор = [
  УнарноеВыражение
	[’:=’ Выражение
	| ’!’ Выражение | ’?’ Выражение | ’<<’ Выражение | ’>>’ Выражение
	]
  | ’VAR’ Идентификатор [’:=’ Выражение]
		{’,’ Идентификатор [’:=’ Выражение]} [’:’ Тип]
  | ’IF’ Выражение ’THEN’ ПоследовательностьОператоров
	{’ELSIF’ Выражение ’THEN’ ПоследовательностьОператоров}
	[’ELSE’ ПоследовательностьОператоров]
	’END’
  | ’WITH’ Идентификатор ’:’ СоставнойИдентификатор ’DO’ ПоследовательностьОператоров
	{’|’ СоставнойИдентификатор ’DO’ ПоследовательностьОператоров}
	[ELSE ПоследовательностьОператоров]
	’END’
  | ’CASE’ Выражение ’OF’ [’|’] Вариант
	{’|’ Вариант}
	[’ELSE’ ПоследовательностьОператоров]
	’END’
  | ’WHILE’ Выражение ’DO’
	  ПоследовательностьОператоров
	’END’
  | ’REPEAT’
	  ПоследовательностьОператоров
	’UNTIL’ Выражение
  | ’FOR’ Идентификатор ’:=’ Выражение ’TO’ Выражение [’BY’ Выражение] ’DO’
	  ПоследовательностьОператоров
	’END’
  | ’LOOP’ ПоследовательностьОператоров ’END’
  | ’EXIT’
  | ’RETURN’ [Выражение]
  | ’AWAIT’ Выражение
  | БлокОператоров
  | ’CODE’ {any} ’END’
  | ’IGNORE’ Выражение
].

Вариант = ВыражениеДиапазона {’,’ ВыражениеДиапазона} ’:’ ПоследовательностьОператоров.

БлокОператоров = ’BEGIN’ [Флаги] ПоследовательностьОператоров ’END’.

ПоследовательностьОператоров = Оператор {’;’ Оператор}.
```

#### 11.1 Блок операторов и последовательности операторов

Операторы могут быть сгруппированы в блок, разделенный словами (скобками) `BEGIN` и `END`. Блок может включать в себя модификаторы в фигурных скобках `{}`, которые изменяют свойства действий внутри блока. Подробнее о модификаторах читайте в описаниях каждого оперетора в отдельности. Последовательность более чем одного оператора, разделенных точками с запятой, обозначает последовательность действий, заданную компонентами операторов.

```
БлокОператоров = ’BEGIN’ [Флаги] ПоследовательностьОператоров ’END’.
ПоследовательностьОператоров = Оператор {’;’ Оператор}.
```

##### 11.1.1 Примеры

```
BEGIN{EXCLUSIVE} (* эксклюзивный блок операторов *)
  state := States.normal;
  AWAIT(state = States.alert)
END;
```

#### 11.2 Оператор присваивания

Присваивание служит для замены текущего значения переменной новым значением, заданным выражением. Оператор присваивания записывается как `: =` и произносится как "становится".

```
УнарноеВыражение ’:=’ Выражение
```

Тип именующего выражения должен быть совместимым по присваиванию с типом выражения.

##### 11.2.1 Примеры

```
i := 0;
x := 3.4;
y := i*i;
```

#### 11.3 Оператор объявление

```
’VAR’ Идентификатор [’:=’ Выражение]
	  {’,’ Идентификатор [’:=’ Выражение]} [’:’ Тип];
```

Переменные могут быть объявлены в последовательности операторов. Оператор объявления обозначается ключевым словом 'VAR'. Подобно объявлению переменной, тип переменной может быть опущен, когда присутствует инициализатор, и когда тип инициализатора должен задавать тип переменной. Переменная видна в последовательности операторов от момента объявления до конца области действия процедуры. Переменная может быть объявлена только один раз в области действия процедуры.

##### 11.3.1 Примеры

```
BEGIN
VAR a := 20, b: SIZE; (* переменные `a` и `b` обе принимают тип `SIZE` *)
VAR c := a, d := 30; (* `c` принимает тип `a`, а `d` - `SIGNED8` *)
...
END
```

##### 11.3.2 Отличия от оригинальной версии Оберона

Мы ввели объявление оператора, мотивированное необходимостью поддержки лучшего способа инициализации для типов значений (запись).

#### 11.4 Оператор вызова процедуры

Вызов процедуры служит для активации процедуры. Вызов процедуры может содержать список фактических параметров, которые подставляются вместо соответствующих им формальных параметров, определенных в объявлении процедуры. Соответствие устанавливается по относительному положению параметров в списках фактических и формальных параметров соответственно.

```
УнарноеВыражение ["(" СписокВыражений ")"];
```

Существует три вида параметров: значение, константа и переменная. В случае переменной фактическим параметром должно быть именующее выражение, представляющее адрес. Если оно обозначает адрес поля экземпляра записи, то адрес поля вычисляется тогда, когда происходит замена формальных параметров фактическими, то есть до выполнения процедуры.

Если формальный параметр является значением, то соответствующий фактический параметр должен быть выражением. Это выражение вычисляется до активации процедуры, и полученное значение присваивается формальному параметру, который теперь представляет собой локальную переменную на стороне вызываемой процедуры. В частности, параметры типа запись при передаче копируются.

Если параметр является константой, то соответствующий фактический параметр может быть скопирован, но это не обязательно. Компилятор может оптимизировать. Это особенно удобно для строк и больших записей.

##### 11.4.1 Примеры

```
PROCEDURE Test(a: SIGNED32; VAR r: REAL;
				CONST c: Student; CONST s: ARRAY OF CHAR);
BEGIN
  IF c.semester = 2 THEN (* `c` может быть передан по ссылке здесь *)
	a := a * 2; (* нет эффекта при вызове процедуры *)
	r := 20; (* есть эффект при вызове *)
	TRACE(s);
  	END;
END Test;

VAR r: REAL;
Test(22, r, student, "Rabbit");
```

##### 11.4.2 Отличия от оригинальной версии Оберона

Мы ввели параметры `CONST` в порядке поддержки доступа только для чтения к большим массивам в рамках математического массива. Это оказалось очень полезным и для записей, и для строк.

#### 11.5 Оператор связи

В подмножестве активных ячеек языка используются различные операторы связи. Они применяются для передачи и приема данных через порт блокирующим или неблокирующим способом.

#### 11.6 Оператор `If-Elsif-Else-End`

Оператор `IF` определяет условное выполнение операторов в зависимости от вычисления булева выражения (условия). Условия при if, elsif вычисляются по очереди, пока одно из них не получит значение `TRUE`, после чего выполняется связанная с этим условием последовательность операторов. Если все значения вычисленных условий - ложь, то выполняется последовательность операторов, следующая за словом `ELSE`, если таковой имеется.

```
’IF’ Выражение ’THEN’ ПоследовательностьОператоров
	{’ELSIF’ Выражение ’THEN’ ПоследовательностьОператоров}
	[’ELSE’ ПоследовательностьОператоров]
	’END’
```

##### 11.6.1 Примеры

```
IF ch <= "9" THEN RETURN ORD( ch ) - ORD( "0" )
ELSIF ch <= "F" THEN RETURN ORD( ch ) - ORD( "A" ) + 10
ELSIF ch <= "f" THEN RETURN ORD( ch ) - ORD( "a" ) + 10
ELSE Error( Basic.NumberIllegalCharacter ); RETURN 0
END
```

#### 11.7 Оператор `Case`

Оператор `CASE` определяет выбор и выполнение последовательности операторов в соответствии со значением выражения. Сначала вычисляется выражение, а затем выполняется последовательность операторов, которые относятся к варианту, чья метка из списка вариантов содержит полученное значение. Выражение и все метки должны иметь один и тот же тип, который может быть перечислением, целым числом, любым множеством или знаком. Метки вариантов являются константами, и ни одно значение не должно встречаться более одного раза в одном операторе `CASE`. Если значение выражения не встречается в качестве метки какого-либо варианта, то выбирается последовательность операторов, следующая за словом `ELSE`, если таковое имеется. А если в данном случае `ELSE` отсутствует, то возникнет исключение.

```
’CASE’ Выражение ’OF’ [’|’] Вариант
	{’|’ Вариант}
	[’ELSE’ ПоследовательностьОператоров]
	’END’
```

##### 11.7.1 Примеры

```
CASE ch OF
  EOT: s := EndOfText
  | ’#’: s := Unequal; GetNextCharacter
  | ’&’: s := And; GetNextCharacter
  | ’[’: s := LeftBracket; GetNextCharacter
  | ’]’: s := RightBracket; GetNextCharacter
  (* ... *)
ELSE
  s := Identifier; GetIdentifier( token );
END;
```

#### 11.8 Оператор `With`

При работе с переменными *p* динамического типа (например, указателями на записи) часто требуется выполнить различные действия, 
в зависимости от конкретного подтипа статического типа *p*. Для этого служит оператор `WITH`, который принимает на себя роль, аналогичную охраннику, расширяя защиту на всю последовательность операторов. Динамический тип *p* поочерёдно сравнивается с типами, указанными
в частях конструкции `WITH`. При первом совпадении выполняется соответствующая последовательность операторов. В рамках этой 
последовательности, статический тип переменной равен типу, указанному перед `DO`.

Оператор `WITH` можно рассматривать как оператор `CASE` для типов.


Если динамический тип охраняемой переменной не принадлежит динамическому типу ни одной из заданных альтернатив, то берется ветка `ELSE`. Если же в подобных случаях ветка `ELSE` не представлена, программа будет прервана.

```
’WITH’ Идентификатор ’:’ СоставнойИдентификатор ’DO’ ПоследовательностьОператоров
	{’|’ СоставнойИдентификатор ’DO’ ПоследовательностьОператоров}
	[ELSE ПоследовательностьОператоров]
	’END’
```

Если тип *T1* относится к составному идентификатору в операторе `WITH`, а тип *T2* - к появляющемуся позже составному идентификатору в том же `WITH`, то *T2* не может расширить *T1* (в противном случае ветка с *T2* никогда не будет доступна).

##### 11.8.1 Примеры

Пример оператора`WITH`:

```
WITH x:
| SyntaxTree.ResultDesignator DO result := ResolveResultDesignator(x)
| SyntaxTree.SelfDesignator DO result := ResolveSelfDesignator(x)
| SyntaxTree.BinaryExpression DO result := ResolveBinaryExpression(x)
| SyntaxTree.UnaryExpression DO result := ResolveUnaryExpression(x)
END;
```

Пример забракованного оператора `WITH`, когда `UnaryExpression` наследуется от `Expression`:

```
WITH x:
| SyntaxTree.Expression DO (* общий случай *)
| SyntaxTree.UnaryExpression DO (* запрещено! *)
END;
```

##### 11.8.2 Отличия от оригинальной версии Оберона

В Обероне-2 оператор `WITH` присутствовал в качестве альтернативы, но потом он снова был удален. Мы вновь ввели его в слегка измененном виде. Мы устранили необходимость повторять имя переменной для каждого возникающего случая.

Следует отметить, что технически `WITH` отличается от `CASE` в следующем смысле. В то время как для `CASE` относительно просто реализовать оптимизированную версию с помощью таблицы ветвей, это не относится к `WITH`, особенно к динамической загрузке модуля. Однако, по крайней мере, косвенной загрузки тегов типа, как это произошло бы в случае с несколькими операторами IF, здесь можно избежать, сохранив адрес тега типа в регистре. Это простая оптимизация, которая может быть реализована с небольшими затратами в компиляторе.

#### 11.9 Оператор `While`

Оператор `WHILE` задает нулевое или большее количество повторений некоторых операторов. Если логическое выражение дает значение `TRUE`, то выполняется последовательность операторов. Вычисление выражения и выполнение оператора повторяются до тех пор, пока логическое выражение принимает значение `TRUE`.

```
’WHILE’ Выражение ’DO’
	ПоследовательностьОператоров
’END’
```

##### 11.9.1 Примеры

```
WHILE len > 0 DO
  data[length] := buf[ofs];
  INC(ofs); INC(length); DEC(len)
END;
```

#### 11.10 Оператор `Repeat-Until`

Оператор `REPEAT` задает повторное выполнение последовательности операторов до тех пор, пока логическое выражение не даст значение `TRUE`. Таким образом, последовательность операторов выполняется один или несколько раз.

```
’REPEAT’
	ПоследовательностьОператоров
’UNTIL’ Выражение
```

##### 11.10.1 Примеры

```
REPEAT
	expression := Expression();
	expressionList.AddExpression( expression )
UNTIL ~Optional( Scanner.Comma );
```

#### 11.11 Оператор `For`

Оператор `FOR` предоставляет средство для многократного повторения последовательности операторов при автоматическом увеличении или уменьшении переменной на фиксированное постоянное значение. Цикл продолжается, пока значение переменной `FOR` (счетчика) находится в диапазоне, указанном двумя выражениями.

Он в основном используется в арифметических алгоритмах, где счетчик обычно может использоваться в качестве индекса массива.

```
’FOR’ Идентификатор ’:=’ Выражение ’TO’ Выражение [’BY’ Выражение] ’DO’
	ПоследовательностьОператоров
’END’
```

Оператор `FOR` эквивалентен оператору `WHILE` с дополнительной временной переменной для конечного значения. Начальное и конечное значения цикла `FOR` вычисляются только один раз. Приращение цикла `FOR` должно быть постоянным выражением.

Цикл...

```
FOR i := НачальноеЗначение TO КонечноеЗначение BY Приращение DO
  Операторы
END;
```

...эквивалентен

```
i := НачальноеЗначение;
temp := КонечноеЗначение;
increment := Приращение;
IF increment > 0 THEN
  WHILE i <= temp DO
	Statements;
	i := i + increment;
  END;
ELSE
  WHILE i >= temp DO
	Statements;
	i := i + increment;
  END;
END;
```

##### 11.11.1 Примеры

```
FOR i := 0 TO EndOfText DO ASSERT(symbols[i] # "") END;
```

#### 11.12 Операторы Loop and Exit

Оператор `Loop` определяет повторное выполнение последовательности операторов, цикл завершается выполнением любого оператора `EXIT` в этой последовательности.

Оператор выхода из цикла состоит из символа `EXIT`. Он указывает завершение цикла и переход к оператору, следующему за ключевым словом `END`, которым оканчивается этот цикл. Каждый оператор `EXIT`, хотя и не синтаксически, но по смыслу привязан к оператору цикла, который его содержит.

```
’LOOP’ ПоследовательностьОператоров ’END’
```

##### 11.12.1 Примеры

В большинстве случаев рекомендуется использовать операторы `WHILE` и `REPEAT`. Оператор цикла может быть полезен для специального повторения, когда существует несколько условий завершения в разных точках кода.

```
LOOP
 IF ("0" <= ch) & (ch <= "9") OR (d = 0) & ("A" <= ch) & (ch <= "F") THEN
	dig[n] := ch; INC( n ) END;
 ELSIF ch = "." THEN
	m := n;
 ELSE EXIT
 END
END;
```

#### 11.13 Оператор Return

Оператор `RETURN` используется для возврата из процедуры. Если процедура объявлена возвращающей значение типа *T*, оператор `RETURN` должен возвращать выражение совместимого по присваиванию типа.

##### 11.13.1 Примеры

```
PROCEDURE Ten( e: SIGNED32 ): FLOAT64;
VAR x, p: FLOAT64;
BEGIN
  x := 1; p := 10;
  WHILE e > 0 DO
	IF ODD( e ) THEN x := x * p END;
	e := e DIV 2;
	IF e > 0 THEN p := p * p END (* предотвращение переполнения *)
  END;
  RETURN x
END Ten;
```

#### 11.14 Оператор Await

Оператор `AWAIT` - это оператор для синхронизации запущенных процессов (потоков).

```
’AWAIT’ Выражение
```

#### 11.15 Блок Code

Блоки `Code` можно использовать для написания встроенного ассемблерного кода в Oberon.

```
’CODE’ {any} ’END’
```

##### 11.15.1 Примеры

```
OPERATOR -"-"*(x {REGISTER}: Vector): Vector;
VAR res{REGISTER}: Vector;
BEGIN
  CODE
	XORPS res, res
	SUBPS res, x
  END;
  RETURN res;
END "-";
```

#### 11.16 Оператор Ignore

Оператор `IGNORE` может использоваться для того, чтобы игнорировать результат вызова процедуры.

```
’IGNORE’ Выражение
```

Оператор `IGNORE` был введен для взаимодействия с библиотеками языка C, где результат вызова библиотеки часто игнорируется. Его не было в оригинальном Обероне.

##### 11.16.1 Примеры

```
IGNORE User32.SetWindowText(root.hWnd, windowTitle);
IGNORE User32.BringWindowToTop( root.hWnd );
IGNORE User32.SetForegroundWindow( root.hWnd );
```

Это оказалось также удобно для поддержки передачи результатов в связанных потоках-выражениях, поскольку они, например, доступны в C++.

```
IGNORE Out.GetWriter() << "Это текст, " << "который связан";
```

### 12 Встроенные функции и символы

В активном Обероне есть несколько встроенных процедур и функций. Мы даем краткий обзор в приведенных ниже таблицах. Обратите внимание, что целые представления для `SIGNEDx` или `UNSIGNEDx`, `SIZE` или `INTEGERFloat` обозначают любые из `FLOATx` или `REAL`. 'Number' означает целые числа или с плавающей точкой. 'Set' - любое из `SETx` или `SET`. 'Complex' -  любое из `COMPLEXx` или `COMPLEX`.

#### 12.1 Глобальные

##### 12.1.1 Функции преобразования

|Функция|Типы аргументов|Тип результата|Описание|
|-|-|-|-|
|ABS(x)|x: Number|Number|возвращает абсолютное значение x|
|CAP(x)|x: CHAR|CHAR|возвращает заглавную букву x|
|CHR(x)|x: Integer|CHAR|возвращает знак по ascii-коду x (и неизвестно что для чисел, больших 255)|
|ENTIER(x)|x: Float|SIGNED32|возвращает наибольшее целое не превышающее x|
|ENTIERH(x)|x: Float|SIGNED64|возвращает наибольшее целое не превышающее x  (УСТАРЕЛО)|
|FIRST(r)|r: RANGE|SIZE|возвращает первый элемент диапазона|
|IM(x)|x: Complex|Float|возвращает мнимую часть x|
|LAST(r)|r: RANGE|SIZE|возвращает последний элемент диапазона|
|LONG(x)|x: Number|Number|преобразование числа вверх (УСТАРЕЛО)|
|ODD(x)|x: Integer|BOOLEAN|возвращает `TRUE`, если установлен наименьший значащий бит x|
|ORD(x)|x: CHAR|SIGNED16|возвращает ascii-код x|
|RE(c)|c: Complex|Float|возвращает вещественную часть c|
|SHORT(x)|x: Number|Number|преобразование числа вниз (УСТАРЕЛО)|
|STEP(r)|r: RANGE|SIZE|возвращает размер шага диапазона|

Устаревшие процедуры преобразования чисел `SHORT` и `LONG` работают с соблюдением отношений:

	FLOAT64 Ↄ FLOAT и SIGNED64 Ↄ SIGNED32 Ↄ SIGNED16 Ↄ SIGNED8.

Для преобразования также могут быть использованы все виды имен числовых типов. Устаревший `ENTIERH(x)` может быть заменен `SIGNED64(x)`.

##### 12.1.2 Арифметические функции

|Функция|Типы аргументов|Тип результата|Описание|
|-|-|-|-|
|DEC(x)|x: Integer||уменьшение x на 1|
|DEC(x,n)|x: Integer, n: Integer||уменьшение x на n|
|EXCL(s,e)|s: SET, e: Integer||исключить элемент e из множества s|
|INC(x)|x: Integer||приращение x на 1|
|INC(x,n)|x: Integer, n: Integer||приращение x на n|
|INCL(s,e)|s: SET, e: Integer||включить элемент e в множество s|
|MAX(T)|Number or Set type T|Number|возвращает максимальное число базового типа T|
|MIN(T)|Number or Set type T|Number|возвращает минимальное число базового типа T|

##### 12.1.3 Функции сдвига

|Функция|Типы аргументов|Тип результата|Описание|
|-|-|-|-|
|ASH(x,y)|x: Integer or Set, y: Integer|Integer or Set|возвращает арифметический сдвиг x на y бит (сдвиги вправо для y < 0)|
|LSH(x,n)|x: Integer or Set, n: Integer|Integer or Set|возвращает значение x логически сдвинутое влево на n бит (сдвигается вправо при n < 0)|
|ROL(x,y)|x: Integer or Set, y: Integer|Integer or Set|возвращает x, прокрученный влево на y бит|
|ROR(x,y)|x: Integer or Set, y: Integer|Integer or Set|возвращает x, прокрученный вправо на y бит|
|ROT(x,n)|x: Integer or Set, n: Integer|Integer or Set|возвращает значение x, прокрученное влево на n бит (прокручивается вправо при n < 0)|
|SHL(x,y)|x: Integer or Set, y: Integer|Integer or Set|возвращает сдвиг x влево на y бит|
|SHR(x,y)|x: Integer or Set, y: Integer|Integer or Set|возвращает сдвиг x вправо на y бит. Тип x определяет тип сдвига: логический или артиметический|

Результат сдвига непредсказуем, если указана слишком большая или слишком малая величина сдвига, выходящая за пределы битовой длины аргумента.

##### 12.1.4 Массивы и математические массивы

|Функция|Типы аргументов|Тип результата|Описание|
|-|-|-|-|
|DIM(a)|a: Math Array|SIZE|размерность|
|INCR(a,d)|a: Math array, d: SIZE|SIZE|возвращает приращение размерности d|
|LEN(x)|x: ARRAY OF|SIZE|возвращает длину x|
|LEN(x,d)|x: Math Array or Array|SIZE|возвращает длину x размерности d|

##### 12.1.5 Адреса, память и типы

|Функция|Типы аргументов|Тип результата|Описание|
|-|-|-|-|
|ADDRESSOF(v)|v: any designator|ADDRESS|возвращает адрес v|
|ADDRESS OF v|v: any designator|ADDRESS|возвращает адрес v|
|COPY(x,y)|x,y: ARRAY OF CHAR|0X-завершенная копия x в y|
|NEW(x,...)|x: pointer type||распределить x|
|NEW T(...)|pointer type T|T|распределить экземпляр T|
|SIZEOF(T)|any type T|SIZE|возвращает размер типа Т|
|SIZE OF T|any type T|SIZE|возвращает размер типа Т|

##### 12.1.6 Доступ к процедуре

Следующая встроенная процедура позволяет подключение экспортированных процедур без необходимости их импорта.

|Функция|Типы аргументов|Тип результата|Описание|
|-|-|-|-|
|GETPROCEDURE(x,y,z)|x и y - массив знаков, z - переменная процедуры||получить процедуру y типа z из модуля x|

Первые два операнда именуют модуль и процедуру в нем, которую нужно искать. Третий операнд должен быть переменной процедуры. Результатом является либо NIL, либо публичная процедура именованного модуля, соответствующая имени и типу переменной процедуры. Для детального контроля доступа глобальные процедуры, такие как переменные, могут быть экспортированы либо со знаком "звездочка", либо со знаком "минус". Процедура, экспортированная со знаком минус, по-прежнему доступна при импорте модулей, но не с помощью `GETPROCEDURE`.

##### 12.1.7 Примеры

`GETPROCEDURE` полезна для интерактивных программ, где пользователь вводит команды или кликает на них, чтобы выполнить. Следующий модуль предоставляет интерфейс для выполнения стандартных команд Оберона, заданных в виде строки, в то время как модуль по-возможности динамически загружается:

```
MODULE Commands;

IMPORT Strings;

PROCEDURE Execute- (CONST command: ARRAY OF CHAR);
VAR pos: SIZE; module, procedure: ARRAY 32 OF CHAR; result: PROCEDURE;
BEGIN
	IF Strings.FindCharacter (’.’, command, pos) THEN
		Strings.Copy (command, module, 0, pos); INC (pos);
		Strings.Copy (command, procedure, pos, Strings.GetLength (command) - pos);
		GETPROCEDURE (module, procedure, result);
		IF result # NIL THEN result () END;
	END;
END Execute;

END Commands.
```

Следующий модуль показывает, как этот интерфейс может быть использован:

```
MODULE Test;

IMPORT Commands;

PROCEDURE Hello*;
BEGIN
	TRACE ("Hello World!");
END Hello;

BEGIN
	Commands.Execute ("Test.Hello");
END Test.
```

##### 12.1.8 Прерывания

|Функция|Типы аргументов|Тип результата|Описание|
|-|-|-|-|
|ASSERT(x)|x: BOOLEAN||прервать, если x не истинно|
|HALT(n)|n: Integer||Создать прерывание с кодом n|

##### 12.1.9 Атомарные операции

Атомарные операции позволяют считывать и изменять данные, совместно используемые двумя или более действиями, не требуя защиты этих данных с помощью блоков исключения:

|Функция|Типы аргументов|Тип результата|Описание|
|-|-|-|-|
|CAS(x,y,z)|x,y,z: same T|T|compare-and-swap (сравнить и заменить)|

Процедура compare-and-swap сравнивает значение переменной, указанной первым аргументом, со значением второго аргумента. Если эти два значения неструктурированного типа совпадают, переменная, перезаписывается значением третьего аргумента. Результат равен исходному значению переменной. Вся операция выполняется атомарно и никогда не прерывается какими-либо другими действиями. Если второй и третий аргументы совпадают, то вся операция фактически равна атомарному чтению общей переменной.

##### 12.1.10 Примеры

Другие атомарные операции, такие как `TAS` - test-and-set (проверить и установить), могут быть реализованы поверх процедуры `CAS`:

```
PROCEDURE TAS* (VAR value: BOOLEAN): BOOLEAN;
BEGIN RETURN CAS (value, FALSE, TRUE);
END TAS
```

#### 12.2 Модуль SYSTEM

(Псевдо-) модуль `SYSTEM` содержит определения, необходимые для непосредственного обращения к ресурсам, определенным для данного компьютера и / или реализации. К ним относятся средства для доступа к устройствам, управляемым компьютером, и средства для ручной коррекции правил совместимости типов данных, которые в противном случае накладываются языковым определением. Функции и процедуры, экспортируемые этим модулем, должны использоваться с осторожностью! Рекомендуется ограничить их использование особыми низкоуровневыми модулями. Такие модули по своей сути неперемещаемы и легко распознаются благодаря идентификатору `SYSTEM`, появляющемуся в списке их импорта.

##### 12.2.1 Манипуляции с битами

|Функция|Типы аргументов|Тип результата|Описание|
|-|-|-|-|
|BIT(adr,n)|adr: ADDRESS; n: INTEGER|BOOLEAN|Возвращает `TRUE`, если установлен бит n в adr, в противном случае `FALSE`|

##### 12.2.2 Типы SYSTEM

|Тип|Описание|
|-|-|
|BYTE|Представление одного байта|

##### 12.2.3 Небезопасное приведение типа

|Функция|Типы аргументов|Тип результата|Описание|
|-|-|-|-|
|VAL(T,x)|T: Type; x: ANY|T|Небезопасное приведение к типу. Возвращает X, интерпретируемый как тип T без преобразования|

##### 12.2.4 Функции прямого доступа к памяти

|Функция|Типы аргументов|Тип результата|Описание|
|-|-|-|-|
|PUT(adr,x)|adr: ADDRESS; x: Type||Mem[adr] := x, где размер типа x - 8, 16, 32 или 64 бита|
|PUT8(adr,x)|adr: ADDRESS; x: (UN)SIGNED8||Mem[adr] := x|
|PUT16(adr,x)|adr: ADRESS; x: (UN)SIGNED16|||
|PUT32(adr,x)|adr: ADDRESS; x: (UN)SIGNED32|||
|PUT64(adr,x)|adr: ADDRESS; x: (UN)SIGNED64|||
|GET(adr,x)|adr: ADDRESS; VAR x: Type||x := Mem[adr], где размер типа x - 8, 16, 32 или 64 бита|
|GET8(adr)|adr: ADDRESS SIGNED8||RETURN Mem[adr]|
|GET16(adr)|adr: ADDRESS SIGNED16|||
|GET32(adr)|adr: ADDRESS SIGNED32|||
|GET64(adr)|adr: ADDRESS SIGNED64|||
|MOVE(src, dst,n)|dst: ADDRESS; n: SIZE||Копирование  "n" байтов с адреса "src" на адрес "dst"|

##### 12.2.5 Доступ к регистрам

|Функция|Типы аргументов|Тип результата|Описание|
|-|-|-|-|
|GetStackPointer()||ADDRESS|возвращает значение регистра указателя стека|
|SetStackPointer(x)|x: ADDRESS||устанавливает значение регистра указателя стека|
|GetFramePointer()||ADDRESS|возвращает значение регистра указателя фрейма|
|SetFramePointer(x)|x: ADDRESS||устанавливает значение регистра указателя фрейма|
|SYSTEM.GetActivity||ADDRESS|возвращает значение регистра указателя активности|
|SYSTEM.SetActivity|x: ADDRESS||устанавливает значение регистра указателя активности|

##### 12.2.6 Прочие

|Функция|Типы аргументов|Тип результата|Описание|
|-|-|-|-|
|NEW(p,s)|p: any pointer, s: SIZE||выделяет часть памяти|
|TYPECODE(T)|type T|ADDRESS|возвращает адрес типа дескриптора T(адрес, к-рый можно привести к типу Heaps.StaticTypeBlockU)|
|HALT(n)|n: Integer||Прервать с кодом n (нерграниченно)|
|MSK(x,y)|x: Integer, y: Integer||Побитовая маскировка y, с помощью маски x|
|Time||ARRAY OF CHAR|возвращает время при компиляции|
|Date||ARRAY OF CHAR|возвращает дату при компиляции|

### 13 Системное программирование с помощью Оберона

Наиболее часто наблюдаемой проблемой системных программистов, впервые работающих на Обероне, является отсутствие логических операций с целыми числами. Нет `a & b` и нет `a | b`. Кроме того, битовые сдвиги должны быть выражены либо с помощью таких функций, как `SHL` или `SHR`, либо с помощью деления. Новичкам в системном программировании с помощью Oberon рекомендуются следующие подходы.

* Используйте `DIV` и умножение, когда вы хотите сдвинуть целые числа.
* Используйте `SHL` и `SHR`. Используйте тип без знака, когда важно, чтобы знаковый бит не распространялся на сдвиги вправо.
* Используйте `MOD` для маскировки младших битов.
* Используйте операции с множествами, когда вы хотите работать с битовыми масками.
* Используйте `ODD` для битовых проверок целых чисел.
* Используйте `SYSTEM.MOVE`, если вы хотите скопировать большие области памяти.
* Используйте `SYSTEM.PUT` or `SYSTEM.GET` для побайтового чтения или записи данных.
* Используйте `POINTER {UNSAFE} TO ...` когда вы хотите получить доступ к памяти напрямую. Значения, совместимые с типом `ADDRESS`, могут быть присвоены небезопасным указателям.

Процедуры, типы и символы могут быть отмечены специальными свойствами, влияющими на поведение компилятора и компоновщика:

* Используйте `PROCEDURE {PLAIN} X(...)` чтобы избежать того, что процедура X содержит фрейм активации процедуры. Процедуры с пометкой "NOPAF" не могут предоставлять переменные или параметры.
* Используйте `PROCEDURE {OPENING} X(...)` для объявления, что процедура должна быть скомпонована в начале образа. Открывающая процедура - всегда PLAIN.
* Используйте `PROCEDURE {CLOSING} X(...)` для объявления, что процедура должна быть скомпонована после всех тел модулей в образе. Закрывающая процедура - всегда PLAIN.
* Используйте `VAR a {UNTRACED}: POINTER ...` чтобы объявить указатель, который не будет отслеживаться сборщиком мусора.
* Используйте `a {ALIGNED(32)}: ...` чтобы убедиться, что символ `а` выравнивается в памяти соответствующим образом.
* Используйте `x EXTERN 100000H ...` чтобы убедиться, что символ `x` закреплен в памяти соответствующим образом.
* Используйте `BEGIN {UNCHECKED} ... END` чтобы выдавать код без каких-либо проверок, таких как проверки стека, нулевого указателя или привязки индекса.
* Используйте `POINTER {UNSAFE} TO RECORD or POINTER {UNSAFE} TO ARRAY` чтобы объявить указатель, который по своей сути небезопасен. Небезопасный указатель совместим по присваиванию с адресом. Очевидно, что небезопасные указатели не могут быть защищены или проверены по типу. Небезопасный указатель на открытые массивы не имеет длины и не может быть передан как обычный массив.

Наконец, вы можете писать целые процедуры или их части с помощью ассемблера.

* Используйте `CODE ... END` для того, чтобы написать встроенный ассемблерный код

Пример кода, скомпонованного в передней части образа ядра:

PROCEDURE {OPENING} KernelBegin;
CODE
  MOV bootFlag, EAX
  LEA EAX, initRegs
  MOV [EAX + 0], ESI
  MOV [EAX + 4], EDI
END KernelBegin;

### 14 Совместимость

Существует лишь несколько случаев совместимости типов, которые должны быть проверены компилятором:

1. *Совместимость по присваиванию* используется в следующих случаях:

   (a) в присваивании `d := e:` Именующее выражение `d` должно именовать переменную (или поле), доступную не только для чтения, и тип `e` должен быть совместим по присваиванию с типом `d`.
   
   (b) в операторах возврата внутри процедур: тип параметра в операторе `return` должен быть совместим по присваиванию с возвращаемым типом соответствующей процедуры.
   
   (c) в типах защитник `a(Tf)` и типах проверка `a IS Tf`: поскольку записи Ra и Rf совместимы по присваиванию, если Ra является расширением Rf, совместимость параметров Ra и Rf равна совместимости расширений в типах защитник и проверка.

2. *Совместимость параметров-значений* используется в следующем случае:

   (a) при вызове процедуры `P(...,a,...)` для параметров-значений: если P определена как
   
   `PROCEDURE P(..., [CONST] f: Tf, ...)`,
   
   то тип фактического параметра-значения `a` должен быть совместим с типом формального параметра-значения Tf.
   
   Совместимость параметров-значений эквивалентна совместимости по присваиванию, если формальный тип не является открытым массивом.
   
3. *Совместимость параметров-переменных* используется в следующем случае:

   (a) при вызове процедуры `P(...,a,...)` для параметров-переменных: если P определена как
  
   `PROCEDURE P(...,VAR f: Tf, ...)`
      
   то тип фактического параметра-переменной `a` должен быть совместим с типом формального параметра-переменной Tf.
      
4. *Совместимость выражений* используется для бинарных операций над выражениями и нуждается в специальной обработке. Для многих арифметических выражений один из двух операндов должен быть совместим по присваисванию с другим. Все остальные случаи описаны в таблице операций в разделе 10.7.

#### 14.1 Одинаковые типы

Две переменные a и b с типами *Ta* и *Tb* имеют *одинаковый тип*, если:

1. *Ta* и *Tb* обозначаются одним и тем же идентификатором типа, или
2. *Ta* и *Tb* объявляются равными в объявлении типа в виде `Ta = Tb`, или
3. a и b отображаются в одном и том же списке идентификаторов в объявлении переменной, поля или формального параметра и не являются открытыми массивами, или 
4. *Ta* и *Tb* - типы массивов с совпадающими длинами и одинаковым типом элементов,
5. *Ta* и *Tb* - типы указателей, оба безопасные или оба небезопасные , с одинаковым базовым типом указателя,
6. *Ta* и *Tb* - типы портов с одинаковым направлением и шириной,
7. *Ta* и *Tb* - тензоры с одинаковым типом элементов,
8. *Ta* и *Tb* - открытые математические массивы с одинаковым типом элементов,
9. *Ta* и *Tb* - открытые математические массивы с одинаковым размером и одинаковым типом элементов,
10. *Ta* и *Tb* - статические математические массивы с одинаковыми размерами, одинаковой длиной и одинаковым типом элементов,
11. *Ta* и *Tb* - типы процедур с совпадающей сигнатурой.

Пункт 3 означает, что a и b имеют один и тот же (потенциально анонимный) тип. Пример:

`a, b: RECORD a: SIZE END;`

##### 14.1.1 Сравнение с оригинальной версией Оберона

Типы массивов с одинаковой длиной и типом элементов не считались одинаковыми в исходном Обероне. Типы портов предназначены для активных ячеек. Типы математических массивов также являются новыми.

#### 14.2 Совпадение сигнатур

Два типа процедур имеют совпадающую сигнатуру, если они оба

1. имеют одинаковый тип возвращаемого значения
2. совпадают по следующим признакам: по соглашению о вызове, по делегированию, no-return ***!!!по отсутствию возвращаемого значения?!!!***, по прерыванию, по вложенности,
3. имеют одинаковое количество формальных параметров, каждый из которых имеет одинаковый вид (`VAR`, `CONST` или значение) и одинаковый тип ***!!!соответственно?!!! Наверное, не все подряд, а только соответствующие друг-другу параметры?***.

#### 14.3 Тип включения

Числовые типы "включают" (значения) "меньших" числовых типов в соответствии со следующей иерархией:

```
		  FLOAT64 ﬤ FLOAT32
		ℶ UNSIGNED64 ℶ SIGNED64 ﬤ UNSIGNED32 ℶ SIGNED32
		ﬤ UNSIGNED16 ℶ SIGNED16 ﬤ UNSIGNED8 ℶ SIGNED8
```

Мы использовали `A ℶ B` для выражения, когда существует совместимость по присваиванию для A ϶ a ← b ϵ B, хотя на самом деле между A и B не существует отношения "надмножества".

#### 14.4 Тип расширения (базовый тип)

Дано объявление типа `Tb = RECORD (Ta) ... END`, Tb является прямым расширением Ta, а Ta - прямым базовым типом Tb. Тип Tb является расширением типа Ta (Ta - базовый тип Tb), если

1. Типы Ta and Tb совпадают или
2. Tb является прямым расширением Ta.

Если `Pa = POINTER TO Ta` и `Pb = POINTER TO Tb`, Pb является расширением Pa (Pa - базовый тип Pb), когда Tb является расширением Ta.

#### 14.5 Совместимость по присваиванию

Выражение l типа *Tl* совместимо по присваиванию с переменной r типа *Tr* (`l := r ` может быть допустимо), если выполняется одно из следующих условий:

1. *Tl* и *Tr* являются одинаковыми типами и не являются открытими массивами;
2. *Tl* и *Tr* являются числовыми типами и *Tl* включает в себя *Tr*;
3. *Tl* и *Tr* - типы "запись" и *Tr* - расширение *Tl*;
4. *Tl* и *Tr* - типы "указатель" и *Tr* - расширение *Tl*;
5. *Tl* - указатель или тип "процедура" и r имеет значение `NIL`;
6. *Tl* - `ARRAY n OF CHAR`, r - строковая константа, содержащая m знаков, где m < n;
7. *Tl* - `ARRAY OF CHAR` и r - строковая константа;
8. *Tl* и *Tr* - одни и те же типы "процедура";
9. *Tl* - тип `ADDRESS` и *Tr* - небезопасный указатель или наоборот;
10. *Tl* и *Tr* - математические массивы, совместимые по присваиванию (см. ниже).

#### 14.6 Совместимые массивы

Фактический параметр r типа *Tr* является массивом, совместимым с формальным параметром l типа *Tl*, если:

1. *Tl* и *Tr* - это один и тот же тип или
2. *Tl* - это открытый массив, *Tr* - произвольный массив, и типы их элементов совместимы, или
3. *Tl* - это `ARRAY OF CHAR` и r - строка, или
4. *Tl* - это `ARRAY OF SYSTEM.BYTE` и *Tr* - любой тип.

#### 14.7 Совместимые математические массивы

Базовым элементом типа математического массива типа *T* определяется рекурсивно следующим образом: если *T* - математеческий массив и тип его элемента *E* - математеческий массив, то *B* является базовым элементом типа *E*, в противном случае *E* является базовым элементом типа *T*.

**Совместимость по переменным математического массива.** Фактический параметр r типа *Tr* совместим как переменная с формальным параметром l типа *Tl*, если они оба являются математическими массивами и типы *Tl* и *Tr* базовых элементов *Bl* и *Br* являются одинаковыми типами, и *Tr* совместим по форме с *Tl-*

**Совместимость по форме.**  Тип математического массива *Tr* совместим по форме с *Tl*, если:

1. *Tl* - это тензор.
2. *Tl* - это открытый математический массив, а *Tr* - открытый или статичемкий математический массив с таким же количеством измерений.
3. *Tl* - это статичемкий математический массив, а *Tr* - статичемкий математический массив с таким же количеством измерений и такой же длиной.

Это определение совместимости по форме, очевидно, применимо к статическим свойствам математического массива. Если математический массив с динамическими свойствами (такими как переменная длина или размерность) оказывается несовместимым по форме во время выполнения, возникает прерывание.

**Совместимость по присваиванию математических массивов.** Фактический параметр r типа *Tr* является *математическим массивом, совместимым по присваиванию* с формальным параметром l типа *Tl*, если они оба являются математическими массивами, а базовый элемент *Bl* типа *Tl* является совместимым по присваиванию с базовым элементом *Br* типа *Tr* и оба удовлетворяют условиям:

1. *Tr* совместим по форме с *Tl* или
2. *Tl* - это открытый математический массив , а *Tr* - тензор.

#### 14.8 Совместимый параметр

  При вызове процедуры фактические параметры должны быть совместимы с формальными параметрами. Рассмотрим параметр в процедуре с формальным параметром типа *Tl* и вызов P(...,r,...) с фактическим параметром (выражением) r типа *Tr*. В этом случае фактический параметр r (выражение типа *Tr*) является совместимым с формальным параметром:

1. если, в случае параметра-значения или параметра-константы,

   (a) *Tr* совместим по присваиванию с *Tl* или
   
   (b) *Tr* - это массив, совместимый с *Tl*
   
2. если, в случае параметра-переменной, l может быть изменен, т. е. l имеет адрес и l не является константой, и:

   (a) *Tl и *Tr* - одного и того же типа или

   (b) *Tr - это массив, совместимый с *Tl*, или

   (c) *Tr* - это математический массив, совместимый по переменным с *Tl*.

## Приложения.

### A. Типы математических массивов: использование

Математические массивы представляют собой языковое расширение Оберона. Их можно рассматривать как и обычные массивы в активном Обероне, но кроме того они значительно расширяют функциональность за счет определения массивов-субструктур , которые могут быть доступны в качестве параметров при вызовах процедур и в качестве операндов в арифметических выражениях.

Назначение математических массивов заключается в возможности интуитивного и эффективного математического программирования, в частности в области (мульти-)линейной алгебры. С помощью строгого подхода семантики значений последовательно исключается ненатуральное понятие указателей.

#### A.1 Объявление

Математические массивы объявляются почти так же, как и обычные массивы в активном Обероне. Различие реализуется дополнительными квадратными скобками в типе массива. Существует четыре ***!!!ниже указано только три!!!*** различных способа объявления математического массива.

1. **Статические массивы** объявляются с фиксированным количеством измерений и с постоянной длиной в виде `array [n1,n2,n3] OF БазовыйТип`, где `n1`, `n2` и `n3` должны быть константами.
2. **Динамические массивы** объявляются с фиксированным количеством измерений и с их неопределенной длиной в виде `ARRAY [*,*] of БазовыйТип`.
3. **Тензорные массивы** объявляются с неопределенным количеством измерений и переменной длиной в виде `ARRAY [?] of БазовыйТип`. Количество измерений определяется во время выполнения, например в операторе распределения `NEW(a,1,2,3,4)` (4 измерения).

Звездочка `*` обозначает произвольный индекс, а вопросительный знак `?` обозначает произвольное число произвольных индексов. Поэтому `ARRAY [*, *] OF REAL` означает динамические массивы размерности два, в то время как массив `ARRAY [?] OF FLOAT32` обозначает массив с произвольным количеством измерений.

Некоторые примеры объявления расширенных массивов приведены ниже:

```
VAR
S1: ARRAY [3,5] OF SIZE;
S2: ARRAY [3] OF ARRAY [5] OF SIZE; (* Эквивалент для S1 *)
D1: ARRAY [*,*] OF REAL;
D2: ARRAY [*] OF ARRAY [*] OF REAL; (* Эквивалент для D1 *)
T: ARRAY [?] of INTEGER;
```

#### A.2 Доступ к одному элементу

Доступ к одному элементу обозначается так же, как и в активном Обероне, квадратными скобками. Отдельные элементы могут быть прочитаны или записаны. Если массив доступен только для чтения или является константой, то элементы могут быть только считаны.

Примеры доступа к одному элементу:

```
VAR
  A: ARRAY [*,*] of REAL;
  t: REAL; i,j: SIZE;
PROCEDURE p(VAR x: REAL);
BEGIN
  (* ... *)
  A[3,5] := t;
  t := A[3,5];
  P(a[i,j]);
```

#### A.3 Распределение

Динамические расширенные массивы и массивы с динамической размерностью должны быть распределены до того, как их элементы или подструктуры станут доступны. Это можно сделать с помощью встроенной функции `NEW` или неявно с помощью присваивания.

Примеры распределения массивов:

```
VAR
	a,b: ARRAY [*,*] of REAL;
	t,s: ARRAY [?] of REAL;
begin
	...
	NEW(a,3,3); (* Распределение *)
	NEW(t,3,3); (* Распределение *)
	s := a; (* неявное распределение *)
	b := a; (* неявное распределение *)
	s := t; (* неявное распределение *)
	s := a; (* неявное распределение, динамическая проверка размерности *)
```

#### A.4 Форма

Форма массивов (геометрическая информация) может быть идентифицирована с помощью встроенных функций `LEN` и `DIM`. Если массив еще не распределен, встроенные функции возвращают нулевые значения.

`LEN` можно использовать с двумя или одним параметром. Используемый с одним параметром, он возвращает вектор длин (то есть `ARRAY [*] OF SIZE`). С помощью встроенной функции `INCR` можно считывать внутренние приращения для каждого измерения.

Примеры того, как получить форму массивов:

```
VAR
	a: ARRAY [*,*] of FLOAT32;
	t: ARRAY [?] of FLOAT32;
	d: SIZE;
	v: ARRAY [*] of SIZE;
begin
	...
	i := LEN(a,d); (* Количество элементов измерения d *)
	v := LEN(t); (* вектор длин *)
	i := INCR(a,0); (* приращение *)
	v := INCR(t); (* вектор приращений *)
	d := DIM(s); (* количество измерений s *)
```

#### A.5 Присваивание и массивы констант

Для математических массивов не существует понятия указателя на массив. Математические массивы снабжены семантикой значений. Согласно общему определению дизайна семантики значений для таких типов массивов, присваивание всегда обозначает копию контента ("глубокая копия"), а не копию ссылок ("мелкая копия"). В некоторых случаях операция глубокого копирования может (в целях оптимизации) быть неглубокой копией, т. е. может быть преобразована компилятором в ссылочную копию. Предпосылками для этого является то, что исходный операнд больше не может быть получен после выполнения оператора присваивания и что операнд-получатель допускает перезапись дескриптора. Однако с абстрактной точки зрения основной принцип передачи значений сохраняется.

Использование присваивания уже было показано в примере пункта А.3. С введением копий значений массивы констант также имеют смысл в языке.

##### A.5.1 Примеры

Пример массива констант и присваивания:

```
VAR
	a: ARRAY [*,*] of REAL;
	t: ARRAY [?] of REAL;
CONST
	c = [[1,2,3],[4,5,6],[7,8,9]];
BEGIN
	...
	a := c; (* присваивание массиву a массива констант c *)
	t := [[1,2,3],[4,5,6],[7,8,9]]; (* присваивание *)
```

#### A.6 Диапазоны и части

Помимо того, что массивы могут быть доступны по элементам, они также могут быть доступны целыми частями, а именно в подструктурах, которые могут быть объявлены с так называемыми диапазонами. Таким образом, индексирование массивов с помощью списка диапазонов (и целых) дает именующее выражение, обозначающее (прямоугольную, регулярную) часть массива.

##### A.6.1 Примеры

Диапазоны и их применения:

```
VAR
	a: ARRAY [*,*] of REAL;
	t,s: ARRAY [?] of REAL;
CONST
	c = [[1,2,3],[4,5,6],[7,8,9]];
BEGIN
...
	a[1..3,2..4] := c; (* форма должна соответствовать *)
	t := a[1..2,2..4]; (* распределение, если необходимо *)
	t[1..2,2..4] := a[1..2,2..4]; (* динамическая проверка размерности *)
	t[1,*] := [1,2,3];
	s[1,?] := a;
```

#### A.7 Параметры, вызов процедур

Массивы могут использоваться в качестве параметров-констант и  параметров-переменных для процедур или методов в математическом Обероне. Параметры-переменные предполагают, что массив может быть изменен вызываемым объектом.

Существуют определенные ограничения и проверки во время выполнения при передаче переменных. Более подробно о них будет расскзано в следующих пунктах.

**Передача по значению.** Передача по значению запрещена для математических массивов. Она была намеренно исключена из языка и без особых проблем может быть заменена присваиваниями.

**Передача переменной.** Если в объявлении параметра присутствует модификатор `VAR`, то соответствующий параметр помечается как параметр-ссылка. Если параметр передается по ссылке, то он вообще не защищен от записи и в некоторых случаях даже может быть повторно выделен. Изменения параметра оказывают воздействие на переменную вызывающей процедуры.

```
PROCEDURE VPS(VAR S: ARRAY [3,3] of Type)
PROCEDURE VPA(VAR A: ARRAY [*,*] of Type)
PROCEDURE VPT(VAR T: ARRAY [?] of Type)
```

**Передача константы.** Если в объявлении параметра присутствует ключевое слово `CONST`, то этот параметр помечается как параметр только для чтения. Таким образом, он защищен от записи в рамках процедуры. Эта защита является временной, то есть переменная, защищенная от записи, не может использоваться в качестве параметра-ссылки.

```
PROCEDURE PS(CONST S: ARRAY [3,3] of Type)
PROCEDURE PA(CONST A: ARRAY [*,*] of Type)
PROCEDURE PT(CONST T: ARRAY [?] of Type)
```

**Виды возврата.** Математические массивы могут быть возвращены с помощью процедур. Поэтому процедуры, возвращающие расширенные массивы, также могут передаваться как значения или константы, но, естественно, не как параметры-переменные.

Примеры видов возвращаемых массивов:

```
PROCEDURE P(): ARRAY [*,*] of Type;
PROCEDURE P(): ARRAY [3,3] of Type;
PROCEDURE P(): ARRAY [?] of Type;
```

##### A.7.1 Ограничения на вызываемой стороне

Из-за высокой степени взаимосвязи между различными вариантами массива (статическим, динамическим, тензорным) некоторые проверки должны быть обеспечены во время выполнения. В этом параграфе мы говорим о возможных ограничениях во время выполнения для различных вероятных случаев.

* **Передача статического массива, открытого массива или тензора как константы.** Данные массива и дескриптор - неизменяемы. Массив доступен только для чтения и не может быть повторно распределен или изменен по размеру.
* **Передача статического массива как переменной.** Содержимое массива может быть изменено только при действиях с переменной вызывающей процедуры.
* **Передача открытого массива как переменной.** Массив в принципе может быть изменен как по своему содержанию, так и по размеру. Однако допуск для повторного распределения `A` проверяется во время выполнения, так как передаваемая переменная могла быть статическим массивом или диапазоном (как в `P(B[1..2,1..2])`). В этом случае изменение размера не имело бы смысла.
* **Передача тензорнного массива как переменной.** У массива `A` может быть изменен как размер, так и содержимое, и даже количество измерений. Однако разрешение перераспределения и изменения размерности, проверяется во время выполнения. Перераспределение и изменение размерности запрещено, если был передан статический массив или диапазон (как в `P(B[1..2,1..2])`). Изменение количества измерений запрещено, если был передан статический или динамический массив (как и в случае `P(B)`, где `B: ARRAY [*,*] of Type`).

**Замечание 4**

*Обратите внимание, в общем случае не гарантируется, что массив констант* `A` *в рамках процедуры* `P` *физически идентичен переменной вызывающей процедуры. Это совсем не так, если имело место преобразование параметров. В качестве примера рассмотрим переменную* `A: ARRAY [] of INTEGER` *и процедуру* `PROCEDURE P(CONST A: ARRAY [] of FLOAT32)`*. Как объяснено в разделе* `??`*, можно вызвать* `P(A)` *с автоматическим преобразованием* `A`*, приводящим к копированию содержимого во время вызова.*

##### A.7.2 Ограничения на вызывающей стороне

В дополнение к возможным ограничениям внутри вызываемой процедуры (как описано в предыдущем параграфе) могут также существовать ограничения во время выполнения на стороне вызывающей процедуры из-за взаимодействия различных вариантов массива.

**Обозначение 1.** *Допустим, следующие переменные* `A, T, S, PA(...), PS(...), PT(...)` *будут определены таким образом:*

```
  VAR S: array [a,b] of Type			  (статический массив)
  VAR A: array [*,*] of Type			  (открытый массив)
  VAR T: array [?] of Type				  (тензор)
  PROCEDURE PS(...): ARRAY [a,b] OF Type  (процедура, возвращающая статический массив)
  PROCEDURE PA(...): ARRAY [*,*] OF Type  (процедура, возвращающая открытый массив)
  PROCEDURE PT(...): ARRAY [?] OF Type	  (процедура, возвращающая тензор)
```

*Кроме того, мы используем выражение* `A[a..b,c..d]` *для любого диапазона подструктуры масива. Здесь* `A` *может свободно заменяться* `T` *or* `S`.*

**Замечание 5**

*Обратите внимание, что использование диапазона для массива в целом влечет за собой проверку геометрии во время выполнения, то есть проверку длины каждого измерения. В случае тензоров производится дополнительная проверка во время выполнения на количество измерений.*

Теперь, используя обозначение выше, покажем какие ограничения применяются в различных случаях:

- **Передача статического массива как константы**

```
  PROCEDURE P(CONST s: ARRAY [A,B] OF Type;
```

-
   - тип `s` и переменная вызывающей процедуры должны точно совпадать. Передача возможна только в том случае, если типы точно совпадают. Поэтому возможны только `P(S)` и `P(PS(...))`.  *[сноска: Текущая реализация даже отклоняет показанный случай, если a=A и b=B, так как типы до сих пор отличимы.]*
   - невозможно передать структуры-подмассивы

- **Передача статического массива как переменной**

```
  PROCEDURE P(VAR s: ARRAY [A,B] OF Type;
```

-
  - разрешено только: `P(S)`
  - ограничения такие же как и выше с дополнительным условием, гласящим, что процедура возвращающая массив не может быть передана

- **Передача открытого массива как константы**

```
  PROCEDURE P(CONST s: ARRAY [*,*] OF Type);
```

-
  - разрешено: `P(A), P(A[a..b,c..d]), P(S), P(PA(...)), P(PS(...))`
  - если передается тензор (`P(T), P(PT(...))`), то размерность проверяется во время выполнения

- **Передача открытого массива как переменной**

```
  PROCEDURE P(VAR s: ARRAY [*,*] OF Type);
```

-
  - разрешено: `P(A), P(A[a..b,c..d]), P(T), P(S)`
  - процедура, возвращающая массив, не может быть передана
  - если передается тензор (`P(T), P(PT(...))`), то размерность проверяется во время выполнения

- **Передача тензорнного массива как константы**

```
  PROCEDURE P(CONST s: ARRAY [?] OF Type);
```

-
  - разрешено: `P(A), P(A[a..b,c..d]), P(T), P(S), P(PA(...)), P(PT(...)), P(PS(...))`
  - нет ограничений

- **Передача тензорнного массива по ссылке**

```
PROCEDURE P(VAR s: ARRAY [?] OF Type);
```

-
  - разрешено: `P(A), P(A[a..b,c..d]), P(T), P(S)`
  - процедура, возвращающая массив, не может быть передана

##### A.7.3 Возвращаемый параметр

Если процедура возвращает статический массив, то фактическое возвращаемое значение должно иметь точный возвращаемый тип. Некоторые запрещенные случаи показаны в следующем примере.

Пример процедуры, возвращающей статические массивы:

```
PROCEDURE P(): ARRAY [5,5] OF Type;
VAR a: ARRAY [*,*] OF Type;
	b: ARRAY [5,5] OF Type;
BEGIN
	NEW(a,5,5);
	RETURN a; 			 (* запрещено, компилироваться не будет *)
	RETURN a[0..4,0..4]; (* запрещено, компилироваться не будет *)
	RETURN b[0..4,0..4]; (* запрещено, компилироваться не будет *)
	RETURN b[*,*]; 		 (* запрещено, компилироваться не будет *)
	RETURN b; 			 (* порядок *)
END P;
```

В процедурах, возвращающих открытые массивы, может быть возвращен любой массив, если количество измерений и базовые типы совпадают. Если представлены тензоры, то количество измерений проверяется во время выполнения. В противном случае это может проверить компилятор.

Примеры процедуры, возвращающей открытые массивы:

```
PROCEDURE P(): ARRAY [*,*] OF Type;
VAR a: ARRAY [*,*] OF Type;
	t: ARRAY [?] OF Type;
	s: ARRAY [3,5] OF Type;
BEGIN
	NEW(a,5,5); NEW(t,5,5);
	RETURN a; (* порядок *)
	RETURN a[*,*]; (* порядок *)
	RETURN s; (* порядок *)
	RETURN s[0..2,0..2]; (* порядок *)
	RETURN t; (* динамическая проверка количества измерений *)
	RETURN t[*,*]; (* динамическая проверка диапазона *)
END P;
```

Процедуры, возвращающие тензоры, не накладывают никаких ограничений на возвращаемые значения ни при компиляции, ни во время выполнения.

#### A.8 Встроенные операции

Для новых расширенных типов массивов был определен и реализован большой набор математических операций. В следующих примерах кода используются такие типы: `A:array [?] OF Type, v:array [*] OF integer, s:number, b:boolean`

*Массив → Скаляр*

```
s := MIN(A); s := MAX(A); s := SUM(A);
```

*Массив → Массив*

операции с умными элементами:

```
A := -B;
A := ~ B;
A := ABS(B);
A := SIGNED64(B); A := ENTIER(B);
```

другие операции

```
A := B‘; transposition
```

*Массив x Массив → Скаляр*

```
s := B +* C;
b := B = C; b := B < C; b := B <= C;
b := B > C ; b := B >= C; b := B \# C;
```

*Массив x Скаляр → Массив | Скаляр x Массив → Массив*

```
A := B + s; A := s + B; A := B - s; A := s - B;
A := s * B; A := B * s;
A := B / s ; A := s / B;
A := s DIV B; A := B DIV s;
A := s MOD B; A := B MOD s;
```

*Массив x Массив → Массив*

операции с умными элементами:

```
A := B DIV C; A := B MOD C;
A := B + C; A := A - C;
A := B .* C; A := B ./ C;
A := B OR C; A := B & C;
A := B .= C; A := B .< C; A := B .<= C;
A := B .> C; A := B .>= C; A := B .# C;
```

другие операции

```
A := B * C; матрица / векторное произведение
A := B ** C; тензорное произведение
A := RESHAPE(B,v); операция видоизменения
```

#### A.9 Совместимость типов

Благодаря автоматическим преобразованиям, которые могут выполняться во время выполнения (за кулисами), расширенные массивы подчиняются другим правилам совместимости типов, нежели традиционные массивы. Естественно, что элементы массивов доступны так же, как и обычные типы данных, и поэтому это утверждение применимо только к выражениям, содержащим (субструктуры) массивов (называемые именующими выражениями массивов). Именующие выражения массивов используются в присваиваниях, как переменные или значения при вызове процедуры и (неявно) для совместимости типов переменных процедуры.

##### A.9.1 Совместимость по присваиванию математических массивов

Массивы и подструктуры массивов совместимы по присваиванию, если для

```
dest := src;
```

выполняются следующие условия:

1. - или `dim(src)=dim(dest)`: количество измерений `dest` равно количеству измерений `src`
   - или `dest` путем перераспределения может быть сделан совместимым по измерению (т. е. `dest` должен иметь тип тензора).

   Для расширенных массивов это может быть проверено во время компиляции, тогда как для тензорных типов это может быть определено только во время выполнения.

2. - или `len(src,i)=dim(dest,i)` для всех *i*: формы `dest` и `src` совпадают
   - или форма `dest` может быть сделана совместимой с формой `src` с помощью перераспределения.

   Если источник и назначение являются статическими массивами или статическими подструктурами, то это может быть проверено во время компиляции, в противном случае это может быть проверено только во время выполнения.

3. Базовые типы `dest` и `src` должны быть совместимы по присваиванию.

##### A.9.2 Совместимость параметров-значений

Массивы и подструктуры массивов совместимы по параметру-значению, если для

```
PROCEDURE P(CONST a: FormalType);

P(A);
```

(фактический) тип `A` является совместимым по присваиванию с (формальным) типом `a` в определении `P`. Таким образом, выражение `P(A)` является (статически и динамически) допустимым, если выражение `a := A` было бы допустимым в данном контексте.

##### A.9.3 Совместимость параметров-переменных

Массивы и подструктуры массивов совместимы по параметру-переменной, если для

```
PROCEDURE P(var f: FormalType);

P(A);
```

(фактический) тип `A` и формальный тип `f`

- или идентичны
- или таковы, что
  1. базовые типы `A` и `f` идентичны и
  2. для форм `Shape(a)` и `Shape(A)`, соответствующим `a` и `A`, истинно, что `shape(a) ϵ shape(A)`. Необходимо различать следующие случаи:
  
     (a) форма `f` - статична. Тогда форма типа `A` также должна быть статичной, и длины должны совпадать.
     
     (b) форма `f` - открыта, но фиксированного размера. Тогда форма типа `A` должна быть такой же размерности или динамической.
     
     (c) форма `f` - тензор. Тогда форма `A` может быть произвольной.

##### A.9.4 Совместимость типов процедур

Две процедуры `P` и `Q` совместимы по типу (т. е. для переменной `p` типа, идентичного типу `P`, можно было бы присвоить `p := Q`) в отношении расширенных массивов, если соответствующие параметры-массивы `a` и `b` процедур `P` и `Q` имеют одинаковые базовые типы, и если они идентичны по форме, т.е. `Base(a)=Base(b)` и `Shape(a)=Shape(b)`.

##### A.9.5 Формализация типов массивов. Домены (области определения) и формы

Хотя мы не очень любим чрезмерную формализацию и хотим по возможности избегать ее в пользу примеров и интуиции, при этом мы думаем, что формальная трактовка типов массивов может значительно продвинуть нас вперед в отношении общего понимания структурированных типов.

Как уже отмечалось ранее, существуют два одинаково важных взгляда на массив, которые необходимо принять во внимание для полного понимания деталей этого вопроса. С одной стороны, массивы содержат данные, и поэтому система должна обеспечить достаточно большое хранилище для значений базового типа. С другой стороны, геометрическая структура массива играет очень важную роль в структурировании данных точно так же, как это происходит с записями и тому подобным. Существенная разница между массивами и записями заключается в том, что массивы могут иметь динамическую структуру, тогда как записи / объекты в целом имеют статический размер и структурированы.

С помощью математической формализации мы попытаемся получить некоторое представление о структурировании массивов. Введем такие понятия, как *домен*, *тип-домен*, *форма* и *тип-форма* массивов.

Неформально говоря, домен переменной массива - это множество возможных индексов, которые могут быть применены для доступа к одному элементу массива. Домен переменной массива не обязательно совпадает с доменом соответствующего типа массива. Это связано с тем, что объявление массива типа `var a: array [,] of FLOAT32` оставляет открытым множество возможных индексов, в то время как оператор `new(a,3,3)`  во время выполнения подтверждает множество допустимых значений `i` и `j` в рамках `v := a[i,j]`. Тип-домен `a` - это множество, содержащее все потенциальные домены `a`. В данном примере - это `Ui,jϵN`*`Sij`*, где *`Sij`*` = {1, ... , i} x {1,...,j}`. Тогда при `i = j = 3` домен `a` - это `{1, ...,3} x {1, ..., 3}`. В следующей таблице мы указываем домен и форму для различных типов и переменных.

|Объявление|Домены|Формы|
|-|-|-|
|M:array n of B|D(M) = {{1,...,n}}|S(M) = {n}|
|r:M|D(r) ϵ D(r) = {1,..., n}|S(r) = n|
|M:array [*] of B|D(M) = UnϵN{{1, ... ,n}}|S(M) = N|
|r:M|D(r) = {1,...,n} for one n|S(r) ϵ N|
|M:array [*,*] of B|D(M) = Un,mϵN{{1,...,n} x {1,...,m}}|S(M) = N↑2|
|r:M|D(r) = {{1,...,n} x {1,...,m}} for one (n,m)|S(r) ϵ N↑2|
|M:array [?] of B|D(M) = UdϵN UkϵN↑d Sd(k)|S(M) = UdN↑d|
|r:M|D(r) = {1,...,k1} x ... x {1,...,kd} for one k,d|S(r) ϵ N↑d for one d ϵ N|

Мы мспользовали обозначение Sd(k) = {1,..., k1} x ... x {1,...,kd}.

С помощью этого инструмента мы можем очень легко выразить совместимость параметра-значения массива `a` (фактического) типа `A` с параметром процедуры `f` (формального) типа `F`. Рассмотрим следующий код

```
VAR a: A;
PROCEDURE P(f: F);
...
P(a); (* это допустимый вызов? *)
```

Выражение `P(a)` допустимо, если базовые типы совместимы и если *D(a)* ϵ *D(F)*, эквивалентно, если *S(a)* ϵ *S(F)*. Поскольку *S(a)* не известно во время компиляции, лучшее, что может сделать компилятор, - это проверить, включено ли *S(A)* в *S(F)* ***!!!нет знака включено!!!***. Мы реализовали эту проверку типа с одним исключением: в случае, когда `A` является тензорным типом и `F` - типом открытого массива, мы проверяем во время компиляции только *S(A)* ∩ *S(F)* ≠ Ø, остальное проверяется во время выполнения.

#### A.10 Доступность возвращаемых параметров

Чтобы дать программистам возможность оптимизировать код в отношении распределения массивов, теперь можно получить доступ к возвращаемому параметру процедуры, типа массива или тензора, как к ссылочному параметру. Он называется `RESULT`.

```
PROCEDURE Test(CONST a: ARRAY [?] OF FLOAT32): ARRAY [?] OF FLOAT32;
BEGIN
	if LEN(a)#LEN(RESULT) then
		NEW(RESULT,len(a));
	end;
	return RESULT; (* ничего не делает, предотвращает копирование *)
END Test;
```

### B. Расширенная форма Бэкуса — Наура (EBNF) активного Оберона

```
Модуль = ’MODULE’ [ПараметрыШаблона] Идентификатор [’IN’ Идентификатор] ’;’
		{СписокИмпорта} ПоследовательностьОбъявлений [Тело]
		’END’ Идентификатор ’.’.

ПараметрыШаблона = ’(’ ПараметрШаблона {’,’ ПараметрШаблона} ’)’.

ПараметрШаблона = (’CONST’ | ’TYPE’) Идентификатор.

СписокИмпорта = ’IMPORT’ Импорт { ’,’ Импорт } ’;’.

Импорт = Идентификатор [’:=’ Идентификатор] [’(’ СписокВыражений ’)’ ]
		[’IN’ Идентификатор].

ПоследовательностьОбъявлений = {
		’CONST’ [ОбъявлениеКонстанты] {’;’ [ОбъявлениеКонстанты]}
		|’TYPE’ [ОбъявлениеТипа] {’;’ [ОбъявлениеТипа]}
		|’VAR’ [ОбъявлениеПеременной] {’;’ [ОбъявлениеПеременной]}
		| ОбъявлениеПроцедуры
		| ОбъявлениеОперации
		| ’;’
		}

ОбъявлениеКонстанты = [ОбъявлениеИдентификатора ’=’ ВыражениеКонстанты].

ВыражениеКонстанты = Выражение.

ОбъявлениеПеременной = СписокИменПеременных [’:’ Тип].

СписокИменПеременных = ИмяПеременной {"," ИмяПеременной}.

ИмяПеременной = ОпределениеИдентификатора [Флаги]
			[’:=’ Выражение | ’EXTERN’ Строка].

Флаги = ’{’ [ Флаг {’,’ Флаг} ] ’}’.

Флаг = Идентификатор [’(’ Выражение ’)’ | ’=’ Выражение].

ОбъявлениеПроцедуры = ’PROCEDURE’ [’^’|’&’|’~’|’-’|Флаги [’-’]]
					[’(’ ОбъявлениеПараметра ’)’]
					ОпределениеИдентификатора [ФормальныеПараметры] ’;’
					ПоследовательностьОбъявлений [Тело]
					’END’ Идентификатор.

ОбъявлениеОперации = ’OPERATOR’ [Флаги] [’-’] Строка [’*’|’-’] ФормальныеПараметры ’;’
					ПоследовательностьОбъявлений
					[Тело]
				  ’END’ Строка.

ФормальныеПараметры = ’(’ [ОбъявлениеПараметра {’;’ ОбъявлениеПараметра}] ’)’
					[’:’ [Флаги] Тип].

ОбъявлениеПараметра = [’VAR’|’CONST’] Идентификатор [Флаги] [’=’ Выражение]
			{’,’ Идентификатор [Флаги] [’=’ Выражение]} ’:’ Тип.

Тело = ’BEGIN’ [Флаги] ПоследовательностьОператоров [’FINALLY’ ПоследовательностьОператоров]
		| ’CODE’ Код.

ОбъявлениеТипа = ОпределениеИдентификатора ’=’ Тип ’;’.

Тип = ТипМассив | ТипМатематическийМассив | ТипЗапись 
	| ТипУказатель | ТипОбъект | ТипПроцедура
    | ТипПеречисление | СоставнойИдентификатор
	| ТипЯчейка | ТипСетьЯчеек | ТипПорт.

ТипМассив = ’ARRAY’ [Выражение {’,’ Выражение}] ’OF’ Тип.

ТипМатематическийМассив = ’ARRAY’ ’[’ РазмерМатематическогоМассива {’,’ РазмерМатематическогоМассива} ’]’ ’OF’ Тип.

РазмерМатематическогоМассива = Выражение | ’*’ | ’?’.

ТипЗапись = ’RECORD’ [’(’ СоставнойИдентификатор ’)’]
		[ОбъявлениеПеременной {’;’ ОбъявлениеПеременной}]
		{ОбъявлениеПроцедуры [’;’]| ОбъявлениеОперации [’;’]}
		’END’.

ТипУказатель = ’POINTER’ [Флаги] ’TO’ Тип.

ТипПроцедура = ’PROCEDURE’ [Флаги] [ФормальныеПараметры].

ТипОбъект = ’OBJECT’
			| ’OBJECT’ [Флаги] [’(’ СоставнойИндентификатор ’)’]
			  ПоследовательностьОбъявлений
			[Тело]
			’END’ [Идентификатор].

ТипПеречисление = ’ENUM’ [’(’СоставнойИдентификатор’)’]
				ОпределениеИдентификатора [’=’ Выражение]
				{’,’ ОпределениеИдентификатора [’=’ Выражение]}
				’END’.

ТипЯчейка = (’CELL’ | ’CELLNET’) [Флаги] [СписокПортов] [’;’] {СписокИмпорта}
			ПоследовательностьОбъявлений
			[Тело] ’END’ [Идентификатор].

СписокПортов = [ОбъявлениеПорта {’;’ ОбъявлениеПорта}].

ОбъявлениеПорта = Идентификатор [Флаги] {’,’ Идентификатор [Флаги]}’:’ ТипПорт.

ТипПорт = ’PORT’ (’IN’|’OUT’) [’(’ Выражение ’)’].

СоставнойИдентификатор = Идентификатор [’.’ Идентификатор].

ОпределениеИдентификатора = Идентификатор [ ’*’ | ’-’ ].

Оператор = [
  УнарноеВыражение
	[’:=’ Выражение
	| ’!’ Выражение | ’?’ Выражение | ’<<’ Выражение | ’>>’ Выражение
	]
  | ’IF’ Выражение ’THEN’ ПоследовательностьОператоров
	{’ELSIF’ Выражение ’THEN’ ПоследовательностьОператоров}
	[’ELSE’ ПоследовательностьОператоров]
	’END’
  | ’WITH’ Идентификатор ’:’ СоставнойИдентификатор ’DO’ ПоследовательностьОператоров
	{’|’ СоставнойИдентификатор ’DO’ ПоследовательностьОператоров}
	[ELSE ПоследовательностьОператоров]
	’END’
  | ’CASE’ Выражение ’OF’ [’|’] Вариант
	{’|’ Вариант}
	[’ELSE’ ПоследовательностьОператоров]
	’END’
  | ’WHILE’ Выражение ’DO’
	  ПоследовательностьОператоров
	’END’
  | ’REPEAT’
	  ПоследовательностьОператоров
	’UNTIL’ Выражение
  | ’FOR’ Идентификатор ’:=’ Выражение ’TO’ Выражение [’BY’ Выражение] ’DO’
	  ПоследовательностьОператоров
	’END’
  | ’LOOP’ ПоследовательностьОператоров ’END’
  | ’EXIT’
  | ’RETURN’ [Выражение]
  | ’AWAIT’ Выражение
  | БлокОператоров
  | ’CODE’ {any} ’END’
  | ’IGNORE’ Выражение
].

Вариант = ВыражениеДиапазона {’,’ ВыражениеДиапазона} ’:’ ПоследовательностьОператоров.

БлокОператоров = ’BEGIN’ [Флаги] ПоследовательностьОператоров ’END’.

ПоследовательностьОператоров = Оператор {’;’ Оператор}.

Выражение = ВыражениеДиапазона [ОперацияОтношения ВыражениеДиапазона].

ОперацияОтношения = ’=’ | ’#’ | ’<’ | ’<=’ | ’>’ | ’>=’ | ’IN’ | ’IS’
					| ’.=’ | ’.#’ | ’.<’ | ’.<=’ | ’.>’ ’.>=’
					| ’??’ | ’!!’ | ’<<?’ | ’>>?’.

ВыражениеДиапазона = ПростоеВыражение
		| [ПростоеВыражение] ’..’ [ПростоеВыражение][’by’ ПростоеВыражение]
		| ’*’ .

ПростоеВыражение = Слагаемое {ОперацияСложения Слагаемое}.

ОперацияСложения = ’+’ | ’-’ | ’or’.

Слагаемое = Множитель {ОперацияУмножения Множитель}.

ОперацияУмножения = ’*’ | ’/’ | ’DIV’ | ’MOD’ | ’&’
				   | ’.*’ | ’./’ | ’\’ | ’**’ | ’+*’ .

Множитель = УнарноеВыражение | УнарнаяОперация Множитель.

УнарнаяОперация = ’~’ | ’+’ | ’-’.

УнарноеВыражение = ПервичноеВыражение [ОперацииИменующегоВыражения] [Флаги].

ПервичноеВыражение = Число | Знак | Строка | Множество | Массив
		| ’NIL’ | ’IMAG’ | ’TRUE’ | ’FALSE’ |
		| ’SELF’ | ’RESULT’ | ’ADDRESS’ | ’SIZE’
		| ’SIZE’ ’OF’ Множитель | ’ADDRESS’ ’OF’ Множитель
		| ’ALIAS’ OF Множитель
		| ’NEW’ СоставнойИдентификатор ’(’ СписокВыражений ’)’
		| ’(’ Выражение ’)’
		| Идентификатор.

ОперацииИменующегоВыражения = { "(" [СписокВыражений] ")"
				| "." Идентификатор
				| ’[’ СписокИндексов ’]’
				| ’^’
				| ’‘’
				} .

СписокВыражений = Выражение { ’,’ Выражение }.

СписокИндексов = ’?’ [’,’ СписокВыражений]
			| СписокВыражений [’,’ ’?’ [’,’ СписокВыражений] ]

Массив = ’[’ Выражение {’,’ Выражение} ’]’.

Множество = "{" [ВыражениеДиапазона {"," ВыражениеДиапазона}] "}".

Строка = ’"’ {Знак} ’"’ | "’" {Знак} "’" | ’\"’ {Знак} ’"\’.

Число = Целое | Вещественное.

Целое = Цифра {["’"]Цифра} | Цифра {["’"]ШестнадцатиричнаяЦифра} ’H’
		| ’0x’ {["’"]ШестнадцатиричнаяЦифра} | ’0b’ {["’"]ДвоичнаяЦифра}.

Вещественное = Цифра {["’"]Цифра} ’.’ {Цифра} [МасштабныйКоэффициент].

МасштабныйКоэффициент = (’E’ | ’D’) [’+’ | ’-’] Цифра {Цифра}.

ШестнадцатиричнаяЦифра = Цифра | ’A’ | ’B’ | ’C’ | ’D’ | ’E’ | ’F’
						| ’a’ | ’b’ | ’c’ | ’d’ | ’e’ | ’f’ .

Идентификатор = Буква {Буква | Цифра | ’_’ }.

Буква = ’A’ | ’B’ | .. |’Z’ | ’a’ | ’b’ | .. | ’z’ .

Цифра = ’0’ | ’1’ | ’2’ | ’3’ | ’4’ | ’5’ | ’6’ | ’7’ | ’8’ | ’9’.
```
