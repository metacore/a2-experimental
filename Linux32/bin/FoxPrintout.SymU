MODULE FoxPrintout;
	IMPORT Scanner := FoxScanner, SyntaxTree := FoxSyntaxTree, Global := FoxGlobal, Basic := FoxBasic, Fingerprinter := FoxFingerprinter, Streams, D := Debugging, SYSTEM;
CONST 
	Exported* = 0; 
	SymbolFile* = 1; 
	SourceCode* = 2; 
	All* = 3; 
	DebugPosition = FALSE; 
TYPE 
	Printer* = OBJECT (SyntaxTree.Visitor)
	VAR 
		w-: Basic.Writer; 
		mode: LONGINT; 
		singleStatement: BOOLEAN; 
		currentScope: SyntaxTree.Scope; 
		ws: Streams.StringWriter; 
		info: BOOLEAN; 
		case: LONGINT; 
		useCase: BOOLEAN; 
		alertCount, commentCount: LONGINT; 
		fingerprinter: Fingerprinter.Fingerprinter; 

		PROCEDURE ^ Small(CONST name: ARRAY OF CHAR; VAR result: ARRAY OF CHAR); 
		PROCEDURE ^ Big(CONST name: ARRAY OF CHAR; VAR result: ARRAY OF CHAR); 
		PROCEDURE ^ Keyword(CONST a: ARRAY OF CHAR); 
		PROCEDURE ^ AlertString(CONST s: ARRAY OF CHAR); 
		PROCEDURE ^ Indent; 
		PROCEDURE ^ Identifier*(x: SyntaxTree.Identifier); 
		PROCEDURE ^ QualifiedIdentifier*(x: SyntaxTree.QualifiedIdentifier); 
		PROCEDURE ^ Type*(x: SyntaxTree.Type); 
		PROCEDURE ^ VisitType*(x: SyntaxTree.Type); 
		PROCEDURE ^ VisitBasicType*(x: SyntaxTree.BasicType); 
		PROCEDURE ^ VisitBooleanType*(x: SyntaxTree.BooleanType); 
		PROCEDURE ^ VisitSetType*(x: SyntaxTree.SetType); 
		PROCEDURE ^ VisitSizeType*(x: SyntaxTree.SizeType); 
		PROCEDURE ^ VisitCharacterType*(x: SyntaxTree.CharacterType); 
		PROCEDURE ^ VisitIntegerType*(x: SyntaxTree.IntegerType); 
		PROCEDURE ^ VisitFloatType*(x: SyntaxTree.FloatType); 
		PROCEDURE ^ VisitComplexType*(x: SyntaxTree.ComplexType); 
		PROCEDURE ^ VisitByteType*(x: SyntaxTree.ByteType); 
		PROCEDURE ^ VisitQualifiedType*(x: SyntaxTree.QualifiedType); 
		PROCEDURE ^ VisitStringType*(x: SyntaxTree.StringType); 
		PROCEDURE ^ VisitEnumerationType*(x: SyntaxTree.EnumerationType); 
		PROCEDURE ^ VisitRangeType*(x: SyntaxTree.RangeType); 
		PROCEDURE ^ VisitArrayType*(x: SyntaxTree.ArrayType); 
		PROCEDURE ^ VisitNilType*(x: SyntaxTree.NilType); 
		PROCEDURE ^ VisitAddressType*(x: SyntaxTree.AddressType); 
		PROCEDURE ^ VisitObjectType*(x: SyntaxTree.ObjectType); 
		PROCEDURE ^ VisitAnyType*(x: SyntaxTree.AnyType); 
		PROCEDURE ^ VisitMathArrayType*(x: SyntaxTree.MathArrayType); 
		PROCEDURE ^ PointerFlags(x: SyntaxTree.PointerType); 
		PROCEDURE ^ ObjectFlags(rec: SyntaxTree.RecordType; x: SyntaxTree.PointerType); 
		PROCEDURE ^ VisitPointerType*(x: SyntaxTree.PointerType); 
		PROCEDURE ^ VisitPortType*(x: SyntaxTree.PortType); 
		PROCEDURE ^ VisitCellType*(x: SyntaxTree.CellType); 
		PROCEDURE ^ VisitRecordType*(x: SyntaxTree.RecordType); 
		PROCEDURE ^ Flag(identifier: SyntaxTree.Identifier; VAR first: BOOLEAN); 
		PROCEDURE ^ FlagEnd(first: BOOLEAN); 
		PROCEDURE ^ Value(identifier: SyntaxTree.Identifier; value: HUGEINT; VAR first: BOOLEAN); 
		PROCEDURE ^ VisitProcedureType*(x: SyntaxTree.ProcedureType); 
		PROCEDURE ^ ExpressionList(x: SyntaxTree.ExpressionList); 
		PROCEDURE ^ Expression*(x: SyntaxTree.Expression); 
		PROCEDURE ^ VisitExpression*(x: SyntaxTree.Expression); 
		PROCEDURE ^ VisitSet*(x: SyntaxTree.Set); 
		PROCEDURE ^ VisitMathArrayExpression*(x: SyntaxTree.MathArrayExpression); 
		PROCEDURE ^ VisitUnaryExpression*(x: SyntaxTree.UnaryExpression); 
		PROCEDURE ^ VisitBinaryExpression*(x: SyntaxTree.BinaryExpression); 
		PROCEDURE ^ VisitRangeExpression*(x: SyntaxTree.RangeExpression); 
		PROCEDURE ^ VisitTensorRangeExpression*(x: SyntaxTree.TensorRangeExpression); 
		PROCEDURE ^ VisitConversion*(x: SyntaxTree.Conversion); 
		PROCEDURE ^ VisitDesignator*(x: SyntaxTree.Designator); 
		PROCEDURE ^ VisitIdentifierDesignator*(x: SyntaxTree.IdentifierDesignator); 
		PROCEDURE ^ VisitSelectorDesignator*(x: SyntaxTree.SelectorDesignator); 
		PROCEDURE ^ VisitBracketDesignator*(x: SyntaxTree.BracketDesignator); 
		PROCEDURE ^ VisitParameterDesignator*(x: SyntaxTree.ParameterDesignator); 
		PROCEDURE ^ VisitIndexDesignator*(x: SyntaxTree.IndexDesignator); 
		PROCEDURE ^ VisitArrowDesignator*(x: SyntaxTree.ArrowDesignator); 
		PROCEDURE ^ ShortType(x: SyntaxTree.Type); 
		PROCEDURE ^ VisitSymbolDesignator*(x: SyntaxTree.SymbolDesignator); 
		PROCEDURE ^ VisitSupercallDesignator*(x: SyntaxTree.SupercallDesignator); 
		PROCEDURE ^ VisitSelfDesignator*(x: SyntaxTree.SelfDesignator); 
		PROCEDURE ^ VisitResultDesignator*(x: SyntaxTree.ResultDesignator); 
		PROCEDURE ^ VisitDereferenceDesignator*(x: SyntaxTree.DereferenceDesignator); 
		PROCEDURE ^ VisitTypeGuardDesignator*(x: SyntaxTree.TypeGuardDesignator); 
		PROCEDURE ^ VisitProcedureCallDesignator*(x: SyntaxTree.ProcedureCallDesignator); 
		PROCEDURE ^ VisitInlineCallDesignator*(x: SyntaxTree.InlineCallDesignator); 
		PROCEDURE ^ VisitStatementDesignator*(x: SyntaxTree.StatementDesignator); 
		PROCEDURE ^ VisitBuiltinCallDesignator*(x: SyntaxTree.BuiltinCallDesignator); 
		PROCEDURE ^ VisitValue*(x: SyntaxTree.Value); 
		PROCEDURE ^ VisitBooleanValue*(x: SyntaxTree.BooleanValue); 
		PROCEDURE ^ Hex(x: HUGEINT); 
		PROCEDURE ^ VisitIntegerValue*(x: SyntaxTree.IntegerValue); 
		PROCEDURE ^ VisitCharacterValue*(x: SyntaxTree.CharacterValue); 
		PROCEDURE ^ VisitSetValue*(x: SyntaxTree.SetValue); 
		PROCEDURE ^ VisitMathArrayValue*(x: SyntaxTree.MathArrayValue); 
		PROCEDURE ^ FormatedFloat(value: LONGREAL; subtype: LONGINT); 
		PROCEDURE ^ VisitRealValue*(x: SyntaxTree.RealValue); 
		PROCEDURE ^ VisitComplexValue*(x: SyntaxTree.ComplexValue); 
		PROCEDURE ^ VisitStringValue*(x: SyntaxTree.StringValue); 
		PROCEDURE ^ VisitNilValue*(x: SyntaxTree.NilValue); 
		PROCEDURE ^ VisitEnumerationValue*(x: SyntaxTree.EnumerationValue); 
		PROCEDURE ^ Symbol*(x: SyntaxTree.Symbol); 
		PROCEDURE ^ VisitSymbol*(x: SyntaxTree.Symbol); 
		PROCEDURE ^ Visible(symbol: SyntaxTree.Symbol): BOOLEAN; 
		PROCEDURE ^ PrintSymbol(x: SyntaxTree.Symbol); 
		PROCEDURE ^ VisitTypeDeclaration*(x: SyntaxTree.TypeDeclaration); 
		PROCEDURE ^ TypeDeclarationList(x: SyntaxTree.TypeDeclaration); 
		PROCEDURE ^ VisitConstant*(x: SyntaxTree.Constant); 
		PROCEDURE ^ ConstantList(x: SyntaxTree.Constant); 
		PROCEDURE ^ VisitVariable*(x: SyntaxTree.Variable); 
		PROCEDURE ^ VariableList(x: SyntaxTree.Variable); 
		PROCEDURE ^ VisitParameter*(x: SyntaxTree.Parameter); 
		PROCEDURE ^ ParameterList*(x: SyntaxTree.Parameter); 
		PROCEDURE ^ Access(access: SET); 
		PROCEDURE ^ VisitProcedure*(x: SyntaxTree.Procedure); 
		PROCEDURE ^ VisitOperator*(x: SyntaxTree.Operator); 
		PROCEDURE ^ ProcedureList(list: SyntaxTree.ProcedureList); 
		PROCEDURE ^ VisitImport*(x: SyntaxTree.Import); 
		PROCEDURE ^ ImportList(x: SyntaxTree.Import); 
		PROCEDURE ^ VisitBuiltin*(x: SyntaxTree.Builtin); 
		PROCEDURE ^ BuiltinList(x: SyntaxTree.Builtin); 
		PROCEDURE ^ BeginComment; 
		PROCEDURE ^ EndComment; 
		PROCEDURE ^ Comment(x: SyntaxTree.Comment); 
		PROCEDURE ^ Comments(c: SyntaxTree.Comment; x: ANY; sameLine: BOOLEAN); 
		PROCEDURE ^ CommentList(x: SyntaxTree.Comment); 
		PROCEDURE ^ Scope*(x: SyntaxTree.Scope); 
		PROCEDURE ^ ProcedureScope(x: SyntaxTree.ProcedureScope); 
		PROCEDURE ^ Statement*(x: SyntaxTree.Statement); 
		PROCEDURE ^ StatementSequence*(x: SyntaxTree.StatementSequence); 
		PROCEDURE ^ VisitStatement*(x: SyntaxTree.Statement); 
		PROCEDURE ^ VisitProcedureCallStatement*(x: SyntaxTree.ProcedureCallStatement); 
		PROCEDURE ^ VisitAssignment*(x: SyntaxTree.Assignment); 
		PROCEDURE ^ VisitCommunicationStatement*(x: SyntaxTree.CommunicationStatement); 
		PROCEDURE ^ IfPart(x: SyntaxTree.IfPart); 
		PROCEDURE ^ VisitIfStatement*(x: SyntaxTree.IfStatement); 
		PROCEDURE ^ WithPart(x: SyntaxTree.WithPart); 
		PROCEDURE ^ VisitWithStatement*(x: SyntaxTree.WithStatement); 
		PROCEDURE ^ CasePart(x: SyntaxTree.CasePart); 
		PROCEDURE ^ VisitCaseStatement*(x: SyntaxTree.CaseStatement); 
		PROCEDURE ^ VisitWhileStatement*(x: SyntaxTree.WhileStatement); 
		PROCEDURE ^ VisitRepeatStatement*(x: SyntaxTree.RepeatStatement); 
		PROCEDURE ^ VisitForStatement*(x: SyntaxTree.ForStatement); 
		PROCEDURE ^ VisitLoopStatement*(x: SyntaxTree.LoopStatement); 
		PROCEDURE ^ VisitExitableBlock*(x: SyntaxTree.ExitableBlock); 
		PROCEDURE ^ VisitExitStatement*(x: SyntaxTree.ExitStatement); 
		PROCEDURE ^ VisitReturnStatement*(x: SyntaxTree.ReturnStatement); 
		PROCEDURE ^ VisitAwaitStatement*(x: SyntaxTree.AwaitStatement); 
		PROCEDURE ^ Modifiers(x: SyntaxTree.Modifier); 
		PROCEDURE ^ VisitStatementBlock*(x: SyntaxTree.StatementBlock); 
		PROCEDURE ^ Code(x: SyntaxTree.Code); 
		PROCEDURE ^ VisitCode*(x: SyntaxTree.Code); 
		PROCEDURE ^ Body(x: SyntaxTree.Body; implementation: BOOLEAN); 
		PROCEDURE ^ Module*(x: SyntaxTree.Module); 
		PROCEDURE ^ SingleStatement*(b: BOOLEAN); 
		PROCEDURE ^  & Init*(w: Streams.Writer; mode: LONGINT; info: BOOLEAN); 
	END Printer; 
VAR 
	debug: Printer; 

	PROCEDURE ^ NewPrinter*(w: Streams.Writer; mode: LONGINT; info: BOOLEAN): Printer; 
	PROCEDURE ^ Info*(CONST info: ARRAY OF CHAR; a: ANY); 
	PROCEDURE ^ Init; 
BEGIN
END FoxPrintout.
