MODULE FoxBinaryObjectFile;
	IMPORT Scanner := FoxScanner, Basic := FoxBasic, SyntaxTree := FoxSyntaxTree, Global := FoxGlobal, SemanticChecker := FoxSemanticChecker, FingerPrinter := FoxFingerPrinter, Sections := FoxSections, Streams, D := Debugging, Files, SYSTEM, Strings, BinaryCode := FoxBinaryCode, Log := KernelLog, Diagnostics, SymbolFileFormat := FoxBinarySymbolFile, Options, Formats := FoxFormats, IntermediateCode := FoxIntermediateCode, Machine;
CONST 
	ofFileTag = 0BBX; 
	ofNoZeroCompress = 0ADX; 
	ofFileVersion = SymbolFileFormat.FileVersionCurrent; 
	ofEUEnd = 0X; 
	ofEURecord = 1X; 
	ofEUProcFlag = LONGINT(2147483648); 
	DefaultNofSysCalls = 12; 
	NewRec = 0; 
	NewArr = 1; 
	NewSys = 2; 
	CaseTable = 3; 
	ProcAddr = 4; 
	Lock = 5; 
	Unlock = 6; 
	Start = 7; 
	Await = 8; 
	InterfaceLookup = 9; 
	RegisterInterface = 10; 
	GetProcedure = 11; 
	Trace = FALSE; 
TYPE 
	Name = ARRAY 256 OF CHAR; 

	ByteArray = POINTER TO ARRAY OF CHAR; 

	ObjectFileFormat* = OBJECT (Formats.ObjectFileFormat)

		PROCEDURE ^  & InitObjectFileFormat; 
		PROCEDURE ^ Export*(module: Formats.GeneratedModule; symbolFileFormat: Formats.SymbolFileFormat): BOOLEAN; 
		PROCEDURE ^ DefineOptions*(options: Options.Options); 
		PROCEDURE ^ GetOptions*(options: Options.Options); 
		PROCEDURE ^ DefaultSymbolFileFormat*(): Formats.SymbolFileFormat; 
		PROCEDURE ^ ForceModuleBodies*(): BOOLEAN; 
	END ObjectFileFormat; 

	Fixup = OBJECT 
	VAR 
		nextFixup: Fixup; 
		fixup: BinaryCode.Fixup; 
		fixupSection: Sections.Section; 
	END Fixup; 

	Section = OBJECT 
	VAR 
		name: Basic.SegmentedName; 
		symbol: SyntaxTree.Symbol; 
		entryNumber: LONGINT; 
		offset: LONGINT; 
		fixups: Fixup; 
		numberFixups: LONGINT; 
		type: LONGINT; 
		resolved: BinaryCode.Section; 
		isCaseTable: BOOLEAN; 
		referenced: BOOLEAN; 

		PROCEDURE ^ SetEntryNumber(num: LONGINT); 
		PROCEDURE ^ SetSymbol(s: SyntaxTree.Symbol); 
		PROCEDURE ^  & Init(CONST name: Basic.SegmentedName); 
		PROCEDURE ^ AddFixup(fixup: BinaryCode.Fixup; fixupSection: Sections.Section); 
		PROCEDURE ^ Dump(w: Streams.Writer); 
	END Section; 

	SectionNameLookup = OBJECT (Basic.HashTableSegmentedName)

		PROCEDURE ^ GetSection(CONST name: Basic.SegmentedName): Section; 
		PROCEDURE ^ PutSection(CONST name: Basic.SegmentedName; section: Section); 
	END SectionNameLookup; 

	SymbolLookup = OBJECT (Basic.HashTable)

		PROCEDURE ^ GetSection(s: SyntaxTree.Symbol): Section; 
		PROCEDURE ^ PutSection(symbol: SyntaxTree.Symbol; section: Section); 
	END SymbolLookup; 

	SectionList = OBJECT (Basic.List)
	VAR 
		lookup: SectionNameLookup; 
		symbolLookup: SymbolLookup; 

		PROCEDURE ^  & Init; 
		PROCEDURE ^ AddSection(name: Basic.SegmentedName): Section; 
		PROCEDURE ^ BySymbol(symbol: SyntaxTree.Symbol): Section; 
		PROCEDURE ^ GetSection(i: LONGINT): Section; 
		PROCEDURE ^ Dump(w: Streams.Writer); 
	END SectionList; 
VAR 
	SysCallMap: ARRAY DefaultNofSysCalls OF CHAR; 

	PROCEDURE ^ FindPC(pc: LONGINT; module: Sections.Module; diagnostics: Diagnostics.Diagnostics): BOOLEAN; 
	PROCEDURE ^ MakeSectionOffsets(module: Sections.Module; VAR constSize, varSize, codeSize, caseTableSize: LONGINT; VAR const, code: ByteArray); 
	PROCEDURE ^ WriteObjectFile*(w: Streams.Writer; module: Sections.Module; symbolFile: Files.File); 
	PROCEDURE ^ Get*(): Formats.ObjectFileFormat; 
BEGIN
END FoxBinaryObjectFile.
