MODULE ArrayXdBytes;
	IMPORT SYSTEM, Array1dBytes, dbgOut := KernelLog, DataIO;
CONST 
	strongIndexChecking = TRUE; 
	debug = FALSE; 
TYPE 
	Index* = LONGINT; 

	IndexArray* = POINTER TO ARRAY OF Index; 

	Address* = LONGINT; 

	ArrayMemoryStructure* = OBJECT 
	VAR 
		baseadr: Index; 
		bytes-: Index; 
		dim-: Index; 
		len-: IndexArray; 
		diminc-: IndexArray; 
		elementsize: Index; 
		origin-: IndexArray; 
		adrwoffset: Index; 
	END ArrayMemoryStructure; 

	Enumerator* = OBJECT 
	VAR 
		dim: LONGINT; 
		mem: ArrayMemoryStructure; 
		adr-, size-: LONGINT; 
		lncdim: LONGINT; 
		pos-, origin, len: IndexArray; 

		PROCEDURE ^  & Init*(mem: ArrayMemoryStructure; enumorigin, enumlen: IndexArray; block: BOOLEAN); 
		PROCEDURE ^ Next*(): BOOLEAN; 
	END Enumerator; 

	Array* = OBJECT (ArrayMemoryStructure)
	VAR 
		protector: ANY; 
		permutation-: IndexArray; 
		bc-: SHORTINT; 
		f0, f1, f2, f3: Index; 
		o0-, o1-, o2-, o3-, l0-, l1-, l2-, l3-: Index; 

		PROCEDURE ^ dbgWriteInfo*; 
		PROCEDURE ^ GetInfo*(VAR elementsize: LONGINT); 
		PROCEDURE ^ SetBoundaryCondition*(c: SHORTINT); 
		PROCEDURE ^ Allocate*(size: LONGINT; VAR baseadr: LONGINT; VAR protector: ANY); 
		PROCEDURE ^ ValidateCache*; 
		PROCEDURE ^ Init(newdim: LONGINT); 
		PROCEDURE ^  & NewXdB*(neworigin, newlen: IndexArray); 
		PROCEDURE ^ AlikeX*(): Array; 
		PROCEDURE ^ CopyX*(): Array; 
		PROCEDURE ^ NewRangeX*(neworigin, newlen: IndexArray; preservedata: BOOLEAN); 
		PROCEDURE ^ OptimizeForAccess*(order: ARRAY OF Index; preservedata: BOOLEAN); 
		PROCEDURE ^ PermuteDimensions*(permutation: IndexArray; rearrangeMemory: BOOLEAN); 
		PROCEDURE ^ DeleteElements*(dimension, first, length: Index); 
		PROCEDURE ^ InsertElements*(dimension, first, length: Index); 
		PROCEDURE ^ ToggleElements*(dimension: Index; pos1, pos2: Index); 
		PROCEDURE ^ PermuteElements*(dimension: Index; permutation: ARRAY OF Index); 
		PROCEDURE ^ MirrorDimension*(dimension: Index); 
		PROCEDURE ^ BlockCopy*(dimension, from, to, length: Index); 
		PROCEDURE ^ BlockMove*(dimension, from, to, length: Index); 
		PROCEDURE ^ LoadXd*(VAR R: DataIO.Reader); 
		PROCEDURE ^ StoreXd*(VAR W: DataIO.Writer; storeRawData: BOOLEAN); 
	END Array; 

	Rectangle = OBJECT 
	VAR 
		origin, len, destpos, destlen: IndexArray; 
		next: Rectangle; 
	END Rectangle; 

	BoundaryEnum* = OBJECT 
	VAR 
		root: Rectangle; 

		PROCEDURE ^  & Init*(a: Array; origin, len: IndexArray); 
		PROCEDURE ^ Get*(VAR origin, len: IndexArray): BOOLEAN; 
	END BoundaryEnum; 

	PROCEDURE ^ StoreMemory(W: DataIO.Writer; baseadr: LONGINT; len: LONGINT); 
	PROCEDURE ^ ReadMemory(R: DataIO.Reader; baseadr: LONGINT; size: LONGINT; VAR len: LONGINT); 
	PROCEDURE ^ Min(l, r: LONGINT): LONGINT; 
	PROCEDURE ^ CheckIndexArray(dim: Index; VAR a: IndexArray); 
	PROCEDURE ^ CopyIndexArray(src: ARRAY OF Index; dest: IndexArray); 
	PROCEDURE ^ Intersect*(org1, len1, org2, len2: IndexArray; VAR org, len: IndexArray): BOOLEAN; 
	PROCEDURE  - CheckLEQ*(lesseq, than: LONGINT);
	CODE {SYSTEM.i386}
		MOV	ECX, [ESP]	;  than
		MOV	EBX, [ESP+4]	;  less
		CMP	EBX, ECX
		JLE	ok
		PUSH	7
		INT	3
		ok:
		ADD	ESP, 8
	
	END CheckLEQ; 
	PROCEDURE  - CheckLE*(lesseq, than: LONGINT);
	CODE {SYSTEM.i386}
		MOV	ECX, [ESP]	;  than
		MOV	EBX, [ESP+4]	;  less
		CMP	EBX, ECX
		JL	ok
		PUSH	7
		INT	3
		ok:
		ADD	ESP, 8
	
	END CheckLE; 
	PROCEDURE  - CheckEQ*(equals, this: LONGINT);
	CODE {SYSTEM.i386}
		MOV	ECX, [ESP]	;  this
		MOV	EBX, [ESP+4]	;  equals
		CMP	EBX, ECX
		JE	ok
		PUSH	7
		INT	3
		ok:
		ADD	ESP, 8
	
	END CheckEQ; 
	PROCEDURE ^ CheckPermutation(dim: LONGINT; VAR permutation: ARRAY OF LONGINT): BOOLEAN; 
	PROCEDURE ^ CompletePermutation(beginning: ARRAY OF LONGINT; full: ARRAY OF LONGINT): BOOLEAN; 
	PROCEDURE ^ ApplyPermutation(permutation: ARRAY OF Index; VAR array: ARRAY OF Index); 
	PROCEDURE ^ IdentityPermutation(dim: LONGINT): IndexArray; 
	PROCEDURE ^ ComputeIncrease(len: IndexArray; permutation: IndexArray; elementsize: LONGINT; diminc: IndexArray); 
	PROCEDURE ^ AMSCopyDescr(src: ArrayMemoryStructure; dest: ArrayMemoryStructure); 
	PROCEDURE ^ EnumArrayPart(mem: ArrayMemoryStructure; pos, len: IndexArray; chunks: BOOLEAN): Enumerator; 
	PROCEDURE ^ TraverseMemory*(proc: Address; mem: ArrayMemoryStructure); 
	PROCEDURE ^ TraverseMemory2*(proc: Address; srcmem, destmem: ArrayMemoryStructure); 
	PROCEDURE ^ TraverseMemory3*(proc: Address; leftmem, rightmem, destmem: ArrayMemoryStructure); 
	PROCEDURE ^ TraverseAndCopy(src, dest: Enumerator); 
	PROCEDURE ^ CopyDataByCoordinateTraversal*(srcmem, destmem: ArrayMemoryStructure); 
	PROCEDURE ^ CopyDataRaw*(srcmem, destmem: ArrayMemoryStructure); 
	PROCEDURE ^ CopyDataPositionPreserving*(srcmem, destmem: ArrayMemoryStructure); 
	PROCEDURE ^ MakeMemoryStructure*(dim: LONGINT; origin, len: IndexArray; elementsize: Index; baseadr: Address): ArrayMemoryStructure; 
	PROCEDURE ^ MakeContinuousMemStruct*(adr, elements, elementsize: LONGINT; VAR memory: ArrayMemoryStructure); 
	PROCEDURE ^ CheckEqDimensions*(l, r: Array); 
	PROCEDURE ^ ToggleDimensions*(a: Array; d1, d2: LONGINT; rearrangeMemory: BOOLEAN); 
	PROCEDURE ^ dbgS(s: ARRAY OF CHAR); 
	PROCEDURE ^ dbgSI(s: ARRAY OF CHAR; i: LONGINT); 
	PROCEDURE ^ dbgSISI(s: ARRAY OF CHAR; i: LONGINT; s2: ARRAY OF CHAR; i2: LONGINT); 
	PROCEDURE ^ dbgSISISI(s: ARRAY OF CHAR; i: LONGINT; s2: ARRAY OF CHAR; i2: LONGINT; s3: ARRAY OF CHAR; i3: LONGINT); 
	PROCEDURE ^ dbgWriteMemoryInfo*(a: ArrayMemoryStructure); 
	PROCEDURE ^ Adr1*(a: Array; x: Index): Index; 
	PROCEDURE ^ Adr2*(a: Array; x, y: Index): Index; 
	PROCEDURE ^ Adr3*(a: Array; x, y, z: Index): Index; 
	PROCEDURE ^ Adr4*(a: Array; x, y, z, t: Index): Index; 
	PROCEDURE ^ AdrX*(a: ArrayMemoryStructure; VAR b: ARRAY OF Index; dim: Index): Index; 
	PROCEDURE ^ Index1*(x: LONGINT): IndexArray; 
	PROCEDURE ^ Array1*(x: LONGINT): IndexArray; 
	PROCEDURE ^ Index2*(x, y: LONGINT): IndexArray; 
	PROCEDURE ^ Array2*(x, y: LONGINT): IndexArray; 
	PROCEDURE ^ Array3*(x, y, z: LONGINT): IndexArray; 
	PROCEDURE ^ Index3*(x, y, z: LONGINT): IndexArray; 
	PROCEDURE ^ Index4*(x, y, z, t: LONGINT): IndexArray; 
	PROCEDURE ^ Array4*(x, y, z, t: LONGINT): IndexArray; 
	PROCEDURE ^ IndexX*(VAR a: ARRAY OF LONGINT): IndexArray; 
	PROCEDURE ^ IndexCpy*(src: IndexArray): IndexArray; 
	PROCEDURE ^ Get1*(a: Array; x: Index; VAR v: ARRAY OF SYSTEM.BYTE); 
	PROCEDURE ^ Get2*(a: Array; x, y: Index; VAR v: ARRAY OF SYSTEM.BYTE); 
	PROCEDURE ^ Get3*(a: Array; x, y, z: Index; VAR v: ARRAY OF SYSTEM.BYTE); 
	PROCEDURE ^ Get4*(a: Array; x, y, z, t: Index; VAR v: ARRAY OF SYSTEM.BYTE); 
	PROCEDURE ^ GetX*(a: Array; VAR b: ARRAY OF Index; dim: Index; VAR v: ARRAY OF SYSTEM.BYTE); 
	PROCEDURE ^ Set1*(a: Array; x: Index; VAR v: ARRAY OF SYSTEM.BYTE); 
	PROCEDURE ^ Set2*(a: Array; x, y: Index; VAR v: ARRAY OF SYSTEM.BYTE); 
	PROCEDURE ^ Set3*(a: Array; x, y, z: Index; VAR v: ARRAY OF SYSTEM.BYTE); 
	PROCEDURE ^ Set4*(a: Array; x, y, z, t: Index; VAR v: ARRAY OF SYSTEM.BYTE); 
	PROCEDURE ^ SetX*(a: Array; VAR b: ARRAY OF Index; dim: Index; VAR v: ARRAY OF SYSTEM.BYTE); 
	PROCEDURE ^ CopyArrayPartToArrayPart*(srcmem, destmem: ArrayMemoryStructure; srcpos, srclen, destpos, destlen: IndexArray); 
	PROCEDURE ^ FillArrayPart*(mem: ArrayMemoryStructure; pos, len: IndexArray; val: ARRAY OF SYSTEM.BYTE); 
	PROCEDURE ^ CopyArrayToMemory*(srcmem: ArrayMemoryStructure; destadr: Index; nrelems: Index); 
	PROCEDURE ^ CopyMemoryToArray*(srcadr: Index; destmem: ArrayMemoryStructure; nrelems: Index); 
	PROCEDURE ^ CopyArrayPartToMemory*(srcmem: ArrayMemoryStructure; destadr: Index; srcpos, srclen: IndexArray; destlen: Index); 
	PROCEDURE ^ CopyMemoryToArrayPart*(srcadr: Index; destmem: ArrayMemoryStructure; srclen: Index; destpos, destlen: IndexArray); 
	PROCEDURE  - InBounds*(origin, len: Index; idx: Index): BOOLEAN;
	CODE {SYSTEM.i386}
		; if (idx < origin) or (idx-origin >= len) then return false end;
		; return true;
		; AL=1 : TRUE; AL=0: FALSE
		MOV	EAX, [ESP]	;  EAX := idx
		MOV	EBX, [ESP+4]	;  EBX := len
		MOV	ECX, [ESP+8]	;  ECX := origin
		CMP	EAX, ECX	;
		JL	outbound	;  idx < origin: outbound
		SUB	EAX, ECX
		CMP	EAX, EBX
		JGE	outbound	;  (idx-origin) >= len
		MOV	AL, 1
		JMP	done	;
		outbound:
		MOV	AL, 0
		done:
		ADD	ESP, 12
	
	END InBounds; 
	PROCEDURE  - PeriodicBounds*(origin, len: Index; idx: Index): Index;
	CODE {SYSTEM.i386}
		; DEC( idx, origin );  idx := idx MOD len;  INC( idx, origin );

		; modulus:
		; a := b MOD c; 	c -> EBX	; b -> EAX

		; CDQ
		; IDIV EBX
		; CMP     EDX,0
		; JNL     2
		; ADD     EDX,EBX

		; EDX -> a

		MOV	EAX, [ESP]	;  EAX := idx
		SUB	EAX, [ESP+8]	;  EAX := EAX-origin
		MOV	EBX, [ESP+4]	;  EBX := len
		CDQ
		IDIV	EBX
		CMP	EDX, 0
		JNL	2
		ADD	EDX, EBX
		MOV	EAX, EDX
		ADD	EAX, [ESP+8]
		ADD	ESP, 12
	
	END PeriodicBounds; 
	PROCEDURE ^ MirrorOnB*(origin, len: Index; idx: Index): Index; 
	PROCEDURE ^ MirrorOffB*(origin, len: Index; idx: Index): Index; 
	PROCEDURE ^ TestB*; 
BEGIN
END ArrayXdBytes.
