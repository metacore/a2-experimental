MODULE Modules;
	IMPORT SYSTEM, Trace, Machine, Heaps, Runtime;
CONST 
	Ok* = 0; 
	AddressSize = SIZEOF(ADDRESS); 
	MaxTags* = 16; 
	Tag0Ofs* =  -(AddressSize * 2); 
	Mth0Ofs* = (Tag0Ofs - (AddressSize * MaxTags)); 
	Ptr0Ofs* = AddressSize; 
	MaxObjFormats = 5; 
	ProtTypeBit* = Heaps.ProtTypeBit; 
	None* = 0; 
	PowerDown* = 1; 
	Reboot* = 2; 
	ClearCode = TRUE; 
	InitTableLen = 1024; 
	InitPtrTableLen = 2048; 
	DefaultContext* = \"A2"\; 
	NoLoader = 3400; 
	TraceBoot = TRUE; 
	ModuleInitTimeout = HUGEINT(0B2D05E00H); 
TYPE 
	Name* = ARRAY 32 OF CHAR; 

	DynamicName* = POINTER {UNSAFE} TO ARRAY 256 OF CHAR; 

	Command* = RECORD 
		name*: Name; 
		argTdAdr*, retTdAdr*: ADDRESS; 
		entryAdr*: ADDRESS; 
	END; 

	ExportDesc* = RECORD 
		fp*: LONGINT; 
		name*{UNTRACED} : DynamicName; 
		adr*: ADDRESS; 
		exports*: LONGINT; 
		dsc*{UNTRACED} : ExportArray; 
	END; 

	ExportArray* = POINTER {UNSAFE} TO ARRAY OF ExportDesc; 

	Bytes* = POINTER TO ARRAY OF CHAR; 

	TerminationHandler* = PROCEDURE ; 

	EntryType* = RECORD 
		class*: CHAR; 
		subclass*: CHAR; 
		size*: INTEGER; 
		type*: ADDRESS; 
	END; 

	FieldEntry* = RECORD 
		name*: DynamicName; 
		offset*: SIZE; 
		type*: EntryType; 
		flags*: SET; 
	END; 

	FieldEntries* = POINTER TO ARRAY OF FieldEntry; 

	ProcedureEntries* = POINTER TO ARRAY OF ProcedureEntry; 

	ProcedureEntry* = RECORD 
		name*: DynamicName; 
		address*: ADDRESS; 
		size*: SIZE; 
		parameters*{UNTRACED} : FieldEntries; 
		variables*{UNTRACED} : FieldEntries; 
		procedures*{UNTRACED} : ProcedureEntries; 
		returnType*: EntryType; 
		flags*: SET; 
	END; 

	TypeDesc* = POINTER TO RECORD 
		descSize: LONGINT; 
		sentinel: LONGINT; 
		tag*: ADDRESS; 
		flags*: SET; 
		mod*{UNTRACED} : Module; 
		name*: Name; 
		fields*{UNTRACED} : FieldEntries; 
		procedures*{UNTRACED} : ProcedureEntries; 
	END; 

	ExceptionTableEntry* = RECORD 
		pcFrom*: ADDRESS; 
		pcTo*: ADDRESS; 
		pcHandler*: ADDRESS; 
	END; 

	ExceptionTable* = POINTER TO ARRAY OF ExceptionTableEntry; 

	ProcTableEntry* = RECORD 
		pcFrom*, pcLimit*, pcStatementBegin*, pcStatementEnd*: ADDRESS; 
		noPtr*: LONGINT; 
	END; 

	ProcTable* = POINTER TO ARRAY OF ProcTableEntry; 

	PtrTable* = POINTER TO ARRAY OF ADDRESS; 

	ProcOffsetEntry* = RECORD 
		data*: ProcTableEntry; 
		startIndex*: LONGINT; 
	END; 

	ProcOffsetTable* = POINTER TO ARRAY OF ProcOffsetEntry; 

	InternalPtr = RECORD 
		p: ANY; 
	END; 

	Module* = OBJECT {EXCLUSIVE} (Heaps.RootObject)
	VAR 
		next*: Module; 
		name*: Name; 
		init, published: BOOLEAN; 
		refcnt*: LONGINT; 
		sb*: ADDRESS; 
		entry*: POINTER TO ARRAY OF ADDRESS; 
		command*: POINTER TO ARRAY OF Command; 
		ptrAdr*: POINTER TO ARRAY OF ADDRESS; 
		typeInfo*: POINTER TO ARRAY OF TypeDesc; 
		module*: POINTER TO ARRAY OF Module; 
		procTable*: ProcTable; 
		ptrTable*: PtrTable; 
		data*, code*, staticTypeDescs*, refs*: Bytes; 
		export*: ExportDesc; 
		term*: TerminationHandler; 
		exTable*: ExceptionTable; 
		noProcs*: LONGINT; 
		firstProc*: ADDRESS; 
		maxPtrs*: LONGINT; 
		internal: POINTER TO ARRAY OF InternalPtr; 
		crc*: LONGINT; 
		body*: PROCEDURE ; 

		PROCEDURE ^ FindRoots*; 
	END Module; 

	LoaderProc* = PROCEDURE (CONST name, fileName: ARRAY OF CHAR; VAR res: LONGINT; VAR msg: ARRAY OF CHAR):Module; 

	; 
VAR 
	extension-: ARRAY MaxObjFormats OF ARRAY 8 OF CHAR; 
	loader: ARRAY MaxObjFormats OF LoaderProc; 
	numLoaders: LONGINT; 
	kernelProc*: ARRAY 11 OF ADDRESS; 
	freeRoot*: Module; 
	root-: Module; 
	initBlock: ANY; 
	procOffsets-: ProcOffsetTable; 
	numProcs: LONGINT; 
	ptrOffsets-: PtrTable; 
	numPtrs: LONGINT; 
	shutdown*: LONGINT; 
	trace: BOOLEAN; 
	register: RECORD 
		first, last: Module; 
	END; 
	callagain: BOOLEAN; 

	PROCEDURE ^ AddLoader*(CONST ext: ARRAY OF CHAR; proc: LoaderProc); 
	PROCEDURE ^ RemoveLoader*(CONST ext: ARRAY OF CHAR; proc: LoaderProc); 
	PROCEDURE ^ Append*(CONST from: ARRAY OF CHAR; VAR to: ARRAY OF CHAR); 
	PROCEDURE ^ Publish*(VAR m: Module; VAR new: BOOLEAN); 
	PROCEDURE ^ Initialize*(VAR module: Module); 
	PROCEDURE ^ Initialize0*(module: Module); 
	PROCEDURE ^ ModuleByName*(CONST name: ARRAY OF CHAR): Module; 
	PROCEDURE ^ GetFileName(CONST name, extension: ARRAY OF CHAR; VAR fileName: ARRAY OF CHAR); 
	PROCEDURE ^ SortProcTable(m: Module); 
	PROCEDURE ^ SelectionSort(exTable: ExceptionTable); 
	PROCEDURE ^ ThisModule*(CONST name: ARRAY OF CHAR; VAR res: LONGINT; VAR msg: ARRAY OF CHAR): Module; 
	PROCEDURE ^ ThisModuleByAdr0*(pc: ADDRESS): Module; 
	PROCEDURE ^ ThisModuleByAdr*(pc: ADDRESS): Module; 
	PROCEDURE ^ GetProcedure*(CONST moduleName, procedureName: ARRAY OF CHAR; argTdAdr, retTdAdr: ADDRESS; VAR entryAdr: ADDRESS); 
	PROCEDURE ^ ThisType*(m: Module; CONST name: ARRAY OF CHAR): TypeDesc; 
	PROCEDURE ^ ThisTypeByAdr*(adr: ADDRESS; VAR m: Module; VAR t: TypeDesc); 
	PROCEDURE ^ NewObj*(t: TypeDesc; isRealtime: BOOLEAN): ANY; 
	PROCEDURE ^ TypeOf*(obj: ANY): TypeDesc; 
	PROCEDURE ^ FindPos(key: ADDRESS; VAR pos: LONGINT): BOOLEAN; 
	PROCEDURE ^ FindProc*(pc: ADDRESS; VAR data: ProcTableEntry; VAR index: LONGINT; VAR success: BOOLEAN); 
	PROCEDURE ^ FindInsertionPos(VAR entry: ProcTableEntry; VAR pos: LONGINT): BOOLEAN; 
	PROCEDURE ^ NumTotalPtrs(procTable: ProcTable): LONGINT; 
	PROCEDURE ^ InsertProcOffsets(procTable: ProcTable; ptrTable: PtrTable; maxPtr: LONGINT); 
	PROCEDURE ^ DeleteProcOffsets(firstProcPC: ADDRESS; noProcsInMod: LONGINT); 
	PROCEDURE ^ InstallTermHandler*(h: TerminationHandler); 
	PROCEDURE ^ FreeModule*(CONST name: ARRAY OF CHAR; VAR res: LONGINT; VAR msg: ARRAY OF CHAR); 
	PROCEDURE ^ Shutdown*(code: LONGINT); 
	PROCEDURE ^ IsExceptionHandled*(VAR pc, fp: ADDRESS; deep: BOOLEAN): BOOLEAN; 
	PROCEDURE ^ GetExceptionHandler*(pc: ADDRESS): ADDRESS; 
	PROCEDURE ^ Initialized*(m: Module): BOOLEAN; 
	PROCEDURE ^ GetKernelProc*(num: LONGINT): ADDRESS; 
	PROCEDURE ^ Register-(module{UNTRACED} : Module); 
	PROCEDURE ^ PublishRegisteredModules; 
	PROCEDURE ^ Main; 
	PROCEDURE ^ Init; 
BEGIN
END Modules.
