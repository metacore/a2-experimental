MODULE CryptoAES;
	IMPORT S := SYSTEM, Ciphers := CryptoCiphers, U := CryptoUtils;
CONST 
	MaxR = 14; 
	ECB = Ciphers.ECB; 
	CBC = Ciphers.CBC; 
	CTR = Ciphers.CTR; 
	b0 = S.VAL(SET, 255); 
	b1 = S.VAL(SET, 65280); 
	b2 = S.VAL(SET, 16711680); 
	b3 = S.VAL(SET, 0FF000000H); 
TYPE 
	RTable = ARRAY 256 OF SET; 

	Ind4 = RECORD 
		a, b, c, d: LONGINT; 
	END; 

	RKeys = ARRAY (4 * (MaxR + 1)) OF SET; 

	Block = ARRAY 4 OF SET; 

	Cipher* = OBJECT (Ciphers.Cipher)
	VAR 
		rounds: SHORTINT; 
		erkeys, drkeys: RKeys; 
		iv: Block; 

		PROCEDURE ^ InitKey*(CONST src: ARRAY OF CHAR; keybits: LONGINT); 
		PROCEDURE ^ SetIV*(CONST src: ARRAY OF CHAR; mode: SHORTINT); 
		PROCEDURE ^ IncIV; 
		PROCEDURE ^ Encrypt*(VAR buf: ARRAY OF CHAR; ofs, len: LONGINT); 
		PROCEDURE ^ Decrypt*(VAR buf: ARRAY OF CHAR; ofs, len: LONGINT); 
		PROCEDURE ^  & Init*; 
	END Cipher; 
VAR 
	e0, e1, e2, e3, e4, d0, d1, d2, d3, d4: RTable; 
	rcon: ARRAY 10 OF SET; 

	PROCEDURE ^ NewCipher*(): Ciphers.Cipher; 
	PROCEDURE ^ Initialize; 
	PROCEDURE ^ ind(s: SET): LONGINT; 
	PROCEDURE ^ split(s: SET; VAR b: Ind4); 
	PROCEDURE ^ Init128(VAR rk: RKeys; CONST src: ARRAY OF CHAR): SHORTINT; 
	PROCEDURE ^ Init192(VAR rk: RKeys; CONST src: ARRAY OF CHAR): SHORTINT; 
	PROCEDURE ^ Init256(VAR rk: RKeys; CONST src: ARRAY OF CHAR): SHORTINT; 
	PROCEDURE ^ Invert(VAR rk: RKeys; rounds: SHORTINT); 
	PROCEDURE ^ RoundE(CONST rk: RKeys; VAR b: Block; rounds: SHORTINT); 
	PROCEDURE ^ RoundD(CONST rk: RKeys; VAR b: Block; rounds: SHORTINT); 
BEGIN
END CryptoAES.
