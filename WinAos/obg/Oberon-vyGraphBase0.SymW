MODULE vyGraphBase0 IN Oberon;
	IMPORT Display, Pictures, Display3, Fonts, Printer, Printer3, Files, Images, Objects, vyPortability;
CONST 
	BrushSize = 100; 
	cDisplayBuffer* = 0; 
	cImageBuffer* = 1; 
	display = 0; 
	print = 1; 
	StdFnt = \"Syntax10.Scn.Fnt"\; 
	paint = Display.paint; 
TYPE 
	tPatPrinter* = PROCEDURE (x, y: INTEGER); 

	tSign* = POINTER TO tSignDesc; 

	tSignDesc = RECORD 
		pat: Display.Pattern; 
		print: tPatPrinter; 
		w-, h-: INTEGER; 
		wDIV2-, hDIV2-: INTEGER; 
	END; 

	doubleBuffer* = POINTER TO doubleBufferDesc; 

	doubleBufferDesc* = RECORD 
		new-: BOOLEAN; 
		displayBuffer: vyPortability.displayBuffer; 
		imageBuffer: Images.Image; 
		mask: Display3.Mask; 
		x, y, w, h: INTEGER; 
		active-: BOOLEAN; 
		type-: INTEGER; 
	END; 

	Brush = RECORD 
		brul, brur: ARRAY BrushSize OF INTEGER; 
		bufl, bufr: ARRAY BrushSize OF INTEGER; 
		bufh, brushr: INTEGER; 
		x, y: INTEGER; 
	END; 

	; 
VAR 
	du, pu, hpu: LONGINT; 
	clipMask*: Display3.Mask; 
	db-: doubleBuffer; 
	xPrnOrg, yPrnOrg, xPortOrg, yPortOrg: INTEGER; 
	status: INTEGER; 
	contextfcol-, contextbcol-: Display.Color; 
	contextmode: INTEGER; 
	contextstyle: SET; 
	contextpattern: LONGINT; 
	contextpensize: INTEGER; 
	contextfnt: ARRAY 64 OF CHAR; 
	tmpr, tmpg, tmpb: INTEGER; 
	Enum: RECORD 
		img: Images.Image; 
		x, y: INTEGER; 
	END; 
	contextimg: Images.Image; 
	contextfpix-, contextbpix-: Images.Pixel; 
	drawingPolygon: BOOLEAN; 
	brush: Brush; 
	stringpict: Pictures.Picture; 
	contextpatternternimage: Images.Image; 
	contextalpha: INTEGER; 
	PrntPat: ARRAY 9 OF Display.Pattern; 
	tmpPatPic: Pictures.Picture; 
	copyPattern*: PROCEDURE (sgn: tSign; x, y: INTEGER); 
	dot*: PROCEDURE (x, y: INTEGER); 
	replConst*: PROCEDURE (x, y, w, h: INTEGER); 
	replString*: PROCEDURE (X, Y: INTEGER; fnt, str: ARRAY OF CHAR); 
	replPict*: PROCEDURE (picture: Pictures.Picture; px, py, x, y, w, h: INTEGER); 
	pict*: PROCEDURE (picture: Pictures.Picture; x, y, w, h, dx, dy: INTEGER); 
	stretchedpict*: PROCEDURE (picture: Pictures.Picture; x, y, w, h, dx, dy, dw, dh: INTEGER); 
	image*: PROCEDURE (VAR image: Images.Image; x, y, w, h, dx, dy: INTEGER); 
	stretchedimage*: PROCEDURE (VAR image: Images.Image; x, y, w, h, dx, dy, dw, dh: INTEGER); 
	line*: PROCEDURE (x0, y0, x1, y1: INTEGER); 
	circle*: PROCEDURE (x, y, r: INTEGER); 
	ellipse*: PROCEDURE (x, y, a, b: INTEGER); 
	rect*: PROCEDURE (x, y, w, h: INTEGER); 
	rect3d*: PROCEDURE (x, y, a, b: INTEGER); 
	paintrect*: PROCEDURE (x, y, w, h: INTEGER); 
	poly*: PROCEDURE (VAR x, y: ARRAY OF INTEGER; n: INTEGER); 

	PROCEDURE ^ SetBackColor*(col: Display.Color); 
	PROCEDURE ^ SetForeColor*(col: Display.Color); 
	PROCEDURE ^ SetFColRGBA*(r, g, b, a: INTEGER); 
	PROCEDURE ^ SetBColRGBA*(r, g, b, a: INTEGER); 
	PROCEDURE ^ SetPenSize*(size: INTEGER); 
	PROCEDURE ^ SetDisplayMode*(m: INTEGER); 
	PROCEDURE ^ SetDisplayStyle*(s: SET); 
	PROCEDURE ^ SetDisplayPattern*(p: LONGINT); 
	PROCEDURE ^ SetFont*(f: ARRAY OF CHAR); 
	PROCEDURE ^ SetAlpha*(a: INTEGER); 
	PROCEDURE ^ Min(x, y: INTEGER): INTEGER; 
	PROCEDURE ^ Max(x, y: INTEGER): INTEGER; 
	PROCEDURE ^ StandardizeRect(VAR x, y, w, h: INTEGER); 
	PROCEDURE ^ RectInRect(x, y, w, h, X, Y, W, H: INTEGER): BOOLEAN; 
	PROCEDURE ^ RectIntersection(VAR x, y, w, h: INTEGER; X, Y, W, H: INTEGER); 
	PROCEDURE ^ PlacedRectIntersect(VAR x, y, w, h, dx, dy: INTEGER; X, Y, W, H: INTEGER); 
	PROCEDURE ^ EmptyIntersection(x, y, w, h, X, Y, W, H: INTEGER): BOOLEAN; 
	PROCEDURE ^ CopyPatternC(sgn: tSign; x, y: INTEGER); 
	PROCEDURE ^ DotC(x, y: INTEGER); 
	PROCEDURE ^ ReplConstC(x, y, w, h: INTEGER); 
	PROCEDURE ^ ReplStringC(X, Y: INTEGER; fnt, str: ARRAY OF CHAR); 
	PROCEDURE ^ LineC(x0, y0, x1, y1: INTEGER); 
	PROCEDURE ^ CircleC(x, y, r: INTEGER); 
	PROCEDURE ^ EllipseC(x, y, a, b: INTEGER); 
	PROCEDURE ^ RectC(x, y, w, h: INTEGER); 
	PROCEDURE ^ Rect3DC(x, y, w, h: INTEGER); 
	PROCEDURE ^ PaintRectC(x, y, w, h: INTEGER); 
	PROCEDURE ^ PolyC(VAR x, y: ARRAY OF INTEGER; n: INTEGER); 
	PROCEDURE ^ ReplPictC(picture: Pictures.Picture; px, py, x, y, w, h: INTEGER); 
	PROCEDURE ^ PictC(picture: Pictures.Picture; x, y, w, h, dx, dy: INTEGER); 
	PROCEDURE ^ StretchedPictC(picture: Pictures.Picture; x, y, w, h, dx, dy, dw, dh: INTEGER); 
	PROCEDURE ^ RestoreRuns(x, y, w, h: INTEGER); 
	PROCEDURE ^ RestoreLines(x, y, w, h: INTEGER); 
	PROCEDURE ^ RestoreBlock(x, y, w, h: INTEGER); 
	PROCEDURE ^ ImageC(VAR img: Images.Image; x, y, w, h, dx, dy: INTEGER); 
	PROCEDURE ^ StretchedImageC(VAR sP: Images.Image; X, Y, W, H, DX, DY, DW, DH: INTEGER); 
	PROCEDURE ^ ImageToPict(img: Images.Image; pict: Pictures.Picture); 
	PROCEDURE ^ ImageP(VAR img: Images.Image; x, y, w, h, dx, dy: INTEGER); 
	PROCEDURE ^ StretchedImageP(VAR img: Images.Image; x, y, w, h, dx, dy, dw, dh: INTEGER); 
	PROCEDURE ^ Doti(x, y: INTEGER); 
	PROCEDURE ^ ReplConsti(x, y, w, h: INTEGER); 
	PROCEDURE ^ DirectReplConsti(x, y, w, h: INTEGER); 
	PROCEDURE ^ PatternToImage(pat: Display.Pattern; patimg: Images.Image); 
	PROCEDURE ^ FillPatterni(pX, pY, X, Y, W, H: INTEGER); 
	PROCEDURE ^ CopyPatterni(sgn: tSign; X, Y: INTEGER); 
	PROCEDURE ^ Recti(X, Y, W, H: INTEGER); 
	PROCEDURE ^ Rect3Di(X, Y, W, H: INTEGER); 
	PROCEDURE ^ BrushJump(VAR b: Brush; x, y: INTEGER); 
	PROCEDURE ^ BrushWalk(VAR b: Brush; x, y: INTEGER); 
	PROCEDURE ^ BrushFlush(VAR b: Brush); 
	PROCEDURE ^ InitBrush(VAR b: Brush; w: INTEGER); 
	PROCEDURE ^ Linei(X, Y, X1, Y1: INTEGER); 
	PROCEDURE ^ FilledPolyi(VAR X, Y: ARRAY OF INTEGER; n: INTEGER); 
	PROCEDURE ^ Polyi(VAR X, Y: ARRAY OF INTEGER; n: INTEGER); 
	PROCEDURE ^ Ellipsei(X, Y, a, b: INTEGER); 
	PROCEDURE ^ Circlei(X, Y, r: INTEGER); 
	PROCEDURE ^ PaintRecti(x, y, w, h: INTEGER); 
	PROCEDURE ^ Picti(sP: Pictures.Picture; X, Y, W, H, DX, DY: INTEGER); 
	PROCEDURE ^ Stringi(x, y: INTEGER; fnt: Fonts.Font; s: ARRAY OF CHAR); 
	PROCEDURE ^ ReplStringi(X, Y: INTEGER; fnt, str: ARRAY OF CHAR); 
	PROCEDURE ^ StretchedPicti(sP: Pictures.Picture; X, Y, W, H, DX, DY, DW, DH: INTEGER); 
	PROCEDURE ^ Imagei(VAR img: Images.Image; x, y, w, h, dx, dy: INTEGER); 
	PROCEDURE ^ IGetRun(P: Images.Image; VAR pix: Images.Pixel; VAR x: INTEGER; y: INTEGER); 
	PROCEDURE ^ StretchedImagei(VAR sP: Images.Image; X, Y, W, H, DX, DY, DW, DH: INTEGER); 
	PROCEDURE ^ PointToPrnPoint(VAR x, y: INTEGER); 
	PROCEDURE ^ SizeToPrnSize(VAR w, h: INTEGER); 
	PROCEDURE ^ CopyPatternPrn(sgn: tSign; x, y: INTEGER); 
	PROCEDURE ^ DotPrn(x, y: INTEGER); 
	PROCEDURE ^ ReplConstPrn(x, y, w, h: INTEGER); 
	PROCEDURE ^ ReplStringPrn(X, Y: INTEGER; fnt, str: ARRAY OF CHAR); 
	PROCEDURE ^ LinePrn(x0, y0, x1, y1: INTEGER); 
	PROCEDURE ^ CirclePrn(x, y, r: INTEGER); 
	PROCEDURE ^ EllipsePrn(x, y, a, b: INTEGER); 
	PROCEDURE ^ RectPrn(x, y, w, h: INTEGER); 
	PROCEDURE ^ Rect3DPrn(x, y, w, h: INTEGER); 
	PROCEDURE ^ PaintRectPrn(x, y, w, h: INTEGER); 
	PROCEDURE ^ PolyPrn(VAR x, y: ARRAY OF INTEGER; n: INTEGER); 
	PROCEDURE ^ ReplPictPrn(picture: Pictures.Picture; px, py, x, y, w, h: INTEGER); 
	PROCEDURE ^ pictPrn(picture: Pictures.Picture; x, y, w, h, dx, dy: INTEGER); 
	PROCEDURE ^ stretchedpictPrn(picture: Pictures.Picture; x, y, w, h, dx, dy, dw, dh: INTEGER); 
	PROCEDURE ^ StdSignPrinter(x, y: INTEGER); 
	PROCEDURE ^ StorePattern*(VAR R: Files.Rider; sgn: tSign); 
	PROCEDURE ^ LoadPattern*(VAR R: Files.Rider): tSign; 
	PROCEDURE ^ NewPattern*(image: ARRAY OF SET; w, h: INTEGER; prn: tPatPrinter): tSign; 
	PROCEDURE ^ SetDisplayPrimitives*; 
	PROCEDURE ^ SetPrinterPrimitives*; 
	PROCEDURE ^ SetImagePrimitives*; 
	PROCEDURE ^ OpenPrinter*(x, y, px, py: INTEGER); 
	PROCEDURE ^ ClosePrinter*; 
	PROCEDURE ^ OpenBuffer*(VAR b: doubleBuffer; x, y, w, h: INTEGER; translucent: BOOLEAN); 
	PROCEDURE ^ UseAsBufferBG*(db: doubleBuffer; img: Images.Image); 
	PROCEDURE ^ WriteBuffer*(b: doubleBuffer); 
	PROCEDURE ^ CloseBuffer*(b: doubleBuffer; VAR x, y: INTEGER); 
BEGIN
END vyGraphBase0.
