MODULE FoxSemanticChecker;
	IMPORT D := Debugging, Basic := FoxBasic, Scanner := FoxScanner, SyntaxTree := FoxSyntaxTree, Diagnostics, Global := FoxGlobal, Printout := FoxPrintout, Formats := FoxFormats, SYSTEM, Strings;
CONST 
	Trace = FALSE; 
	Infinity = MAX(LONGINT); 
	MaxTensorIndexOperatorSize = 4; 
	UndefinedPhase = 0; 
	DeclarationPhase = 1; 
	InlinePhase = 2; 
	ImplementationPhase = 3; 
TYPE 
	Position = SyntaxTree.Position; 

	FileName = ARRAY 256 OF CHAR; 

	LateFix = POINTER TO RECORD 
		p: ANY; 
		scope: SyntaxTree.Scope; 
		next: LateFix; 
	END; 

	LateFixList = OBJECT 
	VAR 
		first, last: LateFix; 

		PROCEDURE ^  & Init; 
		PROCEDURE ^ Get(VAR scope: SyntaxTree.Scope): ANY; 
		PROCEDURE ^ Add(p: ANY; scope: SyntaxTree.Scope); 
	END LateFixList; 

	WithEntry = POINTER TO RECORD 
		previous: WithEntry; 
		symbol: SyntaxTree.Symbol; 
		type: SyntaxTree.Type; 
	END; 

	Replacement* = POINTER TO RECORD 
		name*: Basic.SegmentedName; 
		expression*: SyntaxTree.Expression; 
		used*: BOOLEAN; 
		next*: Replacement; 
	END; 

	Checker* = OBJECT (SyntaxTree.Visitor)
	VAR 
		module: SyntaxTree.Module; 
		diagnostics: Diagnostics.Diagnostics; 
		useDarwinCCalls: BOOLEAN; 
		cooperative: BOOLEAN; 
		error-: BOOLEAN; 
		VerboseErrorMessage: BOOLEAN; 
		typeFixes, pointerFixes: LateFixList; 
		importCache-: SyntaxTree.ModuleScope; 
		arrayBaseImported: BOOLEAN; 
		phase: LONGINT; 
		system-: Global.System; 
		symbolFileFormat-: Formats.SymbolFileFormat; 
		backendName-: ARRAY 32 OF CHAR; 
		resolvedType: SyntaxTree.Type; 
		resolvedExpression: SyntaxTree.Expression; 
		resolvedStatement: SyntaxTree.Statement; 
		currentScope-: SyntaxTree.Scope; 
		currentIsRealtime: BOOLEAN; 
		currentIsUnreachable: BOOLEAN; 
		currentIsCellNet: BOOLEAN; 
		currentIsBodyProcedure: BOOLEAN; 
		currentIsExclusive: BOOLEAN; 
		global: SyntaxTree.ModuleScope; 
		withEntries: WithEntry; 
		activeCellsStatement: BOOLEAN; 
		replacements*: Replacement; 
		cellsAreObjects: BOOLEAN; 
		variableAccessed: BOOLEAN; 

		PROCEDURE ^  & InitChecker*(diagnostics: Diagnostics.Diagnostics; verboseErrorMessage, useDarwinCCalls, cooperative: BOOLEAN; system: Global.System; symbolFileFormat: Formats.SymbolFileFormat; VAR importCache: SyntaxTree.ModuleScope; CONST backend: ARRAY OF CHAR); 
		PROCEDURE ^ Error(position: Position; CONST message: ARRAY OF CHAR); 
		PROCEDURE ^ Warning(position: Position; CONST message: ARRAY OF CHAR); 
		PROCEDURE ^ ErrorSS(position: Position; CONST msg, msg2: ARRAY OF CHAR); 
		PROCEDURE ^ InfoSS(position: Position; CONST msg1: ARRAY OF CHAR; CONST s: Basic.String); 
		PROCEDURE ^ Find(inScope: SyntaxTree.Scope; name: SyntaxTree.Identifier; traverse: BOOLEAN): SyntaxTree.Symbol; 
		PROCEDURE ^ ResolveNamedType(qualifiedIdentifier: SyntaxTree.QualifiedIdentifier; VAR typeDeclaration: SyntaxTree.TypeDeclaration): SyntaxTree.Type; 
		PROCEDURE ^ TypeNeedsResolution(x: SyntaxTree.Type): BOOLEAN; 
		PROCEDURE ^ ResolvedType(x: SyntaxTree.Type): SyntaxTree.Type; 
		PROCEDURE ^ VisitType*(x: SyntaxTree.Type); 
		PROCEDURE ^ VisitBasicType*(x: SyntaxTree.BasicType); 
		PROCEDURE ^ VisitByteType*(x: SyntaxTree.ByteType); 
		PROCEDURE ^ VisitCharacterType*(x: SyntaxTree.CharacterType); 
		PROCEDURE ^ VisitBooleanType*(x: SyntaxTree.BooleanType); 
		PROCEDURE ^ VisitSetType*(x: SyntaxTree.SetType); 
		PROCEDURE ^ VisitAddressType*(x: SyntaxTree.AddressType); 
		PROCEDURE ^ VisitSizeType*(x: SyntaxTree.SizeType); 
		PROCEDURE ^ VisitAnyType*(x: SyntaxTree.AnyType); 
		PROCEDURE ^ VisitObjectType*(x: SyntaxTree.ObjectType); 
		PROCEDURE ^ VisitNilType*(x: SyntaxTree.NilType); 
		PROCEDURE ^ VisitIntegerType*(x: SyntaxTree.IntegerType); 
		PROCEDURE ^ VisitFloatType*(x: SyntaxTree.FloatType); 
		PROCEDURE ^ VisitComplexType*(x: SyntaxTree.ComplexType); 
		PROCEDURE ^ VisitStringType*(x: SyntaxTree.StringType); 
		PROCEDURE ^ CheckEnumerationScope(x: SyntaxTree.EnumerationScope; VAR highest: LONGINT); 
		PROCEDURE ^ VisitEnumerationType*(x: SyntaxTree.EnumerationType); 
		PROCEDURE ^ VisitRangeType*(x: SyntaxTree.RangeType); 
		PROCEDURE ^ VisitQualifiedType*(x: SyntaxTree.QualifiedType); 
		PROCEDURE ^ VisitArrayType*(x: SyntaxTree.ArrayType); 
		PROCEDURE ^ ImportModule(name: SyntaxTree.Identifier; position: Position); 
		PROCEDURE ^ VisitMathArrayType*(x: SyntaxTree.MathArrayType); 
		PROCEDURE ^ AnonymousTypeDeclaration(x: SyntaxTree.Type; CONST prefix: ARRAY OF CHAR); 
		PROCEDURE ^ FixPointerType(type: SyntaxTree.PointerType); 
		PROCEDURE ^ VisitPointerType*(x: SyntaxTree.PointerType); 
		PROCEDURE ^ VisitPortType*(x: SyntaxTree.PortType); 
		PROCEDURE ^ FixProcedureType(procedureType: SyntaxTree.ProcedureType); 
		PROCEDURE ^ HasFlag(VAR modifiers: SyntaxTree.Modifier; name: SyntaxTree.Identifier; VAR position: Position): BOOLEAN; 
		PROCEDURE ^ HasValue(modifiers: SyntaxTree.Modifier; name: SyntaxTree.Identifier; VAR position: Position; VAR value: LONGINT): BOOLEAN; 
		PROCEDURE ^ HasStringValue(modifiers: SyntaxTree.Modifier; name: SyntaxTree.Identifier; VAR position: Position; VAR value: ARRAY OF CHAR): BOOLEAN; 
		PROCEDURE ^ SkipImplementation*(x: SyntaxTree.CellType): BOOLEAN; 
		PROCEDURE ^ CheckModifiers(modifiers: SyntaxTree.Modifier; checkUse: BOOLEAN); 
		PROCEDURE ^ VisitProcedureType*(procedureType: SyntaxTree.ProcedureType); 
		PROCEDURE ^ VisitRecordType*(x: SyntaxTree.RecordType); 
		PROCEDURE ^ VisitCellType*(x: SyntaxTree.CellType); 
		PROCEDURE ^ ResolveArrayStructure*(recordType: SyntaxTree.RecordType); 
		PROCEDURE ^ CollectArrayAccessOperators(recordScope: SyntaxTree.RecordScope; arrayStructure: SyntaxTree.MathArrayType; VAR arrayAccessOperators: SyntaxTree.ArrayAccessOperators); 
		PROCEDURE ^ IndexOperatorHash(indexListSize, indexListKind: LONGINT; isTensor: BOOLEAN): LONGINT; 
		PROCEDURE ^ TwoToThePowerOf(exponent: LONGINT): LONGINT; 
		PROCEDURE ^ CheckLenOperator(operator: SyntaxTree.Operator; arrayStructure: SyntaxTree.MathArrayType): BOOLEAN; 
		PROCEDURE ^ CheckIndexOperator(operator: SyntaxTree.Operator; arrayStructure: SyntaxTree.MathArrayType; VAR isReadOperator, isGeneralOperator: BOOLEAN; VAR indexListSize, indexListKind: LONGINT): BOOLEAN; 
		PROCEDURE ^ FixTypes; 
		PROCEDURE ^ ResolveType(x: SyntaxTree.Type): SyntaxTree.Type; 
		PROCEDURE ^ RegularType(position: Position; type: SyntaxTree.Type): SyntaxTree.Type; 
		PROCEDURE ^ SignatureCompatible(position: Position; this, to: SyntaxTree.ProcedureType): BOOLEAN; 
		PROCEDURE ^ ParameterCompatible(formal: SyntaxTree.Parameter; actual: SyntaxTree.Expression): BOOLEAN; 
		PROCEDURE ^ AssignmentCompatible(left: SyntaxTree.Designator; right: SyntaxTree.Expression): BOOLEAN; 
		PROCEDURE ^ VisitIntegerValue*(value: SyntaxTree.IntegerValue); 
		PROCEDURE ^ VisitRealValue*(value: SyntaxTree.RealValue); 
		PROCEDURE ^ VisitComplexValue*(value: SyntaxTree.ComplexValue); 
		PROCEDURE ^ VisitSetValue*(value: SyntaxTree.SetValue); 
		PROCEDURE ^ VisitMathArrayValue*(value: SyntaxTree.MathArrayValue); 
		PROCEDURE ^ VisitBooleanValue*(value: SyntaxTree.BooleanValue); 
		PROCEDURE ^ VisitStringValue*(value: SyntaxTree.StringValue); 
		PROCEDURE ^ VisitCharacterValue*(value: SyntaxTree.CharacterValue); 
		PROCEDURE ^ VisitNilValue*(value: SyntaxTree.NilValue); 
		PROCEDURE ^ VisitEnumerationValue*(value: SyntaxTree.EnumerationValue); 
		PROCEDURE ^ VisitSet*(set: SyntaxTree.Set); 
		PROCEDURE ^ VisitMathArrayExpression*(x: SyntaxTree.MathArrayExpression); 
		PROCEDURE ^ VisitUnaryExpression*(unaryExpression: SyntaxTree.UnaryExpression); 
		PROCEDURE ^ MathArrayConversion(position: Position; expression: SyntaxTree.Expression; type: SyntaxTree.Type): SyntaxTree.Expression; 
		PROCEDURE ^ ConvertValue(position: Position; expression: SyntaxTree.Value; type: SyntaxTree.Type): SyntaxTree.Expression; 
		PROCEDURE ^ NewConversion*(position: Position; expression: SyntaxTree.Expression; type: SyntaxTree.Type; reference: SyntaxTree.Expression): SyntaxTree.Expression; 
		PROCEDURE ^ CompatibleConversion(position: Position; expression: SyntaxTree.Expression; type: SyntaxTree.Type): SyntaxTree.Expression; 
		PROCEDURE ^ ConvertOperands(VAR left, right: SyntaxTree.Expression); 
		PROCEDURE ^ FindOperator*(system: Global.System; operator: LONGINT; actualParameters: SyntaxTree.ExpressionList; returnType: SyntaxTree.Type): SyntaxTree.Operator; 
		PROCEDURE ^ SetCurrentScope*(scope: SyntaxTree.Scope); 
		PROCEDURE ^ NewOperatorCall*(position: Position; op: LONGINT; leftExpression, rightExpression: SyntaxTree.Expression; resultType: SyntaxTree.Type): SyntaxTree.Expression; 
		PROCEDURE ^ VisitBinaryExpression*(binaryExpression: SyntaxTree.BinaryExpression); 
		PROCEDURE ^ VisitRangeExpression*(x: SyntaxTree.RangeExpression); 
		PROCEDURE ^ VisitTensorRangeExpression*(x: SyntaxTree.TensorRangeExpression); 
		PROCEDURE ^ ResolveDesignator*(d: SyntaxTree.Expression): SyntaxTree.Designator; 
		PROCEDURE ^ VisitSymbolDesignator*(x: SyntaxTree.SymbolDesignator); 
		PROCEDURE ^ VisitSelfDesignator*(x: SyntaxTree.SelfDesignator); 
		PROCEDURE ^ VisitResultDesignator*(x: SyntaxTree.ResultDesignator); 
		PROCEDURE ^ NewSymbolDesignator*(position: Position; left: SyntaxTree.Designator; symbol: SyntaxTree.Symbol): SyntaxTree.Expression; 
		PROCEDURE ^ VisitIdentifierDesignator*(identifierDesignator: SyntaxTree.IdentifierDesignator); 
		PROCEDURE ^ VisitSelectorDesignator*(selectorDesignator: SyntaxTree.SelectorDesignator); 
		PROCEDURE ^ IndexCheck(index, length: SyntaxTree.Expression); 
		PROCEDURE ^ SetIndexBaseType(indexDesignator: SyntaxTree.IndexDesignator; newBaseType: SyntaxTree.Type); 
		PROCEDURE ^ AppendMathIndex(position: Position; indexDesignator: SyntaxTree.IndexDesignator; indexListItem: SyntaxTree.Expression; sourceArray: SyntaxTree.MathArrayType); 
		PROCEDURE ^ AppendIndex(position: Position; index: SyntaxTree.IndexDesignator; expression: SyntaxTree.Expression; over: SyntaxTree.Type); 
		PROCEDURE ^ ConvertToMathArray(expression: SyntaxTree.Expression): SyntaxTree.Expression; 
		PROCEDURE ^ ListOfOpenRanges(itemCount: LONGINT): SyntaxTree.ExpressionList; 
		PROCEDURE ^ NewIndexOperatorCall*(position: Position; left: SyntaxTree.Expression; indexList: SyntaxTree.ExpressionList; rhs: SyntaxTree.Expression): SyntaxTree.Designator; 
		PROCEDURE ^ NewObjectOperatorCall*(position: Position; left: SyntaxTree.Expression; oper: LONGINT; parameters: SyntaxTree.ExpressionList; rhs: SyntaxTree.Expression): SyntaxTree.Designator; 
		PROCEDURE ^ VisitBracketDesignator*(bracketDesignator: SyntaxTree.BracketDesignator); 
		PROCEDURE ^ ExpressionList(expressionList: SyntaxTree.ExpressionList): BOOLEAN; 
		PROCEDURE ^ CanPassInRegister*(type: SyntaxTree.Type): BOOLEAN; 
		PROCEDURE ^ NewProcedureCallDesignator(position: Position; left: SyntaxTree.Designator; actualParameters: SyntaxTree.ExpressionList): SyntaxTree.Designator; 
		PROCEDURE ^ VisitTypeGuardDesignator*(x: SyntaxTree.TypeGuardDesignator); 
		PROCEDURE ^ VisitBuiltinCallDesignator*(x: SyntaxTree.BuiltinCallDesignator); 
		PROCEDURE ^ VisitProcedureCallDesignator*(x: SyntaxTree.ProcedureCallDesignator); 
		PROCEDURE ^ CheckVariable(x: SyntaxTree.Expression): BOOLEAN; 
		PROCEDURE ^ CheckBasicType(x: SyntaxTree.Expression): BOOLEAN; 
		PROCEDURE ^ CheckNumberType(x: SyntaxTree.Expression): BOOLEAN; 
		PROCEDURE ^ CheckNonComplexNumberSizeType(x: SyntaxTree.Expression): BOOLEAN; 
		PROCEDURE ^ CheckAddressType(x: SyntaxTree.Expression): BOOLEAN; 
		PROCEDURE ^ CheckSizeType(x: SyntaxTree.Expression): BOOLEAN; 
		PROCEDURE ^ CheckObjectType(x: SyntaxTree.Expression): BOOLEAN; 
		PROCEDURE ^ CheckIntegerType(x: SyntaxTree.Expression): BOOLEAN; 
		PROCEDURE ^ CheckCharacterType(x: SyntaxTree.Expression): BOOLEAN; 
		PROCEDURE ^ CheckRealType(x: SyntaxTree.Expression): BOOLEAN; 
		PROCEDURE ^ CheckRangeType(x: SyntaxTree.Expression): BOOLEAN; 
		PROCEDURE ^ CheckBooleanType(x: SyntaxTree.Expression): BOOLEAN; 
		PROCEDURE ^ CheckSetType(x: SyntaxTree.Expression): BOOLEAN; 
		PROCEDURE ^ CheckStringType(x: SyntaxTree.Expression): BOOLEAN; 
		PROCEDURE ^ CheckTypeDeclarationType(x: SyntaxTree.Expression): BOOLEAN; 
		PROCEDURE ^ CheckIntegerValue(x: SyntaxTree.Expression; VAR value: LONGINT): BOOLEAN; 
		PROCEDURE ^ CheckStringValue(x: SyntaxTree.Expression; VAR value: ARRAY OF CHAR): BOOLEAN; 
		PROCEDURE ^ IsUnsignedValue(x: SyntaxTree.Expression; maxSizeInBits: LONGINT): BOOLEAN; 
		PROCEDURE ^ IsAddressValue(x: SyntaxTree.Expression): BOOLEAN; 
		PROCEDURE ^ IsAddressExpression(x: SyntaxTree.Expression): BOOLEAN; 
		PROCEDURE ^ IsSizeExpression(x: SyntaxTree.Expression): BOOLEAN; 
		PROCEDURE ^ CheckEnumerationValue(x: SyntaxTree.Expression; VAR value: LONGINT): BOOLEAN; 
		PROCEDURE ^ CheckCharacterValue(x: SyntaxTree.Expression; VAR value: CHAR): BOOLEAN; 
		PROCEDURE ^ CheckPositiveIntegerValue(x: SyntaxTree.Expression; VAR value: LONGINT; includeZero: BOOLEAN): BOOLEAN; 
		PROCEDURE ^ CheckPortType(x: SyntaxTree.Expression; VAR portType: SyntaxTree.PortType): BOOLEAN; 
		PROCEDURE ^ NewBuiltinCallDesignator(position: Position; builtin: SyntaxTree.Builtin; actualParameters: SyntaxTree.ExpressionList; left: SyntaxTree.Designator; returnType: SyntaxTree.Type): SyntaxTree.Expression; 
		PROCEDURE ^ NewTypeGuardDesignator(position: Position; left: SyntaxTree.Designator; type: SyntaxTree.Type; typeExpression: SyntaxTree.Expression): SyntaxTree.Designator; 
		PROCEDURE ^ VisitParameterDesignator*(designator: SyntaxTree.ParameterDesignator); 
		PROCEDURE ^ NewDereferenceDesignator(position: Position; left: SyntaxTree.Designator): SyntaxTree.Designator; 
		PROCEDURE ^ NewSupercallDesignator(position: Position; left: SyntaxTree.Designator): SyntaxTree.Designator; 
		PROCEDURE ^ VisitArrowDesignator*(arrowDesignator: SyntaxTree.ArrowDesignator); 
		PROCEDURE ^ ResolveExpression(expression: SyntaxTree.Expression): SyntaxTree.Expression; 
		PROCEDURE ^ ConstantExpression(expression: SyntaxTree.Expression): SyntaxTree.Expression; 
		PROCEDURE ^ ConstantInteger(expression: SyntaxTree.Expression): SyntaxTree.Expression; 
		PROCEDURE ^ ConstantIntegerGeq0(expression: SyntaxTree.Expression): SyntaxTree.Expression; 
		PROCEDURE ^ ResolveCondition(expression: SyntaxTree.Expression): SyntaxTree.Expression; 
		PROCEDURE ^ ResolveSymbol(x: SyntaxTree.Symbol); 
		PROCEDURE ^ CheckSymbolVisibility(symbol: SyntaxTree.Symbol); 
		PROCEDURE ^ SymbolNeedsResolution(x: SyntaxTree.Symbol): BOOLEAN; 
		PROCEDURE ^ VisitTypeDeclaration*(typeDeclaration: SyntaxTree.TypeDeclaration); 
		PROCEDURE ^ VisitConstant*(constant: SyntaxTree.Constant); 
		PROCEDURE ^ AdaptStackAlignment(procedure: SyntaxTree.Procedure; alignment: LONGINT); 
		PROCEDURE ^ VisitVariable*(variable: SyntaxTree.Variable); 
		PROCEDURE ^ VisitProperty*(property: SyntaxTree.Property); 
		PROCEDURE ^ VisitParameter*(parameter: SyntaxTree.Parameter); 
		PROCEDURE ^ VisitProcedure*(procedure: SyntaxTree.Procedure); 
		PROCEDURE ^ VisitBuiltin*(builtinProcedure: SyntaxTree.Builtin); 
		PROCEDURE ^ VisitOperator*(operator: SyntaxTree.Operator); 
		PROCEDURE ^ AddImport*(module: SyntaxTree.Module; x: SyntaxTree.Import): BOOLEAN; 
		PROCEDURE ^ VisitImport*(x: SyntaxTree.Import); 
		PROCEDURE ^ ResolveStatement(x: SyntaxTree.Statement): SyntaxTree.Statement; 
		PROCEDURE ^ StatementSequence(statementSequence: SyntaxTree.StatementSequence); 
		PROCEDURE ^ VisitProcedureCallStatement*(procedureCall: SyntaxTree.ProcedureCallStatement); 
		PROCEDURE ^ VisitAssignment*(assignment: SyntaxTree.Assignment); 
		PROCEDURE ^ VisitCommunicationStatement*(communication: SyntaxTree.CommunicationStatement); 
		PROCEDURE ^ IfPart(ifPart: SyntaxTree.IfPart; VAR true: BOOLEAN); 
		PROCEDURE ^ VisitIfStatement*(ifStatement: SyntaxTree.IfStatement); 
		PROCEDURE ^ WithPart(withPart: SyntaxTree.WithPart; VAR symbol: SyntaxTree.Symbol); 
		PROCEDURE ^ VisitWithStatement*(withStatement: SyntaxTree.WithStatement); 
		PROCEDURE ^ CasePart(casePart: SyntaxTree.CasePart; type: SyntaxTree.Type; VAR allcases: SyntaxTree.CaseConstant; VAR min, max: LONGINT); 
		PROCEDURE ^ VisitCaseStatement*(caseStatement: SyntaxTree.CaseStatement); 
		PROCEDURE ^ VisitWhileStatement*(whileStatement: SyntaxTree.WhileStatement); 
		PROCEDURE ^ VisitRepeatStatement*(repeatStatement: SyntaxTree.RepeatStatement); 
		PROCEDURE ^ GetGuard(symbol: SyntaxTree.Symbol; VAR type: SyntaxTree.Type): BOOLEAN; 
		PROCEDURE ^ VisitForStatement*(forStatement: SyntaxTree.ForStatement); 
		PROCEDURE ^ VisitLoopStatement*(loopStatement: SyntaxTree.LoopStatement); 
		PROCEDURE ^ VisitExitableBlock*(exitableBlock: SyntaxTree.ExitableBlock); 
		PROCEDURE ^ VisitExitStatement*(exitStatement: SyntaxTree.ExitStatement); 
		PROCEDURE ^ VisitReturnStatement*(returnStatement: SyntaxTree.ReturnStatement); 
		PROCEDURE ^ VisitAwaitStatement*(awaitStatement: SyntaxTree.AwaitStatement); 
		PROCEDURE ^ CheckSystemImport(position: Position); 
		PROCEDURE ^ VisitCode*(code: SyntaxTree.Code); 
		PROCEDURE ^ BlockFlags(block: SyntaxTree.StatementBlock); 
		PROCEDURE ^ VisitStatementBlock*(statementBlock: SyntaxTree.StatementBlock); 
		PROCEDURE ^ Body(body: SyntaxTree.Body); 
		PROCEDURE ^ Register(symbol: SyntaxTree.Symbol; scope: SyntaxTree.Scope; allowDuplicate: BOOLEAN); 
		PROCEDURE ^ Implementation(scope: SyntaxTree.Scope); 
		PROCEDURE ^ Implementations(x: SyntaxTree.Module); 
		PROCEDURE ^ Declarations(scope: SyntaxTree.Scope; skipImplementation: BOOLEAN); 
		PROCEDURE ^ CheckInterOperatorConformity(thisModuleScope, thatModuleScope: SyntaxTree.ModuleScope); 
		PROCEDURE ^ Module*(x: SyntaxTree.Module); 
	END Checker; 

	Warnings* = OBJECT (SyntaxTree.Visitor)
	VAR 
		diagnostics: Diagnostics.Diagnostics; 
		module: SyntaxTree.Module; 

		PROCEDURE ^  & InitWarnings*(diagnostics: Diagnostics.Diagnostics); 
		PROCEDURE ^ VisitPortType*(x: SyntaxTree.PortType); 
		PROCEDURE ^ Type(x: SyntaxTree.Type); 
		PROCEDURE ^ VisitType*(x: SyntaxTree.Type); 
		PROCEDURE ^ VisitBasicType*(x: SyntaxTree.BasicType); 
		PROCEDURE ^ VisitCharacterType*(x: SyntaxTree.CharacterType); 
		PROCEDURE ^ VisitIntegerType*(x: SyntaxTree.IntegerType); 
		PROCEDURE ^ VisitFloatType*(x: SyntaxTree.FloatType); 
		PROCEDURE ^ VisitQualifiedType*(x: SyntaxTree.QualifiedType); 
		PROCEDURE ^ VisitStringType*(x: SyntaxTree.StringType); 
		PROCEDURE ^ VisitEnumerationType*(x: SyntaxTree.EnumerationType); 
		PROCEDURE ^ VisitRangeType*(x: SyntaxTree.RangeType); 
		PROCEDURE ^ VisitArrayType*(x: SyntaxTree.ArrayType); 
		PROCEDURE ^ VisitMathArrayType*(x: SyntaxTree.MathArrayType); 
		PROCEDURE ^ VisitPointerType*(x: SyntaxTree.PointerType); 
		PROCEDURE ^ VisitRecordType*(x: SyntaxTree.RecordType); 
		PROCEDURE ^ VisitCellType*(x: SyntaxTree.CellType); 
		PROCEDURE ^ VisitProcedureType*(x: SyntaxTree.ProcedureType); 
		PROCEDURE ^ Warning(x: SyntaxTree.Symbol; CONST text: ARRAY OF CHAR); 
		PROCEDURE ^ Symbol(x: SyntaxTree.Symbol); 
		PROCEDURE ^ VisitSymbol*(x: SyntaxTree.Symbol); 
		PROCEDURE ^ VisitTypeDeclaration*(x: SyntaxTree.TypeDeclaration); 
		PROCEDURE ^ VisitConstant*(x: SyntaxTree.Constant); 
		PROCEDURE ^ VisitVariable*(x: SyntaxTree.Variable); 
		PROCEDURE ^ VisitProperty*(x: SyntaxTree.Property); 
		PROCEDURE ^ VisitParameter*(x: SyntaxTree.Parameter); 
		PROCEDURE ^ VisitProcedure*(x: SyntaxTree.Procedure); 
		PROCEDURE ^ VisitOperator*(x: SyntaxTree.Operator); 
		PROCEDURE ^ VisitImport*(x: SyntaxTree.Import); 
		PROCEDURE ^ Scope(scope: SyntaxTree.Scope); 
		PROCEDURE ^ Module*(x: SyntaxTree.Module); 
	END Warnings; 

	PROCEDURE ^ IsOberonInline(procedure: SyntaxTree.Procedure): BOOLEAN; 
	PROCEDURE ^ Resolved(x: SyntaxTree.Type): SyntaxTree.Type; 
	PROCEDURE ^ PowerOf2(x: LONGINT): BOOLEAN; 
	PROCEDURE ^ IsCellNetScope(scope: SyntaxTree.Scope): BOOLEAN; 
	PROCEDURE ^ IsCellScope(scope: SyntaxTree.Scope): BOOLEAN; 
	PROCEDURE ^ InCellNetScope(scope: SyntaxTree.Scope): BOOLEAN; 
	PROCEDURE ^ ToMemoryUnits(system: Global.System; size: LONGINT): LONGINT; 
	PROCEDURE ^ GetProcedureAllowed*(type: SyntaxTree.Type): BOOLEAN; 
	PROCEDURE ^ RemoveModuleFromCache*(importCache: SyntaxTree.ModuleScope; x: SyntaxTree.Module); 
	PROCEDURE ^ CompatibleTo(system: Global.System; this, to: SyntaxTree.Type): BOOLEAN; 
	PROCEDURE ^ StaticArrayCompatible(formal: SyntaxTree.Type; actual: SyntaxTree.Type): BOOLEAN; 
	PROCEDURE ^ OpenArrayCompatible(formalType: SyntaxTree.ArrayType; actualType: SyntaxTree.Type): BOOLEAN; 
	PROCEDURE ^ MathArrayCompatible(formalType: SyntaxTree.MathArrayType; actualType: SyntaxTree.Type): BOOLEAN; 
	PROCEDURE ^ MathArrayTypeDistance(system: Global.System; from, to: SyntaxTree.MathArrayType; varpar: BOOLEAN): LONGINT; 
	PROCEDURE ^ ArrayTypeDistance(system: Global.System; from, to: SyntaxTree.ArrayType): LONGINT; 
	PROCEDURE ^ Distance(system: Global.System; procedureType: SyntaxTree.ProcedureType; actualParameters: SyntaxTree.ExpressionList): LONGINT; 
	PROCEDURE ^ ProcedureTypeDistance(system: Global.System; procedureType: SyntaxTree.ProcedureType; right: SyntaxTree.ProcedureType): LONGINT; 
	PROCEDURE ^ TypeDistance(system: Global.System; from, to: SyntaxTree.Type; varpar: BOOLEAN): LONGINT; 
	PROCEDURE ^ IsIntegerType*(type: SyntaxTree.Type): BOOLEAN; 
	PROCEDURE ^ IsAddressType*(type: SyntaxTree.Type; addressWidth: LONGINT): BOOLEAN; 
	PROCEDURE ^ IsSizeType(type: SyntaxTree.Type; addressWidth: LONGINT): BOOLEAN; 
	PROCEDURE ^ IsSignedIntegerType*(type: SyntaxTree.Type): BOOLEAN; 
	PROCEDURE ^ IsUnsignedIntegerType*(type: SyntaxTree.Type): BOOLEAN; 
	PROCEDURE ^ IsIntegerValue(x: SyntaxTree.Expression; VAR value: LONGINT): BOOLEAN; 
	PROCEDURE ^ IsEnumerationValue(x: SyntaxTree.Expression; VAR value: LONGINT): BOOLEAN; 
	PROCEDURE ^ IsRealValue(x: SyntaxTree.Expression; VAR value: LONGREAL): BOOLEAN; 
	PROCEDURE ^ IsComplexValue(x: SyntaxTree.Expression; VAR realValue, imagValue: LONGREAL): BOOLEAN; 
	PROCEDURE ^ IsCharacterValue(x: SyntaxTree.Expression; VAR value: CHAR): BOOLEAN; 
	PROCEDURE ^ IsBooleanValue*(x: SyntaxTree.Expression; VAR value: BOOLEAN): BOOLEAN; 
	PROCEDURE ^ IsSetValue(x: SyntaxTree.Expression; VAR value: SET): BOOLEAN; 
	PROCEDURE ^ IsStringValue(x: SyntaxTree.Expression; VAR value: Scanner.StringType): BOOLEAN; 
	PROCEDURE ^ Indexable(x: SyntaxTree.Type): BOOLEAN; 
	PROCEDURE ^ SameType(t1, t2: SyntaxTree.Type): BOOLEAN; 
	PROCEDURE ^ ArrayBase*(t: SyntaxTree.Type; max: LONGINT): SyntaxTree.Type; 
	PROCEDURE ^ IsOpenArray*(type: SyntaxTree.Type; VAR base: SyntaxTree.Type): BOOLEAN; 
	PROCEDURE ^ IsStaticArray*(type: SyntaxTree.Type; VAR base: SyntaxTree.Type; VAR dim: LONGINT): BOOLEAN; 
	PROCEDURE ^ IsDynamicArray*(type: SyntaxTree.Type; VAR base: SyntaxTree.Type): BOOLEAN; 
	PROCEDURE ^ Dimension*(t: SyntaxTree.Type; form: SET): LONGINT; 
	PROCEDURE ^ IsVariable(expression: SyntaxTree.Expression): BOOLEAN; 
	PROCEDURE ^ IsVariableParameter*(symbol: SyntaxTree.Symbol): BOOLEAN; 
	PROCEDURE ^ IsPointerType*(type: SyntaxTree.Type): BOOLEAN; 
	PROCEDURE ^ IsUnsafePointer*(type: SyntaxTree.Type): BOOLEAN; 
	PROCEDURE ^ IsDisposable*(type: SyntaxTree.Type): BOOLEAN; 
	PROCEDURE ^ IsPointerToRecord(type: SyntaxTree.Type): BOOLEAN; 
	PROCEDURE ^ IsPointerToObject(type: SyntaxTree.Type): BOOLEAN; 
	PROCEDURE ^ ContainsPointer*(type: SyntaxTree.Type): BOOLEAN; 
	PROCEDURE ^ IsStringType*(type: SyntaxTree.Type): BOOLEAN; 
	PROCEDURE ^ IsCharacterType*(type: SyntaxTree.Type): BOOLEAN; 
	PROCEDURE ^ IsEnumerationType*(type: SyntaxTree.Type): BOOLEAN; 
	PROCEDURE ^ IsTypeExtension(base, extension: SyntaxTree.Type): BOOLEAN; 
	PROCEDURE ^ IsEnumerationExtension(base, extension: SyntaxTree.Type): BOOLEAN; 
	PROCEDURE ^ IsCallable(expression: SyntaxTree.Expression): BOOLEAN; 
	PROCEDURE ^ RecordTypeDistance(from, to: SyntaxTree.RecordType): LONGINT; 
	PROCEDURE ^ PointerTypeDistance(from, to: SyntaxTree.PointerType): LONGINT; 
	PROCEDURE ^ IsTypeDesignator(expression: SyntaxTree.Expression; VAR typeDeclaration: SyntaxTree.TypeDeclaration): BOOLEAN; 
	PROCEDURE ^ IsExtensibleType(type: SyntaxTree.Type): BOOLEAN; 
	PROCEDURE ^ IsUnextensibleRecord(d: SyntaxTree.Expression): BOOLEAN; 
	PROCEDURE ^ IsExtensibleDesignator(d: SyntaxTree.Expression): BOOLEAN; 
	PROCEDURE ^ IsBasicType(type: SyntaxTree.Type): BOOLEAN; 
	PROCEDURE ^ RecordBase*(record: SyntaxTree.RecordType): SyntaxTree.RecordType; 
	PROCEDURE ^ FindSuperProcedure*(scope: SyntaxTree.RecordScope; procedure: SyntaxTree.Procedure): SyntaxTree.Procedure; 
	PROCEDURE ^ GetConstructor(record: SyntaxTree.RecordType): SyntaxTree.Procedure; 
	PROCEDURE ^ EnterCase(VAR root: SyntaxTree.CaseConstant; min, max: LONGINT): BOOLEAN; 
	PROCEDURE ^ NewChecker*(diagnostics: Diagnostics.Diagnostics; verboseErrorMessage, useDarwinCCalls, cooperative: BOOLEAN; system: Global.System; symbolFileFormat: Formats.SymbolFileFormat; VAR importCache: SyntaxTree.ModuleScope; CONST backend: ARRAY OF CHAR): Checker; 
	PROCEDURE ^ NewWarnings*(diagnostics: Diagnostics.Diagnostics): Warnings; 
	PROCEDURE ^ IsRangeType(type: SyntaxTree.Type): BOOLEAN; 
	PROCEDURE ^ IsMathArrayType(type: SyntaxTree.Type): BOOLEAN; 
	PROCEDURE ^ IsArrayType(type: SyntaxTree.Type): BOOLEAN; 
	PROCEDURE ^ IsComplexType(type: SyntaxTree.Type): BOOLEAN; 
	PROCEDURE ^ IsArrayStructuredObjectType*(type: SyntaxTree.Type): BOOLEAN; 
	PROCEDURE ^ MathArrayStructureOfType(type: SyntaxTree.Type): SyntaxTree.MathArrayType; 
	PROCEDURE ^ IsStaticRange(x: SyntaxTree.Expression; VAR firstValue, lastValue, stepValue: LONGINT): BOOLEAN; 
	PROCEDURE ^ IsTensor(type: SyntaxTree.Type): BOOLEAN; 
	PROCEDURE ^ IsStaticMathArray*(type: SyntaxTree.Type; VAR length: LONGINT; VAR baseType: SyntaxTree.Type): BOOLEAN; 
	PROCEDURE ^ SymbolHasAddress*(symbol: SyntaxTree.Symbol): BOOLEAN; 
	PROCEDURE ^ HasAddress*(expression: SyntaxTree.Expression): BOOLEAN; 
	PROCEDURE ^ IsLocalVariable*(e: SyntaxTree.Expression): BOOLEAN; 
	PROCEDURE ^ IsStaticProcedure*(procedure: SyntaxTree.Procedure): BOOLEAN; 
	PROCEDURE ^ InMethodTable*(procedure: SyntaxTree.Procedure): BOOLEAN; 
	PROCEDURE ^ ReturnedAsParameter*(type: SyntaxTree.Type): BOOLEAN; 
	PROCEDURE ^ StructuredReturnType*(procedureType: SyntaxTree.ProcedureType): BOOLEAN; 
BEGIN
END FoxSemanticChecker.
