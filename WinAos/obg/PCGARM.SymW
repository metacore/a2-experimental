MODULE PCGARM;
	IMPORT SYSTEM, PCLIR, PCBT, PCM, PCO := PCOARM, RA := PCARMRegisters, PCARMCP, PCAARM, KernelLog;
CONST 
	Trace = FALSE; 
	TTrace = FALSE; 
	INTERNALERROR = 100; 
	ErrImplementationRestriction = 101; 
	ErrInlineNotAligned = 102; 
	RegularIntSize = (PCLIR.IntSize - {PCLIR.Int64}); 
	AL = PCO.AL; 
	NE = PCO.NE; 
	PC = PCO.PC; 
	LR = PCO.LR; 
	SP = PCO.SP; 
	FP = PCO.FP; 
	R0 = PCO.R0; 
	R1 = PCO.R1; 
	R2 = PCO.R2; 
	R3 = PCO.R3; 
	R4 = PCO.R4; 
	R5 = PCO.R5; 
	R6 = PCO.R6; 
	R7 = PCO.R7; 
	R8 = PCO.R8; 
	R9 = PCO.R9; 
	R10 = PCO.R10; 
	R11 = PCO.R11; 
	RReturn = R0; 
	RReturn2 = R1; 
	TwoRegisters = {PCLIR.Int64, PCLIR.Float64}; 
	FDst = 0; 
	FSrc1 = 1; 
	FSrc2 = 2; 
	FSrc3 = 3; 
	FVal = 4; 
	FAdr = 5; 
	none =  -1; 
	rsub =  -2; 
	fastenter =  -3; 
	fastexit =  -4; 
	nopaf =  -5; 
	floatCC =  -6; 
TYPE 
	XOpcode = SHORTINT; 

	XRegister = RECORD 
		Low, High: LONGINT; 
	END; 

	Info = OBJECT (PCLIR.InstructionAttribute)
	VAR 
		xop: XOpcode; 
		flags: SET; 
		dst: XRegister; 
		pos: LONGINT; 
		fixup: Info; 
		target: BOOLEAN; 

		PROCEDURE ^  & Init*; 
	END Info; 
VAR 
	HexTab: ARRAY 16 OF CHAR; 
	codeName: ARRAY 32 OF CHAR; 
	regs: RA.ARMRegisters; 
	pool: PCARMCP.ConstantPool; 
	lastLabelPos: LONGINT; 
	DivIndex, ModIndex: LONGINT; 
	Int64LSH, Int64ASH: LONGINT; 
	FAdd, FSub, FMul, FDiv, FNeg, FAbs, FEntier, FIntToReal, FRealToInt, FRealToReal, FEq, FLe, FLt, FNe, FGe, FGt, FLongOffset: LONGINT; 
	bimboTrace: BOOLEAN; 

	PROCEDURE ^ InitHexTab; 
	PROCEDURE ^ Write(s: ARRAY OF CHAR); 
	PROCEDURE ^ WriteLn(s: ARRAY OF CHAR); 
	PROCEDURE ^ Ln; 
	PROCEDURE ^ Int(i: LONGINT); 
	PROCEDURE ^ Hex(value, len: LONGINT); 
	PROCEDURE ^ Set(s: SET); 
	PROCEDURE ^ Bool(b: BOOLEAN); 
	PROCEDURE ^ ToDo(pc: LONGINT; msg: ARRAY OF CHAR); 
	PROCEDURE ^ Error(pc: LONGINT; msg: ARRAY OF CHAR); 
	PROCEDURE ^ IsShift(op: PCLIR.Opcode): BOOLEAN; 
	PROCEDURE ^ Diadic(op: PCLIR.Opcode): BOOLEAN; 
	PROCEDURE ^ SpecialRegister(virtualReg: LONGINT): BOOLEAN; 
	PROCEDURE ^ MapSpecialRegister(virtualReg: LONGINT): LONGINT; 
	PROCEDURE ^ ResolveRegister(code: PCLIR.Code; virtualReg: LONGINT): XRegister; 
	PROCEDURE ^ XResolveRegister(code: PCLIR.Code; virtualReg: LONGINT; VAR physicalReg: XRegister; VAR signed: BOOLEAN); 
	PROCEDURE ^ FindDefinition(code: PCLIR.Code; virtualReg: LONGINT): PCLIR.Instruction; 
	PROCEDURE ^ IsLoadStoreSpecial(op: PCLIR.Opcode; instr: PCLIR.Instruction): BOOLEAN; 
	PROCEDURE ^ LoadConstant(pc, register, value, count: LONGINT): LONGINT; 
	PROCEDURE ^ InstructionType(code: PCLIR.Code; VAR i: PCLIR.Instruction): LONGINT; 
	PROCEDURE ^ Size(type: LONGINT): LONGINT; 
	PROCEDURE ^ LoadAddress(rAdr: LONGINT; adr: PCM.Attribute); 
	PROCEDURE ^ SystemCall(nr: LONGINT); 
	PROCEDURE ^ Init(): BOOLEAN; 
	PROCEDURE ^ Done(VAR res: WORD); 
	PROCEDURE ^ Enter(code: PCLIR.Code; VAR instr: PCLIR.Instruction; pc: LONGINT); 
	PROCEDURE ^ Exit(code: PCLIR.Code; VAR instr: PCLIR.Instruction; pc: LONGINT); 
	PROCEDURE ^ Compare(code: PCLIR.Code; VAR instr: PCLIR.Instruction); 
	PROCEDURE ^ Trap(code: PCLIR.Code; VAR instr: PCLIR.Instruction; pc: LONGINT); 
	PROCEDURE ^ SaveRegisters(code: PCLIR.Code; VAR instr: PCLIR.Instruction; pc: LONGINT); 
	PROCEDURE ^ LoadRegisters(code: PCLIR.Code; VAR instr: PCLIR.Instruction; pc: LONGINT); 
	PROCEDURE ^ Return(code: PCLIR.Code; VAR instr: PCLIR.Instruction; pc: LONGINT); 
	PROCEDURE ^ Result(code: PCLIR.Code; VAR instr: PCLIR.Instruction; pc: LONGINT); 
	PROCEDURE ^ Pop(code: PCLIR.Code; VAR instr: PCLIR.Instruction; pc: LONGINT); 
	PROCEDURE ^ Push(code: PCLIR.Code; VAR instr: PCLIR.Instruction; pc: LONGINT); 
	PROCEDURE ^ LoadStore(code: PCLIR.Code; VAR instr: PCLIR.Instruction; pc: LONGINT); 
	PROCEDURE ^ LoadC(code: PCLIR.Code; VAR instr: PCLIR.Instruction; pc: LONGINT); 
	PROCEDURE ^ In(code: PCLIR.Code; VAR instr: PCLIR.Instruction; pc: LONGINT); 
	PROCEDURE ^ Out(code: PCLIR.Code; VAR instr: PCLIR.Instruction; pc: LONGINT); 
	PROCEDURE ^ Nop(code: PCLIR.Code; VAR instr: PCLIR.Instruction; pc: LONGINT); 
	PROCEDURE ^ Label(code: PCLIR.Code; VAR instr: PCLIR.Instruction; pc: LONGINT); 
	PROCEDURE ^ JCC(code: PCLIR.Code; VAR instr: PCLIR.Instruction; pc: LONGINT); 
	PROCEDURE ^ FloatingPointComparison(code: PCLIR.Code; VAR instr: PCLIR.Instruction); 
	PROCEDURE ^ Call(code: PCLIR.Code; VAR instr: PCLIR.Instruction; pc: LONGINT); 
	PROCEDURE ^ CallReg(code: PCLIR.Code; VAR instr: PCLIR.Instruction; pc: LONGINT); 
	PROCEDURE ^ SysCall(code: PCLIR.Code; VAR instr: PCLIR.Instruction; pc: LONGINT); 
	PROCEDURE ^ SetCC(code: PCLIR.Code; VAR instr: PCLIR.Instruction; pc: LONGINT); 
	PROCEDURE ^ Kill(code: PCLIR.Code; VAR instr: PCLIR.Instruction; pc: LONGINT); 
	PROCEDURE ^ Phi(code: PCLIR.Code; VAR instr: PCLIR.Instruction; pc: LONGINT); 
	PROCEDURE ^ LoadSP(code: PCLIR.Code; VAR instr: PCLIR.Instruction; pc: LONGINT); 
	PROCEDURE ^ Copy(code: PCLIR.Code; VAR instr: PCLIR.Instruction; pc: LONGINT); 
	PROCEDURE ^ Conversion(code: PCLIR.Code; VAR instr: PCLIR.Instruction; pc: LONGINT); 
	PROCEDURE ^ BitOp(code: PCLIR.Code; VAR instr: PCLIR.Instruction; pc: LONGINT); 
	PROCEDURE ^ DivMod(code: PCLIR.Code; VAR instr: PCLIR.Instruction; pc: LONGINT); 
	PROCEDURE ^ DataProcessingInstruction(code: PCLIR.Code; VAR instr: PCLIR.Instruction; pc: LONGINT); 
	PROCEDURE ^ GetSHIFTMask(size: LONGINT): SET; 
	PROCEDURE ^ PrepareShifterOperands(xop: PCLIR.Opcode; size: LONGINT; flags: SET; rB, rC: XRegister; val: LONGINT; sC: BOOLEAN; VAR mode, conl, conr, sol, sor: SET); 
	PROCEDURE ^ GetROTShifter(size: LONGINT): LONGINT; 
	PROCEDURE ^ ROTPrologue(rA, size: LONGINT); 
	PROCEDURE ^ ROTEpilogue(rD, size: LONGINT; signed: BOOLEAN); 
	PROCEDURE ^ FloatingPointDPI(code: PCLIR.Code; VAR instr: PCLIR.Instruction; pc: LONGINT); 
	PROCEDURE ^ Move(code: PCLIR.Code; VAR instr: PCLIR.Instruction; pc: LONGINT); 
	PROCEDURE ^ Inline(code: PCLIR.Code; VAR instr: PCLIR.Instruction; pc: LONGINT); 
	PROCEDURE ^ Case(code: PCLIR.Code; VAR instr: PCLIR.Instruction; pc: LONGINT); 
	PROCEDURE ^ CaseLabel(code: PCLIR.Code; VAR instr: PCLIR.Instruction; pc: LONGINT); 
	PROCEDURE ^ CaseElse(code: PCLIR.Code; VAR instr: PCLIR.Instruction; pc: LONGINT); 
	PROCEDURE ^ Optimize(code: PCLIR.Code); 
	PROCEDURE ^ InstructionInit(VAR instr: PCLIR.Instruction); 
	PROCEDURE ^ Install*; 
BEGIN
END PCGARM.
