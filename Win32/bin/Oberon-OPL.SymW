MODULE OPL IN Oberon;
	IMPORT SYSTEM, OPT, OPO, OPM;
CONST 
	NewRef = TRUE; 
	Experimental = TRUE; 
	Reg = OPO.Reg; 
	Abs = OPO.Abs; 
	RegRel = OPO.RegRel; 
	Coc = OPO.Coc; 
	ld* = 32; 
	ldbdw* = 64; 
	ldwdw* = 96; 
	ldbw* = 128; 
	ldbdwu* = 160; 
	ldwdwu* = 196; 
	ldbwu* = 224; 
	getReg* = 256; 
	putReg* = 288; 
	ldProc* = 320; 
	ldXProc* = 352; 
	lea* = 384; 
	store* = 416; 
	push* = 448; 
	pop* = 480; 
	add* = 512; 
	sub* = 544; 
	mul* = 576; 
	div* = 608; 
	mod* = 640; 
	neg* = 960; 
	abs* = 992; 
	cmp* = 1056; 
	je* = 1504; 
	jne* = 1536; 
	jl* = 1568; 
	jle* = 1600; 
	jg* = 1632; 
	jge* = 1664; 
	ja* = 1696; 
	jae* = 1728; 
	jb* = 1760; 
	jbe* = 1792; 
	jc* = 1824; 
	jnc* = 1856; 
	jmp* = 1888; 
	jmpReg* = 1920; 
	sete* = 1120; 
	setne* = 1152; 
	setl* = 1184; 
	setle* = 1216; 
	setg* = 1248; 
	setge* = 1280; 
	seta* = 1312; 
	setae* = 1344; 
	setb* = 1376; 
	setbe* = 1408; 
	setc* = 1440; 
	setnc* = 1472; 
	te* = 1952; 
	tne* = 1984; 
	tle* = 2944; 
	ta* = 2016; 
	tae* = 2880; 
	to* = 2912; 
	trap* = 2048; 
	or* = 672; 
	xor* = 704; 
	and* = 736; 
	not* = 1024; 
	bt* = 1088; 
	btr* = 768; 
	bts* = 800; 
	test* = 3424; 
	call* = 2080; 
	callReg* = 2112; 
	xcall* = 2144; 
	ret* = 2176; 
	enter* = 2208; 
	leave* = 2240; 
	sal* = 832; 
	sar* = 864; 
	shr* = 896; 
	rol* = 928; 
	cld* = 2272; 
	repMovs* = 2304; 
	cmpString* = 2336; 
	pushReg* = 2368; 
	popReg* = 2400; 
	case* = 2432; 
	short* = 2976; 
	phi* = 2464; 
	label* = 2496; 
	entier* = 3104; 
	cli* = 3168; 
	sti* = 3200; 
	in* = 3232; 
	out* = 3264; 
	assembler* = 3296; 
	clear* = 3328; 
	std* = 3392; 
	finlabel* = 3456; 
	fload* = 2528; 
	fstore* = 2560; 
	fist* = 2592; 
	fild* = 2624; 
	fadd* = 2656; 
	fsub* = 2688; 
	fmul* = 2720; 
	fdiv* = 2752; 
	fabs* = 2784; 
	fchs* = 2816; 
	fcmp* = 2848; 
	newStat* = 3136; 
	Ld = (ld DIV 32); 
	Ldbdw = (ldbdw DIV 32); 
	Ldwdw = (ldwdw DIV 32); 
	Ldbw = (ldbw DIV 32); 
	Ldbdwu* = (ldbdwu DIV 32); 
	Ldwdwu* = (ldwdwu DIV 32); 
	Ldbwu* = (ldbwu DIV 32); 
	GETreg* = (getReg DIV 32); 
	PUTreg* = (putReg DIV 32); 
	LdProc = (ldProc DIV 32); 
	LdXProc = (ldXProc DIV 32); 
	Lea = (lea DIV 32); 
	Sto = (store DIV 32); 
	Push = (push DIV 32); 
	Pop = (pop DIV 32); 
	Add = (add DIV 32); 
	Sub = (sub DIV 32); 
	Mul = (mul DIV 32); 
	Div = (div DIV 32); 
	Mod = (mod DIV 32); 
	Neg = (neg DIV 32); 
	Abso = (abs DIV 32); 
	Cmp = (cmp DIV 32); 
	Je = (je DIV 32); 
	Jne = (jne DIV 32); 
	Jl = (jl DIV 32); 
	Jle = (jle DIV 32); 
	Jg = (jg DIV 32); 
	Jge = (jge DIV 32); 
	Ja = (ja DIV 32); 
	Jae = (jae DIV 32); 
	Jb = (jb DIV 32); 
	Jbe = (jbe DIV 32); 
	Jc = (jc DIV 32); 
	Jnc = (jnc DIV 32); 
	Jmp = (jmp DIV 32); 
	JmpReg = (jmpReg DIV 32); 
	Sete = (sete DIV 32); 
	Setne = (setne DIV 32); 
	Setl = (setl DIV 32); 
	Setle = (setle DIV 32); 
	Setg = (setg DIV 32); 
	Setge = (setge DIV 32); 
	Seta = (seta DIV 32); 
	Setae = (setae DIV 32); 
	Setb = (setb DIV 32); 
	Setbe = (setbe DIV 32); 
	Setc = (setc DIV 32); 
	Setnc = (setnc DIV 32); 
	Te = (te DIV 32); 
	Tne = (tne DIV 32); 
	Tle = (tle DIV 32); 
	Ta = (ta DIV 32); 
	Tae = (tae DIV 32); 
	To = (to DIV 32); 
	Trap = (trap DIV 32); 
	oR = (or DIV 32); 
	Xor = (xor DIV 32); 
	And = (and DIV 32); 
	Not = (not DIV 32); 
	Bt = (bt DIV 32); 
	Btr = (btr DIV 32); 
	Bts = (bts DIV 32); 
	Test = (test DIV 32); 
	Call = (call DIV 32); 
	CallReg = (callReg DIV 32); 
	Xcall = (xcall DIV 32); 
	Ret = (ret DIV 32); 
	Enter = (enter DIV 32); 
	Leave = (leave DIV 32); 
	Sal = (sal DIV 32); 
	Sar = (sar DIV 32); 
	Shr = (shr DIV 32); 
	Rol = (rol DIV 32); 
	Cld = (cld DIV 32); 
	RepMovs = (repMovs DIV 32); 
	CmpString = (cmpString DIV 32); 
	PushReg = (pushReg DIV 32); 
	PopReg = (popReg DIV 32); 
	Case = (case DIV 32); 
	Short* = (short DIV 32); 
	Phi = (phi DIV 32); 
	Label = (label DIV 32); 
	Entier = (entier DIV 32); 
	Cli = (cli DIV 32); 
	Sti = (sti DIV 32); 
	In = (in DIV 32); 
	Out = (out DIV 32); 
	Assembler = (assembler DIV 32); 
	Clear = (clear DIV 32); 
	Std = (std DIV 32); 
	FinLabel = (finlabel DIV 32); 
	FLoad = (fload DIV 32); 
	FStore = (fstore DIV 32); 
	Fist = (fist DIV 32); 
	Fild = (fild DIV 32); 
	Fadd = (fadd DIV 32); 
	Fsub = (fsub DIV 32); 
	Fmul = (fmul DIV 32); 
	Fdiv = (fdiv DIV 32); 
	Fabs = (fabs DIV 32); 
	Fchs = (fchs DIV 32); 
	Fcmp = (fcmp DIV 32); 
	NewStat = (newStat DIV 32); 
	VarEntryTag = 8CX; 
	EntryTag = 82X; 
	commandTag = 83X; 
	pointerTag = 84X; 
	importTag = 85X; 
	VarConsLinkTag = 8DX; 
	LinkTag = 86X; 
	DataTag = 87X; 
	ExportTag = 88X; 
	CodeTag = 89X; 
	UseTag = 8AX; 
	TypeTag = 8BX; 
	RefTag = 8CX; 
	noHint* =  -1; 
	useEAX* = 0; 
	useECX* = 1; 
	useEDX* = 2; 
	useEBX* = 3; 
	useESP* = 4; 
	useEBP* = 5; 
	useESI* = 6; 
	useEDI* = 7; 
	useST* = 8; 
	tryEAX* = 16; 
	tryECX* = 17; 
	tryEDX* = 18; 
	tryEBX* = 19; 
	tryESI* = 22; 
	tryEDI* = 23; 
	useReg = {useEAX, useECX, useEDX, useEBX, useESP, useEBP, useESI, useEDI}; 
	tryReg = {tryEAX, tryECX, tryEDX, tryEBX, tryESI, tryEDI}; 
	none* =  -1; 
	RiscFP* =  -2; 
	RiscESP* =  -3; 
	noScale = OPO.noScale; 
	Scale1 = OPO.Scale1; 
	Scale2 = OPO.Scale2; 
	Scale4 = OPO.Scale4; 
	RegReg = OPO.RegReg; 
	RegMem = OPO.RegMem; 
	MemReg = OPO.MemReg; 
	ImmReg = OPO.ImmReg; 
	ImmMem = OPO.ImmMem; 
	Nil* = OPM.LANotAlloc; 
	WithTrap* = 1; 
	CaseTrap* = 2; 
	FuncTrap* = 3; 
	EqualGuardTrap* = 5; 
	GuardTrap* = 6; 
	OverflowTrap* = 4; 
	RangeTrap* = 7; 
	DimTrap* = 9; 
	nofTrapFixups = 10; 
	PtrInit = 5; 
	CaseTabelIndex = 0; 
	CaseTableEntryNr = 255; 
	LocProcAssIndex = 1; 
	LocProcAssEntryNr = 254; 
	NewLinkIndex* = 2; 
	NewEntryNr* = 253; 
	NewSysLinkIndex* = 3; 
	NewSysEntryNr* = 252; 
	NewArrayLinkIndex* = 4; 
	NewArrayEntryNr* = 251; 
	StartIndex* = 5; 
	StartEntryNr* = 250; 
	AwaitIndex* = 6; 
	AwaitEntryNr* = 249; 
	LockIndex* = 7; 
	LockEntryNr* = 247; 
	UnlockIndex* = 8; 
	UnlockEntryNr* = 246; 
	InitLinks = 9; 
	MaxCommands = 128; 
	MaxNewMethods = 16; 
	MaxExtensions = 15; 
	MaxEntry* = 128; 
	LinkLength = 512; 
	MaxSaveLevel = 32; 
	Var = 1; 
	VarPar = 2; 
	Con = 3; 
	Fld = 4; 
	Typ = 5; 
	LProc = 6; 
	XProc = 7; 
	CProc = 9; 
	IProc = 10; 
	Module = 11; 
	TProc = 13; 
	Undef = 0; 
	Byte = 1; 
	Bool = 2; 
	Char = 3; 
	SInt = 4; 
	Int = 5; 
	LInt = 6; 
	Real = 7; 
	LReal = 8; 
	Set = 9; 
	String = 10; 
	NilTyp = 11; 
	NoTyp = 12; 
	Pointer = 13; 
	ProcTyp = 14; 
	Comp = 15; 
	HInt = 16; 
	Basic = 1; 
	StaticArr = 2; 
	SDynArr = 3; 
	DynArr = 4; 
	OpenArr = 5; 
	Record = 6; 
	internal = 0; 
	external = 1; 
	externalR = 2; 
	hasBody = 1; 
	slNeeded = 3; 
	activeObj = 5; 
	false = 0; 
	true = 1; 
	noEntry =  -1; 
	BUG = 41; 
	EAX = OPO.EAX; 
	ECX = OPO.ECX; 
	EDX = OPO.EDX; 
	EBX = OPO.EBX; 
	ESP = OPO.ESP; 
	EBP = OPO.EBP; 
	ESI = OPO.ESI; 
	EDI = OPO.EDI; 
	AX = OPO.AX; 
	CX = OPO.CX; 
	DX = OPO.DX; 
	BX = OPO.BX; 
	SP = OPO.SP; 
	BP = OPO.BP; 
	SI = OPO.SI; 
	DI = OPO.DI; 
	AL = OPO.AL; 
	CL = OPO.CL; 
	DL = OPO.DL; 
	BL = OPO.BL; 
	AH = OPO.AH; 
	CH = OPO.CH; 
	DH = OPO.DH; 
	BH = OPO.BH; 
	SplittableReg = {EAX, ECX, EDX, EBX, AX, CX, DX, BX}; 
	noDisp = OPO.noDisp; 
	Disp8 = OPO.Disp8; 
	Disp32 = OPO.Disp32; 
	RegSt = OPO.RegSt; 
	StReg = OPO.StReg; 
	StRegP = OPO.StRegP; 
	MemSt = OPO.MemSt; 
	Regs = RegReg; 
	Mem = MemReg; 
	Imme = ImmReg; 
	Bit8 = OPO.Bit8; 
	Bit16 = OPO.Bit16; 
	Bit32 = OPO.Bit32; 
	Bit64 = OPO.Bit64; 
	sReal = OPO.sReal; 
	lReal = OPO.lReal; 
	eReal = OPO.eReal; 
	sInt = OPO.sInt; 
	noBase = OPO.noBase; 
	noInx = OPO.noInx; 
	noImm = OPO.noImm; 
	free =  -1; 
	Occupied = MIN(INTEGER); 
	Splitted = (Occupied + 1); 
	Ror = OPO.Ror; 
	ROL = OPO.ROL; 
	RCL = OPO.RCL; 
	RCR = OPO.RCR; 
	SHL = OPO.SHL; 
	SAL = OPO.SAL; 
	SHR = OPO.SHR; 
	SAR = OPO.SAR; 
	CMPS = OPO.CMPS; 
	INS = OPO.INS; 
	LODS = OPO.LODS; 
	MOVS = OPO.MOVS; 
	OUTS = OPO.OUTS; 
	SCAS = OPO.SCAS; 
	STOS = OPO.STOS; 
	JO = OPO.JO; 
	JNO = OPO.JNO; 
	JB = OPO.JB; 
	JC = OPO.JC; 
	JNAE = OPO.JNAE; 
	JNB = OPO.JNB; 
	JNC = OPO.JNC; 
	JAE = OPO.JAE; 
	JE = OPO.JE; 
	JZ = OPO.JZ; 
	JNE = OPO.JNE; 
	JNZ = OPO.JNZ; 
	JBE = OPO.JBE; 
	JNA = OPO.JNA; 
	JNBE = OPO.JNBE; 
	JA = OPO.JA; 
	JS = OPO.JS; 
	JNS = OPO.JNS; 
	JP = OPO.JP; 
	JPE = OPO.JPE; 
	JNP = OPO.JNP; 
	JPO = OPO.JPO; 
	JL = OPO.JL; 
	JNGE = OPO.JNGE; 
	JNL = OPO.JNL; 
	JGE = OPO.JGE; 
	JLE = OPO.JLE; 
	JNG = OPO.JNG; 
	JNLE = OPO.JNLE; 
	JG = OPO.JG; 
	SETO = 0; 
	SETNO = 1; 
	SETB = 2; 
	SETNAE = 2; 
	SETAE = 3; 
	SETNB = 3; 
	SETE = 4; 
	SETZ = 4; 
	SETNE = 5; 
	SETNZ = 5; 
	SETBE = 6; 
	SETNA = 6; 
	SETNBE = 7; 
	SETA = 7; 
	SETS = 8; 
	SETNS = 9; 
	SETP = 10; 
	SETPE = 10; 
	SETNP = 11; 
	SETPO = 11; 
	SETL = 12; 
	SETNGE = 12; 
	SETNL = 13; 
	SETGE = 13; 
	SETLE = 14; 
	SETNG = 14; 
	SETNLE = 15; 
	SETG = 15; 
	ADD = OPO.ADD; 
	ADC = OPO.ADC; 
	SUB = OPO.SUB; 
	SBB = OPO.SBB; 
	CMP = OPO.CMP; 
	AND = OPO.AND; 
	Or = OPO.Or; 
	XOR = OPO.XOR; 
	FCOMPP = OPO.FCOMPP; 
	FTST = OPO.FTST; 
	FLDZ = OPO.FLDZ; 
	FLD1 = OPO.FLD1; 
	FABS = OPO.FABS; 
	FCHS = OPO.FCHS; 
	FSTSW = OPO.FSTSW; 
	FINCSTP = OPO.FINCSTP; 
	FDECSTP = OPO.FDECSTP; 
	SAHF = OPO.SAHF; 
	CLD = OPO.CLD; 
	STD = OPO.STD; 
	CBW = OPO.CBW; 
	CWD = OPO.CWD; 
	CLI = OPO.CLI; 
	STI = OPO.STI; 
	EUEnd = 0X; 
	EURecord = 1X; 
	EUProcFlag = LONGINT(2147483648); 
	notag = 1; 
	stdcall = 2; 
	cdecl = 3; 
	untraced = 4; 
	delegate = 5; 
TYPE 
	Instruction* = RECORD 
		scale*, reg*: SHORTINT; 
		op*: INTEGER; 
		dest*, src1*, src2*, inx*, pc*, hint*: LONGINT; 
		link*, used*: INTEGER; 
		node*: OPT.Node; 
		abs*: BOOLEAN; 
	END; 

	InstructionTable* = POINTER TO ARRAY OF Instruction; 

	Map* = POINTER TO MapDesc; 

	MapDesc* = ARRAY OF RECORD 
		pos*, pc*: LONGINT; 
	END; 

	LinkRec = RECORD 
		offset, mod, entry: INTEGER; 
	END; 

	VarConsRec = RECORD 
		mod: LONGINT; 
		entry, noflinks, index: INTEGER; 
	END; 

	VarConsTable = POINTER TO ARRAY OF VarConsRec; 

	VarConsLinkRec = RECORD 
		offset, next: INTEGER; 
	END; 

	VarConsLinkTable = POINTER TO ARRAY OF VarConsLinkRec; 

	SavedRegRec = RECORD 
		reg, sreg, freg: ARRAY 8 OF INTEGER; 
	END; 

	PtrTable = POINTER TO ARRAY OF LONGINT; 

	RecTable = POINTER TO ARRAY OF OPT.Struct; 

	EntryTable = POINTER TO ARRAY OF INTEGER; 

	ExpTable = POINTER TO ARRAY OF LONGINT; 

	ExTableEntry = POINTER TO RECORD 
		pcFrom, pcTo, pcHandler: LONGINT; 
		next: ExTableEntry; 
	END; 

	; 
VAR 
	Instr*: InstructionTable; 
	mapSize*: LONGINT; 
	map*: Map; 
	ptrTab: PtrTable; 
	recTab: RecTable; 
	entry: EntryTable; 
	varConsLink: VarConsTable; 
	link: ARRAY LinkLength OF LinkRec; 
	varConsTab: VarConsLinkTable; 
	nofVarCons, noVarEntries, nofEntries, nofVarConsLinks, nofLinks, nofrecs: INTEGER; 
	nofptrs: LONGINT; 
	ConstErr, RegErr, VarEntryErr, LinkErr: BOOLEAN; 
	regTab, sregTab, fregTab: ARRAY 8 OF LONGINT; 
	savedRegs: ARRAY MaxSaveLevel OF SavedRegRec; 
	nofSavedLevel: INTEGER; 
	ftop: SHORTINT; 
	trapFixupTab: ARRAY nofTrapFixups OF LONGINT; 
	JmpConvert: ARRAY ((Jnc - Je) + 1) OF SHORTINT; 
	SetccConvert: ARRAY ((Setnc - Sete) + 1) OF SHORTINT; 
	FreeRegDisp: SHORTINT; 
	exTableLen: LONGINT; 
	exTable: ExTableEntry; 
	nofStr: INTEGER; 
	linkTable*: LONGINT; 
	gVarLink*: LONGINT; 
	explist: ExpTable; 
	exppos: LONGINT; 

	PROCEDURE ^ Init*; 
	PROCEDURE ^ GetReg8(VAR reg: SHORTINT); 
	PROCEDURE ^ GetThisReg8(this: SHORTINT); 
	PROCEDURE ^ GetSplittableReg(VAR reg: SHORTINT); 
	PROCEDURE ^ GetReg(VAR reg: SHORTINT); 
	PROCEDURE ^ GetThisReg(this: SHORTINT); 
	PROCEDURE ^ AssignNewReg(pReg: LONGINT); 
	PROCEDURE ^ AssignThisReg(pReg: LONGINT; this: SHORTINT); 
	PROCEDURE ^ AssignReg(pReg: LONGINT; VAR reg, base, inx: SHORTINT); 
	PROCEDURE ^ FreeReg(reg: SHORTINT); 
	PROCEDURE ^ DecReg(reg: SHORTINT); 
	PROCEDURE ^ DecCheckReg(pReg: LONGINT; src, base, inx: SHORTINT); 
	PROCEDURE ^ loaded(pReg: LONGINT): BOOLEAN; 
	PROCEDURE ^ FindReg(pReg: LONGINT; VAR reg: SHORTINT); 
	PROCEDURE ^ FindLoadReg(pReg: LONGINT; VAR reg: SHORTINT); 
	PROCEDURE ^ LastUse(reg: SHORTINT): BOOLEAN; 
	PROCEDURE ^ FindMemReg(VAR instr: Instruction; VAR mode, scale, size, base, inx: SHORTINT; VAR disp: LONGINT); 
	PROCEDURE ^ Load(VAR instr: Instruction); 
	PROCEDURE ^ LoadProc(VAR instr: Instruction); 
	PROCEDURE ^ Store(VAR instr: Instruction); 
	PROCEDURE ^ GenPortIO(VAR instr: Instruction); 
	PROCEDURE ^ GenPush(VAR instr: Instruction); 
	PROCEDURE ^ GenPop(VAR instr: Instruction); 
	PROCEDURE ^ Gen1(VAR instr: Instruction; RiscPC: LONGINT); 
	PROCEDURE ^ Gen2(VAR instr: Instruction); 
	PROCEDURE ^ Gen3(VAR instr: Instruction); 
	PROCEDURE ^ Flags(VAR instr: Instruction); 
	PROCEDURE ^ GenAbs(VAR instr: Instruction); 
	PROCEDURE ^ GenDivMod(VAR instr: Instruction); 
	PROCEDURE ^ GenMul(VAR instr: Instruction); 
	PROCEDURE ^ GenRepMovs(VAR instr: Instruction); 
	PROCEDURE ^ GenCmpString(VAR instr: Instruction); 
	PROCEDURE ^ Setcc(VAR instr: Instruction); 
	PROCEDURE ^ GenTrap(trapNr: LONGINT); 
	PROCEDURE ^ GenTrapCC(VAR instr: Instruction); 
	PROCEDURE ^ FixupAndGenTrap; 
	PROCEDURE ^ GenShort(VAR instr: Instruction); 
	PROCEDURE ^ GenPhi(VAR instr: Instruction); 
	PROCEDURE ^ GetFreg(VAR freg: SHORTINT); 
	PROCEDURE ^ FreeFreg(freg: SHORTINT); 
	PROCEDURE ^ ReleaseFreg(freg: SHORTINT); 
	PROCEDURE ^ AssignFreg(pReg: LONGINT); 
	PROCEDURE ^ TakeFreg(pReg: LONGINT; freg: SHORTINT); 
	PROCEDURE ^ FindFreg(pReg: LONGINT; VAR freg: SHORTINT); 
	PROCEDURE ^ LastUseF(freg: SHORTINT): BOOLEAN; 
	PROCEDURE ^ DecCheckFreg(freg: SHORTINT); 
	PROCEDURE ^ Fload(VAR instr: Instruction); 
	PROCEDURE ^ Fstore(VAR instr: Instruction); 
	PROCEDURE ^ FloatGen1(VAR instr: Instruction); 
	PROCEDURE ^ FloatGen3(VAR instr: Instruction); 
	PROCEDURE ^ FloatCmp(VAR instr: Instruction); 
	PROCEDURE ^ AddExceptionHandler(pcFrom, pcTo, pcHandler: LONGINT); 
	PROCEDURE ^ GenFinally(VAR instr: Instruction); 
	PROCEDURE ^ GenEntier(VAR instr: Instruction); 
	PROCEDURE ^ ClearSDynArr(VAR instr: Instruction); 
	PROCEDURE ^ GenEnter(locSize: LONGINT; locals: OPT.Object; sysflag: SHORTINT); 
	PROCEDURE ^ GenLeave(sysflag: SHORTINT); 
	PROCEDURE ^ PushRegs; 
	PROCEDURE ^ PopRegs(VAR instr: Instruction); 
	PROCEDURE ^ FixupJcc(label: LONGINT); 
	PROCEDURE ^ FixupCaseTab(VAR instr: Instruction); 
	PROCEDURE ^ EncodeFixup(i: LONGINT); 
	PROCEDURE ^ GenAsm(instr: Instruction); 
	PROCEDURE ^ GenCode*(pSize: INTEGER); 
	PROCEDURE ^ FixupLocalProcCall*(proc: OPT.Object); 
	PROCEDURE ^ NewVarCons*(mod: LONGINT; entry: INTEGER; VAR index: LONGINT); 
	PROCEDURE ^ VarConsLink(index, offset: LONGINT); 
	PROCEDURE ^ AbsAccess(node: OPT.Node; offset: LONGINT); 
	PROCEDURE ^ NewEntry*(VAR entryNr: LONGINT); 
	PROCEDURE ^ NewLink*(mod, entry: LONGINT; VAR index: LONGINT); 
	PROCEDURE ^ AddLink(index, offset: LONGINT); 
	PROCEDURE ^ AllocConst*(VAR s: ARRAY OF SYSTEM.BYTE; len, align: LONGINT; VAR adr: LONGINT); 
	PROCEDURE ^ AllocCaseTab*(low, high: LONGINT; VAR tab: LONGINT); 
	PROCEDURE ^ AllocTypDesc*(typ: OPT.Struct); 
	PROCEDURE ^ CaseJump*(Label, tab, from, to: LONGINT); 
	PROCEDURE ^ OutRefPoint*(proc: OPT.Object); 
	PROCEDURE ^ OutRefName*(name: ARRAY OF CHAR); 
	PROCEDURE ^ OutRefs*(obj: OPT.Object); 
	PROCEDURE ^ LSW(x: LONGINT): LONGINT; 
	PROCEDURE ^ Export(obj: OPT.Object; VAR nofExp: INTEGER); 
	PROCEDURE ^ Use(obj: OPT.Object); 
	PROCEDURE ^ OutCode*(VAR modName: ARRAY OF CHAR); 
	PROCEDURE ^ Close*; 
BEGIN
END OPL.
