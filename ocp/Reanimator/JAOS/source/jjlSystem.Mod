(* Jaos, Copyright 2003, Patrik Reali, ETH Zurich *)MODULE jjlSystem;	(*automatically generated stub for java/lang/System *)	(*WARNING: DON'T CHANGE THE PROCEDURE NAMES*)IMPORT		SYSTEM, AosKernel,		JT := JVMTypes, JB := JVMBase, JS := JVMSystem, jjlObject, jjiInputStream, jjlString;TYPE	Object = jjlObject.Object;	Properties = Object;	InputStream = jjiInputStream.InputStream;	SecurityManager = Object;	String = jjlString.String;	CharArray=jjlObject.CharArray;	ByteArray=jjlObject.ByteArray;	ShortArray=jjlObject.ShortArray;	IntArray=jjlObject.IntArray;	LongArray=jjlObject.LongArray;	FloatArray=jjlObject.FloatArray;	DoubleArray=jjlObject.DoubleArray;	BoolArray=jjlObject.BoolArray;	RefArray = jjlObject.RefArray;TYPE	System* = OBJECT (Object)		PROCEDURE init();   (* <init>()V *)		BEGIN	(* DON'T IMPLEMENT THIS METHOD *)		END init;	END System;VAR(*	moved to runtime	defaultProperties-: Properties;*)	properties-: Properties;	in-: InputStream;	out-: Object;	err-: Object;	(*	moved to VMSystem	PROCEDURE setIn0(p0: InputStream);   (* setIn0(Ljava/io/InputStream;)V *)	BEGIN	(* put your implementation here *)		in := p0	END setIn0;	PROCEDURE setOut0(p0: Object);   (* setOut0(Ljava/io/PrintStream;)V *)	BEGIN	(* put your implementation here *)		out := p0	END setOut0;	PROCEDURE setErr0(p0: Object);   (* setErr0(Ljava/io/PrintStream;)V *)	BEGIN	(* put your implementation here *)		err := p0	END setErr0;*)	PROCEDURE currentTimeMillis*(): JT.Long;   (* currentTimeMillis()J *)	BEGIN		RETURN AosKernel.GetTimer( );	END currentTimeMillis;	PROCEDURE setIn*(p0: InputStream);   (* setIn(Ljava/io/InputStream;)V *)	BEGIN	(* DON'T IMPLEMENT THIS METHOD *)	END setIn;	PROCEDURE setOut*(p0: Object);   (* setOut(Ljava/io/PrintStream;)V *)	BEGIN	(* DON'T IMPLEMENT THIS METHOD *)	END setOut;	PROCEDURE setErr*(p0: Object);   (* setErr(Ljava/io/PrintStream;)V *)	BEGIN	(* DON'T IMPLEMENT THIS METHOD *)	END setErr;	PROCEDURE getSecurityManager*(): SecurityManager;   (* getSecurityManager()Ljava/lang/SecurityManager; *)	BEGIN	(* DON'T IMPLEMENT THIS METHOD *)	END getSecurityManager;	PROCEDURE CopyRefArray( src : RefArray; start1 : LONGINT; dest : RefArray; start2, len : LONGINT );	VAR sadr, dadr, i : LONGINT;		cls1, cls2 : Object; 	BEGIN		jjlObject.Assert( (LEN(src.p^)>=(start1+len)) & (LEN(dest.p^)>=(start2+len)),									"java/lang/ArrayIndexOutOfBoundsException", "arraycopy()" );																	sadr := SYSTEM.ADR( src.p[start1] ); dadr := SYSTEM.ADR( dest.p[start2] );		IF (sadr < dadr) & (src=dest) THEN			FOR i := 1 TO len  DO 				IF (src.p[start1+len-i] = NIL) THEN				    	dest.p[start2+len-i] := src.p[start1+len-i]								ELSE					 					cls1 := dest.getClass();					cls2 := src.p[start1+len-i].getClass();					jjlObject.Assert( cls1(JB.ArrayClass).ctype.isAssignableFrom( cls2(JB.Class) ), 								   "java/lang/ArrayStoreException", "arraycopy()" );					dest.p[start2+len-i] := src.p[start1+len-i]				END			END		ELSE			FOR i := 0 TO len -1 DO				IF src.p[start1+i]=NIL THEN					dest.p[start2+i] := src.p[start1+i]				ELSE					cls1 := dest.getClass();					cls2 := src.p[start1+i].getClass();					jjlObject.Assert( cls1(JB.ArrayClass).ctype.isAssignableFrom( cls2(JB.Class) ), 								   "java/lang/ArrayStoreException", "arraycopy()" );					dest.p[start2+i] := src.p[start1+i]						   				END					END					END	END CopyRefArray;		PROCEDURE CopyByteArray( src : ByteArray; start1 : LONGINT; dest : ByteArray; start2, len : LONGINT );		VAR sadr, dadr, i : LONGINT;	BEGIN		jjlObject.Assert( (LEN(src.p^)>=(start1+len)) & (LEN(dest.p^)>=(start2+len)),									"java/lang/ArrayIndexOutOfBoundsException", "arraycopy()" );		sadr := SYSTEM.ADR( src.p[start1] ); dadr := SYSTEM.ADR( dest.p[start2] );		IF (sadr < dadr) & (src=dest) THEN			FOR i := 1 TO len  DO dest.p[start2+len-i] := src.p[start1+len-i] END		ELSE			SYSTEM.MOVE( sadr, dadr, len )		END	END CopyByteArray;		PROCEDURE CopyShortArray( src : ShortArray; start1 : LONGINT; dest : ShortArray; start2, len : LONGINT );	VAR sadr, dadr, i : LONGINT;	BEGIN		jjlObject.Assert( (LEN(src.p^)>=(start1+len)) & (LEN(dest.p^)>=(start2+len)),									"java/lang/ArrayIndexOutOfBoundsException", "arraycopy()" );		sadr := SYSTEM.ADR( src.p[start1] ); dadr := SYSTEM.ADR( dest.p[start2] );		IF (sadr < dadr) & (src=dest) THEN			FOR i := 1 TO len  DO dest.p[start2+len-i] := src.p[start1+len-i] END		ELSE			SYSTEM.MOVE( sadr, dadr, len*2 )		END	END CopyShortArray;		PROCEDURE CopyCharArray( src : CharArray; start1 : LONGINT; dest : CharArray; start2, len : LONGINT );	VAR sadr, dadr, i : LONGINT;	BEGIN				jjlObject.Assert( (LEN(src.p^)>=(start1+len)) & (LEN(dest.p^)>=(start2+len)),									"java/lang/ArrayIndexOutOfBoundsException", "arraycopy()" );		sadr := SYSTEM.ADR( src.p[start1] ); dadr := SYSTEM.ADR( dest.p[start2] );		IF (sadr < dadr) & (src=dest) THEN			FOR i := 1 TO len  DO dest.p[start2+len-i] := src.p[start1+len-i] END		ELSE						SYSTEM.MOVE( sadr, dadr, len*2 )		END	END CopyCharArray;		PROCEDURE CopyBoolArray( src : BoolArray; start1 : LONGINT; dest : BoolArray; start2, len : LONGINT );	VAR sadr, dadr, i : LONGINT;	BEGIN		jjlObject.Assert( (LEN(src.p^)>=(start1+len)) & (LEN(dest.p^)>=(start2+len)),									"java/lang/ArrayIndexOutOfBoundsException", "arraycopy()" );		sadr := SYSTEM.ADR( src.p[start1] ); dadr := SYSTEM.ADR( dest.p[start2] );		IF (sadr < dadr) & (src=dest) THEN			FOR i := 1 TO len  DO dest.p[start2+len-i] := src.p[start1+len-i] END		ELSE			SYSTEM.MOVE( sadr, dadr, len )		END	END CopyBoolArray;		PROCEDURE CopyIntArray( src : IntArray; start1 : LONGINT; dest : IntArray; start2, len : LONGINT );	VAR sadr, dadr, i : LONGINT;	BEGIN		jjlObject.Assert( (LEN(src.p^)>=(start1+len)) & (LEN(dest.p^)>=(start2+len)),									"java/lang/ArrayIndexOutOfBoundsException", "arraycopy()" );		sadr := SYSTEM.ADR( src.p[start1] ); dadr := SYSTEM.ADR( dest.p[start2] );		IF (sadr < dadr) & (src=dest) THEN			FOR i := 1 TO len  DO dest.p[start2+len-i] := src.p[start1+len-i] END		ELSE			SYSTEM.MOVE( sadr, dadr, len*4 )		END	END CopyIntArray;		PROCEDURE CopyLongArray( src : LongArray; start1 : LONGINT; dest : LongArray; start2, len : LONGINT );	VAR sadr, dadr, i : LONGINT;	BEGIN		jjlObject.Assert( (LEN(src.p^)>=(start1+len)) & (LEN(dest.p^)>=(start2+len)),									"java/lang/ArrayIndexOutOfBoundsException", "arraycopy()" );		sadr := SYSTEM.ADR( src.p[start1] ); dadr := SYSTEM.ADR( dest.p[start2] );		IF (sadr < dadr) & (src=dest) THEN			FOR i := 1 TO len  DO dest.p[start2+len-i] := src.p[start1+len-i] END		ELSE			SYSTEM.MOVE( sadr, dadr, len*8 )		END	END CopyLongArray;		PROCEDURE CopyFloatArray( src : FloatArray; start1 : LONGINT; dest : FloatArray; start2, len : LONGINT );	VAR sadr, dadr, i : LONGINT;	BEGIN		jjlObject.Assert( (LEN(src.p^)>=(start1+len)) & (LEN(dest.p^)>=(start2+len)),									"java/lang/ArrayIndexOutOfBoundsException", "arraycopy()" );		sadr := SYSTEM.ADR( src.p[start1] ); dadr := SYSTEM.ADR( dest.p[start2] );		IF (sadr < dadr) & (src=dest) THEN			FOR i := 1 TO len  DO dest.p[start2+len-i] := src.p[start1+len-i] END		ELSE			SYSTEM.MOVE( sadr, dadr, len*4 )		END	END CopyFloatArray;		PROCEDURE CopyDoubleArray( src : DoubleArray; start1 : LONGINT; dest : DoubleArray; start2, len : LONGINT );	VAR sadr, dadr, i : LONGINT;	BEGIN		jjlObject.Assert( (LEN(src.p^)>=(start1+len)) & (LEN(dest.p^)>=(start2+len)),									"java/lang/ArrayIndexOutOfBoundsException", "arraycopy()" );		sadr := SYSTEM.ADR( src.p[start1] ); dadr := SYSTEM.ADR( dest.p[start2] );		IF (sadr < dadr) & (src=dest) THEN			FOR i := 1 TO len  DO dest.p[start2+len-i] := src.p[start1+len-i] END		ELSE			SYSTEM.MOVE( sadr, dadr, len*8 )		END	END CopyDoubleArray;		PROCEDURE arraycopy*( src: Object; start1: JT.Int; dest: Object; start2: JT.Int; len: JT.Int);   (* arraycopy(Ljava/lang/Object;ILjava/lang/Object;II)V *)		(*override java!*)	BEGIN			jjlObject.Assert( (src#NIL) & (dest#NIL), "java/lang/NullPointerException", "arraycopy()" );				IF (len=0) THEN RETURN END; 		IF (src IS RefArray) & (dest IS RefArray) THEN 			CopyRefArray( src(RefArray), start1, dest(RefArray), start2, len )							ELSIF (src IS CharArray) & (dest IS CharArray) THEN 			CopyCharArray( src(CharArray), start1,  dest(CharArray) ,start2, len )							ELSIF (src IS ByteArray) & (dest IS ByteArray ) THEN 			CopyByteArray( src(ByteArray), start1, dest(ByteArray), start2, len);					ELSIF (src IS ShortArray) & (dest IS ShortArray ) THEN 			CopyShortArray( src(ShortArray), start1, dest(ShortArray), start2, len )						ELSIF (src IS IntArray) & (dest IS IntArray) THEN 			CopyIntArray( src(IntArray), start1, dest(IntArray), start2, len )						ELSIF (src IS LongArray) & (dest IS LongArray ) THEN ;			CopyLongArray( src(LongArray), start1, dest(LongArray), start2, len )						ELSIF (src IS FloatArray) & (dest IS FloatArray ) THEN 			CopyFloatArray( src(FloatArray), start1, dest(FloatArray), start2, len )					ELSIF (src IS DoubleArray) & (dest IS DoubleArray ) THEN 			CopyDoubleArray( src(DoubleArray), start1, dest(DoubleArray), start2, len )		ELSIF (src IS BoolArray) & (dest IS BoolArray ) THEN 			CopyBoolArray( src(BoolArray), start1, dest(BoolArray), start2, len )		ELSE			jjlObject.Assert( FALSE, "java/lang/ArrayStoreException", "arraycopy" )		END		END arraycopy;	PROCEDURE identityHashCode*(p0: Object): JT.Int;   (* identityHashCode(Ljava/lang/Object;)I *)		(*override java!*)	BEGIN  RETURN SYSTEM.VAL(JT.Int, p0)	END identityHashCode;	PROCEDURE getProperties*(): Properties;   (* getProperties()Ljava/util/Properties; *)	BEGIN	(* DON'T IMPLEMENT THIS METHOD *)	END getProperties;	PROCEDURE setProperties*(p0: Properties);   (* setProperties(Ljava/util/Properties;)V *)	BEGIN	(* DON'T IMPLEMENT THIS METHOD *)	END setProperties;	PROCEDURE setProperty*(p0: String; p1: String): String;   (* setProperty(Ljava/lang/String;Ljava/lang/String;)Ljava/lang/String; *)	BEGIN	(* DON'T IMPLEMENT THIS METHOD *)	END setProperty;	PROCEDURE getProperty2037*(p0: String): String;   (* getProperty(Ljava/lang/String;)Ljava/lang/String; *)	BEGIN	(* DON'T IMPLEMENT THIS METHOD *)	END getProperty2037;	PROCEDURE getProperty2425*(p0: String; p1: String): String;   (* getProperty(Ljava/lang/String;Ljava/lang/String;)Ljava/lang/String; *)	BEGIN	(* DON'T IMPLEMENT THIS METHOD *)	END getProperty2425;	PROCEDURE getenv*(p0: String): String;   (* getenv(Ljava/lang/String;)Ljava/lang/String; *)	BEGIN	(* DON'T IMPLEMENT THIS METHOD *)	END getenv;	PROCEDURE exit*(p0: JT.Int);   (* exit(I)V *)	BEGIN	(* DON'T IMPLEMENT THIS METHOD *)	END exit;	PROCEDURE gc*();   (* gc()V *)	BEGIN	(* DON'T IMPLEMENT THIS METHOD *)	END gc;	PROCEDURE runFinalization*();   (* runFinalization()V *)	BEGIN	(* DON'T IMPLEMENT THIS METHOD *)	END runFinalization;	PROCEDURE runFinalizersOnExit*(p0: BOOLEAN);   (* runFinalizersOnExit(Z)V *)	BEGIN	(* DON'T IMPLEMENT THIS METHOD *)	END runFinalizersOnExit;	PROCEDURE load*(p0: String);   (* load(Ljava/lang/String;)V *)	BEGIN	(* DON'T IMPLEMENT THIS METHOD *)	END load;	PROCEDURE loadLibrary*(p0: String);   (* loadLibrary(Ljava/lang/String;)V *)	BEGIN	(* DON'T IMPLEMENT THIS METHOD *)	END loadLibrary;		PROCEDURE setSecurityManager*(p0: SecurityManager);   (* setSecurityManager(Ljava/lang/SecurityManager;)V *)	BEGIN	(* DON'T IMPLEMENT THIS METHOD *)	END setSecurityManager;	PROCEDURE clinit();   (* <clinit>()V *)	BEGIN	(* DON'T IMPLEMENT THIS METHOD *)	END clinit;	PROCEDURE mapLibraryName*(p0: String): String;   (* mapLibraryName(Ljava/lang/String;)Ljava/lang/String; *)	BEGIN	(* DON'T IMPLEMENT THIS METHOD *)	END mapLibraryName;END jjlSystem.(*	12.02.03	prk	Logging functions, use same interface as AosOut	29.12.02	prk	update to classpath snapshot 28.12.02	09.05.01	prk	removing unneeded oberon methods overwriting java methods	11.04.01	prk	update to classpath 0.02	04.04.01	prk	merge with classpath-0.00 release, prepare for update with 0.01, minimize differencies*)