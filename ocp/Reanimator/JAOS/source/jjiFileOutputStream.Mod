(* Jaos, Copyright 2003, Patrik Reali, ETH Zurich *)MODULE jjiFileOutputStream;	(*automatically generated stub for java/io/FileOutputStream *)	(*WARNING: DON'T CHANGE THE PROCEDURE NAMES*)IMPORT		JC := JVMConsole, JT := JVMTypes,		jjlObject, jjlString,		jjiFileDescriptor, jjiFile, jjiOutputStream;(*		SYSTEM, AosFS,		JT := JVMTypes, jjiOutputStream, jjiFile, jjiFileDescriptor, jjlString, jjlObject, JC := JVMConsole;*)(*TYPE	OutputStream = jjiOutputStream.OutputStream;	File = jjiFile.File;	FileDescriptor = jjiFileDescriptor.FileDescriptor;	String = jjlString.String;	ByteArray = jjlObject.ByteArray;	Bytes = ARRAY MAX(LONGINT) OF CHAR;	Chars = ARRAY OF CHAR;*)VAR	infoInfo: JC.LoggingInfo;TYPE	FileOutputStream* = OBJECT (jjiOutputStream.OutputStream)		VAR			fd-: jjiFileDescriptor.FileDescriptor;			ch-: PTR (*java/nio/channels/FileChannel.Class*);			nativefd-: LONGINT;		PROCEDURE init8336*(p0: jjiFile.File);   (* <init>(Ljava/io/File;)V *)		BEGIN	(* DON'T IMPLEMENT THIS METHOD *)		END init8336;		PROCEDURE init7423*(p0: jjiFile.File; p1: BOOLEAN);   (* <init>(Ljava/io/File;Z)V *)		BEGIN	(* DON'T IMPLEMENT THIS METHOD *)		END init7423;		PROCEDURE init646*(p0: jjiFileDescriptor.FileDescriptor);   (* <init>(Ljava/io/FileDescriptor;)V *)		BEGIN	(* DON'T IMPLEMENT THIS METHOD *)		END init646;		PROCEDURE init1930*(p0: jjlString.String);   (* <init>(Ljava/lang/String;)V *)		BEGIN	(* DON'T IMPLEMENT THIS METHOD *)		END init1930;		PROCEDURE init4072*(p0: jjlString.String; p1: BOOLEAN);   (* <init>(Ljava/lang/String;Z)V *)		BEGIN	(* DON'T IMPLEMENT THIS METHOD *)		END init4072;		PROCEDURE close*();   (* close()V *)		BEGIN	(* DON'T IMPLEMENT THIS METHOD *)		END close;		PROCEDURE finalize();   (* finalize()V *)		BEGIN	(* DON'T IMPLEMENT THIS METHOD *)		END finalize;		PROCEDURE getChannel*(): PTR (*jjncFileChannel.Class*);   (* getChannel()Ljava/nio/channels/FileChannel; *)		BEGIN	(* DON'T IMPLEMENT THIS METHOD *)		END getChannel;		PROCEDURE getFD*(): jjiFileDescriptor.FileDescriptor;   (* getFD()Ljava/io/FileDescriptor; *)		BEGIN	(* DON'T IMPLEMENT THIS METHOD *)		END getFD;		PROCEDURE write96*(p0: JT.Int);   (* write(I)V *)		BEGIN	(* DON'T IMPLEMENT THIS METHOD *)		END write96;		PROCEDURE write340*(p0: jjlObject.ByteArray);   (* write([B)V *)		BEGIN	(* DON'T IMPLEMENT THIS METHOD *)		END write340;		PROCEDURE write1576*(p0: jjlObject.ByteArray; p1: JT.Int; p2: JT.Int);   (* write([BII)V *)		BEGIN	(* DON'T IMPLEMENT THIS METHOD *)		END write1576;	END FileOutputStream;(*TYPE	FileOutputStream* = OBJECT (OutputStream)		VAR			nativefd-: LONGINT;			ch-: PTR;		PROCEDURE init8336*(p0: File);   (* <init>(Ljava/io/File;)V *)		BEGIN	(* DON'T IMPLEMENT THIS METHOD *)		END init8336;		PROCEDURE init646*(p0: FileDescriptor);   (* <init>(Ljava/io/FileDescriptor;)V *)		BEGIN	(* DON'T IMPLEMENT THIS METHOD *)		END init646;		PROCEDURE init1930*(p0: String);   (* <init>(Ljava/lang/String;)V *)		BEGIN	(* DON'T IMPLEMENT THIS METHOD *)		END init1930;		PROCEDURE init4072*(p0: String; p1: BOOLEAN);   (* <init>(Ljava/lang/String;Z)V *)		BEGIN	(* DON'T IMPLEMENT THIS METHOD *)		END init4072;		PROCEDURE close*();   (* close()V *)		BEGIN	(* DON'T IMPLEMENT THIS METHOD *)		END close;		PROCEDURE closeInternal(p0: JT.Int);   (* closeInternal(I)V *)			VAR file: AosFS.File;		BEGIN	(* put your implementation here *)			IF (p0 < 0) OR (p0 > 2) THEN				file := jjiFileDescriptor.FileTable[p0].file;				jjiFileDescriptor.Release(p0);				file.Update();				AosFS.Register(file);			END;		END closeInternal;		PROCEDURE getChannel*(): PTR;   (* getChannel()Ljava/nio/channels/FileChannel; *)		BEGIN	(* DON'T IMPLEMENT THIS METHOD *)		END getChannel;		PROCEDURE finalize();   (* finalize()V *)		BEGIN	(* DON'T IMPLEMENT THIS METHOD *)		END finalize;		PROCEDURE getFD*(): FileDescriptor;   (* getFD()Ljava/io/FileDescriptor; *)		BEGIN	(* DON'T IMPLEMENT THIS METHOD *)		END getFD;		PROCEDURE this();   (* this()V *)		BEGIN	(* DON'T IMPLEMENT THIS METHOD *)		END this;		PROCEDURE open(p0: String; p1: BOOLEAN): JT.Int;   (* open(Ljava/lang/String;Z)I *)			VAR str: ARRAY 256 OF CHAR; f: AosFS.File;		BEGIN	(* put your implementation here *)			jjiFile.ConvertName(p0, str);			JC.String(infoInfo, "FileOutputStream.open "); JC.String(infoInfo, str); JC.Ln(infoInfo);			f := AosFS.Old(str);			IF f = NIL THEN f := AosFS.New(str) END;			RETURN jjiFileDescriptor.Allocate(f, 0)		END open;		PROCEDURE write96*(p0: JT.Int);   (* write(I)V *)		BEGIN	(* DON'T IMPLEMENT THIS METHOD *)		END write96;		PROCEDURE write340*(p0: ByteArray);   (* write([B)V *)		BEGIN	(* DON'T IMPLEMENT THIS METHOD *)		END write340;		PROCEDURE write1576*(p0: ByteArray; p1: JT.Int; p2: JT.Int);   (* write([BII)V *)		BEGIN	(* DON'T IMPLEMENT THIS METHOD *)		END write1576;		PROCEDURE writeInternal(p0: JT.Int; buf: ByteArray; off, count: JT.Int);   (* writeInternal(I[BII)V *)			VAR file: AosFS.File;		BEGIN	(* put your implementation here *)			ASSERT(p0 = SYSTEM.VAL(LONGINT, nativefd));			IF (p0 = 1) OR (p0 = 2) THEN				ASSERT(LEN(buf.p^) >= off+count);				JC.WriteBytes(SYSTEM.VAL(Chars, buf.p^), off, count)			ELSE				file := jjiFileDescriptor.FileTable[p0].file;				file.WriteBytes(jjiFileDescriptor.FileTable[p0], SYSTEM.VAL(Bytes, buf.p^), off, count)			END		END writeInternal;	END FileOutputStream;	PROCEDURE clinit();   (* <clinit>()V *)	BEGIN	(* DON'T IMPLEMENT THIS METHOD *)	END clinit;*)BEGIN	infoInfo.kind := JC.Info; infoInfo.source := JC.Streams;END jjiFileOutputStream.(*	11.01.04	prk	update to classpath 0.06	30.07.03	prk	Logging functions, add kind and source; filtering support	12.02.03	prk	Logging functions, use same interface as AosOut	16.10.01	prk	classpath update and file redesign	16.09.01	prk	console redesign; input implemented; JVMByteBuffer removed	10.07.01	prk	switched to AosFS	11.04.01	prk	update to classpath 0.02*)		