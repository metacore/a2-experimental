(* Jaos, Copyright 2003, Patrik Reali, ETH Zurich *)MODULE JVM;	(** prk, rl **)	(*automatically generated stub for java/lang/Runtime *)(*		The Core of the virtual machine*)IMPORT		PCDebug,		SYSTEM, AosKernel, AosMemory, AosHeap, AosModules, AosActive, AosIO, AosFS,		AosCommands,		StringPool, PCT, PCBT, PC0,		Refs := JVMRefs,		JE := JVMExceptions, jjlObject, jjlString, jjlThrowable, JVMThreads,		JT := JVMTypes, JB := JVMBase,  JS := JVMSystem, JI := JVMInterfaces,		JVMLoader, JVMLinker, JVMRefs,		JC0 := JVMCompiler0, JVMCompiler, JVMOptCompiler,		jjlSystem,		JC := JVMConsole,		jjiFileDescriptor, jjiInputStream, jjiOutputStream,				(* Applet Support *)		WebHTTPClient, WebHTTP, AosTCP;CONST	EnableExceptions = JE.EnableExceptions;	ReleaseMemory* = FALSE;		CheckInitializedOptimization = TRUE;	TYPE	Object = jjlObject.Object;	String = jjlString.String;	Process = jjlObject.Object;	RefArray = jjlObject.RefArray;	ByteArray = jjlObject.ByteArray;	InputStream = jjiInputStream.InputStream;	OutputStream = jjiOutputStream.OutputStream;	Thread = JVMThreads.Thread;	File = Object;	Set = Object;	SecurityManager = Object;TYPE	CompilerInitProc* = PROCEDURE (s: PCT.ModScope);	CompileMethodProc* = PROCEDURE (c: JB.RefClass; i: LONGINT; code: JB.ACodeInfo; VAR offset: LONGINT; VAR map: JB.Map);	JITPlugin = RECORD		Init-: CompilerInitProc;		Compile-: CompileMethodProc;	END;VAR	debugInfo, infoInfo, statusInfo, errorInfo, failureInfo: JC.LoggingInfo;	firstRun: BOOLEAN;	traceMethods*: BOOLEAN;		JIT-: ARRAY 2 OF JITPlugin;	curJIT*, nofJIT-: LONGINT;	TYPE	(* ReaderStream - wrap an AosIO.Reader in a java InputStream; used for reading streams from the net *)	ReaderStream = OBJECT (InputStream)		VAR			reader: AosIO.Reader;				PROCEDURE init*();   (* <init>()V *)		BEGIN	(* DON'T IMPLEMENT THIS METHOD *)		END init;		PROCEDURE available*(): JT.Int;   (* available()I *)		BEGIN	(* DON'T IMPLEMENT THIS METHOD *)		END available;		PROCEDURE close*();   (* close()V *)		BEGIN	(* DON'T IMPLEMENT THIS METHOD *)		END close;		PROCEDURE mark*(p0: JT.Int);   (* mark(I)V *)		BEGIN	(* DON'T IMPLEMENT THIS METHOD *)		END mark;		PROCEDURE markSupported*(): BOOLEAN;   (* markSupported()Z *)		BEGIN	(* DON'T IMPLEMENT THIS METHOD *)		END markSupported;		PROCEDURE read187*(): JT.Int;   (* read()I *)			VAR ch: CHAR;		BEGIN	(* DON'T IMPLEMENT THIS METHOD *)			AosIO.Read(reader, ch);			RETURN ORD(ch)		END read187;		PROCEDURE read331*(p0: ByteArray): JT.Int;   (* read([B)I *)		BEGIN	(* DON'T IMPLEMENT THIS METHOD *)		END read331;		PROCEDURE read1591*(p0: ByteArray; p1: JT.Int; p2: JT.Int): JT.Int;   (* read([BII)I *)		BEGIN	(* DON'T IMPLEMENT THIS METHOD *)		END read1591;		PROCEDURE reset*();   (* reset()V *)		BEGIN	(* DON'T IMPLEMENT THIS METHOD *)		END reset;		PROCEDURE skip*(p0: JT.Long): JT.Long;   (* skip(J)J *)		BEGIN	(* DON'T IMPLEMENT THIS METHOD *)		END skip;				PROCEDURE readByteArray*(VAR buf: ARRAY OF CHAR; off, count: LONGINT): LONGINT;			VAR len: LONGINT;		BEGIN			AosIO.ReadBytes(reader, buf, off, count, len);			RETURN len		END readByteArray;	END ReaderStream;	FrameFactoryParameters* = OBJECT		VAR			w*, h*: LONGINT;						PROCEDURE & Init(w, h: LONGINT);			BEGIN				SELF.w := w; SELF.h := h;			END Init;	END FrameFactoryParameters;(* this is the thread in which the java Programms are running *)	MainThread = OBJECT (JVMThreads.Thread)		VAR			main: JB.Method;			args: RefArray;			PROCEDURE & Init(class, method, signature: ARRAY OF CHAR; args: RefArray);		VAR cls: JB.Class;		BEGIN			SELF.class := JVMThreads.class;			cls := JB.ThisClass0(class, TRUE);			CheckInitialized(cls(JB.ObjectClass));			main := cls.getMethodWithNameAndDesc0(method, signature);			jjlObject.Assert(main#NIL, "java/lang/NoSuchMethodException", "public static void main(String[] args)");			ASSERT(main.offset # 0);			SELF.args := args;			ASSERT(threadGroup # NIL);			ASSERT(~JB.DontRun);			init3900(threadGroup, NIL);			start		END Init;				PROCEDURE run;		VAR dummy: Object;					PROCEDURE HandleException(ex : jjlThrowable.Throwable);			VAR ref : Refs.Ref; topmost, pc, i : LONGINT; mod : AosModules.Module;			BEGIN (* at this time the JSystem.out may not be available *)						(* this should be in ex.printStackTrace() but i'm not very sure in which module						    to implement it since it needs PrintStream and print writer. For now this						    helps to find errors *)				JVMThreads.KillAll();				mod := AosModules.ThisModuleByAdr(ex.pc);				IF mod # NIL THEN 					ref := Refs.FindRefForAdr(mod, pc);									IF (ref#NIL) THEN						JC.WriteString(mod.name);						JC.WriteString("  pc = "); JC.WriteInt(pc - SYSTEM.ADR(mod.code[0]));						JC.WriteString("  "); JC.WriteString(ref.name);						JC.WriteLn;					END				END;										IF ex.stack#NIL THEN					JE.NextStackFrameRef(ex.stack^, ex.stackstart, topmost, pc, mod, ref);					WHILE (mod#NIL) & (ref#NIL) DO						JC.WriteString(mod.name);						JC.WriteString("  pc = "); JC.WriteInt(pc - SYSTEM.ADR(mod.code[0]));						JC.WriteLn;						JE.NextStackFrameRef(ex.stack^, ex.stackstart, topmost, pc, mod, ref)					END				END			END HandleException;					BEGIN			IF EnableExceptions THEN AosActive.SetExceptionHandler(JE.HandleException)  END;			JS.InitFPU; (* the java environment runs in FPU default mode=> all Exceptions masked round to nearest *)(*			IF EnableExceptions THEN JE.InstallOberonExHandler("JVM", "MainThread.run", "HandleException", NIL, jjlThrowable.IHandleIt)  END;*)			dummy := main.invokeNative(NIL, args, NIL, 0);		END run;			END MainThread;	Runtime* = OBJECT (Object)		VAR			(* fields used by java/lang/Runtime *)			libpath-: RefArray; 			(* String[] libpath *)			exitSequence-: Thread;	(* private Thread exitSequence *)			shutdownHooks-: Set;		(* private Set shutdownHooks *)		PROCEDURE init();   (* <init>()V *)		BEGIN	(* DON'T IMPLEMENT THIS METHOD *)		END init;		PROCEDURE addShutdownHook*(p0: Thread);   (* addShutdownHook(Ljava/lang/Thread;)V *)		BEGIN	(* DON'T IMPLEMENT THIS METHOD *)		END addShutdownHook;		PROCEDURE availableProcessors*(): JT.Int;   (* availableProcessors()I *)		BEGIN	(* put your implementation here *)			JC.String(failureInfo, "Runtime.availableProcessors not implented"); JC.Ln(failureInfo);(*			RETURN AosProcessors.numProcessors*)		END availableProcessors;		PROCEDURE exec1092*(p0: String): Process;   (* exec(Ljava/lang/String;)Ljava/lang/Process; *)		BEGIN	(* DON'T IMPLEMENT THIS METHOD *)		END exec1092;		PROCEDURE exec4470*(p0: String; p1: RefArray): Process;   (* exec(Ljava/lang/String;[Ljava/lang/String;)Ljava/lang/Process; *)		BEGIN	(* DON'T IMPLEMENT THIS METHOD *)		END exec4470;		PROCEDURE exec974*(p0: String; p1: RefArray; p2: File): Process;   (* exec(Ljava/lang/String;[Ljava/lang/String;Ljava/io/File;)Ljava/lang/Process; *)		BEGIN	(* DON'T IMPLEMENT THIS METHOD *)		END exec974;		PROCEDURE exec3828*(p0: RefArray): Process;   (* exec([Ljava/lang/String;)Ljava/lang/Process; *)		BEGIN	(* DON'T IMPLEMENT THIS METHOD *)		END exec3828;			PROCEDURE exec2870*(p0: RefArray; p1: RefArray): Process;   (* exec([Ljava/lang/String;[Ljava/lang/String;)Ljava/lang/Process; *)		BEGIN	(* DON'T IMPLEMENT THIS METHOD *)		END exec2870;		PROCEDURE exec8452*(p0: RefArray; p1: RefArray; p2: File): Process;   (* exec([Ljava/lang/String;[Ljava/lang/String;Ljava/io/File;)Ljava/lang/Process; *)		BEGIN	(* DON'T IMPLEMENT THIS METHOD *)		END exec8452;		PROCEDURE execInternal(p0: RefArray; p1: RefArray): Process;   (* execInternal([Ljava/lang/String;[Ljava/lang/String;)Ljava/lang/Process; *)		BEGIN	(* put your implementation here *)			JC.String(failureInfo, "Runtime.execInternal not implemented"); JC.Ln(failureInfo);			HALT(99)		END execInternal;		PROCEDURE exit*(p0: JT.Int);   (* exit(I)V *)		BEGIN	(* DON'T IMPLEMENT THIS METHOD *)			JC.String(infoInfo, "Runtime.exit "); JC.Int(infoInfo, p0, 0); JC.Ln(infoInfo)		END exit;		PROCEDURE exitInternal*(p0: JT.Int);   (* exitInternal(I)V *)		BEGIN	(* put your implementation here *)			JVMThreads.KillAll();(*			current := NIL;*)			JC.String(infoInfo, "JVM: Exit"); JC.Ln(infoInfo);(*			HALT(99) (* there should be a special message *)*)		END exitInternal;		PROCEDURE gc*();   (* gc()V *)		BEGIN AosKernel.GC		END gc;		PROCEDURE getLocalizedInputStream*(p0: InputStream): InputStream;   (* getLocalizedInputStream(Ljava/io/InputStream;)Ljava/io/InputStream; *)		BEGIN	(* DON'T IMPLEMENT THIS METHOD *)		END getLocalizedInputStream;		PROCEDURE getLocalizedOutputStream*(p0: OutputStream): OutputStream;   (* getLocalizedOutputStream(Ljava/io/OutputStream;)Ljava/io/OutputStream; *)		BEGIN	(* DON'T IMPLEMENT THIS METHOD *)		END getLocalizedOutputStream;		PROCEDURE halt*(p0: JT.Int);   (* halt(I)V *)		BEGIN	(* DON'T IMPLEMENT THIS METHOD *)		END halt;		PROCEDURE load*(p0: String);   (* load(Ljava/lang/String;)V *)		BEGIN	(* DON'T IMPLEMENT THIS METHOD *)		END load;		PROCEDURE loadLibrary*(p0: String);   (* loadLibrary(Ljava/lang/String;)V *)			VAR dummy: LONGINT;		BEGIN	(* DON'T IMPLEMENT THIS METHOD *)			dummy := nativeLoad(p0);	(*overwrite java implementation*)		END loadLibrary;		PROCEDURE maxMemory*(): JT.Long;   (* maxMemory()J *)		BEGIN	(* put your implementation here *)			RETURN totalMemory()		END maxMemory;		PROCEDURE nativeGetLibname(p0: String; p1: String): String;   (* nativeGetLibname(Ljava/lang/String;Ljava/lang/String;)Ljava/lang/String; *)		BEGIN	(* put your implementation here *)			RETURN p1		END nativeGetLibname;		PROCEDURE nativeLoad(p0: String): JT.Int;   (* nativeLoad(Ljava/lang/String;)I *)		BEGIN	(* put your implementation here *)			JC.String(errorInfo, "JVM.Runtime.loadLibrary("); JC.Str(errorInfo, p0.value.p); 			JC.String(errorInfo, ") not implemented"); JC.Ln(errorInfo);			RETURN 1	(*successful*)		END nativeLoad;		PROCEDURE removeShutdownHook*(p0: Thread): BOOLEAN;   (* removeShutdownHook(Ljava/lang/Thread;)Z *)		BEGIN	(* DON'T IMPLEMENT THIS METHOD *)		END removeShutdownHook;		PROCEDURE runFinalization*();   (* runFinalization()V *)		BEGIN	(* put your implementation here *)			(*do nothing*)		END runFinalization;		PROCEDURE totalMemory*(): JT.Long;   (* totalMemory()J *)			VAR total, low, high: LONGINT;		BEGIN	(* put your implementation here *)			AosMemory.GetFreeK(total, low, high);			RETURN 1024 * LONG(total)		END totalMemory;		PROCEDURE freeMemory*(): JT.Long;   (* freeMemory()J *)			VAR total, low, high, free, largest: LONGINT;		BEGIN	(* put your implementation here *)			AosHeap.GetHeapInfo(total, free, largest);			AosMemory.GetFreeK(total, low, high);			RETURN LONG(free)+1024*LONG(low+high)		END freeMemory;		PROCEDURE traceInstructions*(p0: BOOLEAN);   (* traceInstructions(Z)V *)		BEGIN	(* put your implementation here *)			JC.String(errorInfo, "Runtime.traceInstructions not implemented"); JC.Ln(errorInfo);		END traceInstructions;		PROCEDURE traceMethodCalls*(p0: BOOLEAN);   (* traceMethodCalls(Z)V *)		BEGIN	(* put your implementation here *)			traceMethods := p0		END traceMethodCalls;			END Runtime;	VAR	(* static fields used by java/lang/Runtime *)	securityManager-: SecurityManager;	(* private static SecurityManager securityManager *)	defaultProperties-: Object;					(* static Properties defaultProperties *)	current-: Runtime;								(* private static final Runtime current *)		threadGroup: Object;	(*cached: java/lang/ThreadGroup.root*)	args : RefArray; (* this must be a gloabal variable; otherwise it seems to be collected by  the gc *)	Trace*: SET;		arrayClass: ARRAY 12 OF JB.Class;	(* cached: java array classes *)	(* these methods come from the Runtime Interface *)		PROCEDURE clinit();   (* <clinit>()V *)	BEGIN	(* DON'T IMPLEMENT THIS METHOD *)	END clinit;	PROCEDURE getRuntime*(): Runtime;   (* getRuntime()Ljava/lang/Runtime; *)	BEGIN	(* DON'T IMPLEMENT THIS METHOD *)	END getRuntime;		PROCEDURE getSecurityManager(): Object;   (* getSecurityManager()Ljava/lang/SecurityManager; *)	BEGIN	(* DON'T IMPLEMENT THIS METHOD *)	END getSecurityManager;		PROCEDURE insertSystemProperties(p0: JB.Class);   (* insertSystemProperties(Ljava/util/Properties;)V *)		VAR c: JB.Class; m: JB.Method; dummy: Object;				PROCEDURE Insert(m: JB.Method; key, val: ARRAY OF CHAR);			VAR par: RefArray;		BEGIN			NEW(par);			NEW(par.p, 2);			par.p[0] := jjlString.MakeLiteral1(key);			par.p[1] := jjlString.MakeLiteral1(val);			dummy := m.invokeNative(p0, par, c, 0)		END Insert;		BEGIN	(* put your implementation here *)		dummy := p0.getClass();		c := dummy(JB.Class);		m := c.getMethodWithNameAndDesc0("setProperty", "(Ljava/lang/String;Ljava/lang/String;)Ljava/lang/Object;");				Insert(m, "java.version", "1.2");		Insert(m, "java.vendor", "Jaos");		Insert(m, "java.vendor.url", "http://www.oberon.ethz.ch/jaos/");		Insert(m, "java.home", "");		Insert(m, "java.vm.specification.version", "2");		Insert(m, "java.vm.specification.vendor", "Sun");		Insert(m, "java.vm.specification.name", "property1");		Insert(m, "java.vm.version", "alpha");		Insert(m, "java.vm.vendor", "Jaos");		Insert(m, "java.vm.name", "Jaos");		Insert(m, "java.specification.version", "J2EE");		Insert(m, "java.specification.vendor", "Sun");		Insert(m, "java.specification.name", "property2");		Insert(m, "java.class.version", "Classpath 02-12-28");		Insert(m, "java.class.path", "property3");		Insert(m, "java.library.path", "property4");		Insert(m, "java.io.tmpdir", "property5");		Insert(m, "java.compiler", "Jaos JIT");		Insert(m, "java.ext.dirs", "property6");		Insert(m, "os.name", "Bluebottle");		Insert(m, "os.arch", "Intel");		Insert(m, "os.version", "Latest");		Insert(m, "file.separator", "/");		Insert(m, "path.separator", ":");		Insert(m, "line.separator", JC.CR);		Insert(m, "user.name", "Bluebottle User");		Insert(m, "user.home", "property7");		Insert(m, "user.dir", "property8");		Insert(m, "file.encoding", "UTF8");	END insertSystemProperties;	PROCEDURE nativeGetLibname(p0: String; p1: String): String;   (* nativeGetLibname(Ljava/lang/String;Ljava/lang/String;)Ljava/lang/String; *)	BEGIN	(* put your implementation here *)		JC.String(failureInfo, "Runtime.nativeGetLibname not implemented"); JC.Ln(failureInfo);		HALT(99)	END nativeGetLibname;	PROCEDURE runFinalizersOnExit*(p0: BOOLEAN);   (* runFinalizersOnExit(Z)V *)	BEGIN	(* DON'T IMPLEMENT THIS METHOD *)	END runFinalizersOnExit;		PROCEDURE runFinalizersOnExitInternal*(p0: BOOLEAN);   (* runFinalizersOnExitInternal(Z)V *)	BEGIN	(* put your implementation here *)		JC.String(failureInfo, "Runtime.runFinalizersOnExitInternal not implemented"); JC.Ln(failureInfo);	END runFinalizersOnExitInternal;		PROCEDURE setSecurityManager(p0: Object);   (* setSecurityManager(Ljava/lang/SecurityManager;)V *)	BEGIN	(* DON'T IMPLEMENT THIS METHOD *)	END setSecurityManager;PROCEDURE GetNameAndArgs(par: PTR; VAR class : ARRAY OF CHAR;  VAR args : RefArray): BOOLEAN;VAR i, j: LONGINT; buffer : ARRAY 256 OF String; str : ARRAY 256 OF CHAR; s: AosCommands.Parameters; sr : AosIO.StringReader;BEGIN	s := par(AosCommands.Parameters);	AosIO.OpenStringReader(sr, LEN(s.str^)); AosIO.SetString(sr, s.str^);	IF sr.EOLN() THEN RETURN FALSE END;		sr.Token(class);	sr.SkipSpaces;		i := 0;	WHILE ~sr.EOLN() & (sr.Peek() # "~") DO		sr.Token(str); sr.SkipSpaces;		buffer[i] := jjlString.CreateString0(str);		JC.String(debugInfo, "Par"); JC.Int(debugInfo, i, 0); JC.String(debugInfo, " = '"); 		JC.String(debugInfo, str); JC.String(debugInfo, "'"); JC.Ln(debugInfo);		INC(i);	END;	IF (i > 0) & (str = "") THEN DEC(i) END;	(* can't understand why this is needed *)	NEW(args); NEW(args.p, i);	FOR j := 0 TO i-1 DO args.p[j] := buffer[j] END;	RETURN TRUE	END GetNameAndArgs;PROCEDURE ExecuteParam*(class: JT.StringBuffer; pars: RefArray);VAR thread: MainThread;	(* args : RefArray; *)BEGIN	IF firstRun THEN Install END;	NEW(args); NEW(args.p, 1); args.p[0] := pars;	IF EnableExceptions THEN AosActive.SetExceptionHandler(JE.HandleException)  END;	IF current = NIL THEN  		CheckInitialized(JB.ThisClass0("java/lang/Runtime", TRUE));		IF current = NIL THEN			NEW(current); current.init;		END	END;	NEW(thread, class, "main", "([Ljava/lang/String;)V", args);	(*thread.start;*)END ExecuteParam;PROCEDURE Execute*(par: PTR): PTR;VAR class: JT.StringBuffer; pars: RefArray;BEGIN {EXCLUSIVE}	IF GetNameAndArgs(par, class, pars) THEN ExecuteParam(class, pars) END;	RETURN NIL;END Execute;(** ExecuteApplet - get code from URL base + code *)PROCEDURE ExecuteApplet*(base, code: ARRAY OF CHAR; w, h: LONGINT);	VAR url, msg: ARRAY 256 OF CHAR; s: ReaderStream; req: WebHTTP.RequestHeader; con: AosTCP.Connection;		rep: WebHTTP.ResponseHeader; res: LONGINT; c: JB.Class; o, dummy: Object; mth: JB.Method; args: RefArray;		i, j: LONGINT; ptr: PTR; fp: FrameFactoryParameters; m: AosModules.Module; newFrame: AosModules.CommandParProc;BEGIN	i := 0;	WHILE base[i] # 0X DO  url[i] := base[i]; INC(i)  END;	j := 0;	WHILE code[j] # 0X DO url[i] := code[j]; INC(i); INC(j)  END;	url[i] := 0X;	JC.String(debugInfo, "Fetching applet "); JC.String(debugInfo, url);	NEW(s);	con := NIL;	WebHTTPClient.Get(url, req, con, rep, s.reader, res); ASSERT(res = 0);	JC.String(debugInfo, rep.transferencoding); JC.String(debugInfo, "  "); JC.Int(debugInfo, res, 0); JC.Ln(debugInfo);		JC.String(debugInfo, "load java/applet/Applet"); JC.Ln(debugInfo);	CheckInitialized(JB.ThisClass0("java/applet/Applet", TRUE));		JC.String(debugInfo, "load applet"); JC.Ln(debugInfo);	c := JVMLoader.LoadClassByStream(s);		(* create applet instance *)	JC.String(debugInfo, "create applet instance"); JC.Ln(debugInfo);	o := New(c(JB.ObjectClass));	(*create instance*)	NEW(args); NEW(args.p, 0);	mth := c.getMethodWithNameAndDesc0("init", "()V");	dummy := mth.invokeNative(o, args, NIL, 0);		(* create applet's graphic context *)	JC.String(debugInfo, "create applet's graphic context"); JC.Ln(debugInfo);	CheckInitialized(JB.ThisClass0("java/awt/Graphics", TRUE));	m := AosModules.ThisModule("jjaAosGraphics", res, msg); ASSERT(res = 0);	newFrame := AosModules.ThisCommandPar(m, "NewFrame");	NEW(fp, w, h);	ptr := newFrame(fp);			(* invoke applet.paint(g) *)	JC.String(debugInfo, "invoke applet.paint(g)"); JC.Ln(debugInfo);	NEW(args); NEW(args.p, 1); args.p[0] := ptr(Object);	mth := c.getMethodWithNameAndDesc0("paint", "(Ljava/awt/Graphics;)V");	dummy := mth.invokeNative(o, args, NIL, 0);			(* start applet instance *)	JC.String(debugInfo, "start applet instance"); JC.Ln(debugInfo);	mth := c.getMethodWithNameAndDesc0("start", "()V");	dummy := mth.invokeNative(o, args, NIL, 0);END ExecuteApplet;(* MapExceptionTable - convert exception table's java offsets to native offsets *)PROCEDURE MapExceptionTable((*method: JB.Method;*) exceptions: JE.CatchTable; map: JB.Map);	VAR i, j, last: LONGINT;		start, end, handler: LONGINT;BEGIN	IF exceptions # NIL THEN		FOR i := 0 TO LEN(exceptions^)-1 DO				(* checks *)			start := exceptions[i].start;			end := exceptions[i].end;				(* if end not mapped, use last good mapped address *)			IF map[end] = 0 THEN				JC.String(errorInfo, "exception.end ");				JC.Hex(errorInfo, end, 0);				JC.String(errorInfo, "H mapped to 0, using last good address ");				WHILE (end >= start) & (map[end] = 0) DO DEC(end) END;				JC.Hex(errorInfo, end, 0);				JC.String(errorInfo, "H");				JC.Ln(errorInfo);			END;				(* check that all code offsets in exception block are contiguous *)			last := 0;			FOR j := start TO end DO ASSERT(map[j] >= last) END;					exceptions[i].start := map[ (*exceptions[i].*)start ];							exceptions[i].end := map[ (*exceptions[i].*)end ];							exceptions[i].handler := map[ exceptions[i].handler ];						start := exceptions[i].start; end := exceptions[i].end; handler := exceptions[i].handler;			ASSERT((exceptions[i].start#0) & (exceptions[i].end#0) & (exceptions[i].handler#0))		END	END		END MapExceptionTable;PROCEDURE CompileClass*(c: JB.Class);VAR i, cinit: LONGINT; name: ARRAY 256 OF CHAR; code: JB.ACodeInfo; map: JB.Map;	(* Copied from Strings.Mod to avoid importing an Oberon module *)	PROCEDURE Prefix(pre: ARRAY OF CHAR; VAR str(** in *): ARRAY OF CHAR): BOOLEAN;		VAR i: LONGINT;	BEGIN		i := 0;		WHILE (pre[i] # 0X) & (pre[i] = str[i]) DO			INC(i)		END;		RETURN pre[i] = 0X	END Prefix;	BEGIN	ASSERT(c # NIL);	IF c IS JB.RefClass THEN		WITH c: JB.RefClass DO			JT.JavaToOberonString(c.name, 0, LEN(c.name^), name);(*			IF Prefix("java/awt", name) OR Prefix("java/net", name) OR Prefix("java/applet", name) THEN				HALT(99);			END;*)			COPY(c.obmod, name);			ASSERT(c.state >= JB.Loaded);			IF (c.superClass # NIL) & (c.superClass.state < JB.Compiled) THEN  CompileClass(c.superClass)  END;			IF c.state < JB.Compiled THEN				curJIT := 1;				c.jit := curJIT;				IF 7 IN Trace THEN					JC.String(debugInfo, "JVM: Compile "); JC.String(debugInfo, c.obobj); JC.Ln(debugInfo)				END;				JVMLoader.FixReferences(c);				JIT[curJIT].Init(c.moduleS);								FOR i := 0 TO LEN(c.methods^)-1 DO					code := c.methods[i].code;					IF code # NIL THEN						IF code.code = NIL THEN JVMLoader.LoadCode(c) END;						JIT[curJIT].Compile(c, i, code, c.methods[i].offset, map);						MapExceptionTable((*c.methods[i],*) code.exceptions, map);						c.methods[i].code.code := NIL;					END				END;				IF ReleaseMemory THEN c.constPool := NIL END;				IF JC0.pc > 0 THEN JS.CreateCode(c.ownModule, JC0.code^, JC0.pc) END;				IF JVMRefs.refsize > 0 THEN JS.CreateRefs(c.ownModule, JVMRefs.refs, JVMRefs.refsize) END;				c.state := JB.Compiled;				IF 7 IN Trace THEN  JC.String(debugInfo, "JVM: Link "); JC.String(debugInfo, c.obobj); JC.Ln(debugInfo)  END;				JVMLinker.Link(c); 				c.state := JB.Linked;  JS.Insert(c.ownModule);				IF 7 IN Trace THEN					JC.String(debugInfo, "JVM: Done "); JC.String(debugInfo, c.obobj); JC.Ln(debugInfo);					JC.String(debugInfo, "cf @ "); JC.Hex(debugInfo, SYSTEM.VAL(LONGINT, c), 0);					JC.String(debugInfo, " / td @ "); JC.Hex(debugInfo, SYSTEM.VAL(LONGINT, c.typedesc), 0); JC.Ln(debugInfo);					JC.String(debugInfo, "sb @ "); JC.Hex(debugInfo, c.ownModule.sb, 0); 					JC.String(debugInfo, " / cd @ "); JC.Hex(debugInfo, SYSTEM.ADR(c.ownModule.code[0]), 0); JC.Ln(debugInfo);				END;			END		END	ELSE		c.state := JB.Linked	ENDEND CompileClass;(* --------------------------------------------- *)(* System Calls *)(** New - allocate one instance of class *)PROCEDURE New(class: JB.ObjectClass): Object;VAR p: PTR; str: ARRAY 256 OF CHAR; obj : Object;BEGIN	IF 0 IN Trace THEN		JC.String(debugInfo, "[NR "); JC.Str(debugInfo, class.name);	END;	(* IF class.state < JB.Compiled THEN  CompileClass(class)  END;  <-- this is done in CheckInitialized*)	IF class.state < JB.Initialized THEN CheckInitialized(class) END;	p := NIL;	JS.NewRec(p, class.typedesc.tag);	IF 0 IN Trace THEN JC.String(debugInfo, "]"); JC.Int(debugInfo, SYSTEM.VAL(LONGINT, p), 0); JC.Ln(debugInfo) END;	obj := SYSTEM.VAL(Object, p); obj.class := class;	RETURN objEND New;(** NewArray - allocate java dynamic array with count elements of size *)PROCEDURE NewArray(count, index: LONGINT): Object;VAR  b: jjlObject.BoolArray;  c: jjlObject.CharArray;  f: jjlObject.FloatArray;  d: jjlObject.DoubleArray;	by: jjlObject.ByteArray;  s: jjlObject.ShortArray;  i: jjlObject.IntArray;  l: jjlObject.LongArray;BEGIN	IF 1 IN Trace THEN JC.String(debugInfo, "[NA "); JC.Int(debugInfo, count, 0); JC.String(debugInfo, "/"); JC.Int(debugInfo, index, 0) END;	CASE index OF	| 4:  NEW(b); NEW(b.p, count);  b.class := arrayClass[4]; RETURN b	| 5:  NEW(c); NEW(c.p, count);  c.class := arrayClass[5]; RETURN c	| 6:  NEW(f); NEW(f.p, count);  f.class := arrayClass[6]; RETURN f	| 7:  NEW(d); NEW(d.p, count);  d.class := arrayClass[7]; RETURN d	| 8:  NEW(by); NEW(by.p, count);  by.class := arrayClass[8]; RETURN by	| 9:  NEW(s); NEW(s.p, count);  s.class := arrayClass[9]; RETURN s	| 10:  NEW(i); NEW(i.p, count);  i.class := arrayClass[10]; RETURN i	| 11:  NEW(l); NEW(l.p, count);  l.class := arrayClass[11]; RETURN l	END;	IF 1 IN Trace THEN JC.String(debugInfo, "]"); JC.Ln(debugInfo) END;END NewArray;(** NewArrayA - allocate dynamic array with count references *)PROCEDURE NewArrayA(count: LONGINT; class: JB.Class): jjlObject.RefArray;VAR	p: jjlObject.RefArray; i: LONGINT; str: ARRAY 256 OF CHAR;			name : JT.String;BEGIN	IF 2 IN Trace THEN		JC.String(debugInfo, "[NAA "); JC.Str(debugInfo, class.name);(*		JT.JavaToOberonString(class.name, 0, LEN(class.name), str);*)		JC.Int(debugInfo, count, 0); JC.String(debugInfo, "/"); JC.Str(debugInfo, class.name); JC.String(debugInfo, "]"); JC.Ln(debugInfo)	END;	jjlObject.Assert(count >=0, "NegativeArraySizeException" , "");	IF class.state < JB.Compiled THEN  CompileClass(class)  END;	NEW(p);  NEW(p.p, count);	IF class.array = NIL THEN		JT.MakeArrayName(name, 1, class.name);		class.array := JB.ThisClass(name, TRUE);	END;	p.class := class.array;	FOR i := 0 TO count-1 DO  p.p[i] := NIL  END; 	RETURN pEND NewArrayA;PROCEDURE MultianewArray(class : JB.Class; count: LONGINT):Object;VAR adr1, adr2, size, i : LONGINT;		dims : ARRAY 256 OF LONGINT;		p : jjlObject.RefArray;				PROCEDURE CreateArray(dim : LONGINT; cls : JB.Class):Object;		VAR len, namelen, i : LONGINT;				obj : Object;				ref : jjlObject.RefArray;							array : JB.ArrayClass;		BEGIN						IF dim > count THEN RETURN NIL;			ELSE 				array := cls(JB.ArrayClass);				len := dims[count-dim]; 				IF array.dim = 1 THEN					IF array.ctype.isPrimitive() THEN												obj := NewArray(len, array.ctype(JB.PrimitiveClass).index)					ELSE obj := NewArrayA(len, array.ctype(JB.RefClass))					END				ELSIF array.dim > 1 THEN					NEW(ref); NEW(ref.p, len); ref.class := array;										FOR i := 0 TO len-1 DO ref.p[i] := CreateArray( dim+1, array.ctype) END; obj := ref;				ELSE RETURN NIL END;				RETURN obj			END		END CreateArray;		BEGIN	adr1 := SYSTEM.ADR(dims[0]);	adr2 := JS.Adr(16); size := count * 4;	SYSTEM.MOVE(adr2, adr1, size);	RETURN CreateArray(1 , class)END MultianewArray;PROCEDURE InstanceOfSysCall(p: LONGINT; class: JB.Class): LONGINT;VAR 	cls : JB.Class;	obj, c : Object;BEGIN	IF 4 IN Trace THEN		JC.String(debugInfo, "[I] "); JC.Ln(debugInfo)	END;	IF p = JT.NULL THEN  RETURN 0	ELSE				obj := SYSTEM.VAL(Object, p);		c := obj.class;	(* don't use getClass() to avoid loading java/lang/Class (not needed here, and bootstrap problem) *)		cls := c(JB.Class);		IF class.isAssignableFrom(cls) THEN RETURN 1		ELSE RETURN 0 END	ENDEND InstanceOfSysCall;PROCEDURE CheckCastSysCall(p: LONGINT; class: JB.Class);VAR fp, pc: LONGINT; res: BOOLEAN; name: JT.StringBuffer;BEGIN	res := (p=JT.NULL) OR (InstanceOfSysCall(p, class) # 0);	IF 5 IN Trace THEN		JC.String(debugInfo, "[CC ");(*		PCDebug.GetTypeName(SYSTEM.VAL(PTR, p), name);*)		name := "<PCDebug.GetTypeName>";		JC.String(debugInfo, name);		JC.String(debugInfo, " IS ");		JC.Str(debugInfo, class.name);					SYSTEM.GETREG(SYSTEM.EBP, fp);		SYSTEM.GET(fp+4, pc);(*		PCDebug.GetProcedure(pc, name);*)		JC.String(debugInfo, "  "); JC.String(debugInfo, name);		JC.String(debugInfo, "]");		JC.Ln(debugInfo)	END;	jjlObject.Assert(res, "java/lang/ClassCastException", "");END CheckCastSysCall;PROCEDURE TraceMethod;	VAR ebp, pc: LONGINT; name: ARRAY 128 OF CHAR;BEGIN	IF traceMethods THEN		SYSTEM.GETREG(SYSTEM.EBP, ebp);		SYSTEM.GET(ebp+4, pc);		PCDebug.GetProcedure(pc, name);(*		name := "<PCDebug.GetProcedure>";*)		JC.String(errorInfo, name);		JC.Ln(errorInfo);	ENDEND TraceMethod;(* Initialized > class.state  >= Allocated	=> the base classes of class must be ckecked and	clinit of class must be invoked *)	PROCEDURE CheckInitialized*(c : JB.Class); (* only Ref (Obj+Intf) Classes may have a static initializer *)VAR clinit : JB.Method; name, desc : JT.String; class: JB.RefClass; str: ARRAY 128 OF CHAR;	pc: LONGINT;BEGIN	IF c IS JB.RefClass THEN		class := c(JB.RefClass);		IF class.state >= JB.Initialized THEN RETURN  END; 					 (* protect for reentrance *)		CompileClass(class); 		class.state := JB.Initialized;															(* protect for reentrance *)		IF (class.superClass # NIL) & (class.superClass.state < JB.Initialized) THEN			CheckInitialized(class.superClass)						 					(* static initializers of subclasses are invoked first *)		END;		JT.OberonToJavaString("<clinit>",name); JT.OberonToJavaString("()V", desc); 		clinit := JB.FindMethod(name, desc, class.methods^, 0, LEN(class.methods^) -1); 						 						IF (clinit #  NIL) & ~JB.DontRun THEN 			JT.JavaToOberonString(c.name, 0, LEN(c.name), str);			IF 6 IN Trace THEN				JC.String(errorInfo, "[IN "); JC.Str(errorInfo, c.name);				JS.Execute(clinit.offset);				JC.String(errorInfo, "]"); JC.Ln(errorInfo);			ELSE				JS.Execute(clinit.offset)			END;		ELSIF (clinit = NIL) THEN				IF 6 IN Trace THEN					JC.String(errorInfo, "[*IN "); JC.Str(errorInfo, c.name);					JC.String(errorInfo, "]"); JC.Ln(errorInfo)				END		ELSE				IF 6 IN Trace THEN					JC.String(errorInfo, "[-IN "); JC.Str(errorInfo, c.name);					JC.String(errorInfo, "]"); JC.Ln(errorInfo);				END		END	ELSE		class.state := JB.Initialized	END;END CheckInitialized;PROCEDURE CheckInitializedSysCall(c : JB.Class);	VAR pc: LONGINT;BEGIN	JS.GetPC(pc); JS.ClearCall(pc);	CheckInitialized(c);END CheckInitializedSysCall;(** LoaderPlugin - plugin for AosModules, allows automatic loading of java classes; first tries with default aos loader (AosLoader.LoadObj) *)PROCEDURE LoaderPlugin*(name, fileName: ARRAY OF CHAR; VAR res: LONGINT; VAR msg: ARRAY OF CHAR): AosModules.Module;	VAR m: AosModules.Module; c: JB.Class;BEGIN	m := NIL;	IF JVMLoader.loading = 0 THEN	(*don't load if this is called while loading the java classes*)		(*JC.String("JVM.Load "); JC.String(name);*)		JVMLoader.dontTrap := TRUE;		c := JB.ThisClass0(name, TRUE);		IF (c # NIL) & (c IS JB.ObjectClass) THEN			(*JC.String(" ok"); JC.Ln;*)			CheckInitialized(c);			m := c(JB.ObjectClass).ownModule;			res := 0;		ELSE			(*JC.String(" failed "); JC.String(msg); JC.Ln;*)(*			COPY(JVMLoader.missingClass, msg); Strings.Append(msg, " not found");			res := -1;*)			JVMLoader.missingClass[0] := 0X;		END;		JVMLoader.dontTrap := FALSE;	ELSE		(*JC.String("JVM.Load avoided  "); JC.String(name); JC.Ln;*)	END;	RETURN mEND LoaderPlugin;(** CompilerPlugin - plugin for Paco, allows automatic loading of symbol table information *)PROCEDURE CompilerPlugin*(self: PCT.Module; VAR new: PCT.Module; name: StringPool.Index);	VAR str: ARRAY 256 OF CHAR; c: JB.Class;BEGIN	StringPool.GetString(name, str);	JVMLoader.dontTrap := TRUE;	c := JB.ThisClass0(str, TRUE);	JVMLoader.dontTrap := FALSE;	(*JC.String("JVM.Import "); JC.String(str); JC.Ln;*)	IF JVMLoader.missingClass[0] # 0X THEN		JVMLoader.missingClass[0] := 0X;		HALT(99);	ELSIF c # NIL THEN		new := c.module;		IF (self # NIL) THEN self.AddImport(new) END;	ENDEND CompilerPlugin;PROCEDURE InstallJIT*(init: CompilerInitProc; compile: CompileMethodProc);BEGIN	JIT[nofJIT].Init := init;	JIT[nofJIT].Compile := compile;	INC(nofJIT)END InstallJIT;PROCEDURE Cleanup;BEGIN	AosModules.RemoveLoader(".class", LoaderPlugin);	PCT.RemoveImporter(CompilerPlugin);END Cleanup;PROCEDURE InstallSysCalls;VAR	new: PROCEDURE(class: JB.ObjectClass): Object;	newarray: PROCEDURE(count, size: LONGINT): Object;	newarraya: PROCEDURE (count: LONGINT; class: JB.Class): jjlObject.RefArray;	multinewarray : PROCEDURE(class: JB.Class; count : LONGINT) : Object;	throw: PROCEDURE (o: PTR);	check: PROCEDURE (p: LONGINT; class: JB.Class);	instance: PROCEDURE (p: LONGINT; class: JB.Class): LONGINT;	CheckInit : PROCEDURE(class : JB.Class);	ILookup : PROCEDURE(tdcls, tdint: AosModules.TypeTag): JI.VTable;	trace: PROCEDURE;BEGIN	new := New; JB.SysCalls[JB.SCNew] := SYSTEM.VAL(LONGINT, new);	newarray := NewArray; JB.SysCalls[JB.SCNewArray] := SYSTEM.VAL(LONGINT, newarray);	newarraya := NewArrayA;  JB.SysCalls[JB.SCNewArrayA] := SYSTEM.VAL(LONGINT, newarraya);	throw := JE.ThrowException;  JB.SysCalls[JB.SCThrow] := SYSTEM.VAL(LONGINT, throw);	check := CheckCastSysCall;  JB.SysCalls[JB.SCCheckCast] := SYSTEM.VAL(LONGINT, check);	instance := InstanceOfSysCall;  JB.SysCalls[JB.SCInstanceOf] := SYSTEM.VAL(LONGINT, instance);	IF CheckInitializedOptimization THEN CheckInit := CheckInitializedSysCall ELSE CheckInit := CheckInitialized END; 	JB.SysCalls[JB.SCCheckInitialized] := SYSTEM.VAL(LONGINT, CheckInit);	multinewarray := MultianewArray; JB.SysCalls[JB.SCMultianewArray] := SYSTEM.VAL(LONGINT, multinewarray);	ILookup := JI.Lookup; JB.SysCalls[JB.SCILookup] := SYSTEM.VAL(LONGINT, ILookup);		JB.SysCalls[JB.SCLock] := SYSTEM.VAL(LONGINT, jjlObject.Lock);	JB.SysCalls[JB.SCUnlock] := SYSTEM.VAL(LONGINT, jjlObject.Unlock);	trace := TraceMethod;	JB.SysCalls[JB.SCTrace] := SYSTEM.VAL(LONGINT, trace);END InstallSysCalls;PROCEDURE InstallUpCalls;BEGIN	JB.NewInstance := New;	JB.NewArray := NewArray;	JB.NewArrayA := NewArrayA;	JB.MultianewArray := MultianewArray;	JB.CheckInitialized := CheckInitialized;	AosModules.AddLoader(".class", LoaderPlugin);	PCT.AddImporter(CompilerPlugin);END InstallUpCalls;(* InstallClasses - load and install the classes that are needed by JVM to function properly *)PROCEDURE InstallClasses;VAR cls: JB.Class; i, off: LONGINT;BEGIN	IF EnableExceptions THEN AosActive.SetExceptionHandler(JE.HandleException)  END;	jjlObject.class := JB.ThisClass0("java/lang/Object", TRUE);	arrayClass[4] := JB.ThisClass0("[Z", TRUE);	arrayClass[5] := JB.ThisClass0("[C", TRUE);	arrayClass[6] := JB.ThisClass0("[F", TRUE);	arrayClass[7] := JB.ThisClass0("[D", TRUE);	arrayClass[8] := JB.ThisClass0("[B", TRUE);	arrayClass[9] := JB.ThisClass0("[S", TRUE);	arrayClass[10] := JB.ThisClass0("[I", TRUE);	arrayClass[11] := JB.ThisClass0("[J", TRUE);	jjlString.Initialize(arrayClass[5], JB.ThisClass0("java/lang/String", TRUE));	CheckInitialized(jjlString.class(JB.ObjectClass));	(* RuntimeExceptions must be present *)	cls := JB.ThisClass0("java/lang/RuntimeException", TRUE);	FOR i := 0 TO LEN(jjlThrowable.TrapMap)-1 DO		jjlThrowable.TrapMap[i] := cls	END;		jjlThrowable.TrapM14 := JB.ThisClass0("java/lang/NullPointerException", TRUE);	cls := JB.ThisClass0("java/lang/ArithmeticException", TRUE);	jjlThrowable.TrapMap[0] := cls;	jjlThrowable.TrapCompiler[2] := cls;	cls := JB.ThisClass0("java/lang/ClassCastException", TRUE);	jjlThrowable.TrapMap[1] := cls;	jjlThrowable.TrapMap[5] := cls;	jjlThrowable.TrapMap[6] := cls;	cls := JB.ThisClass0("java/lang/ArrayIndexOutOfBoundsException", TRUE);	jjlThrowable.TrapMap[7] := cls;	jjlThrowable.TrapMap[9] := cls;	cls := JB.ThisClass0("java/lang/OutOfMemoryError", TRUE);	jjlThrowable.TrapMap[14] := cls;	cls := JB.ThisClass0("java/io/IOException", TRUE);	jjlThrowable.TrapMap[15] := cls;	jjlThrowable.TrapMap[16] := cls;	jjlThrowable.TrapMap[17] := cls;	jjlThrowable.TrapMap[18] := cls;	cls := JB.ThisClass0("java/lang/AbstractMethodError", TRUE);	jjlThrowable.TrapCompiler[1] := cls;	CheckInitialized(JB.ThisClass0("java/lang/Throwable", TRUE));	CheckInitialized(JB.ThisClass0("java/lang/StackTraceElement", TRUE));	(* required by VMThrowable *)	CheckInitialized(JB.ThisClass0("java/lang/VMThrowable", TRUE));	(* to fill stack trace *)	JVMThreads.class := JB.ThisClass0("java/lang/Thread", TRUE);	CheckInitialized(JVMThreads.class);		cls := JB.ThisClass0("java/lang/ThreadGroup", TRUE);	WITH cls: JB.ObjectClass DO		CheckInitialized(cls);		off := JB.GetFieldOffset(cls, StringPool.GetIndex1("root"));		SYSTEM.GET(off + cls.ownModule.sb, threadGroup);	(*don't use reflection (f.get) to avoid loading Field*)	END;	ASSERT(threadGroup # NIL, 500);	ASSERT(		(threadGroup.class = cls) OR		(InstanceOfSysCall(SYSTEM.VAL(LONGINT, threadGroup), cls) = 1), 501);	JVMThreads.MakeFirstThread(threadGroup);	CheckInitialized(JB.ThisClass0("java/lang/System", TRUE));	firstRun := FALSE;	IF EnableExceptions THEN AosActive.SetExceptionHandler(NIL)  ENDEND InstallClasses;PROCEDURE Install*;BEGINEND Install;BEGIN	debugInfo.kind := JC.Debug; debugInfo.source := JC.VM;	infoInfo.kind := JC.Info; infoInfo.source := JC.VM;	errorInfo.kind := JC.Error; errorInfo.source := JC.VM;	failureInfo.kind := JC.Failure; failureInfo.source := JC.VM;	JC.String(infoInfo, "Jaos JVM / prk"); JC.Ln(infoInfo);	IF ~EnableExceptions THEN JC.String(infoInfo, "JVM Warning: Exceptions disabled"); JC.Ln(infoInfo) END;	IF ~ReleaseMemory THEN JC.String(infoInfo, "JVM Warning: Keeping Debug Information"); JC.Ln(infoInfo) END;	firstRun := TRUE;	AosModules.InstallTermHandler(Cleanup);	InstallJIT(JVMCompiler.Init, JVMCompiler.EncodeMethod);	InstallJIT(JVMOptCompiler.Init, JVMOptCompiler.EncodeMethod);	curJIT := 1;	Trace := {6};	InstallSysCalls;		(* classes to bootstrap the VM *) 	InstallUpCalls;	InstallClasses;END JVM.JVM.CloseConsoleJVM.AllocateMemory(**	Trace Values		0	1	NR		1	2	NA		2	4	NAA		3	8	not implemented		4	16	I		5	32	CC		6	64	IN		7	128	JVM.Compile*)(*	11.01.04	prk	update to classpath 0.06	30.07.03	prk	Logging functions, add kind and source; filtering support	09.03.03	prk	active object removed, explicit kernel call used: trouble if java allocates thread object	09.03.03	prk	clear CheckInitialized call	09.03.03	prk	create exception trace	09.03.03	prk	cache array classes to avoid lookup (improve 202_jess)	12.02.03	prk	Logging functions, use same interface as AosOut	29.12.02	prk	update to classpath snapshot 28.12.02	19.08.02	prk	prevent java.awt, java.net, java.applet from compiling, throw an exception	25.04.02	prk	reorganization; unified compiler interface for creating plugins	19.03.02	prk	export mapping information, allow compilation step to generate map	19.03.02	prk	method call tracing	11.03.02	prk	do not allocate SecurityManager at startup	05.02.02	prk	Runtime.freeMemory, Runtime.totalMemory fixed	21.11.01	prk	loader plugin, file suffix is .class instead of .java	23.10.01	prk	support for applets	18.10.01	prk	create a first entry in the reference section with the list of the global variables	18.09.01	prk	load Field, Method, and Class on demand only	13.09.01	prk	native implementation of java/lang/reflect/Constructor	05.09.01	prk	make class loading and initializing more efficient	21.08.01	prk	remove internal class-list, use PCT one instead	05.06.01	prk	Runtime, use classpath 0.02 implementation	27.05.01	prk	Logging improved	22.05.01	prk	Compile Base Class before its extensions. Inherit methods	21.05.01	prk	Store Console to file	16.05.01	prk	RunFinalization implemented	08.05.01	prk	InvokeMethod improved	11.04.01	prk	update to classpath 0.02	04.04.01	prk	merge with classpath-0.00 release, prepare for update with 0.01, minimize differencies	28.03.01	prk	JVM.ShowStubs fixed	28.03.01	prk	ByteBuffer renamed to JVMByteBuffer	22.03.01	prk	CreatePrimitiveClasses removed, done during module initialization*)