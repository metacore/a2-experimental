(* Jaos, Copyright 2003, Patrik Reali, ETH Zurich *)MODULE jjlDouble;	(*automatically generated stub for java/lang/Double *)	(*WARNING: DON'T CHANGE THE PROCEDURE NAMES*)IMPORT	SYSTEM,	JVMConverter, JT := JVMTypes, jjlNumber, jjlString, jjlObject, JVMBase, JP := JVMParser;TYPE	Number = jjlNumber.Number;	String = jjlString.String;	Object = jjlObject.Object;	Class = JVMBase.Class;CONST	(* static final fields *)	MAXVALUE* = MAX(REAL);	MINVALUE* = MIN(REAL);	NEGATIVEINFINITY* = SYSTEM.VAL(LONGREAL, 0FFF0000000000000H);	NaN* = SYSTEM.VAL(LONGREAL, 7FF8000000000000H);	POSITIVEINFINITY* = SYSTEM.VAL(LONGREAL, 7FF0000000000000H);	serialVersionUID* = 296BFB04296BFB04H;	TYPE	Double* = OBJECT (Number)		VAR			value-: JT.Double;		PROCEDURE init84*(p0: JT.Double);   (* <init>(D)V *)		BEGIN	(* DON'T IMPLEMENT THIS METHOD *)		END init84;		PROCEDURE init1930*(p0: String);   (* <init>(Ljava/lang/String;)V *)		BEGIN	(* DON'T IMPLEMENT THIS METHOD *)		END init1930;		PROCEDURE compareTo7354*(p0: Double): JT.Int;   (* compareTo(Ljava/lang/Double;)I *)		BEGIN	(* DON'T IMPLEMENT THIS METHOD *)		END compareTo7354;		PROCEDURE compareTo6908*(p0: Object): JT.Int;   (* compareTo(Ljava/lang/Object;)I *)		BEGIN	(* DON'T IMPLEMENT THIS METHOD *)		END compareTo6908;		PROCEDURE byteValue*(): JT.Byte;   (* byteValue()B *)		BEGIN	(* DON'T IMPLEMENT THIS METHOD *)		END byteValue;		PROCEDURE shortValue*(): JT.Short;   (* shortValue()S *)		BEGIN	(* DON'T IMPLEMENT THIS METHOD *)		END shortValue;		PROCEDURE doubleValue*(): JT.Double;   (* doubleValue()D *)		BEGIN	(* DON'T IMPLEMENT THIS METHOD *)		END doubleValue;		PROCEDURE equals*(p0: Object): BOOLEAN;   (* equals(Ljava/lang/Object;)Z *)		BEGIN	(* DON'T IMPLEMENT THIS METHOD *)		END equals;		PROCEDURE floatValue*(): JT.Float;   (* floatValue()F *)		BEGIN	(* DON'T IMPLEMENT THIS METHOD *)		END floatValue;		PROCEDURE hashCode*(): JT.Int;   (* hashCode()I *)		BEGIN	(* DON'T IMPLEMENT THIS METHOD *)		END hashCode;		PROCEDURE intValue*(): JT.Int;   (* intValue()I *)		BEGIN	(* DON'T IMPLEMENT THIS METHOD *)		END intValue;		PROCEDURE isInfinite*(): BOOLEAN;   (* isInfinite()Z *)		BEGIN	(* DON'T IMPLEMENT THIS METHOD *)		END isInfinite;		PROCEDURE isNaN*(): BOOLEAN;   (* isNaN()Z *)		BEGIN	(* DON'T IMPLEMENT THIS METHOD *)		END isNaN;		PROCEDURE longValue*(): JT.Long;   (* longValue()J *)		BEGIN	(* DON'T IMPLEMENT THIS METHOD *)		END longValue;		PROCEDURE toString*(): Object;   (* toString()Ljava/lang/String; *)		BEGIN	(* DON'T IMPLEMENT THIS METHOD *)		END toString;	END Double;VAR	Type-: Class;	PROCEDURE clinit();   (* <clinit>()V *)	BEGIN	(* DON'T IMPLEMENT THIS METHOD *)	END clinit;	PROCEDURE compare*(p0: JT.Double; p1: JT.Double): JT.Int;   (* compare(DD)I *)	BEGIN	(* DON'T IMPLEMENT THIS METHOD *)	END compare;	PROCEDURE doubleToLongBits*(double: JT.Double): JT.Long;   (* doubleToLongBits(D)J *)	BEGIN			RETURN SYSTEM.VAL( HUGEINT, double )	END doubleToLongBits;	PROCEDURE doubleToRawLongBits*(double: JT.Double): JT.Long;   (* doubleToRawLongBits(D)J *)	BEGIN			RETURN SYSTEM.VAL( HUGEINT, double )	END doubleToRawLongBits;	PROCEDURE initIDs();   (* initIDs()V *)		VAR a: LONGINT;	BEGIN	(* put your implementation here *)	END initIDs;	PROCEDURE isInfinite*(p0: JT.Double): BOOLEAN;   (* isInfinite(D)Z *)	BEGIN	(* DON'T IMPLEMENT THIS METHOD *)	END isInfinite;	PROCEDURE isNaN*(p0: JT.Double): BOOLEAN;   (* isNaN(D)Z *)	BEGIN	(* DON'T IMPLEMENT THIS METHOD *)	END isNaN;	PROCEDURE longBitsToDouble*(long: JT.Long): JT.Double;   (* longBitsToDouble(J)D *)	VAR double : LONGREAL;	BEGIN			SYSTEM.MOVE( SYSTEM.ADR( long ), SYSTEM.ADR( double ), 8 );		RETURN double	END longBitsToDouble;	PROCEDURE parseDouble*(p0: String): JT.Double;   (* parseDouble(Ljava/lang/String;)D *)	VAR sr : JP.StringReader;		val : LONGREAL;		success : BOOLEAN;		buffer : ARRAY 32 OF CHAR;	BEGIN		NEW( sr ); sr.init( p0.value.p, 0, p0.count );		success := JP.ParseFloat( sr, val );		IF ~success THEN			jjlString.ToOberon( p0, buffer );			jjlObject.Assert( FALSE, "java/lang/NumberFormatException", buffer )		END;		RETURN val 	END parseDouble;	PROCEDURE toString7612*(p0: JT.Double): String;   (* toString(D)Ljava/lang/String; *)	BEGIN	(* DON'T IMPLEMENT THIS METHOD *)	END toString7612;	PROCEDURE toString8391(x: JT.Double; p1: BOOLEAN): String;   (* toString(DZ)Ljava/lang/String; *)	VAR str: ARRAY 64 OF CHAR;	BEGIN		JVMConverter.RealToStr(x, str);		RETURN jjlString.MakeLiteral1(str)	END toString8391;	PROCEDURE toString*(x: JT.Double): String;   (* toString(D)Ljava/lang/String; *)	BEGIN	(* DON'T IMPLEMENT THIS METHOD *)	END toString;	PROCEDURE valueOf*(p0: String): Double;   (* valueOf(Ljava/lang/String;)Ljava/lang/Double; *)	BEGIN	(* DON'T IMPLEMENT THIS METHOD *)	END valueOf;END jjlDouble.