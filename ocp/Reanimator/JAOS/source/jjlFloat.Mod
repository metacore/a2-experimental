(* Jaos, Copyright 2003, Patrik Reali, ETH Zurich *)MODULE jjlFloat;	(*automatically generated stub for java/lang/Float *)	(*WARNING: DON'T CHANGE THE PROCEDURE NAMES*)IMPORT	SYSTEM,	JVMConverter,	JT := JVMTypes, jjlNumber, jjlString, jjlObject, JVMBase, JP := JVMParser;TYPE	Number = jjlNumber.Number;	String = jjlString.String;	Object = jjlObject.Object;	Class = JVMBase.Class;CONST	(* final static fields *)	MAXVALUE* = MAX(REAL);	MINVALUE* = MIN(REAL);	NEGATIVEINFINITY* = SYSTEM.VAL(REAL, 0FF800000H);	(*also -MAX*2 *)	NaN* = SYSTEM.VAL(REAL, 7FC00000H);	POSITIVEINFINITY* = SYSTEM.VAL(REAL, 7F800000H);	(*also MAX*2 *)	serialVersionUID* = 0DB3CF0ECDB3CF0ECH;TYPE	Float* = OBJECT (Number)		VAR			value-: JT.Float;		PROCEDURE init84*(p0: JT.Double);   (* <init>(D)V *)		BEGIN	(* DON'T IMPLEMENT THIS METHOD *)		END init84;		PROCEDURE init92*(p0: JT.Float);   (* <init>(F)V *)		BEGIN	(* DON'T IMPLEMENT THIS METHOD *)		END init92;		PROCEDURE init1930*(p0: String);   (* <init>(Ljava/lang/String;)V *)		BEGIN	(* DON'T IMPLEMENT THIS METHOD *)		END init1930;		PROCEDURE byteValue*(): JT.Byte;   (* byteValue()B *)		BEGIN	(* DON'T IMPLEMENT THIS METHOD *)		END byteValue;		PROCEDURE compareTo7799*(p0: Float): JT.Int;   (* compareTo(Ljava/lang/Float;)I *)		BEGIN	(* DON'T IMPLEMENT THIS METHOD *)		END compareTo7799;		PROCEDURE compareTo6908*(p0: Object): JT.Int;   (* compareTo(Ljava/lang/Object;)I *)		BEGIN	(* DON'T IMPLEMENT THIS METHOD *)		END compareTo6908;		PROCEDURE doubleValue*(): JT.Double;   (* doubleValue()D *)		BEGIN	(* DON'T IMPLEMENT THIS METHOD *)		END doubleValue;		PROCEDURE equals*(p0: Object): BOOLEAN;   (* equals(Ljava/lang/Object;)Z *)		BEGIN	(* DON'T IMPLEMENT THIS METHOD *)		END equals;		PROCEDURE floatValue*(): JT.Float;   (* floatValue()F *)		BEGIN	(* DON'T IMPLEMENT THIS METHOD *)		END floatValue;		PROCEDURE hashCode*(): JT.Int;   (* hashCode()I *)		BEGIN	(* DON'T IMPLEMENT THIS METHOD *)		END hashCode;		PROCEDURE intValue*(): JT.Int;   (* intValue()I *)		BEGIN	(* DON'T IMPLEMENT THIS METHOD *)		END intValue;		PROCEDURE isInfinite*(): BOOLEAN;   (* isInfinite()Z *)		BEGIN	(* DON'T IMPLEMENT THIS METHOD *)		END isInfinite;		PROCEDURE isNaN*(): BOOLEAN;   (* isNaN()Z *)		BEGIN	(* DON'T IMPLEMENT THIS METHOD *)		END isNaN;		PROCEDURE longValue*(): JT.Long;   (* longValue()J *)		BEGIN	(* DON'T IMPLEMENT THIS METHOD *)		END longValue;		PROCEDURE shortValue*(): JT.Short;   (* shortValue()S *)		BEGIN	(* DON'T IMPLEMENT THIS METHOD *)		END shortValue;		PROCEDURE toString*(): Object;   (* toString()Ljava/lang/String; *)		BEGIN	(* DON'T IMPLEMENT THIS METHOD *)		END toString;	END Float;VAR	Type-: Class;	PROCEDURE clinit();   (* <clinit>()V *)	BEGIN	(* DON'T IMPLEMENT THIS METHOD *)	END clinit;	PROCEDURE compare*(p0: JT.Float; p1: JT.Float): JT.Int;   (* compare(FF)I *)	BEGIN	(* DON'T IMPLEMENT THIS METHOD *)	END compare;	PROCEDURE floatToIntBits*(x: JT.Float): JT.Int;   (* floatToIntBits(F)I *)	BEGIN			RETURN SYSTEM.VAL( LONGINT, x )	END floatToIntBits;	PROCEDURE floatToRawIntBits*(x: JT.Float): JT.Int;   (* floatToRawIntBits(F)I *)	BEGIN			RETURN SYSTEM.VAL( LONGINT, x )	END floatToRawIntBits;	PROCEDURE intBitsToFloat*(i: JT.Int): JT.Float;   (* intBitsToFloat(I)F *)	BEGIN			RETURN SYSTEM.VAL( REAL, i )	END intBitsToFloat;	PROCEDURE isInfinite*(p0: JT.Float): BOOLEAN;   (* isInfinite(F)Z *)	BEGIN	(* DON'T IMPLEMENT THIS METHOD *)	END isInfinite;	PROCEDURE isNaN*(p0: JT.Float): BOOLEAN;   (* isNaN(F)Z *)	BEGIN	(* DON'T IMPLEMENT THIS METHOD *)	END isNaN;	PROCEDURE parseFloat*(p0: String): JT.Float;   (* parseFloat(Ljava/lang/String;)F *)	VAR sr : JP.StringReader;		val : LONGREAL;		success : BOOLEAN;		buffer : ARRAY 32 OF CHAR;	BEGIN			NEW( sr ); sr.init( p0.value.p, 0, p0.count );		success := JP.ParseFloat( sr, val );		IF ~success THEN			jjlString.ToOberon( p0, buffer );			jjlObject.Assert( FALSE, "java/lang/NumberFormatException", buffer )		END;		RETURN SHORT(val)	END parseFloat;	PROCEDURE toString*(x: JT.Float): String;   (* toString(F)Ljava/lang/String; *)	VAR str: ARRAY 64 OF CHAR;	BEGIN		JVMConverter.RealToStr(x, str);		RETURN jjlString.MakeLiteral1(str)	END toString;	PROCEDURE valueOf*(p0: String): Float;   (* valueOf(Ljava/lang/String;)Ljava/lang/Float; *)	BEGIN	(* DON'T IMPLEMENT THIS METHOD *)	END valueOf;END jjlFloat.