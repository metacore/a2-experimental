(* Jaos, Copyright 2003, Patrik Reali, ETH Zurich *)MODULE jjlThrowable;	(*automatically generated stub for java/lang/Throwable *)	(*WARNING: DON'T CHANGE THE PROCEDURE NAMES*)IMPORT		JC := JVMConsole,		SYSTEM, JT := JVMTypes, JS := JVMSystem, JE := JVMExceptions, jjlObject, jjlString, JB := JVMBase;CONST		TraceMapping = FALSE;		AbstractMethodError* = 0CAFEH+1;		LDivZero* = 0CAFEH+2;			(* static final fields *)		serialVersionUID* = -3042686055658047285;TYPE	Object = jjlObject.Object;		RefArray = jjlObject.RefArray;	String = jjlString.String;	Class = JB.Class;VAR	errorInfo: JC.LoggingInfo;TYPE	Throwable* = OBJECT (Object)		VAR			(* java/lang/Throwable fields *)			detailMessage-: String;			cause-: Throwable;			stackTrace-: RefArray;			vmState-: PTR;	(* private transient VMThrowable vmState *)						(* own fields *)			stack- : POINTER TO ARRAY OF CHAR;			stackstart-, pc- : LONGINT;				PROCEDURE init*();   (* <init>()V *)		BEGIN	(* DON'T IMPLEMENT THIS METHOD *)		END init;				PROCEDURE init1930*(msg: String);   (* <init>(Ljava/lang/String;)V *)			VAR dummy: Throwable;		BEGIN	(* DON'T IMPLEMENT THIS METHOD *)			init^();			cause := SELF;			NEW(stackTrace);			NEW(stackTrace.p, 0);			dummy := fillInStackTrace();			detailMessage := msg;		END init1930;		PROCEDURE init1464*(p0: String; p1: Throwable);   (* <init>(Ljava/lang/String;Ljava/lang/Throwable;)V *)		BEGIN	(* DON'T IMPLEMENT THIS METHOD *)		END init1464;		PROCEDURE init977*(p0: Throwable);   (* <init>(Ljava/lang/Throwable;)V *)		BEGIN	(* DON'T IMPLEMENT THIS METHOD *)		END init977;		PROCEDURE fillInStackTrace*(): Throwable;   (* fillInStackTrace()Ljava/lang/Throwable; *)		BEGIN	(* DON'T IMPLEMENT THIS METHOD *)		END fillInStackTrace;		PROCEDURE getCause*(): Throwable;   (* getCause()Ljava/lang/Throwable; *)		BEGIN	(* DON'T IMPLEMENT THIS METHOD *)		END getCause;		PROCEDURE getLocalizedMessage*(): Object;   (* getLocalizedMessage()Ljava/lang/String; *)		BEGIN	(* DON'T IMPLEMENT THIS METHOD *)		END getLocalizedMessage;		PROCEDURE getMessage*(): Object;   (* getMessage()Ljava/lang/String; *)		BEGIN	(* DON'T IMPLEMENT THIS METHOD *)		END getMessage;		PROCEDURE getStackTrace*(): RefArray;   (* getStackTrace()[Ljava/lang/StackTraceElement; *)		BEGIN	(* DON'T IMPLEMENT THIS METHOD *)		END getStackTrace;		PROCEDURE initCause*(p0: Throwable): Throwable;   (* initCause(Ljava/lang/Throwable;)Ljava/lang/Throwable; *)		BEGIN	(* DON'T IMPLEMENT THIS METHOD *)		END initCause;		PROCEDURE printStackTrace164*();   (* printStackTrace()V *)		BEGIN	(* DON'T IMPLEMENT THIS METHOD *)		END printStackTrace164;		PROCEDURE printStackTrace118*(p0: Object);   (* printStackTrace(Ljava/io/PrintStream;)V *)		BEGIN	(* DON'T IMPLEMENT THIS METHOD *)		END printStackTrace118;				PROCEDURE printStackTrace2574*(p0: Object );   (* printStackTrace(Ljava/io/PrintWriter;)V *)		BEGIN	(* DON'T IMPLEMENT THIS METHOD *)		END printStackTrace2574;		PROCEDURE printStackTrace0(p0: Object);   (* printStackTrace0(Ljava/io/PrintWriter;)V *)		BEGIN	(* put your implementation here *)			JC.String(errorInfo, "Throwable.printStackTrace0 not implemented"); JC.Ln(errorInfo);		END printStackTrace0;		PROCEDURE printStackTrace1(p0: Object);   (* printStackTrace1(Ljava/io/PrintWriter;)V *)		BEGIN	(* DON'T IMPLEMENT THIS METHOD *)		END printStackTrace1;		PROCEDURE stackTraceString(): String;		BEGIN	(* DON'T IMPLEMENT THIS METHOD *)		END stackTraceString;				PROCEDURE setStackTrace*(p0: RefArray);   (* setStackTrace([Ljava/lang/StackTraceElement;)V *)		BEGIN	(* DON'T IMPLEMENT THIS METHOD *)		END setStackTrace;		PROCEDURE this();   (* this()V *)		(* synthetic method, not in source *)		BEGIN	(* DON'T IMPLEMENT THIS METHOD *)		END this;		PROCEDURE toString*(): Object;   (* toString()Ljava/lang/String; *)		BEGIN	(* DON'T IMPLEMENT THIS METHOD *)		END toString;				PROCEDURE finit();		(* dummy synthetic method *)		BEGIN		END finit;	END Throwable;VAR			(* java/lang/Throwable static fields *)	nl-: String;	(* up calls *)	SetMessage* : PROCEDURE ( this: Throwable; message : Object );	(* --> Implementation in jjlString *)	PrintStackTraceToStream* : PROCEDURE( this : Throwable;																				 stream : Object );	(*--> Implementation in jjiPrintStream *)				TrapMap*: ARRAY 19 OF JB.Class;	TrapM14*: JB.Class;	TrapCompiler*: ARRAY 3 OF JB.Class;			PROCEDURE clinit();   (* <clinit>()V *)	BEGIN	(* DON'T IMPLEMENT THIS METHOD *)	END clinit;		PROCEDURE stackTraceStringBuffer(p0: Class; p1: String; p2: RefArray; p3: JT.Int);   (* stackTraceStringBuffer(Ljava/lang/StringBuffer;Ljava/lang/String;[Ljava/lang/StackTraceElement;I)V *)	BEGIN	(* DON'T IMPLEMENT THIS METHOD *)	END stackTraceStringBuffer;	PROCEDURE SaveStack( this, origin, size, pc : LONGINT  );		VAR throwable : Throwable;	BEGIN		throwable := SYSTEM.VAL( Throwable, this );		throwable.pc := pc;		throwable.stackstart := origin;(*		NEW( throwable.stack, size );		SYSTEM.MOVE( origin, SYSTEM.ADR( throwable.stack[0] ), size );*)	END SaveStack;		PROCEDURE TranslateTrap( err : LONGINT; VAR mapped : BOOLEAN ):LONGINT;		VAR ex : jjlObject.Object; cls : JB.Class; tag: PTR;	BEGIN(*		IF TraceMapping THEN JC.Str0("Translate "); JC.Int(err); JC.Ln END;*)			cls := NIL; mapped := FALSE;											IF err = -14 THEN			cls := TrapM14		ELSIF (err >= 0) & (err < 19) THEN			cls := TrapMap[err]		ELSIF (err < 0CAFEH) & (err - 0CAFEH  < 3) THEN			cls := TrapCompiler[err - 0CAFEH]		ELSE			RETURN 0;		END;		IF (cls # NIL) THEN			tag := cls(JB.ObjectClass).typedesc.tag;			(* do not use cls.newInstance() because newInstance makes some Assertions that are not needed*)						JS.NewRec(SYSTEM.VAL(PTR, ex), tag);			ex.class := cls;			ex.init;			mapped := TRUE;			RETURN SYSTEM.VAL( LONGINT, ex )		END;		RETURN err				END TranslateTrap;	PROCEDURE IHandleIt*( ex : PTR; adr : LONGINT ): BOOLEAN;VAR c : JB.ObjectClass; t : Object;		o : Throwable;BEGIN(* ASSERTS are not a goot idea since this is called in privileged mode *)	IF ex = NIL THEN RETURN TRUE END;	c := SYSTEM.VAL( JB.ObjectClass, ex ); 	o := SYSTEM.VAL( Throwable, adr ); 	t := o.getClass();	RETURN c.isAssignableFrom( t(JB.Class) )	END IHandleIt;PROCEDURE Assert( condition : BOOLEAN; extype, msg : ARRAY OF CHAR );VAR cls : JB.Class;  obj : Object;BEGIN	IF ~condition THEN		cls := JB.ThisClass0( extype, TRUE );		ASSERT( (cls#NIL) & (cls IS JB.ObjectClass ));		obj := cls.newInstance();		WITH obj: Throwable DO			obj.cause := obj;			IF msg # "" THEN				obj.detailMessage := jjlString.CreateString0( msg )			END		END;		JE.ThrowException( obj )	ENDEND Assert;					BEGIN	JE.SaveStack := SaveStack; 	JE.TranslateTrap := TranslateTrap;	jjlObject.Assert := Assert;	errorInfo.kind := JC.Error; errorInfo.source := JC.VM;END jjlThrowable.(*	11.01.04	prk	update to classpath 0.06	30.07.03	prk	Logging functions, add kind and source; filtering support	09.03.03	prk	create exception trace	12.02.03	prk	Logging functions, use same interface as AosOut	05.09.01	prk	use java implementation for toString and init	16.08.01	prk	Remove use of Oberon modules, use only Aos ones	11.04.01	prk	update to classpath 0.02*)		