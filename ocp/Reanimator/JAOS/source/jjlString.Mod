(* Jaos, Copyright 2003, Patrik Reali, ETH Zurich *)MODULE jjlString;	(*automatically generated stub for java/lang/String *)	(*WARNING: DON'T CHANGE THE PROCEDURE NAMES*)IMPORT		SYSTEM,		StringPool,		JT := JVMTypes, JS := JVMSystem, jjlObject, BIT;CONST TableSize = 1021;TYPE	Object = jjlObject.Object;	CharArray = jjlObject.CharArray;	RefArray = jjlObject.RefArray;	StringBuffer = jjlObject.Object;	ByteArray = jjlObject.ByteArray;	Locale = jjlObject.Object;	Hashtable = jjlObject.Object;CONST	serialVersionUID* = -6849794470754667710;		TYPE	HashNode = POINTER TO RECORD		next-: HashNode;		string-: String	END;			String* = OBJECT (Object)		VAR			value-: CharArray;			count-: JT.Int;			cachedHashCode-: JT.Int;			offset-: JT.Int;				PROCEDURE init*();   (* <init>()V *)		BEGIN	(* DON'T IMPLEMENT THIS METHOD *)		END init;		PROCEDURE init2488*(p0: StringBuffer);   (* <init>(Ljava/lang/StringBuffer;)V *)		BEGIN	(* DON'T IMPLEMENT THIS METHOD *)		END init2488;		PROCEDURE init1930*(p0: String);   (* <init>(Ljava/lang/String;)V *)		BEGIN	(* DON'T IMPLEMENT THIS METHOD *)		END init1930;		PROCEDURE charAt*(p0: JT.Int): JT.Unicode;   (* charAt(I)C *)		BEGIN	(* DON'T IMPLEMENT THIS METHOD *)		END charAt;		PROCEDURE compareTo6908*(p0: Object): JT.Int;   (* compareTo(Ljava/lang/Object;)I *)		BEGIN	(* DON'T IMPLEMENT THIS METHOD *)		END compareTo6908;		PROCEDURE compareTo1941*(p0: String): JT.Int;   (* compareTo(Ljava/lang/String;)I *)		BEGIN	(* DON'T IMPLEMENT THIS METHOD *)		END compareTo1941;		PROCEDURE compareToIgnoreCase*(p0: String): JT.Int;   (* compareToIgnoreCase(Ljava/lang/String;)I *)		BEGIN	(* DON'T IMPLEMENT THIS METHOD *)		END compareToIgnoreCase;		PROCEDURE contentEquals*(p0: StringBuffer): BOOLEAN;   (* contentEquals(Ljava/lang/StringBuffer;)Z *)		BEGIN	(* DON'T IMPLEMENT THIS METHOD *)		END contentEquals;(*		PROCEDURE concat*(p0: String): String;   (* concat(Ljava/lang/String;)Ljava/lang/String; *)		BEGIN	(* DON'T IMPLEMENT THIS METHOD *)		END concat;*)		PROCEDURE concat*(p0: String): String;   (* concat(Ljava/lang/String;)Ljava/lang/String; *)			VAR s: String; i, j: LONGINT;		BEGIN	(* DON'T IMPLEMENT THIS METHOD *)			NEW(s);			NEW(s.value);			NEW(s.value.p, count + p0.count);			SYSTEM.MOVE(SYSTEM.ADR(value.p[offset]), SYSTEM.ADR(s.value.p[0]), count*2);			SYSTEM.MOVE(SYSTEM.ADR(p0.value.p[p0.offset]), SYSTEM.ADR(s.value.p[count]), p0.count*2);(*			FOR i := 0 TO count-1 DO				s.value.p[i] := value.p[offset+i]			END;			FOR i := 0 TO p0.count-1 DO				s.value.p[count+i] := p0.value.p[p0.offset+i]			END;*)			s.count := count + p0.count;			s.offset := 0;			RETURN s		END concat;				PROCEDURE endsWith*(p0: String): BOOLEAN;   (* endsWith(Ljava/lang/String;)Z *)		BEGIN	(* DON'T IMPLEMENT THIS METHOD *)		END endsWith;		PROCEDURE equalsIgnoreCase*(p0: String): BOOLEAN;   (* equalsIgnoreCase(Ljava/lang/String;)Z *)		BEGIN	(* DON'T IMPLEMENT THIS METHOD *)		END equalsIgnoreCase;		PROCEDURE equals*(p0: Object): BOOLEAN;   (* equals(Ljava/lang/Object;)Z *)		BEGIN	(* DON'T IMPLEMENT THIS METHOD *)		END equals;		PROCEDURE getBytes272*(): ByteArray;   (* getBytes()[B *)		BEGIN	(* DON'T IMPLEMENT THIS METHOD *)		END getBytes272;		PROCEDURE getBytes2528*(p0: JT.Int; p1: JT.Int; p2: ByteArray; p3: JT.Int);   (* getBytes(II[BI)V *)		BEGIN	(* DON'T IMPLEMENT THIS METHOD *)		END getBytes2528;		PROCEDURE getBytes3916*(p0: String): ByteArray;   (* getBytes(Ljava/lang/String;)[B *)		BEGIN	(* DON'T IMPLEMENT THIS METHOD *)		END getBytes3916;		PROCEDURE getChars*(p0: JT.Int; p1: JT.Int; p2: CharArray; p3: JT.Int);   (* getChars(II[CI)V *)		BEGIN	(* DON'T IMPLEMENT THIS METHOD *)		END getChars;		PROCEDURE hashCode*(): JT.Int;   (* hashCode()I *)		BEGIN	(* DON'T IMPLEMENT THIS METHOD *)		END hashCode;		PROCEDURE indexOf503*(p0: JT.Int; p1: JT.Int): JT.Int;   (* indexOf(II)I *)		BEGIN	(* DON'T IMPLEMENT THIS METHOD *)		END indexOf503;		PROCEDURE indexOf127*(p0: JT.Int): JT.Int;   (* indexOf(I)I *)		BEGIN	(* DON'T IMPLEMENT THIS METHOD *)		END indexOf127;		PROCEDURE indexOf1941*(p0: String): JT.Int;   (* indexOf(Ljava/lang/String;)I *)		BEGIN	(* DON'T IMPLEMENT THIS METHOD *)		END indexOf1941;		PROCEDURE indexOf4131*(p0: String; p1: JT.Int): JT.Int;   (* indexOf(Ljava/lang/String;I)I *)		BEGIN	(* DON'T IMPLEMENT THIS METHOD *)		END indexOf4131;		PROCEDURE intern*(): String;   (* intern()Ljava/lang/String; *)				BEGIN			RETURN Internalize(SELF)		END intern;		PROCEDURE lastIndexOf127*(p0: JT.Int): JT.Int;   (* lastIndexOf(I)I *)		BEGIN	(* DON'T IMPLEMENT THIS METHOD *)		END lastIndexOf127;		PROCEDURE lastIndexOf503*(p0: JT.Int; p1: JT.Int): JT.Int;   (* lastIndexOf(II)I *)		BEGIN	(* DON'T IMPLEMENT THIS METHOD *)		END lastIndexOf503;		PROCEDURE lastIndexOf1941*(p0: String): JT.Int;   (* lastIndexOf(Ljava/lang/String;)I *)		BEGIN	(* DON'T IMPLEMENT THIS METHOD *)		END lastIndexOf1941;		PROCEDURE lastIndexOf4131*(p0: String; p1: JT.Int): JT.Int;   (* lastIndexOf(Ljava/lang/String;I)I *)		BEGIN	(* DON'T IMPLEMENT THIS METHOD *)		END lastIndexOf4131;		PROCEDURE length*(): JT.Int;   (* length()I *)		BEGIN	(* DON'T IMPLEMENT THIS METHOD *)		END length;		PROCEDURE matches*(p0: String): BOOLEAN;   (* matches(Ljava/lang/String;)Z *)		BEGIN	(* DON'T IMPLEMENT THIS METHOD *)		END matches;		PROCEDURE regionMatches1690*(p0: JT.Int; p1: String; p2: JT.Int; p3: JT.Int): BOOLEAN;   (* regionMatches(ILjava/lang/String;II)Z *)		BEGIN	(* DON'T IMPLEMENT THIS METHOD *)		END regionMatches1690;		PROCEDURE regionMatches3005*(p0: BOOLEAN; p1: JT.Int; p2: String; p3: JT.Int; p4: JT.Int): BOOLEAN;   (* regionMatches(ZILjava/lang/String;II)Z *)		BEGIN	(* DON'T IMPLEMENT THIS METHOD *)		END regionMatches3005;		PROCEDURE replace*(p0: JT.Unicode; p1: JT.Unicode): String;   (* replace(CC)Ljava/lang/String; *)		BEGIN	(* DON'T IMPLEMENT THIS METHOD *)		END replace;		PROCEDURE replaceAll*(p0: String; p1: String): String;   (* replaceAll(Ljava/lang/String;Ljava/lang/String;)Ljava/lang/String; *)		BEGIN	(* DON'T IMPLEMENT THIS METHOD *)		END replaceAll;		PROCEDURE replaceFirst*(p0: String; p1: String): String;   (* replaceFirst(Ljava/lang/String;Ljava/lang/String;)Ljava/lang/String; *)		BEGIN	(* DON'T IMPLEMENT THIS METHOD *)		END replaceFirst;		PROCEDURE split5908*(p0: String): RefArray;   (* split(Ljava/lang/String;)[Ljava/lang/String; *)		BEGIN	(* DON'T IMPLEMENT THIS METHOD *)		END split5908;		PROCEDURE split7520*(p0: String; p1: JT.Int): RefArray;   (* split(Ljava/lang/String;I)[Ljava/lang/String; *)		BEGIN	(* DON'T IMPLEMENT THIS METHOD *)		END split7520;		PROCEDURE startsWith1926*(p0: String): BOOLEAN;   (* startsWith(Ljava/lang/String;)Z *)		BEGIN	(* DON'T IMPLEMENT THIS METHOD *)		END startsWith1926;		PROCEDURE substring4982*(p0: JT.Int): String;   (* substring(I)Ljava/lang/String; *)		BEGIN	(* DON'T IMPLEMENT THIS METHOD *)		END substring4982;		PROCEDURE startsWith4144*(p0: String; p1: JT.Int): BOOLEAN;   (* startsWith(Ljava/lang/String;I)Z *)		BEGIN	(* DON'T IMPLEMENT THIS METHOD *)		END startsWith4144;		PROCEDURE toCharArray*(): CharArray;   (* toCharArray()[C *)		BEGIN	(* DON'T IMPLEMENT THIS METHOD *)		END toCharArray;		PROCEDURE subSequence*(p0: JT.Int; p1: JT.Int): PTR(*CharSequence*);   (* subSequence(II)Ljava/lang/CharSequence; *)		BEGIN	(* DON'T IMPLEMENT THIS METHOD *)		END subSequence;		PROCEDURE substring1028*(p0: JT.Int; p1: JT.Int): String;   (* substring(II)Ljava/lang/String; *)		BEGIN	(* DON'T IMPLEMENT THIS METHOD *)		END substring1028;		PROCEDURE toLowerCase1539*(): String;   (* toLowerCase()Ljava/lang/String; *)		BEGIN	(* DON'T IMPLEMENT THIS METHOD *)		END toLowerCase1539;		PROCEDURE toLowerCase5543*(p0: Locale): String;   (* toLowerCase(Ljava/util/Locale;)Ljava/lang/String; *)		BEGIN	(* DON'T IMPLEMENT THIS METHOD *)		END toLowerCase5543;		PROCEDURE toString*(): Object;   (* toString()Ljava/lang/String; *)		BEGIN	(* DON'T IMPLEMENT THIS METHOD *)		END toString;		PROCEDURE toUpperCase1539*(): String;   (* toUpperCase()Ljava/lang/String; *)		BEGIN	(* DON'T IMPLEMENT THIS METHOD *)		END toUpperCase1539;		PROCEDURE trim*(): String;   (* trim()Ljava/lang/String; *)		BEGIN	(* DON'T IMPLEMENT THIS METHOD *)		END trim;		PROCEDURE toUpperCase5543*(p0: Locale): String;   (* toUpperCase(Ljava/util/Locale;)Ljava/lang/String; *)		BEGIN	(* DON'T IMPLEMENT THIS METHOD *)		END toUpperCase5543;		PROCEDURE init336*(p0: CharArray);   (* <init>([C)V *)		BEGIN	(* DON'T IMPLEMENT THIS METHOD *)		END init336;		PROCEDURE init1592*(p0: CharArray; p1: JT.Int; p2: JT.Int);   (* <init>([CII)V *)		BEGIN	(* DON'T IMPLEMENT THIS METHOD *)		END init1592;		PROCEDURE init3348(p0: CharArray; p1: JT.Int; p2: JT.Int; p3: BOOLEAN);   (* <init>([CIIZ)V *)		BEGIN	(* DON'T IMPLEMENT THIS METHOD *)		END init3348;		PROCEDURE init340*(p0: ByteArray);   (* <init>([B)V *)		BEGIN	(* DON'T IMPLEMENT THIS METHOD *)		END init340;		PROCEDURE init989*(p0: ByteArray; p1: String);   (* <init>([BLjava/lang/String;)V *)		BEGIN	(* DON'T IMPLEMENT THIS METHOD *)		END init989;		PROCEDURE init1165*(p0: ByteArray; p1: JT.Int; p2: JT.Int; p3: String);   (* <init>([BIILjava/lang/String;)V *)		BEGIN	(* DON'T IMPLEMENT THIS METHOD *)		END init1165;		PROCEDURE init1576*(p0: ByteArray; p1: JT.Int; p2: JT.Int);   (* <init>([BII)V *)		BEGIN	(* DON'T IMPLEMENT THIS METHOD *)		END init1576;		PROCEDURE init896*(p0: ByteArray; p1: JT.Int);   (* <init>([BI)V *)		BEGIN	(* DON'T IMPLEMENT THIS METHOD *)		END init896;		PROCEDURE init3448*(p0: ByteArray; p1: JT.Int; p2: JT.Int; p3: JT.Int);   (* <init>([BIII)V *)		BEGIN	(* DON'T IMPLEMENT THIS METHOD *)		END init3448;	END String;VAR	(* java/lang/String static fields *)	CASEINSENSITIVEORDER*: Object;	(* use object to break recursion *)	upperExpand-: Object;	upperSpecial-: Object;		(* own fields *)	InternTable: ARRAY TableSize OF HashNode;	charArray-: Object; 	class-: Object;		(* should be Class, but in the module hierarchy Strings is lower than JVMBase *)	bootstrapping-: BOOLEAN;	(*JVM is booting, class not available yet*)		(* statistics *)	NInternalizedEntries, NInternalizedSlots: LONGINT;		PROCEDURE upperCaseExpansion(p0: JT.Unicode): JT.Int;   (* upperCaseExpansion(C)I *)	BEGIN	(* DON'T IMPLEMENT THIS METHOD *)	END upperCaseExpansion;	PROCEDURE upperCaseIndex(p0: JT.Unicode): JT.Int;   (* upperCaseIndex(C)I *)	BEGIN	(* DON'T IMPLEMENT THIS METHOD *)	END upperCaseIndex;	PROCEDURE valueOf273*(p0: JT.Unicode): String;   (* valueOf(C)Ljava/lang/String; *)	BEGIN	(* DON'T IMPLEMENT THIS METHOD *)	END valueOf273;	PROCEDURE valueOf7612*(p0: JT.Double): String;   (* valueOf(D)Ljava/lang/String; *)	BEGIN	(* DON'T IMPLEMENT THIS METHOD *)	END valueOf7612;	PROCEDURE valueOf8942*(p0: JT.Float): String;   (* valueOf(F)Ljava/lang/String; *)	BEGIN	(* DON'T IMPLEMENT THIS METHOD *)	END valueOf8942;	PROCEDURE valueOf736*(p0: JT.Long): String;   (* valueOf(J)Ljava/lang/String; *)	BEGIN	(* DON'T IMPLEMENT THIS METHOD *)	END valueOf736;	PROCEDURE valueOf4982*(p0: JT.Int): String;   (* valueOf(I)Ljava/lang/String; *)	BEGIN	(* DON'T IMPLEMENT THIS METHOD *)	END valueOf4982;	PROCEDURE valueOf5901*(p0: Object): String;   (* valueOf(Ljava/lang/Object;)Ljava/lang/String; *)	BEGIN	(* DON'T IMPLEMENT THIS METHOD *)	END valueOf5901;	PROCEDURE valueOf8075*(p0: BOOLEAN): String;   (* valueOf(Z)Ljava/lang/String; *)	BEGIN	(* DON'T IMPLEMENT THIS METHOD *)	END valueOf8075;	PROCEDURE valueOf3909*(p0: CharArray): String;   (* valueOf([C)Ljava/lang/String; *)	BEGIN	(* DON'T IMPLEMENT THIS METHOD *)	END valueOf3909;		PROCEDURE valueOf1007*(p0: CharArray; p1: JT.Int; p2: JT.Int): String;   (* valueOf([CII)Ljava/lang/String; *)	BEGIN	(* DON'T IMPLEMENT THIS METHOD *)	END valueOf1007;	PROCEDURE copyValueOf3909*(p0: CharArray): String;   (* copyValueOf([C)Ljava/lang/String; *)	BEGIN	(* DON'T IMPLEMENT THIS METHOD *)	END copyValueOf3909;	PROCEDURE copyValueOf1007*(p0: CharArray; p1: JT.Int; p2: JT.Int): String;   (* copyValueOf([CII)Ljava/lang/String; *)	BEGIN	(* DON'T IMPLEMENT THIS METHOD *)	END copyValueOf1007;		PROCEDURE zeroBasedStringValue(p0: String): CharArray;	BEGIN	(* DON'T IMPLEMENT THIS METHOD *)	END zeroBasedStringValue;	PROCEDURE clinit();   (* <clinit>()V *)	BEGIN	(* DON'T IMPLEMENT THIS METHOD *)	END clinit;	PROCEDURE CreateString*(str: JT.String): String;	(** for creating Strings from oberon, bootstrap only *)	VAR s: String;	BEGIN				ASSERT((class # NIL) OR bootstrapping);		NEW(s);  NEW(s.value);		s.value.p := str;		s.class := class;		s.value.class := charArray;		s.offset := 0;  s.count := LEN(s.value.p^);		RETURN s	END CreateString;		PROCEDURE CreateString0*(str: ARRAY OF CHAR): String;	(** for creating Strings from oberon, bootstrap only *)	VAR s: String;	BEGIN		ASSERT((class # NIL) OR bootstrapping);		NEW(s); NEW(s.value);		JT.OberonToJavaString(str, s.value.p);		s.class := class;		s.value.class := charArray;		s.offset := 0; s.count := LEN(s.value.p^);		RETURN s	END CreateString0;		PROCEDURE Hash(name: JT.String; len: LONGINT):LONGINT;	VAR hash, i: LONGINT;	BEGIN		hash := 0;		FOR i := 0 TO len-1 DO			hash :=  ASH(hash, 1); hash := BIT.LXOR(hash, name[i]); hash := hash MOD TableSize 		END;		RETURN hash	END Hash;		PROCEDURE Hash0(name: ARRAY OF CHAR): LONGINT;	VAR hash, i: LONGINT;	BEGIN		hash := 0; i := 0;		WHILE name[i] # 0X DO			hash :=  ASH(hash, 1); hash := BIT.LXOR(hash, ORD(name[i])); hash := hash MOD TableSize;			INC(i)		END;		RETURN hash	END Hash0;		(** MakeLiteral - Insert a string in the pool or return a string with equivalent value if already there *)		PROCEDURE Internalize(s: String): String;		VAR  index: LONGINT;  n, p, q: HashNode;	BEGIN {EXCLUSIVE}		index := Hash(s.value.p, s.count);		p := InternTable[index];		IF p = NIL THEN			INC(NInternalizedEntries); INC(NInternalizedSlots);			NEW(n); n.string := s; InternTable[index] := n		ELSE			WHILE (p # NIL) & (s # p.string) & ~JT.Equal(s.value.p, s.count, p.string.value.p, p.string.count) DO				q := p; p := p.next			END;			IF p = NIL THEN				INC(NInternalizedEntries);				NEW(n); n.string := s; q.next := n			ELSE				s := p.string			END		END;		RETURN s	END Internalize;		PROCEDURE MakeLiteral*(s: JT.String;  slen: LONGINT): String;		VAR  index: LONGINT;  n, p, q: HashNode;	BEGIN {EXCLUSIVE}		index := Hash(s, slen);		p := InternTable[index];		IF p = NIL THEN			INC(NInternalizedEntries); INC(NInternalizedSlots);			NEW(n); n.string := CreateString(s); InternTable[index] := n		ELSE			WHILE (p # NIL) & ~JT.Equal(s, slen, p.string.value.p, p.string.count) DO q := p; p := p.next END;			IF p = NIL THEN				INC(NInternalizedEntries);				NEW(n); n.string := CreateString(s); q.next := n			ELSE				n := p			END		END;		RETURN n.string	END MakeLiteral;		PROCEDURE MakeLiteral1*(str: ARRAY OF CHAR): String;		VAR  index: LONGINT;  n, p, q: HashNode;	BEGIN		BEGIN {EXCLUSIVE}			index := Hash0(str);			p := InternTable[index];			IF p = NIL THEN				INC(NInternalizedEntries); INC(NInternalizedSlots);				NEW(n); n.string := CreateString0(str); InternTable[index] := n			ELSE				WHILE (p # NIL) & ~JT.Equal0(p.string.value.p, p.string.count, str) DO q := p; p := p.next END;				IF p = NIL THEN					INC(NInternalizedEntries);					NEW(n); n.string := CreateString0(str); q.next := n				ELSE					n := p				END			END		END;		RETURN n.string	END MakeLiteral1;		PROCEDURE MakeLiteral0*(idx: StringPool.Index): String;	VAR  index: LONGINT;  n, p, q: HashNode; str: ARRAY 256 OF CHAR;	BEGIN		StringPool.GetString(idx, str);		RETURN MakeLiteral1(str)	END MakeLiteral0;		PROCEDURE EqualStrings*(a, b: String): BOOLEAN;	(* bootstrap *)	BEGIN RETURN JT.Equal(a.value.p, a.count, b.value.p, b.count)	END EqualStrings;		PROCEDURE CompareStrings*(a, b: String): LONGINT;	BEGIN RETURN JT.CompareUniString(a.value.p, a.count, b.value.p, b.count)	END CompareStrings;		PROCEDURE ToOberon*(s: String; VAR str: ARRAY OF CHAR);	BEGIN JT.JavaToOberonString(s.value.p, s.offset, s.count, str)	END ToOberon;		PROCEDURE Initialize*(charArrayClass, stringClass: Object);		VAR i: LONGINT;  p: HashNode;	BEGIN {EXCLUSIVE}		charArray := charArrayClass;		class := stringClass;		bootstrapping := FALSE;				(*patch class field in all registered strings*)		FOR i := 0 TO TableSize-1 DO			p := InternTable[i];			WHILE p # NIL DO				p.string.class := stringClass;				p.string.value.class := charArrayClass;				p := p.next			END		END	END Initialize;BEGIN	bootstrapping := TRUEEND jjlString.(*	05.09.01	prk	XOR removed, use BIT.LXOR instead	29.05.01	prk	initialization improved	18.05.01	prk	use classpath implementation	11.04.01	prk	update to classpath 0.02*)	