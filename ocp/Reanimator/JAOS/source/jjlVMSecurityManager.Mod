(* Jaos, Copyright 2003, Patrik Reali, ETH Zurich *)MODULE jjlVMSecurityManager;	(*automatically generated stub for java/lang/VMSecurityManager *)	(*WARNING: DON'T CHANGE THE PROCEDURE NAMES*)IMPORT		SYSTEM,		AosModules,		PCT,		JT := JVMTypes, jjlObject, JC := JVMConsole, JB := JVMBase;CONST	Trace = FALSE;TYPE	Object = jjlObject.Object;	ClassLoader = jjlObject.Object(*jjlClassLoader.ClassLoader*);	RefArray = jjlObject.RefArray;VAR	debugInfo: JC.LoggingInfo;TYPE	VMSecurityManager* = OBJECT (Object)		PROCEDURE init();   (* <init>()V *)		BEGIN	(* DON'T IMPLEMENT THIS METHOD *)		END init;	END VMSecurityManager;	VAR		searchedPc: LONGINT;		searchedClass: JB.RefClass;	PROCEDURE currentClassLoader(): ClassLoader;   (* currentClassLoader()Ljava/lang/ClassLoader; *)	BEGIN	(* put your implementation here *)		HALT(99)	END currentClassLoader;		PROCEDURE SearchForPC(m: PCT.Module);		VAR c: JB.Class; base: LONGINT;	BEGIN		IF m.info # NIL THEN			c := m.info(JB.Class);			IF c IS JB.RefClass THEN				WITH c: JB.RefClass DO					base := SYSTEM.ADR(c.ownModule.code[0]);					IF (searchedPc >= base) & (searchedPc < base + LEN(c.ownModule.code)) THEN						searchedClass := c					ELSIF c.stub # NIL THEN						base := SYSTEM.ADR(c.stub.code[0]);						IF (searchedPc >= base) & (searchedPc < base + LEN(c.stub.code)) THEN							searchedClass := c						END					END				END			END		END	END SearchForPC;		PROCEDURE getClassContext(): RefArray;   (* getClassContext()[Ljava/lang/Class; *)		VAR fp, pc, pos, i: LONGINT; stack: ARRAY 128 OF JB.Class; r: RefArray;			m: AosModules.Module;	BEGIN		IF Trace THEN JC.String(debugInfo, "getClassContext:"); JC.Ln(debugInfo) END;		SYSTEM.GETREG(SYSTEM.EBP, fp);		SYSTEM.GET(fp+4, pc);		SYSTEM.GET(fp, fp);		WHILE (fp # 0) DO			SYSTEM.GET(fp+4, pc);			searchedPc := pc; searchedClass := NIL;			PCT.Enumerate(JT.DB, SearchForPC);			IF searchedClass # NIL THEN				IF Trace THEN JC.Char(debugInfo, 9X); JC.String(debugInfo, searchedClass.obmod); JC.Ln(debugInfo) END;				stack[pos] := searchedClass;				INC(pos)			ELSIF Trace THEN				m := AosModules.ThisModuleByAdr(pc);				IF m # NIL THEN					JC.Char(debugInfo, 9X); JC.String(debugInfo, "!"); JC.String(debugInfo, m.name); JC.Ln(debugInfo);				ELSE					JC.Char(debugInfo, 9X); JC.String(debugInfo, "failed"); JC.Ln(debugInfo);				END			END;			SYSTEM.GET(fp, fp);		END;				NEW(r);		NEW(r.p, pos);		FOR i := 0 TO pos-1 DO  r.p[i] := stack[i]  END;		RETURN r	END getClassContext;BEGIN	debugInfo.kind := JC.Debug; debugInfo.source := JC.VM;END jjlVMSecurityManager.(*	30.07.03	prk	Logging functions, add kind and source; filtering support	12.02.03	prk	Logging functions, use same interface as AosOut	11.03.02	prk	first implementation*)