(* Jaos, Copyright 2003, Patrik Reali, ETH Zurich *)MODULE jjlMath;	(*automatically generated stub for java/lang/Math *)	(*WARNING: DON'T CHANGE THE PROCEDURE NAMES*)IMPORT  MathL, JS := JVMSystem, JT := JVMTypes, jjlObject, jjlDouble(*, jjuRandom*);TYPE	Object = jjlObject.Object;	(*Random = jjuRandom.Random;*)CONST	(* static final fields *)	E* = MathL.e;	PI* = MathL.pi;	TYPE	Math* = OBJECT (Object)		PROCEDURE init*();   (* <init>()V *)		BEGIN	(* DON'T IMPLEMENT THIS METHOD *)		END init;	END Math;VAR	rand-: Object;(*Random;*)	PROCEDURE clinit();   (* <clinit>()V *)	BEGIN	(* DON'T IMPLEMENT THIS METHOD *)	END clinit;	PROCEDURE IEEEremainder*(x: JT.Double; y: JT.Double): JT.Double;   (* IEEEremainder(DD)D *)	BEGIN		RETURN JS.IEEEReminder( x, y )	END IEEEremainder;	PROCEDURE abs70*(p0: JT.Double): JT.Double;   (* abs(D)D *)	BEGIN	(* DON'T IMPLEMENT THIS METHOD *)	END abs70;	PROCEDURE abs76*(p0: JT.Float): JT.Float;   (* abs(F)F *)	BEGIN	(* DON'T IMPLEMENT THIS METHOD *)	END abs76;	PROCEDURE abs127*(p0: JT.Int): JT.Int;   (* abs(I)I *)	BEGIN	(* DON'T IMPLEMENT THIS METHOD *)	END abs127;	PROCEDURE abs112*(p0: JT.Long): JT.Long;   (* abs(J)J *)	BEGIN	(* DON'T IMPLEMENT THIS METHOD *)	END abs112;	PROCEDURE acos*(y: JT.Double): JT.Double;   (* acos(D)D *)	VAR x, res : LONGREAL;	BEGIN		IF (y < 0.0) OR (y > PI) THEN			res := jjlDouble.NaN		ELSE			x :=y*y;					res := MathL.arctan( MathL.sqrt((1-x)/x) )		END;		RETURN res	END acos;	PROCEDURE asin*(y: JT.Double): JT.Double;   (* asin(D)D *)	VAR x, res : LONGREAL;	BEGIN		IF (y < -PI/2) OR (y > PI/2) THEN			res := jjlDouble.NaN		ELSE			x := y*y;			res :=  MathL.arctan( MathL.sqrt( x/(1-x)))		END;		RETURN res	END asin;	PROCEDURE atan*(x: JT.Double): JT.Double;   (* atan(D)D *)	VAR res: LONGREAL;	BEGIN		IF (x < -PI/2) OR (x > PI/2) THEN			res := jjlDouble.NaN		ELSE			res := MathL.arctan( x )		END;		RETURN res	END atan;	PROCEDURE atan2*(x: JT.Double; y: JT.Double): JT.Double;   (* atan2(DD)D *)	VAR phi : LONGREAL;	BEGIN			phi := y/x(*/MathL.sqrt( x*x+y*y )*);		RETURN MathL.arctan( phi )	END atan2;	PROCEDURE ceil*(x: JT.Double): JT.Double;   (* ceil(D)D *)	VAR r : LONGREAL;	BEGIN		r := JS.Round( x, JS.RCHOP );			IF r >= x THEN RETURN r		ELSE RETURN (r+1.0) END			END ceil;	PROCEDURE cos*(x: JT.Double): JT.Double;   (* cos(D)D *)	BEGIN			RETURN MathL.cos( x )	END cos;	PROCEDURE exp*(x: JT.Double): JT.Double;   (* exp(D)D *)	BEGIN		RETURN MathL.exp( x )	END exp;	PROCEDURE floor*(x: JT.Double): JT.Double;   (* floor(D)D *)	VAR r : LONGREAL;	BEGIN		r := JS.Round( x, JS.RCHOP );		IF r <= x THEN RETURN r		ELSE RETURN (r-1.0) 		END			END floor;	PROCEDURE log*(x: JT.Double): JT.Double;   (* log(D)D *)	BEGIN			RETURN MathL.ln( x )	END log;	PROCEDURE max422*(p0: JT.Double; p1: JT.Double): JT.Double;   (* max(DD)D *)	BEGIN	(* DON'T IMPLEMENT THIS METHOD *)	END max422;	PROCEDURE max444*(p0: JT.Float; p1: JT.Float): JT.Float;   (* max(FF)F *)	BEGIN	(* DON'T IMPLEMENT THIS METHOD *)	END max444;	PROCEDURE max503*(p0: JT.Int; p1: JT.Int): JT.Int;   (* max(II)I *)	BEGIN	(* DON'T IMPLEMENT THIS METHOD *)	END max503;	PROCEDURE max480*(p0: JT.Long; p1: JT.Long): JT.Long;   (* max(JJ)J *)	BEGIN	(* DON'T IMPLEMENT THIS METHOD *)	END max480;	PROCEDURE min422*(p0: JT.Double; p1: JT.Double): JT.Double;   (* min(DD)D *)	BEGIN	(* DON'T IMPLEMENT THIS METHOD *)	END min422;	PROCEDURE min444*(p0: JT.Float; p1: JT.Float): JT.Float;   (* min(FF)F *)	BEGIN	(* DON'T IMPLEMENT THIS METHOD *)	END min444;	PROCEDURE min503*(p0: JT.Int; p1: JT.Int): JT.Int;   (* min(II)I *)	BEGIN	(* DON'T IMPLEMENT THIS METHOD *)	END min503;	PROCEDURE min480*(p0: JT.Long; p1: JT.Long): JT.Long;   (* min(JJ)J *)	BEGIN	(* DON'T IMPLEMENT THIS METHOD *)	END min480;	PROCEDURE pow*(x: JT.Double; y: JT.Double): JT.Double;   (* pow(DD)D *)	BEGIN			RETURN MathL.exp( y* MathL.ln( x ) )	END pow;	PROCEDURE random*(): JT.Double;   (* random()D *)	BEGIN	(* DON'T IMPLEMENT THIS METHOD *)	END random;	PROCEDURE rint*(x: JT.Double): JT.Double;   (* rint(D)D *)	BEGIN			RETURN JS.Round( x, JS.RNEAREST )	END rint;		PROCEDURE round72*(p0: JT.Double): JT.Long;   (* round(D)J *)	BEGIN	(* DON'T IMPLEMENT THIS METHOD *)	END round72;	PROCEDURE round75*(p0: JT.Double): JT.Int;   (* round(D)I *)	BEGIN	(* DON'T IMPLEMENT THIS METHOD *)	END round75;	PROCEDURE round67*(p0: JT.Float): JT.Int;   (* round(F)I *)	BEGIN	(* DON'T IMPLEMENT THIS METHOD *)	END round67;	PROCEDURE sin*(x: JT.Double): JT.Double;   (* sin(D)D *)	BEGIN			RETURN MathL.sin( x );	END sin;	PROCEDURE sqrt*(x: JT.Double): JT.Double;   (* sqrt(D)D *)	BEGIN		RETURN MathL.sqrt( x )	END sqrt;	PROCEDURE tan*(x: JT.Double): JT.Double;   (* tan(D)D *)	BEGIN			RETURN MathL.sin( x )/MathL.cos(x)	END tan;	PROCEDURE toDegrees*(p0: JT.Double): JT.Double;   (* toDegrees(D)D *)	BEGIN	(* DON'T IMPLEMENT THIS METHOD *)	END toDegrees;	PROCEDURE toRadians*(p0: JT.Double): JT.Double;   (* toRadians(D)D *)	BEGIN	(* DON'T IMPLEMENT THIS METHOD *)	END toRadians;END jjlMath.(*	23.05.01	prk	asin, acos, atan: operand range checking	11.04.01	prk	update to classpath 0.02	04.04.01	prk	merge with classpath-0.00 release, prepare for update with 0.01, minimize differencies	04.04.01	prk	First implementation*)