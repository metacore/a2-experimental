<?xml version="1.0" encoding="ISO-8859-1" standalone="yes"?>

<Kernels>
	
	<ILKernel name = "SubCopy2DAligned_LI_R_LR">		
<![CDATA[
il_ps_2_0
;
;	2D subarray copy for the case when arrays are non virtualized and copy regions are aligned to
;	nComponents (srcOrigin[1] MOD nComponents = 0) & (dstOrigin[1] MOD nComponents = 0) 
;	& (subSize[1] MOD nComponents) = 0)
;	for both input and output
; 
;	inputs: 1
;	outputs: 1
;	data type: LONGINT/REAL/LONGREAL
;	nComponents: any (but same for input and output)
;	constants: 1 (REAL) : [(srcOrigin[1]-dstOrigin[1]) DIV nComponents,srcOrigin[0]-dstOrigin[0],...,...]
;
dcl_input_position_interp(linear_noperspective) vWinCoord0.xy__ ; origin in the output range
dcl_output_generic o0
dcl_cb cb0[1]
dcl_resource_id(0)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)

add r0.xy, vWinCoord0.xy, cb0[0].xy	; compute position in the input
sample_resource(0)_sampler(0) r1, r0
mov o0, r1
end
]]>
	</ILKernel>
	
	<ILKernel name = "SubCopy2DUnaligned_LI_R_4">
<![CDATA[
il_ps_2_0
;
;	2D subarray copy for the case when arrays are non virtualized and copy regions are not aligned to
;	nComponents (srcOrigin[1] MOD nComponents # 0) OR (dstOrigin[1] MOD nComponents # 0) OR (subSize[1] MOD nComponents) # 0)
; 
;	inputs: 2 (src,dst)
;	outputs: 1 (dst)
;	data type: LONGINT/REAL
;	nComponents: 4 (same for input and output)
;	constants: 1,  2 x 4 (LONGINT) : [srcOrigin[1],srcOrigin[0],dstOrigin[1],dstOrigin[0]];  [subSize[1],subSize[0],dstOrigin[1] DIV 4,...]
;
dcl_input_position_interp(linear_noperspective) vWinCoord0.xy__ ; origin in the output range
dcl_output_generic o0
dcl_cb cb0[2]
dcl_resource_id(0)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float) ; src array
dcl_resource_id(1)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float) ; dst array

dcl_literal l0, 4, 0xFFFFFFFF, 0xFFFFFFFF, 0

ftoi r0.xy, vWinCoord0.xy ; convert output position in multi-component elements  to integers
mov r0.z, r0.x ; r0.z := Int(vWinCoord0.x)

; output position in single-component elements
umul r0.x, r0.x, l0.x ; x*4

; account unaligned dstOrigin[1]
ieq r4.x, r0.z, cb0[1].z ; Int(vWinCoord0.x) = dstOrigin[1] DIV 4
if_logicalnz r4.x
	umod r4.x, cb0[0].z, l0.x ; dstOrigin[1] MOD 4
	iadd r0.x, r0.x, r4.x
endif

; input position in single-component elements
umad r1.xy, cb0[0].zw, l0.yz, cb0[0].xy ; [srcOrigin[1],srcOrigin[0]] - [dstOrigin[1],dstOrigin[0]]
iadd r1.xy, r0.xy, r1.xy

umod r4.x, r1.x, l0.x ; input.x MOD 4
udiv r1.x, r1.x, l0.x ; input position in multi-component elements
itof r1.xy, r1.xy

switch r4.x
	
	case 0
		sample_resource(0)_sampler(0) r3.xyzw, r1.xy
	break
		
	case 1		
		sample_resource(0)_sampler(0) r3._yzw, r1.xy		
		sample_resource(0)_sampler(0)_aoffimmi(1,0,0) r3.x___, r1.xy
		mov r3.xyzw, r3.yzwx
	break
	
	case 2
		sample_resource(0)_sampler(0) r3.__zw, r1.xy
		sample_resource(0)_sampler(0)_aoffimmi(1,0,0) r3.xy__, r1.xy		
		mov r3.xyzw, r3.zwxy
	break
	
	case 3
		sample_resource(0)_sampler(0) r3.___w, r1.xy
		sample_resource(0)_sampler(0)_aoffimmi(1,0,0) r3.xyz_, r1.xy
		mov r3.xyzw, r3.wxyz
	break
endswitch

; write to the output

iadd r4.x, cb0[0].z, cb0[1].x ; dstOrigin[1] + subSize[1]	
iadd r4.x, r4.x, l0.y ; dstOrigin[1] + subSize[1] - 1 ; right dst bound in single-component elements	
udiv r4.y, r4.x, l0.x ; (dstOrigin[1] + subSize[1] - 1) DIV 4 ; right dst bound in multi-component elements

ine r4.z, r0.z, cb0[1].z ; output.x # (dstOrigin[1] DIV 4) -> not the left dst bound
if_logicalnz r4.z		
	
	ine r4.z, r0.z, r4.y ; Int(vWinCoord0.x) # (dstOrigin[1] + subSize[1] - 1) DIV 4 -> not the right dst bound
	if_logicalnz r4.z
		mov o0.xyzw, r3.xyzw
	else
		
		umod r4.z, r4.x, l0.x ; (dstOrigin[1] + subSize[1] - 1) MOD 4
		
		switch r4.z
			
			case 0
				sample_resource(1)_sampler(1) r3._yzw, vWinCoord0.xy
				mov o0, r3
			break
			
			case 1
				sample_resource(1)_sampler(1) r3.__zw, vWinCoord0.xy
				mov o0, r3
			break
			
			case 2
				sample_resource(1)_sampler(1) r3.___w, vWinCoord0.xy
				mov o0, r3
			break
			
			case 3
				mov o0, r3
			break
		endswitch
		
	endif
	
else ; the left dst bound

	ine r4.z, r0.z, r4.y ; Int(vWinCoord0.x) # (dstOrigin[1] + subSize[1] - 1) DIV 4 -> not the right dst bound
	if_logicalnz r4.z
			
		umod r4.z, cb0[0].z, l0.x ; dstOrigin[1] MOD 4
		
		switch r4.z						
		
			case 0
				mov o0, r3
			break
			
			case 1
				mov r3.0yzw, r3.0xyz
				sample_resource(1)_sampler(1) r3.x___, vWinCoord0.xy
				mov o0, r3
			break
			
			case 2
				mov r3.00zw, r3.00xy
				sample_resource(1)_sampler(1) r3.xy__, vWinCoord0.xy
				mov o0, r3
			break
			
			case 3
				mov r3.000w, r3.000x
				sample_resource(1)_sampler(1) r3.xyz_, vWinCoord0.xy
				mov o0, r3
			break
									
		endswitch				
			
	else ; very specific case when subSize[1] <= nComponents			
	
		umod r4.x, cb0[0].z, l0.x; dstOrigin[1] MOD 4		
		
		switch r4.x
			
			case 0				
				switch cb0[1].x ; subSize[1]
				
					case 1
						sample_resource(1)_sampler(1) r3._yzw, vWinCoord0.xy
						mov o0, r3
					break
					
					case 2
						sample_resource(1)_sampler(1) r3.__zw, vWinCoord0.xy
					mov o0, r3
					break
					
					case 3
						sample_resource(1)_sampler(1) r3.___w, vWinCoord0.xy
						mov o0, r3
					break
					
					case 4
						mov o0, r3
					break
										
				endswitch;
			break
			
			case 1
				switch cb0[1].x ; subSize[1]
					case 1
						mov r3.y, r3.x
						sample_resource(1)_sampler(1) r3.x_zw, vWinCoord0.xy	
						mov o0, r3
					break
					
					case 2
						mov r3.0yz0, r3.0xy0
						sample_resource(1)_sampler(1) r3.x__w, vWinCoord0.xy	
						mov o0, r3
					break
					
					case 3
						mov r3.0yzw, r3.0xyz
						sample_resource(1)_sampler(1) r3.x___, vWinCoord0.xy	
						mov o0, r3
					break										
				endswitch;
			break
			
			case 2
				switch cb0[1].x ; subSize[1]
					case 1
						mov r3.z, r3.x
						sample_resource(1)_sampler(1) r3.xy_w, vWinCoord0.xy	
						mov o0, r3
					break
					
					case 2
						mov r3.00zw, r3.00xy
						sample_resource(1)_sampler(1) r3.xy__, vWinCoord0.xy
						mov o0, r3
					break										
				endswitch;
			break
			
			case 3				
				mov r3.w, r3.x
				sample_resource(1)_sampler(1) r3.xyz_, vWinCoord0.xy
				mov o0, r3
			break
		endswitch				
		
	endif

endif								

end				
]]>	
	</ILKernel>
	
	<ILKernel name = "SubCopy2DNonVirtToVirt_LI_R_4">					
<![CDATA[
il_ps_2_0
;
;	2D subarray copy for the case when source array is not virtualized and destination is virtualized
; 
;	inputs: 1 (src)
;	outputs: 1 (dst)
;	data type: LONGINT/REAL
;	nComponents: 4 - for the input, 1 - for the output (virtualized)
;	constants: 1, 2x4 (LONGINT) : [srcOrigin[1]-dstOrigin[1],srcOrigin[0]-dstOrigin[0],dst.Width,dst.physWidth]; [dstOrigin[1],dstOrigin[0],dstOrigin[1]+subSize[1]-1,dstOrigin[0]+subSize[0]-1]
;
dcl_input_position_interp(linear_noperspective) vWinCoord0.xy__ ; origin in the output range
dcl_output_generic o0
dcl_cb cb0[2]
dcl_resource_id(0)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float) ; src array
dcl_resource_id(1)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float) ; dst array

dcl_literal l0, 4, 0, 0, 0

; compute linear index in the output
ftoi r0.xy, vWinCoord0.xy
umad r0.x, r0.y, cb0[0].w, r0.x ; ind := y*dst.physWidth + x

; compute non-virtual position in the output
udiv r0.y, r0.x, cb0[0].z ; y := ind DIV dst.Width
umod r0.x, r0.x, cb0[0].z

ilt r1.xy, r0.xy, cb0[1].xy ; [x,y] < [dstOrigin[1],dstOrigin[0]]
inot r1.xy, r1.xy ;  ~([x,y] < [dstOrigin[1],dstOrigin[0]]) -> [x,y] >= [dstOrigin[1],dstOrigin[0]]
ilt r2.xy, r0.xy, cb0[1].zw ; [x,y] < [dstOrigin[1]+subSize[1]-1,dstOrigin[0]+subSize[0]-1]
and r1.xy, r1.xy, r2.xy
ieq r2.xy, r0.xy, cb0[1].zw ; [x,y] = [dstOrigin[1]+subSize[1]-1,dstOrigin[0]+subSize[0]-1]
ior r1.xy, r1.xy, r2.xy ; ([x,y] >= [dstOrigin[1],dstOrigin[0]]) & ([x,y] <= [dstOrigin[1]+subSize[1]-1,dstOrigin[0]+subSize[0]-1])

and r1.x, r1.x, r1.y
if_logicalnz r1.x

	; compute 2D position in the input, in single-component elements
	iadd r0.xy, r0.xy, cb0[0].xy

	umod r0.z, r0.x, l0.x ; x MOD 4

	udiv r0.x, r0.x, l0.x ; input position in multi-component elements
	itof r0.xy, r0.xy ; convert [x,y] to floats

	switch r0.z
		
		case 0
			sample_resource(0)_sampler(0) o0.x, r0.xy
		break
		
		case 1
			sample_resource(0)_sampler(0) r1._y__, r0.xy
			mov o0.x, r1.y
		break
		
		case 2
			sample_resource(0)_sampler(0) r1.__z_, r0.xy
			mov o0.x, r1.z
		break
	
		case 3
			sample_resource(0)_sampler(0) r1.___w, r0.xy
			mov o0.x, r1.w
		break
	endswitch	

else
	sample_resource(1)_sampler(1) o0.x, vWinCoord0.xy	
endif

end				
]]>	
	</ILKernel>
	
	<ILKernel name = "SubCopy2DVirtToNonVirtAligned_LI_R_4">	
<![CDATA[
il_ps_2_0
;
;	2D subarray copy for the case when source array is virtualized, destination is not virtualized, and copy regions are aligned to
;	nComponents (dstOrigin[1] MOD nComponents = 0) & (subSize[1] MOD nComponents) = 0)
; 
;	inputs: 1 (src)
;	outputs: 1 (dst)
;	data type: LONGINT/REAL
;	nComponents: 4 - for the output, 1 - for the input (virtualized)
;	constants: 1 (LONGINT) : [srcOrigin[1]-dstOrigin[1],srcOrigin[0]-dstOrigin[0],src.Width,src.physWidth]
;
dcl_input_position_interp(linear_noperspective) vWinCoord0.xy__ ; origin in the output range
dcl_output_generic o0
dcl_cb cb0[1]
dcl_resource_id(0)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float) ; src array
dcl_resource_id(1)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float) ; dst array

dcl_literal l0, 4, 0xFFFFFFFF, 0, 0

; compute non-virtual position in the input
ftoi r0.xy, vWinCoord0.xy
umul r0.x, r0.x, l0.x ; output position in single-component elements
iadd r0.xy, r0.xy, cb0[0].xy ; input position in single-component elements

; compute linear index in the input
umad r1.x, r0.y, cb0[0].z, r0.x ; ind := y*src.Width + x

; compute 2D virtual position in the input
udiv r1.y, r1.x, cb0[0].w ; y := ind DIV src.physWidth
umod r1.x, r1.x, cb0[0].w ; x := ind MOD src.physWidth

umad r4.x, r1.x, l0.y, cb0[0].w ; r4.x := src.physWidth - x

itof r1.xy, r1.xy

ige r4.z, r4.x, l0.x ; src.physWidth - x >= 4
if_logicalnz r4.z		
	
	sample_resource(0)_sampler(0)_aoffimmi(0,0,0) o0.x, r1.xy
	sample_resource(0)_sampler(0)_aoffimmi(1,0,0) o0.y, r1.xy
	sample_resource(0)_sampler(0)_aoffimmi(2,0,0) o0.z, r1.xy
	sample_resource(0)_sampler(0)_aoffimmi(3,0,0) o0.w, r1.xy
		
else
	
	itof r5.x, cb0[0].w
	
	add r2.xy, r1.xy, r1.10
	ge r5.z, r2.x, r5.x ; x+1 >= src.physWidth
	if_logicalnz r5.z
		add r2.0y, r2.y, r2.1 ; INC(y)
	endif
	
	add r3.xy, r2.xy, r2.10
	ge r5.z, r3.x, r5.x ; x+1 >= src.physWidth
	if_logicalnz r5.z
		add r3.0y, r3.y, r3.1 ; INC(y)
	endif
	
	add r4.xy, r3.xy, r3.10
	ge r5.z, r4.x, r5.x ; x+1 >= src.physWidth
	if_logicalnz r5.z
		add r4.0y, r4.y, r4.1 ; INC(y)
	endif
	
	sample_resource(0)_sampler(0) o0.x, r1.xy
	sample_resource(0)_sampler(0) o0.y, r2.xy
	sample_resource(0)_sampler(0) o0.z, r3.xy
	sample_resource(0)_sampler(0) o0.w, r4.xy
		
endif

end
]]>	
	</ILKernel>
	
	<ILKernel name = "SubCopy2DSplit8ToNonVirtAligned_LI_R_LR">		
<![CDATA[
il_ps_2_0
;
;	2D subarray copy for the case when input array is splitted into 8 parts, output array is not virtualized
;	and copy regions are aligned to nComponents (srcOrigin[1] MOD nComponents = 0) 
;	& (dstOrigin[1] MOD nComponents = 0) & (subSize[1] MOD nComponents) = 0) for both input and output
; 
;	inputs: 8
;	outputs: 1
;	data type: LONGINT/REAL/LONGREAL
;	nComponents: any (but same for input and output)
;	constants: 1 (REAL) : [(srcOrigin[1]-dstOrigin[1]) DIV nComponents,srcOrigin[0]-dstOrigin[0],...,...]
;
dcl_input_position_interp(linear_noperspective) vWinCoord0.xy__ ; origin in the output range
dcl_output_generic o0

dcl_cb cb0[1]
dcl_resource_id(0)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(1)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(2)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(3)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(4)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(5)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(6)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(7)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)

dcl_literal l0, 8, 0, 0, 0

; compute position in the input
add r0.xy, vWinCoord0.xy, cb0[0].xy

ftoi r0, r0
umod r1.z, r0.y, l0.x ; r1.z = y MOD 8
udiv r0.y, r0.y, l0.x ; y := y DIV 8
itof r0, r0

switch r1.z
	
	case 0
		sample_resource(0)_sampler(0) r1, r0
	break
	
	case 1
		sample_resource(1)_sampler(1) r1, r0
	break
	
	case 2
		sample_resource(2)_sampler(2) r1, r0
	break
	
	case 3
		sample_resource(3)_sampler(3) r1, r0
	break
	
	case 4
		sample_resource(4)_sampler(4) r1, r0
	break
	
	case 5
		sample_resource(5)_sampler(5) r1, r0
	break
	
	case 6
		sample_resource(6)_sampler(6) r1, r0
	break
	
	case 7
		sample_resource(7)_sampler(7) r1, r0
	break
	
endswitch

mov o0, r1

end
]]>
	</ILKernel>
	
	<ILKernel name = "SubCopy2DSplit4ToNonVirtAligned_LI_R_LR">		
<![CDATA[
il_ps_2_0
;
;	2D subarray copy for the case when input array is splitted into 4 parts, output array is not virtualized
;	and copy regions are aligned to nComponents (srcOrigin[1] MOD nComponents = 0) 
;	& (dstOrigin[1] MOD nComponents = 0) & (size[1] MOD nComponents) = 0) for both input and output
; 
;	inputs: 4
;	outputs: 1
;	data type: LONGINT/REAL/LONGREAL
;	nComponents: any (but same for input and output)
;	constants: 1 (REAL) : [(srcOrigin[1]-dstOrigin[1]) DIV nComponents,srcOrigin[0]-dstOrigin[0],...,...]
;
dcl_input_position_interp(linear_noperspective) vWinCoord0.xy__ ; origin in the output range
dcl_output_generic o0

dcl_cb cb0[1]
dcl_resource_id(0)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(1)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(2)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(3)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)

dcl_literal l0, 4, 0, 0, 0

; compute position in the input
add r0.xy, vWinCoord0.xy, cb0[0].xy

ftoi r0, r0
umod r1.z, r0.y, l0.x ; r1.z = y MOD 4
udiv r0.y, r0.y, l0.x ; y := y DIV 4
itof r0, r0

switch r1.z
	
	case 0
		sample_resource(0)_sampler(0) r1, r0
	break
	
	case 1
		sample_resource(1)_sampler(1) r1, r0
	break
	
	case 2
		sample_resource(2)_sampler(2) r1, r0
	break
	
	case 3
		sample_resource(3)_sampler(3) r1, r0
	break	
	
endswitch

mov o0, r1

end
]]>
	</ILKernel>
	
	<ILKernel name = "SubCopy2DSplit8ToSplit8Aligned_LI_R_LR">		
<![CDATA[
il_ps_2_0
;
;	2D subarray copy for the case of splitted arrays and copy regions are aligned to
;	nComponents (srcOrigin[1] MOD nComponents = 0) & (dstOrigin[1] MOD nComponents = 0) 
;	& (subSize[1] MOD nComponents = 0) and 
;	(srcOrigin[0] MOD 8 = 0) & (dstOrigin[0] MOD 8 = 0) & (size[0] MOD 8 = 0)
;	for both input and output
; 
;	inputs: 8
;	outputs: 8
;	data type: LONGINT/REAL/LONGREAL
;	nComponents: any (but same for input and output)
;	constants: 1 (REAL) : [(srcOrigin[1]-dstOrigin[1]) DIV nComponents,(srcOrigin[0]-dstOrigin[0]) DIV 8,...,...]
;
dcl_input_position_interp(linear_noperspective) vWinCoord0.xy__ ; origin in the output range

dcl_output_generic o0
dcl_output_generic o1
dcl_output_generic o2
dcl_output_generic o3
dcl_output_generic o4
dcl_output_generic o5
dcl_output_generic o6
dcl_output_generic o7

dcl_cb cb0[1]

dcl_resource_id(0)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(1)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(2)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(3)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(4)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(5)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(6)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(7)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)

add r0.xy, vWinCoord0.xy, cb0[0].xy	; compute position in the input

; load input data
sample_resource(0)_sampler(0) r1, r0
sample_resource(1)_sampler(1) r2, r0
sample_resource(2)_sampler(2) r3, r0
sample_resource(3)_sampler(3) r4, r0
sample_resource(4)_sampler(4) r5, r0
sample_resource(5)_sampler(5) r6, r0
sample_resource(6)_sampler(6) r7, r0
sample_resource(7)_sampler(7) r8, r0

; store to the output
mov o0, r1
mov o1, r2
mov o2, r3
mov o3, r4
mov o4, r5
mov o5, r6
mov o6, r7
mov o7, r8

end
]]>
	</ILKernel>
	
	<ILKernel name = "ClearMemory">
<![CDATA[
il_ps_2_0
;
;	Clear GPU memory resource
; 
;	inputs: 0
;	outputs: 1
;	data type: any
;	nComponents: any
;	constants: 0
;
dcl_output_generic o0
mov r0, r0.0000
mov o0, r0
end
]]>						
	</ILKernel>
	
	<ILKernel name = "Elementwise_LI_R_LR">
<![CDATA[
il_cs_2_0
dcl_num_thread_per_group 64
;
;	Elementwise array operations
; 
;	inputs: 2
;	global buffer: yes
;	data type: LONGINT,REAL,LONGREAL
;	nComponents: 4/(2 for LONGREAL)
;	constants: 1, 1x4 (LONGINT)
;

dcl_cb cb0[2]	; [physWidth,dType,opCode,nElems]
					; [inpOffset0,inpOffset1,outOffset,...]
					; nElems - total number elements in multiple components

dcl_resource_id(0)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(1)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)

dcl_literal l0, 4, 1, 0xFFFFFFFF, 3
dcl_literal l1, 0, 0xBFF00000, 0, 0xBFF00000 ; [-1, -1] in doubles

iadd r20.x, cb0[0].w, l0.w ; nElems+3
udiv r20.x, r20.x, l0.x ; (nElems+3) DIV 4

ilt r0.z, vaTid.x, r20.x ; check thread index < nMaxThreads
if_logicalnz r0.z

	; compute linear index of first element
	imul r0.xyz, vaTid.xxx, l0.xxx ; account 4 elems per thread
	
	iadd r0.xyz, r0.xyz, cb0[1].xyz ; account offsets
	
	; compute 2D positions of 4 adjacent elems
	udiv r1.y, r0.x, cb0[0].x
	umod r1.x, r0.x, cb0[0].x
	iadd r0.x, r0.x, l0.y ; increment linear index
	
	udiv r1.w, r0.x, cb0[0].x
	umod r1.z, r0.x, cb0[0].x
	iadd r0.x, r0.x, l0.y
	
	udiv r2.y, r0.x, cb0[0].x
	umod r2.x, r0.x, cb0[0].x
	iadd r0.x, r0.x, l0.y
	
	udiv r2.w, r0.x, cb0[0].x
	umod r2.z, r0.x, cb0[0].x
	
	itof r1, r1
	itof r2, r2
	
	; load input elements
	sample_resource(0)_sampler(0) r3, r1.xy
	sample_resource(0)_sampler(0) r4, r1.zw
	sample_resource(0)_sampler(0) r5, r2.xy
	sample_resource(0)_sampler(0) r6, r2.zw
	
	; compute 2D positions of 4 adjacent elems
	udiv r1.y, r0.y, cb0[0].x
	umod r1.x, r0.y, cb0[0].x
	iadd r0.y, r0.y, l0.y ; increment linear index
	
	udiv r1.w, r0.y, cb0[0].x
	umod r1.z, r0.y, cb0[0].x
	iadd r0.y, r0.y, l0.y
	
	udiv r2.y, r0.y, cb0[0].x
	umod r2.x, r0.y, cb0[0].x
	iadd r0.y, r0.y, l0.y
	
	udiv r2.w, r0.y, cb0[0].x
	umod r2.z, r0.y, cb0[0].x
	
	itof r1, r1
	itof r2, r2
	
	sample_resource(1)_sampler(1) r7, r1.xy
	sample_resource(1)_sampler(1) r8, r1.zw
	sample_resource(1)_sampler(1) r9, r2.xy
	sample_resource(1)_sampler(1) r10, r2.zw
	
	switch cb0[0].z ; opCode
		
		case 1 ; OpAdd
			
			switch cb0[0].y ; dType
				
				case 3 ; TLONGINT
					iadd r3, r3, r7
					iadd r4, r4, r8
					iadd r5, r5, r9
					iadd r6, r6, r10
					break
				
				case 5 ; TREAL
					add r3, r3, r7
					add r4, r4, r8
					add r5, r5, r9
					add r6, r6, r10
					break
				
				case 6 ; TLONGREAL
					dadd r3.xy, r3.xy, r7.xy
					dadd r3.zw, r3.zw, r7.zw
					dadd r4.xy, r4.xy, r8.xy
					dadd r4.zw, r4.zw, r8.zw
					dadd r5.xy, r5.xy, r9.xy
					dadd r5.zw, r5.zw, r9.zw
					dadd r6.xy, r6.xy, r10.xy
					dadd r6.zw, r6.zw, r10.zw
					break							
				
			endswitch
			
			break
		
		case 2 ; OpSub
			
			switch cb0[0].y ; dType
				
				case 3 ; TLONGINT
					imad r3, r7, l0.zzzz, r3
					imad r4, r8, l0.zzzz, r4
					imad r5, r9, l0.zzzz, r5
					imad r6, r10, l0.zzzz, r6
					break
				
				case 5 ; TREAL
					sub r3, r3, r7
					sub r4, r4, r8
					sub r5, r5, r9
					sub r6, r6, r10
					break
				
				case 6 ; TLONGREAL
					dmad r3.xy, r7.xy, l1.xy, r3.xy
					dmad r3.zw, r7.zw, l1.zw, r3.zw
					dmad r4.xy, r8.xy, l1.xy, r4.xy
					dmad r4.zw, r8.zw, l1.zw, r4.zw
					dmad r5.xy, r9.xy, l1.xy, r5.xy
					dmad r5.zw, r9.zw, l1.zw, r5.zw
					dmad r6.xy, r10.xy, l1.xy, r6.xy
					dmad r6.zw, r10.zw, l1.zw, r6.zw
					break
				
			endswitch
			
			break
		
		case 8 ; OpEwMul
			
			switch cb0[0].y ; dType
				
				case 3 ; TLONGINT
					imul r3, r3, r7
					imul r4, r4, r8
					imul r5, r5, r9
					imul r6, r6, r10
					break
				
				case 5 ; TREAL
					mul r3, r3, r7
					mul r4, r4, r8
					mul r5, r5, r9
					mul r6, r6, r10
					break
				
				case 6 ; TLONGREAL
					dmul r3.xy, r3.xy, r7.xy
					dmul r3.zw, r3.zw, r7.zw
					dmul r4.xy, r4.xy, r8.xy
					dmul r4.zw, r4.zw, r8.zw
					dmul r5.xy, r5.xy, r9.xy
					dmul r5.zw, r5.zw, r9.zw
					dmul r6.xy, r6.xy, r10.xy
					dmul r6.zw, r6.zw, r10.zw
					break
				
			endswitch
			
			break
		
		case 9 ; OpEwDiv
			
			switch cb0[0].y ; dType
				
				case 3 ; TLONGINT										
					udiv r3, r3, r7
					udiv r4, r4, r8
					udiv r5, r5, r9
					udiv r6, r6, r10
					
					break
				
				case 5 ; TREAL
					div_zeroop(inf_else_max) r3, r3, r7
					div_zeroop(inf_else_max) r4, r4, r8
					div_zeroop(inf_else_max) r5, r5, r9
					div_zeroop(inf_else_max) r6, r6, r10
					break
				
				case 6 ; TLONGREAL
					ddiv r3.xy, r3.xy, r7.xy
					ddiv r3.zw, r3.zw, r7.zw
					ddiv r4.xy, r4.xy, r8.xy
					ddiv r4.zw, r4.zw, r8.zw
					ddiv r5.xy, r5.xy, r9.xy
					ddiv r5.zw, r5.zw, r9.zw
					ddiv r6.xy, r6.xy, r10.xy
					ddiv r6.zw, r6.zw, r10.zw
					break
				
			endswitch
			
			break
		
	endswitch
	
	iadd r20.x, r20.x, l0.z ; nMaxThreads - 1
	ilt r0.w, vaTid.x, r20.x	
	if_logicalnz r0.w
		; store to the output
		mov g[r0.z], r3
		mov g[r0.z+1], r4
		mov g[r0.z+2], r5
		mov g[r0.z+3], r6
	else
		umod r0.w, cb0[0].w, l0.x ; nelems MOD 4
			
		switch r0.w
			case 0
				mov g[r0.z], r3
				mov g[r0.z+1], r4
				mov g[r0.z+2], r5
				mov g[r0.z+3], r6
			break
			
			case 1
				mov g[r0.z], r3				
			break
			
			case 2
				mov g[r0.z], r3
				mov g[r0.z+1], r4
			break
			
			case 3
				mov g[r0.z], r3
				mov g[r0.z+1], r4
				mov g[r0.z+2], r5
			break
		endswitch
	endif	
endif

end		
]]>
	</ILKernel>	
	
<ILKernel name = "ElementwiseScalarRhs_LI_R_LR">
<![CDATA[
il_cs_2_0
dcl_num_thread_per_group 64
;
;	Elementwise operation on array and scalar, where scalar is a right hand side
; 
;	inputs: 1
;	global buffer: yes
;	data type: LONGINT,REAL,LONGREAL
;	nComponents: 4/(2 for LONGREAL)
;	constants: 1, 1x4 (LONGINT), 1x4 (varaable type)
;

dcl_cb cb0[1]	; [physWidth,dType,opCode,..]
dcl_cb cb1[1]	; [...]

dcl_resource_id(0)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)

dcl_literal l0, 4, 1, 0xFFFFFFFF, 0
dcl_literal l1, 0, 0xBFF00000, 0, 0xBFF00000 ; [-1, -1] in doubles

; compute linear index of first element
imul r0.xy, vaTid.xx, l0.xx ; account 4 quads per thread

; compute 2D positions of 4 adjacent quads
udiv r1.y, r0.x, cb0[0].x
umod r1.x, r0.x, cb0[0].x
iadd r0.x, r0.x, l0.y ; increment linear index

udiv r1.w, r0.x, cb0[0].x
umod r1.z, r0.x, cb0[0].x
iadd r0.x, r0.x, l0.y

udiv r2.y, r0.x, cb0[0].x
umod r2.x, r0.x, cb0[0].x
iadd r0.x, r0.x, l0.y

udiv r2.w, r0.x, cb0[0].x
umod r2.z, r0.x, cb0[0].x

itof r1, r1
itof r2, r2

; load input elements
sample_resource(0)_sampler(0) r3, r1.xy
sample_resource(0)_sampler(0) r4, r1.zw
sample_resource(0)_sampler(0) r5, r2.xy
sample_resource(0)_sampler(0) r6, r2.zw

switch cb0[0].z ; opCode
	
	case 1 ; OpAdd
		
		switch cb0[0].y ; dType
			
			case 3 ; TLONGINT
				iadd r3, r3, cb1[0].xxxx
				iadd r4, r4, cb1[0].xxxx
				iadd r5, r5, cb1[0].xxxx
				iadd r6, r6, cb1[0].xxxx
				break
			
			case 5 ; TREAL
				add r3, r3, cb1[0].xxxx
				add r4, r4, cb1[0].xxxx
				add r5, r5, cb1[0].xxxx
				add r6, r6, cb1[0].xxxx
				break
			
			case 6 ; TLONGREAL
				dadd r3.xy, r3.xy, cb1[0].xy
				dadd r3.zw, r3.zw, cb1[0].xy
				dadd r4.xy, r4.xy, cb1[0].xy
				dadd r4.zw, r4.zw, cb1[0].xy
				dadd r5.xy, r5.xy, cb1[0].xy
				dadd r5.zw, r5.zw, cb1[0].xy
				dadd r6.xy, r6.xy, cb1[0].xy
				dadd r6.zw, r6.zw, cb1[0].xy
				break
			
		endswitch
		
		break
	
	case 2 ; OpSub
		
		switch cb0[0].y ; dType
			
			case 3 ; TLONGINT
				imad r3, r7, l0.zzzz, cb1[0].xxxx
				imad r4, r8, l0.zzzz, cb1[0].xxxx
				imad r5, r9, l0.zzzz, cb1[0].xxxx
				imad r6, r10, l0.zzzz, cb1[0].xxxx
				break
			
			case 5 ; TREAL
				sub r3, r3, cb1[0].xxxx
				sub r4, r4, cb1[0].xxxx
				sub r5, r5, cb1[0].xxxx
				sub r6, r6, cb1[0].xxxx
				break
			
			case 6 ; TLONGREAL
				dmad r3.xy, cb1[0].xy, l1.xy, r3.xy
				dmad r3.zw, cb1[0].xy, l1.zw, r3.zw
				dmad r4.xy, cb1[0].xy, l1.xy, r4.xy
				dmad r4.zw, cb1[0].xy, l1.zw, r4.zw
				dmad r5.xy, cb1[0].xy, l1.xy, r5.xy
				dmad r5.zw, cb1[0].xy, l1.zw, r5.zw
				dmad r6.xy, cb1[0].xy, l1.xy, r6.xy
				dmad r6.zw, cb1[0].xy, l1.zw, r6.zw
				break
			
		endswitch
		
		break
	
	case 8 ; OpEwMul
		
		switch cb0[0].y ; dType
			
			case 3 ; TLONGINT
				imul r3, r3, cb1[0].xxxx
				imul r4, r4, cb1[0].xxxx
				imul r5, r5, cb1[0].xxxx
				imul r6, r6, cb1[0].xxxx
				break
			
			case 5 ; TREAL
				mul r3, r3, cb1[0].xxxx
				mul r4, r4, cb1[0].xxxx
				mul r5, r5, cb1[0].xxxx
				mul r6, r6, cb1[0].xxxx
				break
			
			case 6 ; TLONGREAL
				dmul r3.xy, r3.xy, cb1[0].xy
				dmul r3.zw, r3.zw, cb1[0].xy
				dmul r4.xy, r4.xy, cb1[0].xy
				dmul r4.zw, r4.zw, cb1[0].xy
				dmul r5.xy, r5.xy, cb1[0].xy
				dmul r5.zw, r5.zw, cb1[0].xy
				dmul r6.xy, r6.xy, cb1[0].xy
				dmul r6.zw, r6.zw, cb1[0].xy
				break
			
		endswitch
		
		break
	
	case 9 ; OpEwDiv
		
		switch cb0[0].y ; dType
			
			case 3 ; TLONGINT										
				udiv r3, r3, cb1[0].xxxx
				udiv r4, r4, cb1[0].xxxx
				udiv r5, r5, cb1[0].xxxx
				udiv r6, r6, cb1[0].xxxx
				
				break
			
			case 5 ; TREAL
				div_zeroop(inf_else_max) r3, r3, cb1[0].xxxx
				div_zeroop(inf_else_max) r4, r4, cb1[0].xxxx
				div_zeroop(inf_else_max) r5, r5, cb1[0].xxxx
				div_zeroop(inf_else_max) r6, r6, cb1[0].xxxx
				break
			
			case 6 ; TLONGREAL
				ddiv r3.xy, r3.xy, cb1[0].xy
				ddiv r3.zw, r3.zw, cb1[0].xy
				ddiv r4.xy, r4.xy, cb1[0].xy
				ddiv r4.zw, r4.zw, cb1[0].xy
				ddiv r5.xy, r5.xy, cb1[0].xy
				ddiv r5.zw, r5.zw, cb1[0].xy
				ddiv r6.xy, r6.xy, cb1[0].xy
				ddiv r6.zw, r6.zw, cb1[0].xy
				break
			
		endswitch
		
		break
	
endswitch

; store to the output
mov g[r0.y], r3
mov g[r0.y+1], r4
mov g[r0.y+2], r5
mov g[r0.y+3], r6

end		
]]>
	</ILKernel>
	
<ILKernel name = "ElementwiseScalarLhs_LI_R_LR">
<![CDATA[
il_cs_2_0
dcl_num_thread_per_group 64
;
;	Elementwise operation on array and scalar, where scalar is a left hand side
; 
;	inputs: 2
;	global buffer: yes
;	data type: LONGINT,REAL,LONGREAL
;	nComponents: 4/(2 for LONGREAL)
;	constants: 1, 1x4 (LONGINT), 1x4 (varaable type)
;

dcl_cb cb0[1]	; [physWidth,dType,opCode,..]
dcl_cb cb1[1]	; [...]

dcl_resource_id(0)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)

dcl_literal l0, 4, 1, 0xFFFFFFFF, 0
dcl_literal l1, 0, 0xBFF00000, 0, 0xBFF00000 ; [-1, -1] in doubles

; compute linear index of first element
imul r0.xy, vaTid.xx, l0.xx ; account 4 quads per thread

; compute 2D positions of 4 adjacent quads
udiv r1.y, r0.x, cb0[0].x
umod r1.x, r0.x, cb0[0].x
iadd r0.x, r0.x, l0.y ; increment linear index

udiv r1.w, r0.x, cb0[0].x
umod r1.z, r0.x, cb0[0].x
iadd r0.x, r0.x, l0.y

udiv r2.y, r0.x, cb0[0].x
umod r2.x, r0.x, cb0[0].x
iadd r0.x, r0.x, l0.y

udiv r2.w, r0.x, cb0[0].x
umod r2.z, r0.x, cb0[0].x

itof r1, r1
itof r2, r2

; load input elements
sample_resource(0)_sampler(0) r7, r1.xy
sample_resource(0)_sampler(0) r8, r1.zw
sample_resource(0)_sampler(0) r9, r2.xy
sample_resource(0)_sampler(0) r10, r2.zw

switch cb0[0].z ; opCode
	
	case 1 ; OpAdd
		
		switch cb0[0].y ; dType
			
			case 3 ; TLONGINT
				iadd r3, cb1[0].xxxx, r7
				iadd r4, cb1[0].xxxx, r8
				iadd r5, cb1[0].xxxx, r9
				iadd r6, cb1[0].xxxx, r10
				break
			
			case 5 ; TREAL
				add r3, cb1[0].xxxx, r7
				add r4, cb1[0].xxxx, r8
				add r5, cb1[0].xxxx, r9
				add r6, cb1[0].xxxx, r10
				break
			
			case 6 ; TLONGREAL
				dadd r3.xy, cb1[0].xy, r7.xy
				dadd r3.zw, cb1[0].xy, r7.zw
				dadd r4.xy, cb1[0].xy, r8.xy
				dadd r4.zw, cb1[0].xy, r8.zw
				dadd r5.xy, cb1[0].xy, r9.xy
				dadd r5.zw, cb1[0].xy, r9.zw
				dadd r6.xy, cb1[0].xy, r10.xy
				dadd r6.zw, cb1[0].xy, r10.zw
				break
			
		endswitch
		
		break
	
	case 2 ; OpSub
		
		switch cb0[0].y ; dType
			
			case 3 ; TLONGINT
				imad r3, r7, l0.zzzz, cb1[0].xxxx
				imad r4, r8, l0.zzzz, cb1[0].xxxx
				imad r5, r9, l0.zzzz, cb1[0].xxxx
				imad r6, r10, l0.zzzz, cb1[0].xxxx
				break
			
			case 5 ; TREAL
				sub r3, cb1[0].xxxx, r7
				sub r4, cb1[0].xxxx, r8
				sub r5, cb1[0].xxxx, r9
				sub r6, cb1[0].xxxx, r10
				break
			
			case 6 ; TLONGREAL
				dmad r3.xy, r7.xy, l1.xy, cb1[0].xy
				dmad r3.zw, r7.zw, l1.zw, cb1[0].xy
				dmad r4.xy, r8.xy, l1.xy, cb1[0].xy
				dmad r4.zw, r8.zw, l1.zw, cb1[0].xy
				dmad r5.xy, r9.xy, l1.xy, cb1[0].xy
				dmad r5.zw, r9.zw, l1.zw, cb1[0].xy
				dmad r6.xy, r10.xy, l1.xy, cb1[0].xy
				dmad r6.zw, r10.zw, l1.zw, cb1[0].xy
				break
			
		endswitch
		
		break
	
	case 8 ; OpEwMul
		
		switch cb0[0].y ; dType
			
			case 3 ; TLONGINT
				imul r3, cb1[0].xxxx, r7
				imul r4, cb1[0].xxxx, r8
				imul r5, cb1[0].xxxx, r9
				imul r6, cb1[0].xxxx, r10
				break
			
			case 5 ; TREAL
				mul r3, cb1[0].xxxx, r7
				mul r4, cb1[0].xxxx, r8
				mul r5, cb1[0].xxxx, r9
				mul r6, cb1[0].xxxx, r10
				break
			
			case 6 ; TLONGREAL
				dmul r3.xy, cb1[0].xy, r7.xy
				dmul r3.zw, cb1[0].xy, r7.zw
				dmul r4.xy, cb1[0].xy, r8.xy
				dmul r4.zw, cb1[0].xy, r8.zw
				dmul r5.xy, cb1[0].xy, r9.xy
				dmul r5.zw, cb1[0].xy, r9.zw
				dmul r6.xy, cb1[0].xy, r10.xy
				dmul r6.zw, cb1[0].xy, r10.zw
				break
			
		endswitch
		
		break
	
	case 9 ; OpEwDiv
		
		switch cb0[0].y ; dType
			
			case 3 ; TLONGINT										
				udiv r3, cb1[0].xxxx, r7
				udiv r4, cb1[0].xxxx, r8
				udiv r5, cb1[0].xxxx, r9
				udiv r6, cb1[0].xxxx, r10
				
				break
			
			case 5 ; TREAL
				div_zeroop(inf_else_max) r3, cb1[0].xxxx, r7
				div_zeroop(inf_else_max) r4, cb1[0].xxxx, r8
				div_zeroop(inf_else_max) r5, cb1[0].xxxx, r9
				div_zeroop(inf_else_max) r6, cb1[0].xxxx, r10
				break
			
			case 6 ; TLONGREAL
				ddiv r3.xy, cb1[0].xy, r7.xy
				ddiv r3.zw, cb1[0].xy, r7.zw
				ddiv r4.xy, cb1[0].xy, r8.xy
				ddiv r4.zw, cb1[0].xy, r8.zw
				ddiv r5.xy, cb1[0].xy, r9.xy
				ddiv r5.zw, cb1[0].xy, r9.zw
				ddiv r6.xy, cb1[0].xy, r10.xy
				ddiv r6.zw, cb1[0].xy, r10.zw
				break
			
		endswitch
		
		break
	
endswitch

; store to the output
mov g[r0.y], r3
mov g[r0.y+1], r4
mov g[r0.y+2], r5
mov g[r0.y+3], r6

end		
]]>
	</ILKernel>
	
<ILKernel name = "EwMulAddSub_LI_R_LR">
<![CDATA[
il_cs_2_0
dcl_num_thread_per_group 64
;
;	implements t := x + y.*z or t := x - y.*z
; 
;	inputs: 3
;	global buffer: yes
;	data type: LONGINT,REAL,LONGREAL
;	nComponents: 4/(2 for LONGREAL)
;	constants: 1, 1x4 (LONGINT)
;

dcl_cb cb0[2]	; [physWidth,dType,opCode,nElems]
					; [inpOffset0,inpOffset1,inpOffset2,outOffset]
					; nElems - total number elements in multiple components

dcl_resource_id(0)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(1)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(2)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)

dcl_literal l0, 4, 1, 0xFFFFFFFF, 3
dcl_literal l1, 0, 0xBFF00000, 0, 0xBFF00000 ; [-1, -1] in doubles

iadd r20.x, cb0[0].w, l0.w ; nElems+3
udiv r20.x, r20.x, l0.x ; (nElems+3) DIV 4

ilt r0.z, vaTid.x, r20.x ; check thread index < nMaxThreads
if_logicalnz r0.z

	; compute linear index of first element
	imul r0.xyzw, vaTid.xxxx, l0.xxxx ; account 4 elems per thread
	
	iadd r0.xyzw, r0.xyzw, cb0[1].xyzw ; account offsets
	
	; compute 2D positions of 4 adjacent elems
	udiv r1.y, r0.x, cb0[0].x
	umod r1.x, r0.x, cb0[0].x
	iadd r0.x, r0.x, l0.y ; increment linear index
	
	udiv r1.w, r0.x, cb0[0].x
	umod r1.z, r0.x, cb0[0].x
	iadd r0.x, r0.x, l0.y
	
	udiv r2.y, r0.x, cb0[0].x
	umod r2.x, r0.x, cb0[0].x
	iadd r0.x, r0.x, l0.y
	
	udiv r2.w, r0.x, cb0[0].x
	umod r2.z, r0.x, cb0[0].x
	
	itof r1, r1
	itof r2, r2
	
	; load input elements
	sample_resource(0)_sampler(0) r3, r1.xy
	sample_resource(0)_sampler(0) r4, r1.zw
	sample_resource(0)_sampler(0) r5, r2.xy
	sample_resource(0)_sampler(0) r6, r2.zw
	
	; compute 2D positions of 4 adjacent elems
	udiv r1.y, r0.y, cb0[0].x
	umod r1.x, r0.y, cb0[0].x
	iadd r0.y, r0.y, l0.y ; increment linear index
	
	udiv r1.w, r0.y, cb0[0].x
	umod r1.z, r0.y, cb0[0].x
	iadd r0.y, r0.y, l0.y
	
	udiv r2.y, r0.y, cb0[0].x
	umod r2.x, r0.y, cb0[0].x
	iadd r0.y, r0.y, l0.y
	
	udiv r2.w, r0.y, cb0[0].x
	umod r2.z, r0.y, cb0[0].x
	
	itof r1, r1
	itof r2, r2
	
	sample_resource(1)_sampler(1) r7, r1.xy
	sample_resource(1)_sampler(1) r8, r1.zw
	sample_resource(1)_sampler(1) r9, r2.xy
	sample_resource(1)_sampler(1) r10, r2.zw
	
	; compute 2D positions of 4 adjacent elems
	udiv r1.y, r0.z, cb0[0].x
	umod r1.x, r0.z, cb0[0].x
	iadd r0.z, r0.z, l0.y ; increment linear index
	
	udiv r1.w, r0.z, cb0[0].x
	umod r1.z, r0.z, cb0[0].x
	iadd r0.z, r0.z, l0.y
	
	udiv r2.y, r0.z, cb0[0].x
	umod r2.x, r0.z, cb0[0].x
	iadd r0.z, r0.z, l0.y
	
	udiv r2.w, r0.z, cb0[0].x
	umod r2.z, r0.z, cb0[0].x
	
	itof r1, r1
	itof r2, r2
	
	sample_resource(2)_sampler(2) r11, r1.xy
	sample_resource(2)_sampler(2) r12, r1.zw
	sample_resource(2)_sampler(2) r13, r2.xy
	sample_resource(2)_sampler(2) r14, r2.zw
	
	switch cb0[0].z ; opCode
		
		case 10 ; OpEwMulAdd
			
			switch cb0[0].y ; dType
				
				case 3 ; TLONGINT
					imad r3, r7, r11, r3
					imad r4, r8, r12, r4
					imad r5, r9, r13, r5
					imad r6, r10, r14, r6										
					break
				
				case 5 ; TREAL
					; does not work, - some BUG!
					mad r3, r7, r11, r3
					mad r4, r8, r12, r4
					mad r5, r9, r13, r5
					mad r6, r10, r14, r6									
					break
				
				case 6 ; TLONGREAL
					dmad r3.xy, r7.xy, r11.xy, r3.xy
					dmad r3.zw, r7.zw, r11.zw, r3.zw
					dmad r4.xy, r8.xy, r12.xy, r4.xy
					dmad r4.zw, r8.zw, r12.zw, r4.zw
					dmad r5.xy, r9.xy, r13.xy, r5.xy
					dmad r5.zw, r9.zw, r13.zw, r5.zw
					dmad r6.xy, r10.xy, r14.xy, r6.xy
					dmad r6.zw, r10.zw, r14.zw, r6.zw
					break
				
			endswitch
			
		break
		
		case 11 ; OpEwMulSub
			
			switch cb0[0].y ; dType
				
				case 3 ; TLONGINT
					imul r7, r7, r11
					imul r8, r8, r12
					imul r9, r9, r13
					imul r10, r10, r14
					
					imad r3, r7, l0.zzzz, r3
					imad r4, r8, l0.zzzz, r4
					imad r5, r9, l0.zzzz, r5
					imad r6, r10, l0.zzzz, r6
					break
				
				case 5 ; TREAL
					mul r7, r7, r11
					mul r8, r8, r12
					mul r9, r9, r13
					mul r10, r10, r14
					
					sub r3, r3, r7
					sub r4, r4, r8
					sub r5, r5, r9
					sub r6, r6, r10
					break
				
				case 6 ; TLONGREAL
					dmul r7.xy, r7.xy, r11.xy
					dmul r7.zw, r7.zw, r11.zw
					dmul r8.xy, r8.xy, r12.xy
					dmul r8.zw, r8.zw, r12.zw
					dmul r9.xy, r9.xy, r13.xy
					dmul r9.zw, r9.zw, r13.zw
					dmul r10.xy, r10.xy, r14.xy
					dmul r10.zw, r10.zw, r14.zw										
					
					dmad r3.xy, r7.xy, l1.xy, r3.xy
					dmad r3.zw, r7.zw, l1.zw, r3.zw
					dmad r4.xy, r8.xy, l1.xy, r4.xy
					dmad r4.zw, r8.zw, l1.zw, r4.zw
					dmad r5.xy, r9.xy, l1.xy, r5.xy
					dmad r5.zw, r9.zw, l1.zw, r5.zw
					dmad r6.xy, r10.xy, l1.xy, r6.xy
					dmad r6.zw, r10.zw, l1.zw, r6.zw
					break
				
			endswitch
			
			break
		
	endswitch	
	
	iadd r20.x, r20.x, l0.z ; nMaxThreads - 1
	ilt r0.z, vaTid.x, r20.x
	if_logicalnz r0.z
		; store to the output
		mov g[r0.w], r3
		mov g[r0.w+1], r4
		mov g[r0.w+2], r5
		mov g[r0.w+3], r6
	else
		umod r0.z, cb0[0].w, l0.x ; nelems MOD 4
			
		switch r0.z
			case 0
				mov g[r0.w], r3
				mov g[r0.w+1], r4
				mov g[r0.w+2], r5
				mov g[r0.w+3], r6
			break
			
			case 1
				mov g[r0.w], r3				
			break
			
			case 2
				mov g[r0.w], r3
				mov g[r0.w+1], r4
			break
			
			case 3
				mov g[r0.w], r3
				mov g[r0.w+1], r4
				mov g[r0.w+2], r5
			break
		endswitch
	endif	
endif

end		
]]>
	</ILKernel>	
	
<ILKernel name = "Inject_LI_R">
<![CDATA[
il_cs_2_0
dcl_num_thread_per_group 64
;
;	Injective assignment
; 
;	inputs: 1
;	global buffer: yes
;	data type: LONGINT,REAL
;	nComponents: 4
;	constants: 1, 1x4 (LONGINT)
;

dcl_cb cb0[1]	; [physWidth,dType,...]

dcl_resource_id(0)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(1)_type(2d,unnorm)_fmtx(uint)_fmty(uint)_fmtz(uint)_fmtw(uint)

dcl_literal l0, 4, 1, 0xFFFFFFFF, 0
dcl_literal l1, 0xBFF00000, 0, 0xBFF00000, 0 ; [-1, -1] in doubles

; compute linear index of first element
imul r0.xy, vaTid.xx, l0.xx ; account 4 quads per thread

; compute 2D positions of 4 adjacent quads
udiv r1.y, r0.x, cb0[0].x
umod r1.x, r0.x, cb0[0].x
iadd r0.x, r0.x, l0.y ; increment linear index

udiv r1.w, r0.x, cb0[0].x
umod r1.z, r0.x, cb0[0].x
iadd r0.x, r0.x, l0.y

udiv r2.y, r0.x, cb0[0].x
umod r2.x, r0.x, cb0[0].x
iadd r0.x, r0.x, l0.y

udiv r2.w, r0.x, cb0[0].x
umod r2.z, r0.x, cb0[0].x

itof r1, r1
itof r2, r2

; load input elements
sample_resource(0)_sampler(0) r3, r1.xy
sample_resource(0)_sampler(0) r4, r1.zw
sample_resource(0)_sampler(0) r5, r2.xy
sample_resource(0)_sampler(0) r6, r2.zw

sample_resource(1)_sampler(1) r7, r1.xy
sample_resource(1)_sampler(1) r8, r1.zw
sample_resource(1)_sampler(1) r9, r2.xy
sample_resource(1)_sampler(1) r10, r2.zw

mov r11, g[r0.y]
mov r12, g[r0.y+1]
mov r13, g[r0.y+2]
mov r14, g[r0.y+3]
		
switch cb0[0].y ; dType
	
	case 3 ; TLONGINT
		
		break
	
	case 5 ; TREAL
	
		if_logicalnz r7.x
			mov r11.x, r3.x
		endif
		if_logicalnz r7.y
			mov r11.y, r3.y
		endif
		if_logicalnz r7.z
			mov r11.z, r3.z
		endif
		if_logicalnz r7.w
			mov r11.w, r3.w
		endif
		
		;***
		
		if_logicalnz r8.x
			mov r12.x, r4.x
		endif
		if_logicalnz r8.y
			mov r12.y, r4.y
		endif
		if_logicalnz r8.z
			mov r12.z, r4.z
		endif
		if_logicalnz r8.w
			mov r12.w, r4.w
		endif
		
		;***
		
		if_logicalnz r9.x
			mov r13.x, r5.x
		endif
		if_logicalnz r9.y
			mov r13.y, r5.y
		endif
		if_logicalnz r9.z
			mov r13.z, r5.z
		endif
		if_logicalnz r9.w
			mov r13.w, r5.w
		endif
		
		;***
		
		if_logicalnz r10.x
			mov r14.x, r6.x
		endif
		if_logicalnz r10.y
			mov r14.y, r6.y
		endif
		if_logicalnz r10.z
			mov r14.z, r6.z
		endif
		if_logicalnz r10.w
			mov r14.w, r6.w
		endif
		
		break
	
endswitch

; store to the output
mov g[r0.y], r11
mov g[r0.y+1], r12
mov g[r0.y+2], r13
mov g[r0.y+3], r14

end		
]]>
	</ILKernel>
	
			
	<ILKernel name = "MatMulSplit8_R">		
<![CDATA[
il_ps_2_0
;
;	Multiplication of matrices splitted into 8 parts: C := A*B
; 
;	inputs: 16
;	outputs: 8
;	data type: REAL
;	nComponents: 4
;	constants: 1, 1x4 (REAL) : [A.physWidth,...,...,...]
;
dcl_input_position_interp(linear_noperspective) vWinCoord0.xy__
dcl_cb cb0[1]	; [A.physWidth,...]

dcl_output_generic o0
dcl_output_generic o1
dcl_output_generic o2
dcl_output_generic o3
dcl_output_generic o4
dcl_output_generic o5
dcl_output_generic o6
dcl_output_generic o7

; parts of A
dcl_resource_id(0)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(1)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(2)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(3)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(4)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(5)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(6)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(7)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)

; parts of B
dcl_resource_id(8)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(9)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(10)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(11)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(12)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(13)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(14)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(15)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)

dcl_literal l0, 2.0f, 0.5f, 0.0f, 0.0f

; initialize sample counters of A
mov r0.0y, vWinCoord0.y		; r0 := [0,y]
sub r0.x, r0.x, r0.1				; account first increment

; initialize sample counter of B
mov r1.x0, vWinCoord0.x		; [x,0]
sub r1.y, r1.y, l0.y				; account first increment

; clear float4 accumulators for 8x4 * 4x4 matrix multiply result
mov r34, r34.0000	
mov r35, r35.0000
mov r36, r36.0000
mov r37, r37.0000
mov r38, r38.0000	
mov r39, r39.0000
mov r40, r40.0000
mov r41, r41.0000

mov r2.0y00, cb0[0].x			; r2.x is the loop counter, r2.y := A.width
sub r2.x, r2.x, r2.1				; account first increment

whileloop

	; increment sample counter of B
	add r1.y, r1.y, l0.y

	; increment sample counter of A
	add r0.x, r0.x, r0.1

	add r2.x, r2.x, r2.1	; loop counter ++

   	ge r2.z, r2.x, r2.y	; while(loop counter < A.physWidth)
   	break_logicalnz r2.z

	; load next 4x4 block of B

	mod r3.x, r2.x, l0.x	; r3.x := r2.x % 2

	eq r3.y, r3.x, r3.0
	if_logicalnz r3.y	; if r3.x == 0
		sample_resource(8)_sampler(8) r10, r1.xy00
		sample_resource(9)_sampler(9) r11, r1.xy00
		sample_resource(10)_sampler(10) r12, r1.xy00
		sample_resource(11)_sampler(11) r13, r1.xy00
	else
		sample_resource(12)_sampler(12) r10, r1.xy00
		sample_resource(13)_sampler(13) r11, r1.xy00
		sample_resource(14)_sampler(14) r12, r1.xy00
		sample_resource(15)_sampler(15) r13, r1.xy00
	endif

	; load next 8x4 block of A
	sample_resource(0)_sampler(0) r26, r0.xy00
	sample_resource(1)_sampler(1) r27, r0.xy00
	sample_resource(2)_sampler(2) r28, r0.xy00
	sample_resource(3)_sampler(3) r29, r0.xy00
	sample_resource(4)_sampler(4) r30, r0.xy00
	sample_resource(5)_sampler(5) r31, r0.xy00
	sample_resource(6)_sampler(6) r32, r0.xy00
	sample_resource(7)_sampler(7) r33, r0.xy00

	; compute Ablk * Bblk

	; row 1
	mad r42, r26.x, r10, r34	; r42 := Ablk[0,0]*Bblk0[0,*] + Cblk[0,*]
	mad r42, r26.y, r11, r42	; r42 := Ablk[0,1]*Bblk0[1,*] + r42
	mad r42, r26.z, r12, r42	; r42 := Ablk[0,2]*Bblk0[2,*] + r42
	mad r34, r26.w, r13, r42	; Cblk[0,*] := Ablk[0,3]*Bblk0[3,*] + r42
	; row 2
	mad r42, r27.x, r10, r35
	mad r42, r27.y, r11, r42
	mad r42, r27.z, r12, r42
	mad r35, r27.w, r13, r42
	; row 3
	mad r42, r28.x, r10, r36
	mad r42, r28.y, r11, r42
	mad r42, r28.z, r12, r42
	mad r36, r28.w, r13, r42
	; row 4
	mad r42, r29.x, r10, r37
	mad r42, r29.y, r11, r42
	mad r42, r29.z, r12, r42
	mad r37, r29.w, r13, r42
	; row 5
	mad r42, r30.x, r10, r38
	mad r42, r30.y, r11, r42
	mad r42, r30.z, r12, r42
	mad r38, r30.w, r13, r42
	; row 6
	mad r42, r31.x, r10, r39
	mad r42, r31.y, r11, r42
	mad r42, r31.z, r12, r42
	mad r39, r31.w, r13, r42
	; row 7
	mad r42, r32.x, r10, r40
	mad r42, r32.y, r11, r42
	mad r42, r32.z, r12, r42
	mad r40, r32.w, r13, r42
	; row 8
	mad r42, r33.x, r10, r41
	mad r42, r33.y, r11, r42
	mad r42, r33.z, r12, r42
	mad r41, r33.w, r13, r42

endloop

; store the result
mov o0, r34
mov o1, r35
mov o2, r36
mov o3, r37
mov o4, r38
mov o5, r39
mov o6, r40
mov o7, r41

end
]]>
	</ILKernel>
	
	<ILKernel name = "MatMulSplit8Unroll2_R">		
<![CDATA[
il_ps_2_0
;
;	Multiplication of matrices splitted into 8 parts: C := A*B
; 	use loop unrolling by 2
;
;	inputs: 16
;	outputs: 8
;	data type: REAL
;	nComponents: 4
;	constants: 1, 1x4 (REAL) : [A.physWidth,...,...,...]
;
dcl_input_position_interp(linear_noperspective) vWinCoord0.xy__
dcl_cb cb0[1]	; [A.physWidth,...]

dcl_output_generic o0
dcl_output_generic o1
dcl_output_generic o2
dcl_output_generic o3
dcl_output_generic o4
dcl_output_generic o5
dcl_output_generic o6
dcl_output_generic o7

dcl_resource_id(0)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(1)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(2)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(3)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(4)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(5)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(6)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(7)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)

dcl_resource_id(8)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(9)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(10)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(11)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)

dcl_resource_id(12)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(13)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(14)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(15)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)

dcl_literal l0, 2.0f, 0.5f, 0.0f, 0.0f

; initialize sample counters of A
mov r0.01z0, vWinCoord0.00y0		; r0 := [0,1,y,0]
sub r0.xy, r0.xy, l0.xx					; account first increment

; initialize sample counter of B
mov r1.x0, vWinCoord0.x			; [x,0,1,...]
sub r1.y, r1.y, r1.1					; account first increment

; clear float4 accumulators for 8x4 * 4x4 matrix multiply result
mov r34, r34.0000	
mov r35, r35.0000
mov r36, r36.0000
mov r37, r37.0000
mov r38, r38.0000	
mov r39, r39.0000
mov r40, r40.0000
mov r41, r41.0000

mul r2.0y, l0.y, cb0[0].x	; r2.x is the loop counter, r2.y := floor(A.physWidth/2)
flr r2.y, r2.y
sub r2.x, r2.x, r2.1		; account first increment

whileloop

	; increment sample counter of B
	add r1.y, r1.y, r1.1

	; increment sample counters of A
	add r0.xy, r0.xy, l0.xx

	add r2.x, r2.x, r2.1	; loop counter ++

   ge r2.z, r2.x, r2.y	; while(loop counter < floor(A.physWidth/2))
   break_logicalnz r2.z

	; load 2 next 4x4 blocks of B
	sample_resource(8)_sampler(8) r10, r1.xy00
	sample_resource(9)_sampler(9) r11, r1.xy00
	sample_resource(10)_sampler(10) r12, r1.xy00
	sample_resource(11)_sampler(11) r13, r1.xy00

	sample_resource(12)_sampler(12) r14, r1.xy00
	sample_resource(13)_sampler(13) r15, r1.xy00
	sample_resource(14)_sampler(14) r16, r1.xy00
	sample_resource(15)_sampler(15) r17, r1.xy00

	; load next 8x4 block of A
	sample_resource(0)_sampler(0) r26, r0.xz00
	sample_resource(1)_sampler(1) r27, r0.xz00
	sample_resource(2)_sampler(2) r28, r0.xz00
	sample_resource(3)_sampler(3) r29, r0.xz00
	sample_resource(4)_sampler(4) r30, r0.xz00
	sample_resource(5)_sampler(5) r31, r0.xz00
	sample_resource(6)_sampler(6) r32, r0.xz00
	sample_resource(7)_sampler(7) r33, r0.xz00

	; compute Ablk * Bblk0

	; row 1
	mad r42, r26.x, r10, r34	; r42 := Ablk[0,0]*Bblk0[0,*] + Cblk[0,*]
	mad r42, r26.y, r11, r42	; r42 := Ablk[0,1]*Bblk0[1,*] + r42
	mad r42, r26.z, r12, r42	; r42 := Ablk[0,2]*Bblk0[2,*] + r42
	mad r34, r26.w, r13, r42	; Cblk[0,*] := Ablk[0,3]*Bblk0[3,*] + r42
	; row 2
	mad r42, r27.x, r10, r35
	mad r42, r27.y, r11, r42
	mad r42, r27.z, r12, r42
	mad r35, r27.w, r13, r42
	; row 3
	mad r42, r28.x, r10, r36
	mad r42, r28.y, r11, r42
	mad r42, r28.z, r12, r42
	mad r36, r28.w, r13, r42
	; row 4
	mad r42, r29.x, r10, r37
	mad r42, r29.y, r11, r42
	mad r42, r29.z, r12, r42
	mad r37, r29.w, r13, r42
	; row 5
	mad r42, r30.x, r10, r38
	mad r42, r30.y, r11, r42
	mad r42, r30.z, r12, r42
	mad r38, r30.w, r13, r42
	; row 6
	mad r42, r31.x, r10, r39
	mad r42, r31.y, r11, r42
	mad r42, r31.z, r12, r42
	mad r39, r31.w, r13, r42
	; row 7
	mad r42, r32.x, r10, r40
	mad r42, r32.y, r11, r42
	mad r42, r32.z, r12, r42
	mad r40, r32.w, r13, r42
	; row 8
	mad r42, r33.x, r10, r41
	mad r42, r33.y, r11, r42
	mad r42, r33.z, r12, r42
	mad r41, r33.w, r13, r42

	; load next 8x4 block of A
	sample_resource(0)_sampler(0) r26, r0.yz00
	sample_resource(1)_sampler(1) r27, r0.yz00
	sample_resource(2)_sampler(2) r28, r0.yz00
	sample_resource(3)_sampler(3) r29, r0.yz00
	sample_resource(4)_sampler(4) r30, r0.yz00
	sample_resource(5)_sampler(5) r31, r0.yz00
	sample_resource(6)_sampler(6) r32, r0.yz00
	sample_resource(7)_sampler(7) r33, r0.yz00

	; compute Ablk * Bblk1

	; row 1
	mad r42, r26.x, r14, r34	; r42 := Ablk[0,0]*Bblk1[0,*] + Cblk[0,*]
	mad r42, r26.y, r15, r42	; r42 := Ablk[0,1]*Bblk1[1,*] + r42
	mad r42, r26.z, r16, r42	; r42 := Ablk[0,2]*Bblk1[2,*] + r42
	mad r34, r26.w, r17, r42	; Cblk[0,*] := Ablk[0,3]*Bblk1[3,*] + r42
	; row 2
	mad r42, r27.x, r14, r35
	mad r42, r27.y, r15, r42
	mad r42, r27.z, r16, r42
	mad r35, r27.w, r17, r42
	; row 3
	mad r42, r28.x, r14, r36
	mad r42, r28.y, r15, r42
	mad r42, r28.z, r16, r42
	mad r36, r28.w, r17, r42
	; row 4
	mad r42, r29.x, r14, r37
	mad r42, r29.y, r15, r42
	mad r42, r29.z, r16, r42
	mad r37, r29.w, r17, r42
	; row 5
	mad r42, r30.x, r14, r38
	mad r42, r30.y, r15, r42
	mad r42, r30.z, r16, r42
	mad r38, r30.w, r17, r42
	; row 6
	mad r42, r31.x, r14, r39
	mad r42, r31.y, r15, r42
	mad r42, r31.z, r16, r42
	mad r39, r31.w, r17, r42
	; row 7
	mad r42, r32.x, r14, r40
	mad r42, r32.y, r15, r42
	mad r42, r32.z, r16, r42
	mad r40, r32.w, r17, r42
	; row 8
	mad r42, r33.x, r14, r41
	mad r42, r33.y, r15, r42
	mad r42, r33.z, r16, r42
	mad r41, r33.w, r17, r42

endloop

mul r2.x, r2.x, l0.x	; r2.x is the loop counter, r2.y := 2*floor(A.width/2)
sub r2.x, r2.x, r2.1	; account first increment

whileloop

	; increment sample counter of B
	add r1.y, r1.y, l0.y

	; increment sample counters of A
	add r0.x, r0.x, r0.1

	add r2.x, r2.x, r2.1	; loop counter ++

   ge r2.z, r2.x, cb0[0].x	; while(loop counter < A.width)
   break_logicalnz r2.z

	; load next 4x4 block of B

	mod r3.x, r2.x, l0.x	; r3.x := r2.x % 2

	eq r3.y, r3.x, r3.0
	if_logicalnz r3.y	; if r3.x == 0
		sample_resource(8)_sampler(8) r10, r1.xy00
		sample_resource(9)_sampler(9) r11, r1.xy00
		sample_resource(10)_sampler(10) r12, r1.xy00
		sample_resource(11)_sampler(11) r13, r1.xy00
	else
		sample_resource(12)_sampler(12) r10, r1.xy00
		sample_resource(13)_sampler(13) r11, r1.xy00
		sample_resource(14)_sampler(14) r12, r1.xy00
		sample_resource(15)_sampler(15) r13, r1.xy00
	endif

	; load next 8x4 block of A
	sample_resource(0)_sampler(0) r26, r0.xz00
	sample_resource(1)_sampler(1) r27, r0.xz00
	sample_resource(2)_sampler(2) r28, r0.xz00
	sample_resource(3)_sampler(3) r29, r0.xz00
	sample_resource(4)_sampler(4) r30, r0.xz00
	sample_resource(5)_sampler(5) r31, r0.xz00
	sample_resource(6)_sampler(6) r32, r0.xz00
	sample_resource(7)_sampler(7) r33, r0.xz00

	; compute Ablk * Bblk

	; row 1
	mad r42, r26.x, r10, r34	; r42 := Ablk[0,0]*Bblk0[0,*] + Cblk[0,*]
	mad r42, r26.y, r11, r42	; r42 := Ablk[0,1]*Bblk0[1,*] + r42
	mad r42, r26.z, r12, r42	; r42 := Ablk[0,2]*Bblk0[2,*] + r42
	mad r34, r26.w, r13, r42	; Cblk[0,*] := Ablk[0,3]*Bblk0[3,*] + r42
	; row 2
	mad r42, r27.x, r10, r35
	mad r42, r27.y, r11, r42
	mad r42, r27.z, r12, r42
	mad r35, r27.w, r13, r42
	; row 3
	mad r42, r28.x, r10, r36
	mad r42, r28.y, r11, r42
	mad r42, r28.z, r12, r42
	mad r36, r28.w, r13, r42
	; row 4
	mad r42, r29.x, r10, r37
	mad r42, r29.y, r11, r42
	mad r42, r29.z, r12, r42
	mad r37, r29.w, r13, r42
	; row 5
	mad r42, r30.x, r10, r38
	mad r42, r30.y, r11, r42
	mad r42, r30.z, r12, r42
	mad r38, r30.w, r13, r42
	; row 6
	mad r42, r31.x, r10, r39
	mad r42, r31.y, r11, r42
	mad r42, r31.z, r12, r42
	mad r39, r31.w, r13, r42
	; row 7
	mad r42, r32.x, r10, r40
	mad r42, r32.y, r11, r42
	mad r42, r32.z, r12, r42
	mad r40, r32.w, r13, r42
	; row 8
	mad r42, r33.x, r10, r41
	mad r42, r33.y, r11, r42
	mad r42, r33.z, r12, r42
	mad r41, r33.w, r13, r42

endloop

; store the result
mov o0, r34
mov o1, r35
mov o2, r36
mov o3, r37
mov o4, r38
mov o5, r39
mov o6, r40
mov o7, r41
end
]]>
	</ILKernel>
	
<ILKernel name = "MatMulTSplit8Unroll2_R">		
<![CDATA[
il_ps_2_0
;
;	Multiplication of matrices splitted into 8 parts: C := A*B'
; 	use loop unrolling by 2
;
;	inputs: 16
;	outputs: 8
;	data type: REAL
;	nComponents: 4
;	constants: 1, 1x4 (REAL) : [A.physWidth,...,...,...]
;
dcl_input_position_interp(linear_noperspective) vWinCoord0.xy__
dcl_cb cb0[1]	; [A.physWidth,...]

dcl_output_generic o0
dcl_output_generic o1
dcl_output_generic o2
dcl_output_generic o3
dcl_output_generic o4
dcl_output_generic o5
dcl_output_generic o6
dcl_output_generic o7

dcl_resource_id(0)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(1)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(2)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(3)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(4)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(5)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(6)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(7)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)

dcl_resource_id(8)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(9)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(10)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(11)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)

dcl_resource_id(12)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(13)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(14)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(15)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)

dcl_literal l0, 2.0f, 0.5f, 0.0f, 0.0f
dcl_literal l1, 2, 0, 0, 0

; initialize sample counters of A
mov r0.01z0, vWinCoord0.00y0		; r0 := [0,1,y,0]
sub r0.xy, r0.xy, l0.xx					; account first increment

; initialize sample counter of B
ftoi r1.y, vWinCoord0.x			; [0,x,...]
umod r1.z, r1.y, l1.x
udiv r1.y, r1.y, l1.x
itof r1.xy, r1.0y
sub r1.x, r1.x, r1.1						; account first increment

; clear float4 accumulators for 8x4 * 4x4 matrix multiply result
mov r34, r34.0000
mov r35, r35.0000
mov r36, r36.0000
mov r37, r37.0000
mov r38, r38.0000	
mov r39, r39.0000
mov r40, r40.0000
mov r41, r41.0000

mul r2.0y, l0.y, cb0[0].x	; r2.x is the loop counter, r2.y := floor(A.physWidth/2)
flr r2.y, r2.y
sub r2.x, r2.x, r2.1		; account first increment

whileloop

	; increment sample counter of B
	add r1.x, r1.x, r1.1

	; increment sample counters of A
	add r0.xy, r0.xy, l0.xx

	add r2.x, r2.x, r2.1	; loop counter ++

	ge r2.z, r2.x, r2.y	; while(loop counter < floor(A.physWidth/2))
	break_logicalnz r2.z
	
	if_logicalz r1.z
		; load 2 next 4x4 blocks of B
		sample_resource(8)_sampler(8) r10, r1.xy00
		sample_resource(9)_sampler(9) r11, r1.xy00
		sample_resource(10)_sampler(10) r12, r1.xy00
		sample_resource(11)_sampler(11) r13, r1.xy00
		
		add r1.x, r1.x, r1.1
		
		sample_resource(8)_sampler(8) r14, r1.xy00
		sample_resource(9)_sampler(9) r15, r1.xy00
		sample_resource(10)_sampler(10) r16, r1.xy00
		sample_resource(11)_sampler(11) r17, r1.xy00				
	else
		
		sample_resource(12)_sampler(12) r10, r1.xy00
		sample_resource(13)_sampler(13) r11, r1.xy00
		sample_resource(14)_sampler(14) r12, r1.xy00
		sample_resource(15)_sampler(15) r13, r1.xy00
		
		add r1.x, r1.x, r1.1
		
		sample_resource(12)_sampler(12) r14, r1.xy00
		sample_resource(13)_sampler(13) r15, r1.xy00
		sample_resource(14)_sampler(14) r16, r1.xy00
		sample_resource(15)_sampler(15) r17, r1.xy00		
	endif
	
	transpose r10, r10
	transpose r14, r14
	
	; load next 8x4 block of A
	sample_resource(0)_sampler(0) r26, r0.xz00
	sample_resource(1)_sampler(1) r27, r0.xz00
	sample_resource(2)_sampler(2) r28, r0.xz00
	sample_resource(3)_sampler(3) r29, r0.xz00
	sample_resource(4)_sampler(4) r30, r0.xz00
	sample_resource(5)_sampler(5) r31, r0.xz00
	sample_resource(6)_sampler(6) r32, r0.xz00
	sample_resource(7)_sampler(7) r33, r0.xz00

	; compute Ablk * Bblk0

	; row 1
	mad r42, r26.x, r10, r34	; r42 := Ablk[0,0]*Bblk0[0,*] + Cblk[0,*]
	mad r42, r26.y, r11, r42	; r42 := Ablk[0,1]*Bblk0[1,*] + r42
	mad r42, r26.z, r12, r42	; r42 := Ablk[0,2]*Bblk0[2,*] + r42
	mad r34, r26.w, r13, r42	; Cblk[0,*] := Ablk[0,3]*Bblk0[3,*] + r42
	; row 2
	mad r42, r27.x, r10, r35
	mad r42, r27.y, r11, r42
	mad r42, r27.z, r12, r42
	mad r35, r27.w, r13, r42
	; row 3
	mad r42, r28.x, r10, r36
	mad r42, r28.y, r11, r42
	mad r42, r28.z, r12, r42
	mad r36, r28.w, r13, r42
	; row 4
	mad r42, r29.x, r10, r37
	mad r42, r29.y, r11, r42
	mad r42, r29.z, r12, r42
	mad r37, r29.w, r13, r42
	; row 5
	mad r42, r30.x, r10, r38
	mad r42, r30.y, r11, r42
	mad r42, r30.z, r12, r42
	mad r38, r30.w, r13, r42
	; row 6
	mad r42, r31.x, r10, r39
	mad r42, r31.y, r11, r42
	mad r42, r31.z, r12, r42
	mad r39, r31.w, r13, r42
	; row 7
	mad r42, r32.x, r10, r40
	mad r42, r32.y, r11, r42
	mad r42, r32.z, r12, r42
	mad r40, r32.w, r13, r42
	; row 8
	mad r42, r33.x, r10, r41
	mad r42, r33.y, r11, r42
	mad r42, r33.z, r12, r42
	mad r41, r33.w, r13, r42

	; load next 8x4 block of A
	sample_resource(0)_sampler(0) r26, r0.yz00
	sample_resource(1)_sampler(1) r27, r0.yz00
	sample_resource(2)_sampler(2) r28, r0.yz00
	sample_resource(3)_sampler(3) r29, r0.yz00
	sample_resource(4)_sampler(4) r30, r0.yz00
	sample_resource(5)_sampler(5) r31, r0.yz00
	sample_resource(6)_sampler(6) r32, r0.yz00
	sample_resource(7)_sampler(7) r33, r0.yz00

	; compute Ablk * Bblk1

	; row 1
	mad r42, r26.x, r14, r34	; r42 := Ablk[0,0]*Bblk1[0,*] + Cblk[0,*]
	mad r42, r26.y, r15, r42	; r42 := Ablk[0,1]*Bblk1[1,*] + r42
	mad r42, r26.z, r16, r42	; r42 := Ablk[0,2]*Bblk1[2,*] + r42
	mad r34, r26.w, r17, r42	; Cblk[0,*] := Ablk[0,3]*Bblk1[3,*] + r42
	; row 2
	mad r42, r27.x, r14, r35
	mad r42, r27.y, r15, r42
	mad r42, r27.z, r16, r42
	mad r35, r27.w, r17, r42
	; row 3
	mad r42, r28.x, r14, r36
	mad r42, r28.y, r15, r42
	mad r42, r28.z, r16, r42
	mad r36, r28.w, r17, r42
	; row 4
	mad r42, r29.x, r14, r37
	mad r42, r29.y, r15, r42
	mad r42, r29.z, r16, r42
	mad r37, r29.w, r17, r42
	; row 5
	mad r42, r30.x, r14, r38
	mad r42, r30.y, r15, r42
	mad r42, r30.z, r16, r42
	mad r38, r30.w, r17, r42
	; row 6
	mad r42, r31.x, r14, r39
	mad r42, r31.y, r15, r42
	mad r42, r31.z, r16, r42
	mad r39, r31.w, r17, r42
	; row 7
	mad r42, r32.x, r14, r40
	mad r42, r32.y, r15, r42
	mad r42, r32.z, r16, r42
	mad r40, r32.w, r17, r42
	; row 8
	mad r42, r33.x, r14, r41
	mad r42, r33.y, r15, r42
	mad r42, r33.z, r16, r42
	mad r41, r33.w, r17, r42
		
endloop

mul r2.x, r2.x, l0.x	; r2.x is the loop counter, r2.y := 2*floor(A.width/2)
sub r2.x, r2.x, r2.1	; account first increment

whileloop

	; increment sample counter of B
	add r1.x, r1.x, r1.1

	; increment sample counters of A
	add r0.x, r0.x, r0.1

	add r2.x, r2.x, r2.1	; loop counter ++

   	ge r2.z, r2.x, cb0[0].x	; while(loop counter < A.width)
   	break_logicalnz r2.z

	; load next 4x4 block of B		
	if_logicalz r1.z
		sample_resource(8)_sampler(8) r10, r1.xy00
		sample_resource(9)_sampler(9) r11, r1.xy00
		sample_resource(10)_sampler(10) r12, r1.xy00
		sample_resource(11)_sampler(11) r13, r1.xy00
	else
		sample_resource(12)_sampler(12) r10, r1.xy00
		sample_resource(13)_sampler(13) r11, r1.xy00
		sample_resource(14)_sampler(14) r12, r1.xy00
		sample_resource(15)_sampler(15) r13, r1.xy00
	endif
	
	transpose r10, r10

	; load next 8x4 block of A
	sample_resource(0)_sampler(0) r26, r0.xz00
	sample_resource(1)_sampler(1) r27, r0.xz00
	sample_resource(2)_sampler(2) r28, r0.xz00
	sample_resource(3)_sampler(3) r29, r0.xz00
	sample_resource(4)_sampler(4) r30, r0.xz00
	sample_resource(5)_sampler(5) r31, r0.xz00
	sample_resource(6)_sampler(6) r32, r0.xz00
	sample_resource(7)_sampler(7) r33, r0.xz00

	; compute Ablk * Bblk

	; row 1
	mad r42, r26.x, r10, r34	; r42 := Ablk[0,0]*Bblk0[0,*] + Cblk[0,*]
	mad r42, r26.y, r11, r42	; r42 := Ablk[0,1]*Bblk0[1,*] + r42
	mad r42, r26.z, r12, r42	; r42 := Ablk[0,2]*Bblk0[2,*] + r42
	mad r34, r26.w, r13, r42	; Cblk[0,*] := Ablk[0,3]*Bblk0[3,*] + r42
	; row 2
	mad r42, r27.x, r10, r35
	mad r42, r27.y, r11, r42
	mad r42, r27.z, r12, r42
	mad r35, r27.w, r13, r42
	; row 3
	mad r42, r28.x, r10, r36
	mad r42, r28.y, r11, r42
	mad r42, r28.z, r12, r42
	mad r36, r28.w, r13, r42
	; row 4
	mad r42, r29.x, r10, r37
	mad r42, r29.y, r11, r42
	mad r42, r29.z, r12, r42
	mad r37, r29.w, r13, r42
	; row 5
	mad r42, r30.x, r10, r38
	mad r42, r30.y, r11, r42
	mad r42, r30.z, r12, r42
	mad r38, r30.w, r13, r42
	; row 6
	mad r42, r31.x, r10, r39
	mad r42, r31.y, r11, r42
	mad r42, r31.z, r12, r42
	mad r39, r31.w, r13, r42
	; row 7
	mad r42, r32.x, r10, r40
	mad r42, r32.y, r11, r42
	mad r42, r32.z, r12, r42
	mad r40, r32.w, r13, r42
	; row 8
	mad r42, r33.x, r10, r41
	mad r42, r33.y, r11, r42
	mad r42, r33.z, r12, r42
	mad r41, r33.w, r13, r42

endloop

; store the result
mov o0, r34
mov o1, r35
mov o2, r36
mov o3, r37
mov o4, r38
mov o5, r39
mov o6, r40
mov o7, r41
end
]]>
	</ILKernel>	
	
	<ILKernel name = "MatVecMulSplit8_R">
<![CDATA[
il_ps_2_0
;
;	Matrix vector multiplication with matrix being splitted into 8 parts: C := A*b
; 
;	inputs: 9
;	outputs: 1
;	data type: REAL
;	nComponents: 4
;	constants: 1, 1x4 (REAL) : [A.physWidth,...,...,...]
;
dcl_input_position_interp(linear_noperspective) vWinCoord0.xy__
dcl_output_generic o0

dcl_cb cb0[1]

dcl_resource_id(0)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(1)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(2)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(3)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(4)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(5)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(6)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(7)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)

dcl_resource_id(8)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)

dcl_literal l0, 0.0f, 0.5f, 0.0f, 0.0f

mov r0, r0.0000	; r0.xy is [x,y] of the first rhs element

flr r2.y, vWinCoord0.x
mul r2.y, r2.y, l0.y
flr r1.0y, r2.y		; r1.xy -> [x,y] of first element in input row
sub r2.y, r2.y, r1.y	; remainder of division by 2

sub r0.x, r0.x, r0.1		; account first increment
sub r1.x, r1.x, r1.1		; account first increment

mov r20, r20.0000
mov r21, r21.0000
mov r22, r22.0000
mov r23, r23.0000

mov r10, r10.0000			; loop counter
sub r10.x, r10.x, r10.1	; account first increment

mov r11, cb0[0]

eq r2.z, r2.y, r2.0
if_logicalnz r2.z	; if frac(y/2) == 0

	whileloop

		; increment counters of row elements
		add r0.x, r0.x, r0.1
		add r1.x, r1.x, r1.1

		add r10.x, r10.x, r10.1	; loop counter ++
		ge r10.y, r10.x, r11.x	; while(loop counter < cb0[0].x)
		break_logicalnz r10.y

		; load next part of rhs
		sample_resource(8)_sampler(8) r5, r0.xy

		; load next parts from 4 rows
		sample_resource(0)_sampler(0) r6, r1.xy
		sample_resource(1)_sampler(1) r7, r1.xy
		sample_resource(2)_sampler(2) r8, r1.xy
		sample_resource(3)_sampler(3) r9, r1.xy

		; do elementwise multiply	
		mad r20, r5, r6, r20
		mad r21, r5, r7, r21
		mad r22, r5, r8, r22
		mad r23, r5, r9, r23
	endloop

else

	whileloop

		; increment counters of row elements
		add r0.x, r0.x, r0.1
		add r1.x, r1.x, r1.1

		add r10.x, r10.x, r10.1	; loop counter ++
		ge r10.y, r10.x, r11.x	; while(loop counter < cb0[0].x)
		break_logicalnz r10.y

		; load next part of rhs
		sample_resource(8)_sampler(8) r5, r0.xy

		; load next parts from 4 rows
		sample_resource(4)_sampler(4) r6, r1.xy
		sample_resource(5)_sampler(5) r7, r1.xy
		sample_resource(6)_sampler(6) r8, r1.xy
		sample_resource(7)_sampler(7) r9, r1.xy

		; do elementwise multiply	
		mad r20, r5, r6, r20
		mad r21, r5, r7, r21
		mad r22, r5, r8, r22
		mad r23, r5, r9, r23
	endloop

endif

; now do final horizontal add
dp4 r30.x, r20, r20.1111	; r +* ones == r.x+r.y+r.z+r.w
dp4 r30.y, r21, r21.1111
dp4 r30.z, r22, r22.1111
dp4 r30.w, r23, r23.1111

mov o0, r30

end
]]>
	</ILKernel>

	<ILKernel name = "ConvolveRows5_R">		
<![CDATA[
il_ps_2_0
;
;	Convolve set of lines using up to 5 coefficients FIR filter: y[k] = sum_m(h[m]*x[k+m])
; 
;	inputs: 1
;	outputs: 1
;	data type: REAL
;	nComponents: 4
;	constants: 2, 8x4 (REAL) and 1x4 (REAL)
;
dcl_input_position_interp(linear_noperspective) vWinCoord0.xy__ ; origin in the output range
dcl_output_generic o0

dcl_cb cb0[8]	; [h0,h1,h2,h3],[h4,0,0,0]
					; [0,h0,h1,h2],[h3,h4,0,0]
					; [0,0,h0,h1],[h2,h3,h4,0]
					; [0,0,0,h0],[h1,h2,h3,h4]
					
dcl_cb cb1[1]	; [hotSpot,...,...,...]

dcl_resource_id(0)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)

dcl_literal l0, 4.0f, 0.25f, 0.0f, 0.0f
dcl_literal l1, 4, 0, 0, 0

; output position in single component elements
flr r0.xy, vWinCoord0.xy
mul r0.x, r0.x, l0.x ; x := x*4

; input position in single component elements
sub r0.x, r0.x, cb1[0].x ; x - hotSpot
ftoi r13.x, r0.x

; input position in multi component elements
mul r0.x, r0.x, l0.y ; x / 4
flr r20.xy, r0.xy

umod r13.x, r13.x, l1.x ; x MOD 4

; load input data

ine r13.y, r13.x, r13.0 ; (x MOD 4) # 0
if_logicalnz r13.y

	sample_resource(0)_sampler(0) r10, r20.xy
	sample_resource(0)_sampler(0)_aoffimmi(1,0,0) r11, r20.xy
	sample_resource(0)_sampler(0)_aoffimmi(2,0,0) r12, r20.xy
	
	call 0 ; get input data in r0, r1
else
	
	sample_resource(0)_sampler(0) r0, r20.xy	
	sample_resource(0)_sampler(0)_aoffimmi(1,0,0) r1, r20.xy
endif

call 1
mov o0, r10

endmain

; function giving input data in r0 and r1 registers given r10, r11, r12 and r13.x = (x MOD 4)
func 0
	
	switch r13.x
		
		case 1
			mov r0.xyz_, r10.yzw0
			mov r0.w, r11.x
			
			mov r1.xyz_, r11.yzw0
			mov r1.w, r12.x
		break
		
		case 2
			mov r0.xy__, r10.zw00
			mov r0.__zw, r11.00xy
			
			mov r1.xy__, r11.zw00
			mov r1.__zw, r12.00xy
		break
		
		case 3
			mov r0.x___, r10.w000
			mov r0._yzw, r11.0xyz
			
			mov r1.x___, r11.w000
			mov r1._yzw, r12.0xyz
		break
			
	endswitch

ret	
endfunc

; function for computing the convolution given r0 and r1, result is returned in r10
func 1
	mul r10, r0, cb0[0]
	mad r10, r1, cb0[1], r10

	mul r11, r0, cb0[2]
	mad r11, r1, cb0[3], r11

	mul r12, r0, cb0[4]
	mad r12, r1, cb0[5], r12

	mul r13, r0, cb0[6]
	mad r13, r1, cb0[7], r13
	
	dp4 r10.x, r10, r10.1111
	dp4 r10.y, r11, r11.1111
	dp4 r10.z, r12, r12.1111
	dp4 r10.w, r13, r13.1111
ret
endfunc

end
]]>
	</ILKernel>
	
	<ILKernel name = "ConvolveRows9_R">		
<![CDATA[
il_ps_2_0
;
;	Convolve set of lines using up to 9 coefficients FIR filter: y[k] = sum_m(h[m]*x[k+m])
; 
;	inputs: 1
;	outputs: 1
;	data type: REAL
;	nComponents: 4
;	constants: 2, 12x4 (REAL) and 1x4 (REAL)
;
dcl_input_position_interp(linear_noperspective) vWinCoord0.xy__ ; origin in the output range
dcl_output_generic o0

dcl_cb cb0[12]	; [h0,h1,h2,h3],[h4,h5,h6,h7],[h8,0,0,0]
					; [0,h0,h1,h2],[h3,h4,h5,h6],[h7,h8,0,0]
					; [0,0,h0,h1],[h2,h3,h4,h5],[h6,h7,h8,0]
					; [0,0,0,h0],[h1,h2,h3,h4],[h5,h6,h7,h8]
					
dcl_cb cb1[1]	; [hotSpot,...,...,...]

dcl_resource_id(0)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)

dcl_literal l0, 4.0f, 0.25f, 0.0f, 0.0f
dcl_literal l1, 4, 0, 0, 0

; output position in single component elements
flr r0.xy, vWinCoord0.xy
mul r0.x, r0.x, l0.x ; x := x*4

; input position in single component elements
sub r0.x, r0.x, cb1[0].x ; x - hotSpot
ftoi r14.x, r0.x

; input position in multi component elements
mul r0.x, r0.x, l0.y ; x / 4
flr r20.xy, r0.xy

umod r14.x, r14.x, l1.x ; x MOD 4

; load input data

ine r14.y, r14.x, r14.0 ; (x MOD 4) # 0
if_logicalnz r13.y

	sample_resource(0)_sampler(0) r10, r20.xy
	sample_resource(0)_sampler(0)_aoffimmi(1,0,0) r11, r20.xy
	sample_resource(0)_sampler(0)_aoffimmi(2,0,0) r12, r20.xy
	sample_resource(0)_sampler(0)_aoffimmi(3,0,0) r13, r20.xy
	
	call 0 ; get input data in r0, r1, r2
else
	
	sample_resource(0)_sampler(0) r0, r20.xy	
	sample_resource(0)_sampler(0)_aoffimmi(1,0,0) r1, r20.xy
	sample_resource(0)_sampler(0)_aoffimmi(2,0,0) r2, r20.xy
endif

call 1
mov o0, r10

endmain

; function giving input data in r0, r1, r2 registers given r10, r11, r12, r13 and r14.x = (x MOD 4)
func 0
	
	switch r14.x
		
		case 1
			mov r0.xyz_, r10.yzw0
			mov r0.w, r11.x
			
			mov r1.xyz_, r11.yzw0
			mov r1.w, r12.x
			
			mov r2.xyz_, r12.yzw0
			mov r2.w, r13.x
		break
		
		case 2
			mov r0.xy__, r10.zw00
			mov r0.__zw, r11.00xy
			
			mov r1.xy__, r11.zw00
			mov r1.__zw, r12.00xy
			
			mov r2.xy__, r12.zw00
			mov r2.__zw, r13.00xy
		break
		
		case 3
			mov r0.x___, r10.w000
			mov r0._yzw, r11.0xyz
			
			mov r1.x___, r11.w000
			mov r1._yzw, r12.0xyz
			
			mov r2.x___, r12.w000
			mov r2._yzw, r13.0xyz
		break
			
	endswitch

ret	
endfunc

; function for computing the convolution given r0, r1, r2,  result is returned in r10
func 1
	mul r10, r0, cb0[0]
	mad r10, r1, cb0[1], r10
	mad r10, r2, cb0[2], r10

	mul r11, r0, cb0[3]
	mad r11, r1, cb0[4], r11
	mad r11, r2, cb0[5], r11

	mul r12, r0, cb0[6]
	mad r12, r1, cb0[7], r12
	mad r12, r2, cb0[8], r12

	mul r13, r0, cb0[9]
	mad r13, r1, cb0[10], r13
	mad r13, r2, cb0[11], r13
	
	dp4 r10.x, r10, r10.1111
	dp4 r10.y, r11, r11.1111
	dp4 r10.z, r12, r12.1111
	dp4 r10.w, r13, r13.1111
ret
endfunc

end
]]>
	</ILKernel>
	
	<ILKernel name = "ConvolveRows12_R">		
<![CDATA[
il_ps_2_0
;
;	Convolve set of lines using up to 12 coefficients FIR filter: y[k] = sum_m(h[m]*x[k+m])
; 
;	inputs: 1
;	outputs: 1
;	data type: REAL
;	nComponents: 4
;	constants: 2, 16x4 (REAL) and 1x4 (REAL)
;
dcl_input_position_interp(linear_noperspective) vWinCoord0.xy__ ; origin in the output range
dcl_output_generic o0

dcl_cb cb0[12]	; [h0,h1,h2,h3],[h4,h5,h6,h7],[h8,h9,h10,h11],[h12,0,0,0]
					; [0,h0,h1,h2],[h3,h4,h5,h6],[h7,h8,h9,h10],[h11,h12,0,0]
					; [0,0,h0,h1],[h2,h3,h4,h5],[h6,h7,h8,h9],[h10,h11,h12,0]
					; [0,0,0,h0],[h1,h2,h3,h4],[h5,h6,h7,h8],[h9,h10,h11,h12]
					
dcl_cb cb1[1]	; [hotSpot,...,...,...]

dcl_resource_id(0)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)

dcl_literal l0, 4.0f, 0.25f, 0.0f, 0.0f
dcl_literal l1, 4, 0, 0, 0

; output position in single component elements
flr r0.xy, vWinCoord0.xy
mul r0.x, r0.x, l0.x ; x := x*4

; input position in single component elements
sub r0.x, r0.x, cb1[0].x ; x - hotSpot
ftoi r15.x, r0.x

; input position in multi component elements
mul r0.x, r0.x, l0.y ; x / 4
flr r20.xy, r0.xy

umod r15.x, r15.x, l1.x ; x MOD 4

; load input data

ine r15.y, r15.x, r15.0 ; (x MOD 4) # 0
if_logicalnz r15.y

	sample_resource(0)_sampler(0) r10, r20.xy
	sample_resource(0)_sampler(0)_aoffimmi(1,0,0) r11, r20.xy
	sample_resource(0)_sampler(0)_aoffimmi(2,0,0) r12, r20.xy
	sample_resource(0)_sampler(0)_aoffimmi(3,0,0) r13, r20.xy
	sample_resource(0)_sampler(0)_aoffimmi(4,0,0) r14, r20.xy
	
	call 0 ; get input data in r0, r1, r2, r3
else
	
	sample_resource(0)_sampler(0) r0, r20.xy	
	sample_resource(0)_sampler(0)_aoffimmi(1,0,0) r1, r20.xy
	sample_resource(0)_sampler(0)_aoffimmi(2,0,0) r2, r20.xy
	sample_resource(0)_sampler(0)_aoffimmi(3,0,0) r3, r20.xy
endif

call 1
mov o0, r10

endmain

; function giving input data in r0, r1, r2, r3 registers given r10, r11, r12, r13, r14 and r15.x = (x MOD 4)
func 0
	
	switch r15.x
		
		case 1
			mov r0.xyz_, r10.yzw0
			mov r0.w, r11.x
			
			mov r1.xyz_, r11.yzw0
			mov r1.w, r12.x
			
			mov r2.xyz_, r12.yzw0
			mov r2.w, r13.x
			
			mov r3.xyz_, r13.yzw0
			mov r3.w, r14.x
		break
		
		case 2
			mov r0.xy__, r10.zw00
			mov r0.__zw, r11.00xy
			
			mov r1.xy__, r11.zw00
			mov r1.__zw, r12.00xy
			
			mov r2.xy__, r12.zw00
			mov r2.__zw, r13.00xy
			
			mov r3.xy__, r13.zw00
			mov r3.__zw, r14.00xy
		break
		
		case 3
			mov r0.x___, r10.w000
			mov r0._yzw, r11.0xyz
			
			mov r1.x___, r11.w000
			mov r1._yzw, r12.0xyz
			
			mov r2.x___, r12.w000
			mov r2._yzw, r13.0xyz
			
			mov r3.x___, r13.w000
			mov r3._yzw, r14.0xyz
		break
			
	endswitch

ret	
endfunc

; function for computing the convolution given r0, r1, r2, r3  result is returned in r10
func 1
	mul r10, r0, cb0[0]
	mad r10, r1, cb0[1], r10
	mad r10, r2, cb0[2], r10
	mad r10, r3, cb0[3], r10

	mul r11, r0, cb0[4]
	mad r11, r1, cb0[5], r11
	mad r11, r2, cb0[6], r11
	mad r11, r3, cb0[7], r11

	mul r12, r0, cb0[8]
	mad r12, r1, cb0[9], r12
	mad r12, r2, cb0[10], r12
	mad r12, r3, cb0[11], r12

	mul r13, r0, cb0[12]
	mad r13, r1, cb0[13], r13
	mad r13, r2, cb0[14], r13
	mad r13, r3, cb0[15], r13	
	
	dp4 r10.x, r10, r10.1111
	dp4 r10.y, r11, r11.1111
	dp4 r10.z, r12, r12.1111
	dp4 r10.w, r13, r13.1111
ret
endfunc

end
]]>
	</ILKernel>		
	
	<ILKernel name = "ConvolveRows5Down2_R">		
<![CDATA[
il_ps_2_0
;
;	Convolve set of lines using up to 5 coefficients FIR filter combined with downsampling by 2
; 
;	inputs: 1
;	outputs: 1
;	data type: REAL
;	nComponents: 4
;	constants: 2, 8x4 (REAL) and 1x4 (REAL)
;
dcl_input_position_interp(linear_noperspective) vWinCoord0.xy__ ; origin in the output range
dcl_output_generic o0

dcl_cb cb0[8]	; [h0,h1,h2,h3],[h4,0,0,0]
					; [0,h0,h1,h2],[h3,h4,0,0]
					; [0,0,h0,h1],[h2,h3,h4,0]
					; [0,0,0,h0],[h1,h2,h3,h4]
					
dcl_cb cb1[1]	; [hotSpot,...,...,...]

dcl_resource_id(0)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)

dcl_literal l0, 8.0f, 0.25f, 0.0f, 0.0f
dcl_literal l1, 4, 0, 0, 0

; output position in multi component elements
flr r0.xy, vWinCoord0.xy

; input position in single component elements
mul r0.x, r0.x, l0.x
sub r0.x, r0.x, cb1[0].x ; x - hotSpot
ftoi r13.x, r0.x

; input position in multi component elements
mul r0.x, r0.x, l0.y ; x / 4
flr r20.xy, r0.xy

umod r14.x, r13.x, l1.x ; x MOD 4

; load input data

ine r13.y, r14.x, r14.0 ; (x MOD 4) # 0
if_logicalnz r13.y

	sample_resource(0)_sampler(0)_aoffimmi(0,0,0) r10, r20.xy
	sample_resource(0)_sampler(0)_aoffimmi(1,0,0) r11, r20.xy
	sample_resource(0)_sampler(0)_aoffimmi(2,0,0) r12, r20.xy
	sample_resource(0)_sampler(0)_aoffimmi(3,0,0) r13, r20.xy
	
	call 0 ; get input data in r0, r1, r2
else
	
	sample_resource(0)_sampler(0)_aoffimmi(0,0,0) r0, r20.xy	
	sample_resource(0)_sampler(0)_aoffimmi(1,0,0) r1, r20.xy
	sample_resource(0)_sampler(0)_aoffimmi(2,0,0) r2, r20.xy
endif

call 1
mov o0, r10

endmain

; function giving input data in r0, r1, r2 registers given r10, r11, r12, r13 and r14.x = (x MOD 4)
func 0
	
	switch r14.x
		
		case 1
			mov r0.xyz_, r10.yzw0
			mov r0.w, r11.x
			
			mov r1.xyz_, r11.yzw0
			mov r1.w, r12.x
			
			mov r2.xyz_, r12.yzw0
			mov r2.w, r13.x
		break
		
		case 2
			mov r0.xy__, r10.zw00
			mov r0.__zw, r11.00xy
			
			mov r1.xy__, r11.zw00
			mov r1.__zw, r12.00xy
			
			mov r2.xy__, r12.zw00
			mov r2.__zw, r13.00xy
		break
		
		case 3
			mov r0.x___, r10.w000
			mov r0._yzw, r11.0xyz
			
			mov r1.x___, r11.w000
			mov r1._yzw, r12.0xyz
			
			mov r2.x___, r12.w000
			mov r2._yzw, r13.0xyz
		break
			
	endswitch

ret	
endfunc

; function for computing the convolution given r0, r1, r2 result is returned in r10
func 1
	
	; #TODO:  optimize
	
	mul r10, r0, cb0[0]
	mad r10, r1, cb0[1], r10

	mul r11, r0, cb0[2]
	mad r11, r1, cb0[3], r11

	mul r12, r0, cb0[4]
	mad r12, r1, cb0[5], r12

	mul r13, r0, cb0[6]
	mad r13, r1, cb0[7], r13
	
	dp4 r14.x, r10, r10.1111
	dp4 r14.y, r11, r11.1111
	dp4 r14.z, r12, r12.1111
	dp4 r14.w, r13, r13.1111
	
	mul r10, r1, cb0[0]
	mad r10, r2, cb0[1], r10

	mul r11, r1, cb0[2]
	mad r11, r2, cb0[3], r11

	mul r12, r1, cb0[4]
	mad r12, r2, cb0[5], r12

	mul r13, r1, cb0[6]
	mad r13, r2, cb0[7], r13
	
	dp4 r15.x, r10, r10.1111
	dp4 r15.y, r11, r11.1111
	dp4 r15.z, r12, r12.1111
	dp4 r15.w, r13, r13.1111
	
	mov r10.xy__, r14.xz00
	mov r10.__zw, r15.00xz
ret
endfunc

end
]]>
	</ILKernel>
	
	<ILKernel name = "ConvolveRows5Up2_R">		
<![CDATA[
il_ps_2_0
;
;	Convolve set of lines using up to 5 coefficients FIR filter combined with upsampling by 2
; 
;	inputs: 1
;	outputs: 1
;	data type: REAL
;	nComponents: 4
;	constants: 2, 8x4 (REAL) and 1x4 (REAL)
;
dcl_input_position_interp(linear_noperspective) vWinCoord0.xy__ ; origin in the output range
dcl_output_generic o0

dcl_cb cb0[8]	; [h0,h1,h2,h3],[h4,0,0,0]
					; [0,h0,h1,h2],[h3,h4,0,0]
					; [0,0,h0,h1],[h2,h3,h4,0]
					; [0,0,0,h0],[h1,h2,h3,h4]
					
dcl_cb cb1[1]	; [hotSpot,...,...,...]

dcl_resource_id(0)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)

dcl_literal l0, 4.0f, 0.25f, 0.5f, 0.0f
dcl_literal l1, 4, 0, 0, 0

; output position in single component elements
flr r0.xy, vWinCoord0.xy
mul r0.x, r0.x, l0.x ; x := x*4
sub r0.x, r0.x, cb1[0].x ; x - hotSpot

; input position in single component elements
add r0.x, r0.x, r0.1 ; x := x + 1
mul r0.x, r0.x, l0.z ; x := x / 2
frc r14.x, r0.x ; fraction(x/2)
ftoi r13.x, r0.x

; input position in multi component elements
mul r0.x, r0.x, l0.y ; x / 4
flr r20.xy, r0.xy

umod r13.x, r13.x, l1.x ; x MOD 4

; load input data

ine r13.y, r13.x, r13.0 ; (x MOD 4) # 0
if_logicalnz r13.y

	sample_resource(0)_sampler(0)_aoffimmi(0,0,0) r10, r20.xy
	sample_resource(0)_sampler(0)_aoffimmi(1,0,0) r11, r20.xy		
	
	call 0 ; get input data in r0		
else
	
	sample_resource(0)_sampler(0) r0, r20.xy
endif

call 1
mov o0, r10

endmain

; function giving input data in r0 register given r10, r11 and r13.x = (x MOD 4)
func 0
	
	switch r13.x
		
		case 1
			mov r0.xyz_, r10.yzw0
			mov r0.w, r11.x						
		break
		
		case 2
			mov r0.xy__, r10.zw00
			mov r0.__zw, r11.00xy						
		break
		
		case 3
			mov r0.x___, r10.w000
			mov r0._yzw, r11.0xyz
		break
			
	endswitch

ret	
endfunc

; function for computing the convolution given r0 and r14.x = fraction(x/2), result is returned in r10
func 1
	
	; account upsampling by 2
	ne r14.x, r14.x, r14.0 ; fraction(x/2) # 0
	if_logicalnz r14.x
		
		mov r1.x0z0, r0.x0y0
		mov r2.x0z0, r0.z0w0
	else
		
		mov r1.0y0w, r0.0x0y
		mov r2.0y0w, r0.0z0w
	endif
	
	mul r10, r1, cb0[0]
	mad r10, r2, cb0[1], r10

	mul r11, r1, cb0[2]
	mad r11, r2, cb0[3], r11

	mul r12, r1, cb0[4]
	mad r12, r2, cb0[5], r12

	mul r13, r1, cb0[6]
	mad r13, r2, cb0[7], r13
	
	dp4 r10.x, r10, r10.1111
	dp4 r10.y, r11, r11.1111
	dp4 r10.z, r12, r12.1111
	dp4 r10.w, r13, r13.1111
ret
endfunc

end
]]>
	</ILKernel>
	
<ILKernel name = "TransposeSplit8_R">
<![CDATA[
il_ps_2_0
;
;	Transposition of matrices splitted into 8 parts
; 
;	inputs: 8
;	outputs: 8
;	data type: REAL
;	nComponents: 4
;	constants: 0
;
dcl_input_position_interp(linear_noperspective) vWinCoord0.xy__
dcl_output_generic o0
dcl_output_generic o1
dcl_output_generic o2
dcl_output_generic o3
dcl_output_generic o4
dcl_output_generic o5
dcl_output_generic o6
dcl_output_generic o7

dcl_resource_id(0)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(1)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(2)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(3)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(4)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(5)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(6)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(7)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)

dcl_literal l0, 2.0f, 0.5f, 0.0f, 0.0f

; compute position in the input
flr r0.xy, vWinCoord0.yx
mul r0.xy, r0.xy, l0.xy ; [x*2, y/ 2]
frc r1.y, r0.y ; r1.y := frac(y/2)
flr r0.y, r0.y

eq r1.z, r1.y, r1.0
if_logicalnz r1.z	; if frac(y/2) == 0

	sample_resource(0)_sampler(0)_aoffimmi(0,0,0) r1, r0.xy
	sample_resource(0)_sampler(0)_aoffimmi(1,0,0) r2, r0.xy
	
	sample_resource(1)_sampler(1)_aoffimmi(0,0,0) r3, r0.xy
	sample_resource(1)_sampler(1)_aoffimmi(1,0,0) r4, r0.xy
	
	sample_resource(2)_sampler(2)_aoffimmi(0,0,0) r5, r0.xy
	sample_resource(2)_sampler(2)_aoffimmi(1,0,0) r6, r0.xy
	
	sample_resource(3)_sampler(3)_aoffimmi(0,0,0) r7, r0.xy
	sample_resource(3)_sampler(3)_aoffimmi(1,0,0) r8, r0.xy
else			
		
	sample_resource(4)_sampler(4)_aoffimmi(0,0,0) r1, r0.xy
	sample_resource(4)_sampler(4)_aoffimmi(1,0,0) r2, r0.xy
	
	sample_resource(5)_sampler(5)_aoffimmi(0,0,0) r3, r0.xy
	sample_resource(5)_sampler(5)_aoffimmi(1,0,0) r4, r0.xy
	
	sample_resource(6)_sampler(6)_aoffimmi(0,0,0) r5, r0.xy
	sample_resource(6)_sampler(6)_aoffimmi(1,0,0) r6, r0.xy
	
	sample_resource(7)_sampler(7)_aoffimmi(0,0,0) r7, r0.xy
	sample_resource(7)_sampler(7)_aoffimmi(1,0,0) r8, r0.xy
endif

	mov r10.x, r1.x
	mov r10.y, r3.x
	mov r10.z, r5.x
	mov r10.w, r7.x	
	
	mov r11.x, r1.y
	mov r11.y, r3.y
	mov r11.z, r5.y
	mov r11.w, r7.y
	
	mov r12.x, r1.z
	mov r12.y, r3.z
	mov r12.z, r5.z
	mov r12.w, r7.z
	
	mov r13.x, r1.w
	mov r13.y, r3.w
	mov r13.z, r5.w
	mov r13.w, r7.w
	
	;
	
	mov r14.x, r2.x
	mov r14.y, r4.x
	mov r14.z, r6.x
	mov r14.w, r8.x 
	
	mov r15.x, r2.y
	mov r15.y, r4.y
	mov r15.z, r6.y
	mov r15.w, r8.y
	
	mov r16.x, r2.z
	mov r16.y, r4.z
	mov r16.z, r6.z
	mov r16.w, r8.z
	
	mov r17.x, r2.w
	mov r17.y, r4.w
	mov r17.z, r6.w
	mov r17.w, r8.w
	
	mov o0, r10
	mov o1, r11
	mov o2, r12
	mov o3, r13
	mov o4, r14
	mov o5, r15
	mov o6, r16
	mov o7, r17
	
end		
]]>
	</ILKernel>	
	
	<ILKernel name = "Inv8x8_R">
<![CDATA[
il_cs_2_0
dcl_num_thread_per_group 64
;
;	Inversion of a matrix 8x8
; 
;	inputs: 0
;	outputs: 0
;	global buffer: Yes
;	data type: REAL
;	nComponents: 4
;	constants: 0
;

dcl_literal l0, 16, 0, 0, 0

umul r16.x, vaTid.x, l0.x

; load input matrix

mov r0, g[r16.x]
mov r1, g[r16.x+1]
mov r2, g[r16.x+2]
mov r3, g[r16.x+3]

mov r4, g[r16.x+4]
mov r5, g[r16.x+5]
mov r6, g[r16.x+6]
mov r7, g[r16.x+7]

mov r8, g[r16.x+8]
mov r9, g[r16.x+9]
mov r10, g[r16.x+10]
mov r11, g[r16.x+11]

mov r12, g[r16.x+12]
mov r13, g[r16.x+13]
mov r14, g[r16.x+14]
mov r15, g[r16.x+15]

call 4

umul r16.x, vaTid.x, l0.x

; store matrix inverse
mov g[r16.x], r0
mov g[r16.x+1], r1
mov g[r16.x+2], r2
mov g[r16.x+3], r3

mov g[r16.x+4], r4
mov g[r16.x+5], r5
mov g[r16.x+6], r6
mov g[r16.x+7], r7

mov g[r16.x+8], r8
mov g[r16.x+9], r9
mov g[r16.x+10], r10
mov g[r16.x+11], r11

mov g[r16.x+12], r12
mov g[r16.x+13], r13
mov g[r16.x+14], r14
mov g[r16.x+15], r15

endmain

; 2x2 matrix multiplication
;	r0: [x, y; z,w] - lhs, r1: [x, y; z,w] - rhs
;	result is in r0, uses r>=100 as stack
func 0
	; push to the stack
	mov r100, r2
	
	; first row of the result
	mul r2.xy, r0.xx, r1.xy
	mad r0.xy, r0.yy, r1.zw, r2.xy
	
	; second row of the result
	mul r2.xy, r0.zz, r1.xy
	mad r0.__zw, r0.00ww, r1.00zw, r2.00xy
	
	; pop from the stack
	mov r2, r100
ret
endfunc

; 4x4 matrix multiplication
;	r0, r1, r2, r3 - lhs, r4, r5, r6, r7 - rhs
;	result is in r0, r1, r2, r3, uses r>=101 as stack
func 1
	; push to the stack
	mov r101, r8
	
	; row 1
	mul r8, r0.xxxx, r4
	mad r8, r0.yyyy, r5, r8
	mad r8, r0.zzzz, r6, r8
	mad r0, r0.wwww, r7, r8
	
	; row 2
	mul r8, r1.xxxx, r4
	mad r8, r1.yyyy, r5, r8
	mad r8, r1.zzzz, r6, r8
	mad r1, r1.wwww, r7, r8
	
	; row 3
	mul r8, r2.xxxx, r4
	mad r8, r2.yyyy, r5, r8
	mad r8, r2.zzzz, r6, r8
	mad r2, r2.wwww, r7, r8
	
	; row 4	
	mul r8, r3.xxxx, r4
	mad r8, r3.yyyy, r5, r8
	mad r8, r3.zzzz, r6, r8
	mad r3, r3.wwww, r7, r8					
	
	; pop from the stack
	mov r8, r101
ret
endfunc

; inversion of a 2x2 matrix
; matrix is stored in r0, result is given in r0, function uses r>=102 as stack
;	r0: 
;		[ x  y ]
;		[ z w ]
;
; inverse:
;
;		[ w -y ]	           1
;					* ---------------
;		[ -z  x ]		x*w - y*z
func 2
	mov r102, r1 ; push r1 to the stack
	
	mul r1.xy, r0.xy00, r0.wz00 ; [x*w,y*z]
	sub r1.x, r1.x, r1.y ; x*w-y*z
	
	mov r0.x__w, r0.w00x ; x <-> w
	mov r0.yz, r0_neg(yz)
	div_zeroop(inf_else_max) r0, r0, r1.xxxx ; ./(x*w-y*z)
	
	mov r1, r102 ; pop r1 from the stack
ret
endfunc

; inversion of a 4x4 matrix
; matrix is stored in r0, r1, r2, r3, result is given in same registers, function uses r>=103 as stack
;
;		[ r0.x  r0.y | r0.z r0.w ]
;		[ r1.x  r1.y | r1.z r1.w ]		[ A | B ]
;		------------------------------ =	--------- 
;		[ r2.x  r2.y | r2.z r2.w ]		[C  | D]
;		[ r3.x  r3.y | r3.z r3.w ]
;
; inverse:
;
;	
;		W := inv(D)
;		X := B*W
;		Y := W*C
;
;		IA := inv(A-X*C)
;		IB := -IA*X
;		IC := -Y*IA
;		ID := W-Y*IB
;
func 3
	mov r103, r4
	mov r104, r5
	mov r105, r6
	
	; C
	mov r4, r3.00xy
	mov r4.xy, r2.xy	
	
	; D
	mov r5, r3
	mov r5.xy__, r2.zw00
	
	mov r2, r4 ; r2 = C
	mov r3, r5 ; r3 = D
	
	; r4 = A
	mov r4, r1.00xy
	mov r4.xy, r0.xy
	
	; r5 = B
	mov r5, r1
	mov r5.xy__, r0.zw00
	
	; compute W = inv(D)
	mov r0, r3 ; D
	call 2
	mov r3, r0 ; r3 = W
	
	mov r1, r2 ; C
	call 0 ; W*C
	mov r6, r0 ; r6 = Y
	
	mov r0, r5 ; B
	mov r1, r3 ; W
	call 0
	mov r5, r0 ; r5 = X
	
	mov r1, r2 ; C
	call 0 ; r0 = X*C
	sub r0, r4, r0 ; r0 = A-X*C
	call 2
	mov r4, r0 ; r4 := IA
	
	mov r1, r5 ; X
	call 0 ; r0 := IA*X = -IB
	mov r5, r0_neg(xyzw) ; r5 = IB
	
	mov r0, r6 ; Y
	mov r1, r4 ; IA
	call 0 ; r0 = Y*IA
	mov r2, r0_neg(xyzw) ; r2 = IC

	mov r0, r6
	mov r1, r5
	call 0 ; r0 = Y*IB
	sub r3, r3, r0 ; r3 = ID = W-Y*IB
	
	; convert to original format
				
	mov r0.xy, r4.xy
	mov r0.__zw, r5.00xy
	
	mov r1, r5
	mov r1.xy__, r4.zw00
	
	mov r4, r2
	mov r5, r3
	
	mov r2.xy, r4.xy
	mov r2.__zw, r5.00xy
	
	mov r3, r5
	mov r3.xy__, r4.zw00
	
	; pop from the stack
	mov r4, r103
	mov r5, r104
	mov r6, r105	
ret
endfunc

; inversion of a 8x8 matrix
; matrix is stored in r0-r15, result is given in same registers, function uses r>=106 as stack
;
;		[ r0   |  r1  ]
;		[ r2   |  r3  ]		
;		[ r4   |  r5  ] 
;		[ r6   |  r7  ]		[ A | B ]
;		---------------- =	--------- 
;		[ r8   | r9   ] 		[C  | D]
;		[ r10 | r11 ]		
;		[ r12 | r13 ] 
;		[ r14 | r15 ]
;
; inverse:
;
;	
;		W := inv(D)
;		X := B*W
;		Y := W*C
;
;		IA := inv(A-X*C)
;		IB := -IA*X
;		IC := -Y*IA
;		ID := W-Y*IB
;
func 4
;	; push to the stack
;	mov r106, r16
;	mov r107, r17
;	mov r108, r18
;	mov r109, r19	
;	mov r110, r20
;	mov r111, r21
;	mov r112, r22
;	mov r113, r23
	
	; keep r0-r7 unchanged
	mov r16, r0
	mov r17, r1
	mov r18, r2
	mov r19, r3	
	mov r20, r4
	mov r21, r5
	mov r22, r6
	mov r23, r7
	
	; compute W = inv(D)
	
	; load D
	mov r0, r9
	mov r1, r11
	mov r2, r13
	mov r3, r15
	call 3 ; r0-r3 = W = inv(D)
	
	; store W
	mov r9, r0
	mov r11, r1
	mov r13, r2
	mov r15, r3		
	
	; load B to r0-r3
	mov r0, r17
	mov r1, r19
	mov r2, r21
	mov r3, r23
	
	; load W to r4-r7
	mov r4, r9
	mov r5, r11
	mov r6, r13
	mov r7, r15
	call 1 ; r0-r3 = X = B*W
	
	; store X in B
	mov r17, r0
	mov r19, r1
	mov r21, r2
	mov r23, r3
	
	; load C
	mov r4, r8
	mov r5, r10
	mov r6, r12
	mov r7, r14
	call 1 ; r0-r3 = X*C
	
	; compute A-X*C
	sub r0, r16, r0
	sub r1, r18, r1
	sub r2, r20, r2
	sub r3, r22, r3
	call 3 ; r0-r3 = IA = inv(A-X*C)
	
	; store IA
	mov r16, r0
	mov r18, r1
	mov r20, r2
	mov r22, r3
	
	;load X
	mov r4, r17_neg(xyzw)
	mov r5, r19_neg(xyzw)
	mov r6, r21_neg(xyzw)
	mov r7, r23_neg(xyzw)
	call 1 ; r0-r3 = IB = -IA*X
	
	; store IB
	mov r17, r0
	mov r19, r1
	mov r21, r2
	mov r23, r3
	
	; compute Y
	;
	
	; load W and C
	mov r0, r9
	mov r1, r11
	mov r2, r13
	mov r3, r15
	
	mov r4, r8
	mov r5, r10
	mov r6, r12
	mov r7, r14
	call 1 ; r0-r3 = Y = W*C
	
	; store Y in C
	mov r8, r0
	mov r10, r1
	mov r12, r2
	mov r14, r3
	
	; load IB
	mov r4, r17	
	mov r5, r19
	mov r6, r21
	mov r7, r23
	call 1 ; r0-r3 = Y*IB
	
	; compute ID = W-Y*IB
	sub r9, r9, r0
	sub r11, r11, r1
	sub r13, r13, r2
	sub r15, r15, r3
	
	; compute IC = -Y*IA 
	
	; load Y
	mov r0, r8
	mov r1, r10
	mov r2, r12
	mov r3, r14
	
	; load IA
	mov r4, r16_neg(xyzw)
	mov r5, r18_neg(xyzw)
	mov r6, r20_neg(xyzw)
	mov r7, r22_neg(xyzw)
	call 1 ; r0-r3 = IC
	
	; store IC
	mov r8, r0
	mov r10, r1
	mov r12, r2
	mov r14, r3
	
	; store IA
	mov r0, r16
	mov r2, r18
	mov r4, r20
	mov r6, r22
	
	; store IB
	mov r1, r17
	mov r3, r19
	mov r5, r21
	mov r7, r23
	
;	; pop from the stack
;	mov r16, r106
;	mov r17, r107
;	mov r18, r108
;	mov r19, r109
;	mov r20, r110
;	mov r21, r111
;	mov r22, r112
;	mov r23, r113
ret
endfunc

end		
]]>
	</ILKernel>				
	
	<ILKernel name = "Transpose2DVirtToVirt_LI_R_LR">
<![CDATA[
il_ps_2_0
;
;	Transposition of a 2D virtualized array resulting in a virtualized array: C := A.Transpose
; 
;	inputs: 1
;	outputs: 1
;	global buffer: No
;	data type: LONGINT/REAL/LONGREAL
;	nComponents: 1
;	constants: 1, 1x4 (LONGINT)
;	
dcl_cb cb0[1] ; [physWidth,A.width,C.width,...]
dcl_output_generic o0
dcl_input_position_interp(linear_noperspective) vWinCoord0.xy__
dcl_resource_id(0)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)

; compute linear index in the output
ftoi r0.xy, vWinCoord0.xy
umad r0.x, r0.y, cb0[0].x, r0.x ; ind := y*physWidth + x

; compute non-virtual position in the output
udiv r0.y, r0.x, cb0[0].z ; y := ind DIV C.Width
umod r0.x, r0.x, cb0[0].z

; non-virtual position in the input
mov r0.xy, r0.yx

; linear index in the input
umad r0.x, r0.y, cb0[0].y, r0.x

; virtual position in the input
udiv r0.y, r0.x, cb0[0].x ; y := ind DIV physWidth
umod r0.x, r0.x, cb0[0].x

itof r0.xy, r0.xy
sample_resource(0)_sampler(0) o0, r0.xy

end
]]>
	</ILKernel>
	
<ILKernel name = "ConvolveRows5Virt_R">
<![CDATA[
il_cs_2_0
dcl_num_thread_per_group 64
;
;	Convolve set of lines in a virtualized memory layout with 5 taps FIR kernel
;	each thread processes a single line
; 
;	inputs: 1
;	outputs: 0
;	data type: REAL
;	global buffer: Yes
;	nComponents: 1
;	constants: 2, 8x4 (REAL) and 1x4 (LONGINT)
;
dcl_cb cb0[8]	; [h0,h1,h2,h3],[h4,0,0,0]
					; [0,h0,h1,h2],[h3,h4,0,0]
					; [0,0,h0,h1],[h2,h3,h4,0]
					; [0,0,0,h0],[h1,h2,h3,h4]
					
dcl_cb cb1[1]	; [hotSpot,width,physWidth,boundary]
dcl_resource_id(0)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)

dcl_literal l0, 4, 0xFFFFFFFC, 0xFFFFFFFF, 1

; compute linear index of first element of line to process
umul r20.x, vaTid.x, cb1[0].y ; iLine*width

; output index
iadd r21.x, r20.x, cb1[0].x ; inp.ind + hotSpot
umod r21.z, r21.x, l0.x ; out.ind MOD 4
imad r21.z, r21.z, l0.z, l0.x ; 4 - (out.ind MOD 4)

; shift pointers to be aligned to 4 components
iadd r20.x, r20.x, r21.z
iadd r21.x, r21.x, r21.z
udiv r21.x, r21.x, l0.x ; output position in quads

; compute right input bound
iadd r21.y, cb1[0].y, l0.y ; width - 4
imad r21.y, r21.z, l0.z, r21.y ; width-4-(4 - (out.ind MOD 4))
udiv r21.y, r21.y, l0.x ; (width-4-(4 - (out.ind MOD 4))) DIV 4
umul r21.y, r21.y, l0.x ; 4*((width-4-(4 - (out.ind MOD 4))) DIV 4)
iadd r21.y, r20.x, r21.y

ine r20.z, cb1[0].x, r20.0 ; hotSpot # 0
if_logicalnz r20.z	
	; process left boundary	
endif

; load first quads
call 0
mov r0, r9

iadd r20.x, r20.x, l0.x
call 0
mov r1, r9

; compute result
call 1
mov g[r21.x], r10

whileloop
	
	iadd r20.x, r20.x, l0.x ; INC(inp.ind,4)
	iadd r21.x, r21.x, l0.w ; INC(out.ind,1)
	
	ige r21.z, r20.x, r21.y ; inp.ind >= right bound
	break_logicalnz r21.z
				
	mov r0, r1 ; keep old quad
	call 0 ; load new quad
	mov r1, r9
	
	; compute result
	call 1
	
	; store result
	mov g[r21.x], r10	
endloop

; process right boundary

endmain

; loading next quad given linear index in r20.x, loaded quad is in r9, r20.x is not incremented, uses r22.xyz
; TODO: optimize!!!
func 0	
	
	mov r22.z, r20.x		
	
	umod r22.x, r22.z, cb1[0].z
	udiv r22.y, r22.z, cb1[0].z
	
	iadd r22.w, r22.x, l0.x
	lt r22.w, r22.w, cb1[0].z
	if_logicalnz r22.w
		sample_resource(0)_sampler(0)_aoffimmi(0,0,0) r9.x, r22.xy
		sample_resource(0)_sampler(0)_aoffimmi(1,0,0) r9.y, r22.xy
		sample_resource(0)_sampler(0)_aoffimmi(2,0,0) r9.z, r22.xy
		sample_resource(0)_sampler(0)_aoffimmi(3,0,0) r9.w, r22.xy
	else		
		umod r22.x, r22.z, cb1[0].z
		udiv r22.y, r22.z, cb1[0].z
		itof r22.xy, r22.xy
		sample_resource(0)_sampler(0) r9.x, r22.xy
		
		iadd r22.z, r22.z, l0.w
		umod r22.x, r22.z, cb1[0].z
		udiv r22.y, r22.z, cb1[0].z
		itof r22.xy, r22.xy
		sample_resource(0)_sampler(0) r9.y, r22.xy
		
		iadd r22.z, r22.z, l0.w
		umod r22.x, r22.z, cb1[0].z
		udiv r22.y, r22.z, cb1[0].z
		itof r22.xy, r22.xy
		sample_resource(0)_sampler(0) r9.z, r22.xy
		
		iadd r22.z, r22.z, l0.w
		umod r22.x, r22.z, cb1[0].z
		udiv r22.y, r22.z, cb1[0].z
		itof r22.xy, r22.xy
		sample_resource(0)_sampler(0) r9.w, r22.xy		
	endif	
ret
endfunc

; function for computing the convolution given r0 and r1, result is returned in r10, uses r11-r13
func 1
	mul r10, r0, cb0[0]
	mad r10, r1, cb0[1], r10

	mul r11, r0, cb0[2]
	mad r11, r1, cb0[3], r11

	mul r12, r0, cb0[4]
	mad r12, r1, cb0[5], r12

	mul r13, r0, cb0[6]
	mad r13, r1, cb0[7], r13
	
	dp4 r10.x, r10, r10.1111
	dp4 r10.y, r11, r11.1111
	dp4 r10.z, r12, r12.1111
	dp4 r10.w, r13, r13.1111
ret
endfunc

end
]]>
	</ILKernel>	
	

<ILKernel name = "ConvolveRows9Virt_R">
<![CDATA[
il_cs_2_0
dcl_num_thread_per_group 64
;
;	Convolve set of lines in a virtualized memory layout with 9 taps FIR kernel
;	each thread processes a single line
; 
;	inputs: 1
;	outputs: 0
;	data type: REAL
;	global buffer: Yes
;	nComponents: 1
;	constants: 2, 8x4 (REAL) and 1x4 (LONGINT)
;
dcl_cb cb0[12]	; [h0,h1,h2,h3],[h4,h5,h6,h7],[h8,0,0,0]
					; [0,h0,h1,h2],[h3,h4,h5,h6],[h7,h8,0,0]
					; [0,0,h0,h1],[h2,h3,h4,h5],[h6,h7,h8,0]
					; [0,0,0,h0],[h1,h2,h3,h4],[h5,h6,h7,h8]
					
dcl_cb cb1[1]	; [hotSpot,width,physWidth,boundary]
dcl_resource_id(0)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)

dcl_literal l0, 4, 0xFFFFFFF8, 0xFFFFFFFF, 1

; compute linear index of first element of line to process
umul r20.x, vaTid.x, cb1[0].y ; iLine*width

; output index
iadd r21.x, r20.x, cb1[0].x ; inp.ind + hotSpot
umod r21.z, r21.x, l0.x ; out.ind MOD 4
imad r21.z, r21.z, l0.z, l0.x ; 4 - (out.ind MOD 4)

; shift pointers to be aligned to 4 components
iadd r20.x, r20.x, r21.z
iadd r21.x, r21.x, r21.z
udiv r21.x, r21.x, l0.x ; output position in quads

; compute right input bound
iadd r21.y, cb1[0].y, l0.y ; width - 8
imad r21.y, r21.z, l0.z, r21.y ; width-8-(4 - (out.ind MOD 4))
udiv r21.y, r21.y, l0.x ; (width-8-(4 - (out.ind MOD 4))) DIV 4
umul r21.y, r21.y, l0.x ; 4*((width-8-(4 - (out.ind MOD 4))) DIV 4)
iadd r21.y, r20.x, r21.y

ine r20.z, cb1[0].x, r20.0 ; hotSpot # 0
if_logicalnz r20.z	
	; process left boundary	
endif

; load first quads
call 0
mov r0, r9

iadd r20.x, r20.x, l0.x
call 0
mov r1, r9

iadd r20.x, r20.x, l0.x
call 0
mov r2, r9

; compute result
call 1
mov g[r21.x], r10

whileloop
	
	iadd r20.x, r20.x, l0.x ; INC(inp.ind,4)
	iadd r21.x, r21.x, l0.w ; INC(out.ind,1)
	
	ige r21.z, r20.x, r21.y ; inp.ind >= right bound
	break_logicalnz r21.z
				
	mov r0, r1 ; keep old quads
	mov r1, r2
	call 0 ; load new quad
	mov r2, r9
	
	; compute result
	call 1
	
	; store result
	mov g[r21.x], r10
endloop

; process right boundary

endmain

; loading next quad given linear index in r20.x, loaded quad is in r9, r20.x is not incremented, uses r22.xyz
; TODO: optimize!!!
func 0	
	
	mov r22.z, r20.x		
	
	umod r22.x, r22.z, cb1[0].z
	udiv r22.y, r22.z, cb1[0].z
	
	iadd r22.w, r22.x, l0.x
	lt r22.w, r22.w, cb1[0].z
	if_logicalnz r22.w
		sample_resource(0)_sampler(0)_aoffimmi(0,0,0) r9.x, r22.xy
		sample_resource(0)_sampler(0)_aoffimmi(1,0,0) r9.y, r22.xy
		sample_resource(0)_sampler(0)_aoffimmi(2,0,0) r9.z, r22.xy
		sample_resource(0)_sampler(0)_aoffimmi(3,0,0) r9.w, r22.xy
	else		
		umod r22.x, r22.z, cb1[0].z
		udiv r22.y, r22.z, cb1[0].z
		itof r22.xy, r22.xy
		sample_resource(0)_sampler(0) r9.x, r22.xy
		
		iadd r22.z, r22.z, l0.w
		umod r22.x, r22.z, cb1[0].z
		udiv r22.y, r22.z, cb1[0].z
		itof r22.xy, r22.xy
		sample_resource(0)_sampler(0) r9.y, r22.xy
		
		iadd r22.z, r22.z, l0.w
		umod r22.x, r22.z, cb1[0].z
		udiv r22.y, r22.z, cb1[0].z
		itof r22.xy, r22.xy
		sample_resource(0)_sampler(0) r9.z, r22.xy
		
		iadd r22.z, r22.z, l0.w
		umod r22.x, r22.z, cb1[0].z
		udiv r22.y, r22.z, cb1[0].z
		itof r22.xy, r22.xy
		sample_resource(0)_sampler(0) r9.w, r22.xy		
	endif	
ret
endfunc

; function for computing the convolution given r0, r1, r2,  result is returned in r10, uses r11, r12, r13
func 1
	mul r10, r0, cb0[0]
	mad r10, r1, cb0[1], r10
	mad r10, r2, cb0[2], r10

	mul r11, r0, cb0[3]
	mad r11, r1, cb0[4], r11
	mad r11, r2, cb0[5], r11

	mul r12, r0, cb0[6]
	mad r12, r1, cb0[7], r12
	mad r12, r2, cb0[8], r12

	mul r13, r0, cb0[9]
	mad r13, r1, cb0[10], r13
	mad r13, r2, cb0[11], r13
	
	dp4 r10.x, r10, r10.1111
	dp4 r10.y, r11, r11.1111
	dp4 r10.z, r12, r12.1111
	dp4 r10.w, r13, r13.1111
ret
endfunc

end
]]>
</ILKernel>	
		
	<ILKernel name = "ReshapeVirtToVirt_LI_R">
<![CDATA[
il_cs_2_0
dcl_num_thread_per_group 64
;
;	Reshape a virtualized array to a virtualized array
; 
;	inputs: 1
;	outputs: 0
;	global buffer: yes
;	data type: LONGINT, REAL
;	nComponents: 4
;	constants: 2, 2x4 (LONGINT)
;

dcl_resource_id(0)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)

dcl_cb cb0[2] ; [xPitchSrc,xPitchDst,physWidth,xSizeSrc], [xSizeDst,...]

dcl_literal l0, 4, 1, 0xFFFFFFFF, 0

mov r0.x, vaTid.x
udiv r0.y, r0.x, cb0[0].y ; line number of current quad
umod r1.y, r0.x, cb0[0].y ; position of the quad within the line
umul r0.x, r1.y, l0.x ; single element position within the line
umad r0.x, r0.y, cb0[1].x, r0.x ; nLines*xSizeDst + ind -> actual linear index in single elements

udiv r0.y, r0.x, cb0[0].w ; line number in the input
umod r4.x, r0.x, cb0[0].w ; single element position within the line
umul r0.z, cb0[0].x, l0.x ; xPitchSrc*4
umad r0.x, r0.y, r0.z, r4.x ; single element position with account of input's padding
umod r4.y, r0.x, l0.x ; 4 components misalignment
udiv r1.x, r0.x, l0.x ; linear index in quads

; 2D input position in quads
udiv r0.y, r1.x, cb0[0].z
umod r0.x, r1.x, cb0[0].z

; increment linear index and compute 2D position of the next quad
iadd r1.x, r1.x, l0.y
udiv r0.w, r1.x, cb0[0].z
umod r0.z, r1.x, cb0[0].z
itof r0, r0

umod r1.z, cb0[0].w, l0.x ; xSizeSrc MOD 4
ieq r1.z, r1.z, r1.0 ; no padding in input
imad r4.x, r4.x, l0.z, cb0[0].w ; xSizeSrc - single element position within the line
ige r1.w, r4.x, l0.x
ior r1.z, r1.z, r1.w ; (xSizeSrc MOD 4 = 0) OR (xSizeSrc - indWithinLine >= 4)

if_logicalnz r1.z

	switch r4.y
		case 0 ; no misalignment			
			sample_resource(0)_sampler(0) r2, r0.xy
			break
		case 1			
			sample_resource(0)_sampler(0) r2._yzw, r0.xy		
			sample_resource(0)_sampler(0) r2.x___, r0.zw
			mov r2.xyzw, r2.yzwx
			break
		case 2
			sample_resource(0)_sampler(0) r2.__zw, r0.xy		
			sample_resource(0)_sampler(0) r2.xy__, r0.zw
			mov r2.xyzw, r2.zwxy
			break
		case 3
			sample_resource(0)_sampler(0) r2.___w, r0.xy		
			sample_resource(0)_sampler(0) r2.xyz_, r0.zw
			mov r2.xyzw, r2.wxyz
			break
	endswitch	
	
else
	
	switch r4.y
	
		case 0 ; no misalignment
			
			switch r4.x
				case 1					
					sample_resource(0)_sampler(0) r2.x___, r0.xy
					sample_resource(0)_sampler(0) r3.xyz_, r0.zw
					mov r2._yzw, r3.0xyz
					break
				
				case 2					
					sample_resource(0)_sampler(0) r2.xy__, r0.xy
					sample_resource(0)_sampler(0) r3.xy__, r0.zw
					mov r2.__zw, r3.00xy
					break
					
				case 3
					sample_resource(0)_sampler(0) r2.xyz_, r0.xy
					sample_resource(0)_sampler(0) r3.x___, r0.zw
					mov r2.___w, r3.000x
					break	
			endswitch
			
			break
		case 1
			
			switch r4.x
				case 1					
					sample_resource(0)_sampler(0) r2._y__, r0.xy
					sample_resource(0)_sampler(0) r3.xyz_, r0.zw
					mov r2.x, r2.y
					mov r2._yzw, r3.0xyz
					break
				
				case 2					
					sample_resource(0)_sampler(0) r2._yz_, r0.xy
					sample_resource(0)_sampler(0) r3.xy__, r0.zw
					mov r2.xy00, r2.yz00
					mov r2.__zw, r3.00xy
					break
					
				case 3					
					sample_resource(0)_sampler(0) r2._yzw, r0.xy
					sample_resource(0)_sampler(0) r3.x___, r0.zw
					mov r2.xyz0, r2.yzw0
					mov r2.___w, r3.x
					break	
			endswitch
			
			break
		case 2
			
			switch r4.x
				case 1					
					sample_resource(0)_sampler(0) r2.__z_, r0.xy
					sample_resource(0)_sampler(0) r3.xyz_, r0.zw
					mov r2.x, r2.z
					mov r2._yzw, r3.0xyz
					break
				
				case 2				
					sample_resource(0)_sampler(0) r2.__zw, r0.xy
					sample_resource(0)_sampler(0) r3.xy__, r0.zw
					mov r2.xy00, r2.zw00
					mov r2.__zw, r3.00xy
					break
					
				case 3
					iadd r1.x, r1.x, l0.y
					udiv r4.y, r1.x, cb0[0].z
					umod r4.x, r1.x, cb0[0].z
					itof r4.xy, r4.xy
					sample_resource(0)_sampler(0) r2.__zw, r0.xy
					sample_resource(0)_sampler(0) r3.x___, r0.zw
					sample_resource(0)_sampler(0) r2.x___, r4.xy
					mov r2.xy0w, r2.zw0x
					mov r2.__z_, r3.00x0
					break	
									
			endswitch
			
			break
		case 3
			
			switch r4.x
				case 1					
					sample_resource(0)_sampler(0) r2.___w, r0.xy
					sample_resource(0)_sampler(0) r3.xyz_, r0.zw
					mov r2.x, r2.w
					mov r2._yzw, r3.0xyz
					break
				
				case 2
					iadd r1.x, r1.x, l0.y
					udiv r4.y, r1.x, cb0[0].z
					umod r4.x, r1.x, cb0[0].z
					itof r4.xy, r4.xy
					sample_resource(0)_sampler(0) r2.___w, r0.xy
					sample_resource(0)_sampler(0) r3.x___, r0.zw
					sample_resource(0)_sampler(0) r2.xy__, r4.xy
					mov r2.x0zw, r2.w0xy
					mov r2._y__, r3.0x00
					break
					
				case 3
					iadd r1.x, r1.x, l0.y
					udiv r4.y, r1.x, cb0[0].z
					umod r4.x, r1.x, cb0[0].z
					itof r4.xy, r4.xy
					sample_resource(0)_sampler(0) r2.___w, r0.xy
					sample_resource(0)_sampler(0) r3.xy__, r0.zw
					sample_resource(0)_sampler(0) r2.x___, r4.xy
					mov r2.x00w, r2.w00x
					mov r2._yz_, r3.0xy0
					break
									
			endswitch						
			
			break
	endswitch
		
endif

iadd r1.y, r1.y, l0.y ; increment position of the output quad within the line
ieq r0.z, r1.y, cb0[0].y ; ind+1 = xPitchDst
if_logicalnz r0.z
	
	umod r0.z, cb0[1].x, l0.x ; misalignment xSizeDst MOD 4
	switch r0.z
		case 0 ; no misalignment
			break
		case 1
			mov r2, r2.x000
			break
		case 2
			mov r2, r2.xy00
			break
		case 3
			mov r2, r2.xyz0
			break
	endswitch
	
endif

mov g[vaTid.x], r2

end
]]>
	</ILKernel>
	
<ILKernel name = "ReshapeVirtToSplit8_LI_R">
<![CDATA[
il_ps_2_0
;
;	Reshape a virtualized array to a matrix splitted into 8 parts 
; 
;	inputs: 1
;	outputs: 8
;	data type: LONGINT, REAL
;	nComponents: 4
;	constants: 2, 2x4 (LONGINT)
;

dcl_input_position_interp(linear_noperspective) vWinCoord0.xy__
dcl_output_generic o0
dcl_output_generic o1
dcl_output_generic o2
dcl_output_generic o3
dcl_output_generic o4
dcl_output_generic o5
dcl_output_generic o6
dcl_output_generic o7

dcl_resource_id(0)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)

dcl_cb cb0[2] ; [xPitchSrc,xPitchDst,physWidthSrc,xSizeSrc], [xSizeDst,...]
; in this case xPitchDst = physWidthDst

dcl_literal l0, 4, 1, 0xFFFFFFFF, 8

; ************** part 1 **************
; output quad is stored in r2

ftoi r0, vWinCoord0.xy ; 2D output position in quads
mov r1.y, r0.x ; remember position in quads within the row
umul r0.x, r0.x, l0.x ; x in single elements
umul r1.x, r0.y, l0.w ; y*8
umad r0.x, r1.x, cb0[1].x, r0.x ; y*8*xSizeDst + x -> actual linear index in single elements
mov r4.w, r0.x ; remember index value for not to recomputing it again for other matrix parts

udiv r0.y, r0.x, cb0[0].w ; line number in the input
umod r4.x, r0.x, cb0[0].w ; single element position within the line
umul r0.z, cb0[0].x, l0.x ; xPitchSrc*4
umad r0.x, r0.y, r0.z, r4.x ; single element position with account of input's padding
umod r4.y, r0.x, l0.x ; 4 components misalignment
udiv r1.x, r0.x, l0.x ; linear index in quads

; 2D input position in quads
udiv r0.y, r1.x, cb0[0].z
umod r0.x, r1.x, cb0[0].z

; increment linear index and compute 2D position of the next quad
iadd r1.x, r1.x, l0.y
udiv r0.w, r1.x, cb0[0].z
umod r0.z, r1.x, cb0[0].z
itof r0, r0

umod r1.z, cb0[0].w, l0.x ; xSizeSrc MOD 4
ieq r1.z, r1.z, r1.0 ; no padding in input
imad r4.x, r4.x, l0.z, cb0[0].w ; xSizeSrc - single element position within the line
ige r1.w, r4.x, l0.x
ior r1.z, r1.z, r1.w ; (xSizeSrc MOD 4 = 0) OR (xSizeSrc - indWithinLine >= 4)

if_logicalnz r1.z

	switch r4.y
		case 0 ; no misalignment			
			sample_resource(0)_sampler(0) r2, r0.xy
			break
		case 1
			sample_resource(0)_sampler(0) r2._yzw, r0.xy		
			sample_resource(0)_sampler(0) r2.x___, r0.zw
			mov r2.xyzw, r2.yzwx
			break
		case 2
			sample_resource(0)_sampler(0) r2.__zw, r0.xy		
			sample_resource(0)_sampler(0) r2.xy__, r0.zw
			mov r2.xyzw, r2.zwxy
			break
		case 3
			sample_resource(0)_sampler(0) r2.___w, r0.xy		
			sample_resource(0)_sampler(0) r2.xyz_, r0.zw
			mov r2.xyzw, r2.wxyz
			break
	endswitch
	
else
	
	switch r4.y
	
		case 0 ; no misalignment
			
			switch r4.x
				case 1					
					sample_resource(0)_sampler(0) r2.x___, r0.xy
					sample_resource(0)_sampler(0) r3.xyz_, r0.zw
					mov r2._yzw, r3.0xyz
					break
				
				case 2					
					sample_resource(0)_sampler(0) r2.xy__, r0.xy
					sample_resource(0)_sampler(0) r3.xy__, r0.zw
					mov r2.__zw, r3.00xy
					break
					
				case 3
					sample_resource(0)_sampler(0) r2.xyz_, r0.xy
					sample_resource(0)_sampler(0) r3.x___, r0.zw
					mov r2.___w, r3.000x
					break	
			endswitch
			
			break
		case 1
			
			switch r4.x
				case 1					
					sample_resource(0)_sampler(0) r2._y__, r0.xy
					sample_resource(0)_sampler(0) r3.xyz_, r0.zw
					mov r2.x, r2.y
					mov r2._yzw, r3.0xyz
					break
				
				case 2					
					sample_resource(0)_sampler(0) r2._yz_, r0.xy
					sample_resource(0)_sampler(0) r3.xy__, r0.zw
					mov r2.xy00, r2.yz00
					mov r2.__zw, r3.00xy
					break
					
				case 3					
					sample_resource(0)_sampler(0) r2._yzw, r0.xy
					sample_resource(0)_sampler(0) r3.x___, r0.zw
					mov r2.xyz0, r2.yzw0
					mov r2.___w, r3.x
					break	
			endswitch
			
			break
		case 2
			
			switch r4.x
				case 1					
					sample_resource(0)_sampler(0) r2.__z_, r0.xy
					sample_resource(0)_sampler(0) r3.xyz_, r0.zw
					mov r2.x, r2.z
					mov r2._yzw, r3.0xyz
					break
				
				case 2				
					sample_resource(0)_sampler(0) r2.__zw, r0.xy
					sample_resource(0)_sampler(0) r3.xy__, r0.zw
					mov r2.xy00, r2.zw00
					mov r2.__zw, r3.00xy
					break
					
				case 3
					iadd r1.x, r1.x, l0.y
					udiv r4.y, r1.x, cb0[0].z
					umod r4.x, r1.x, cb0[0].z
					itof r4.xy, r4.xy
					sample_resource(0)_sampler(0) r2.__zw, r0.xy
					sample_resource(0)_sampler(0) r3.x___, r0.zw
					sample_resource(0)_sampler(0) r2.x___, r4.xy
					mov r2.xy0w, r2.zw0x
					mov r2.__z_, r3.00x0
					break	
									
			endswitch
			
			break
		case 3
			
			switch r4.x
				case 1					
					sample_resource(0)_sampler(0) r2.___w, r0.xy
					sample_resource(0)_sampler(0) r3.xyz_, r0.zw
					mov r2.x, r2.w
					mov r2._yzw, r3.0xyz
					break
				
				case 2
					iadd r1.x, r1.x, l0.y
					udiv r4.y, r1.x, cb0[0].z
					umod r4.x, r1.x, cb0[0].z
					itof r4.xy, r4.xy
					sample_resource(0)_sampler(0) r2.___w, r0.xy
					sample_resource(0)_sampler(0) r3.x___, r0.zw
					sample_resource(0)_sampler(0) r2.xy__, r4.xy
					mov r2.x0zw, r2.w0xy
					mov r2._y__, r3.0x00
					break
					
				case 3
					iadd r1.x, r1.x, l0.y
					udiv r4.y, r1.x, cb0[0].z
					umod r4.x, r1.x, cb0[0].z
					itof r4.xy, r4.xy
					sample_resource(0)_sampler(0) r2.___w, r0.xy
					sample_resource(0)_sampler(0) r3.xy__, r0.zw
					sample_resource(0)_sampler(0) r2.x___, r4.xy
					mov r2.x00w, r2.w00x
					mov r2._yz_, r3.0xy0
					break
									
			endswitch
			
			break
	endswitch
		
endif

; ************** part 2 **************
; output quad is stored in r5

iadd r4.w, r4.w, cb0[1].x ; y*8*xSizeDst + x + i*xSizeDst* -> actual linear index in single elements
mov r0.x, r4.w

udiv r0.y, r0.x, cb0[0].w ; line number in the input
umod r4.x, r0.x, cb0[0].w ; single element position within the line
umul r0.z, cb0[0].x, l0.x ; xPitchSrc*4
umad r0.x, r0.y, r0.z, r4.x ; single element position with account of input's padding
umod r4.y, r0.x, l0.x ; 4 components misalignment
udiv r1.x, r0.x, l0.x ; linear index in quads

; 2D input position in quads
udiv r0.y, r1.x, cb0[0].z
umod r0.x, r1.x, cb0[0].z

; increment linear index and compute 2D position of the next quad
iadd r1.x, r1.x, l0.y
udiv r0.w, r1.x, cb0[0].z
umod r0.z, r1.x, cb0[0].z
itof r0, r0

umod r1.z, cb0[0].w, l0.x ; xSizeSrc MOD 4
ieq r1.z, r1.z, r1.0 ; no padding in input
imad r4.x, r4.x, l0.z, cb0[0].w ; xSizeSrc - single element position within the line
ige r1.w, r4.x, l0.x
ior r1.z, r1.z, r1.w ; (xSizeSrc MOD 4 = 0) OR (xSizeSrc - indWithinLine >= 4)

if_logicalnz r1.z

	switch r4.y
		case 0 ; no misalignment			
			sample_resource(0)_sampler(0) r5, r0.xy
			break
		case 1			
			sample_resource(0)_sampler(0) r5._yzw, r0.xy		
			sample_resource(0)_sampler(0) r5.x___, r0.zw
			mov r5.xyzw, r5.yzwx
			break
		case 2
			sample_resource(0)_sampler(0) r5.__zw, r0.xy		
			sample_resource(0)_sampler(0) r5.xy__, r0.zw
			mov r5.xyzw, r5.zwxy
			break
		case 3
			sample_resource(0)_sampler(0) r5.___w, r0.xy		
			sample_resource(0)_sampler(0) r5.xyz_, r0.zw
			mov r5.xyzw, r5.wxyz
			break
	endswitch
	
else
	
	switch r4.y
	
		case 0 ; no misalignment
			
			switch r4.x
				case 1					
					sample_resource(0)_sampler(0) r5.x___, r0.xy
					sample_resource(0)_sampler(0) r3.xyz_, r0.zw
					mov r5._yzw, r3.0xyz
					break
				
				case 2					
					sample_resource(0)_sampler(0) r5.xy__, r0.xy
					sample_resource(0)_sampler(0) r3.xy__, r0.zw
					mov r5.__zw, r3.00xy
					break
					
				case 3
					sample_resource(0)_sampler(0) r5.xyz_, r0.xy
					sample_resource(0)_sampler(0) r3.x___, r0.zw
					mov r5.___w, r3.000x
					break	
			endswitch
			
			break
		case 1
			
			switch r4.x
				case 1					
					sample_resource(0)_sampler(0) r5._y__, r0.xy
					sample_resource(0)_sampler(0) r3.xyz_, r0.zw
					mov r5.x, r5.y
					mov r5._yzw, r3.0xyz
					break
				
				case 2					
					sample_resource(0)_sampler(0) r5._yz_, r0.xy
					sample_resource(0)_sampler(0) r3.xy__, r0.zw
					mov r5.xy00, r5.yz00
					mov r5.__zw, r3.00xy
					break
					
				case 3					
					sample_resource(0)_sampler(0) r5._yzw, r0.xy
					sample_resource(0)_sampler(0) r3.x___, r0.zw
					mov r5.xyz0, r5.yzw0
					mov r5.___w, r3.x
					break	
			endswitch
			
			break
		case 2
			
			switch r4.x
				case 1					
					sample_resource(0)_sampler(0) r5.__z_, r0.xy
					sample_resource(0)_sampler(0) r3.xyz_, r0.zw
					mov r5.x, r5.z
					mov r5._yzw, r3.0xyz
					break
				
				case 2				
					sample_resource(0)_sampler(0) r5.__zw, r0.xy
					sample_resource(0)_sampler(0) r3.xy__, r0.zw
					mov r5.xy00, r5.zw00
					mov r5.__zw, r3.00xy
					break
					
				case 3
					iadd r1.x, r1.x, l0.y
					udiv r4.y, r1.x, cb0[0].z
					umod r4.x, r1.x, cb0[0].z
					itof r4.xy, r4.xy
					sample_resource(0)_sampler(0) r5.__zw, r0.xy
					sample_resource(0)_sampler(0) r3.x___, r0.zw
					sample_resource(0)_sampler(0) r5.x___, r4.xy
					mov r5.xy0w, r5.zw0x
					mov r5.__z_, r3.00x0
					break	
									
			endswitch
			
			break
		case 3
			
			switch r4.x
				case 1					
					sample_resource(0)_sampler(0) r5.___w, r0.xy
					sample_resource(0)_sampler(0) r3.xyz_, r0.zw
					mov r5.x, r5.w
					mov r5._yzw, r3.0xyz
					break
				
				case 2
					iadd r1.x, r1.x, l0.y
					udiv r4.y, r1.x, cb0[0].z
					umod r4.x, r1.x, cb0[0].z
					itof r4.xy, r4.xy
					sample_resource(0)_sampler(0) r5.___w, r0.xy
					sample_resource(0)_sampler(0) r3.x___, r0.zw
					sample_resource(0)_sampler(0) r5.xy__, r4.xy
					mov r5.x0zw, r5.w0xy
					mov r5._y__, r3.0x00
					break
					
				case 3
					iadd r1.x, r1.x, l0.y
					udiv r4.y, r1.x, cb0[0].z
					umod r4.x, r1.x, cb0[0].z
					itof r4.xy, r4.xy
					sample_resource(0)_sampler(0) r5.___w, r0.xy
					sample_resource(0)_sampler(0) r3.xy__, r0.zw
					sample_resource(0)_sampler(0) r5.x___, r4.xy
					mov r5.x00w, r5.w00x
					mov r5._yz_, r3.0xy0
					break
									
			endswitch
			
			break
	endswitch
		
endif


; ************** part 3 **************
; output quad is stored in r6

iadd r4.w, r4.w, cb0[1].x ; y*8*xSizeDst + x + i*xSizeDst* -> actual linear index in single elements
mov r0.x, r4.w

udiv r0.y, r0.x, cb0[0].w ; line number in the input
umod r4.x, r0.x, cb0[0].w ; single element position within the line
umul r0.z, cb0[0].x, l0.x ; xPitchSrc*4
umad r0.x, r0.y, r0.z, r4.x ; single element position with account of input's padding
umod r4.y, r0.x, l0.x ; 4 components misalignment
udiv r1.x, r0.x, l0.x ; linear index in quads

; 2D input position in quads
udiv r0.y, r1.x, cb0[0].z
umod r0.x, r1.x, cb0[0].z

; increment linear index and compute 2D position of the next quad
iadd r1.x, r1.x, l0.y
udiv r0.w, r1.x, cb0[0].z
umod r0.z, r1.x, cb0[0].z
itof r0, r0

umod r1.z, cb0[0].w, l0.x ; xSizeSrc MOD 4
ieq r1.z, r1.z, r1.0 ; no padding in input
imad r4.x, r4.x, l0.z, cb0[0].w ; xSizeSrc - single element position within the line
ige r1.w, r4.x, l0.x
ior r1.z, r1.z, r1.w ; (xSizeSrc MOD 4 = 0) OR (xSizeSrc - indWithinLine >= 4)

if_logicalnz r1.z

	switch r4.y
		case 0 ; no misalignment			
			sample_resource(0)_sampler(0) r6, r0.xy
			break
		case 1			
			sample_resource(0)_sampler(0) r6._yzw, r0.xy		
			sample_resource(0)_sampler(0) r6.x___, r0.zw
			mov r6.xyzw, r6.yzwx
			break
		case 2
			sample_resource(0)_sampler(0) r6.__zw, r0.xy		
			sample_resource(0)_sampler(0) r6.xy__, r0.zw
			mov r6.xyzw, r6.zwxy
			break
		case 3
			sample_resource(0)_sampler(0) r6.___w, r0.xy		
			sample_resource(0)_sampler(0) r6.xyz_, r0.zw
			mov r6.xyzw, r6.wxyz
			break
	endswitch
	
else
	
	switch r4.y
	
		case 0 ; no misalignment
			
			switch r4.x
				case 1					
					sample_resource(0)_sampler(0) r6.x___, r0.xy
					sample_resource(0)_sampler(0) r3.xyz_, r0.zw
					mov r6._yzw, r3.0xyz
					break
				
				case 2					
					sample_resource(0)_sampler(0) r6.xy__, r0.xy
					sample_resource(0)_sampler(0) r3.xy__, r0.zw
					mov r6.__zw, r3.00xy
					break
					
				case 3
					sample_resource(0)_sampler(0) r6.xyz_, r0.xy
					sample_resource(0)_sampler(0) r3.x___, r0.zw
					mov r6.___w, r3.000x
					break	
			endswitch
			
			break
		case 1
			
			switch r4.x
				case 1					
					sample_resource(0)_sampler(0) r6._y__, r0.xy
					sample_resource(0)_sampler(0) r3.xyz_, r0.zw
					mov r6.x, r6.y
					mov r6._yzw, r3.0xyz
					break
				
				case 2					
					sample_resource(0)_sampler(0) r6._yz_, r0.xy
					sample_resource(0)_sampler(0) r3.xy__, r0.zw
					mov r6.xy00, r6.yz00
					mov r6.__zw, r3.00xy
					break
					
				case 3					
					sample_resource(0)_sampler(0) r6._yzw, r0.xy
					sample_resource(0)_sampler(0) r3.x___, r0.zw
					mov r6.xyz0, r6.yzw0
					mov r6.___w, r3.x
					break	
			endswitch
			
			break
		case 2
			
			switch r4.x
				case 1					
					sample_resource(0)_sampler(0) r6.__z_, r0.xy
					sample_resource(0)_sampler(0) r3.xyz_, r0.zw
					mov r6.x, r6.z
					mov r6._yzw, r3.0xyz
					break
				
				case 2				
					sample_resource(0)_sampler(0) r6.__zw, r0.xy
					sample_resource(0)_sampler(0) r3.xy__, r0.zw
					mov r6.xy00, r6.zw00
					mov r6.__zw, r3.00xy
					break
					
				case 3
					iadd r1.x, r1.x, l0.y
					udiv r4.y, r1.x, cb0[0].z
					umod r4.x, r1.x, cb0[0].z
					itof r4.xy, r4.xy
					sample_resource(0)_sampler(0) r6.__zw, r0.xy
					sample_resource(0)_sampler(0) r3.x___, r0.zw
					sample_resource(0)_sampler(0) r6.x___, r4.xy
					mov r6.xy0w, r6.zw0x
					mov r6.__z_, r3.00x0
					break	
									
			endswitch
			
			break
		case 3
			
			switch r4.x
				case 1					
					sample_resource(0)_sampler(0) r6.___w, r0.xy
					sample_resource(0)_sampler(0) r3.xyz_, r0.zw
					mov r6.x, r6.w
					mov r6._yzw, r3.0xyz
					break
				
				case 2
					iadd r1.x, r1.x, l0.y
					udiv r4.y, r1.x, cb0[0].z
					umod r4.x, r1.x, cb0[0].z
					itof r4.xy, r4.xy
					sample_resource(0)_sampler(0) r6.___w, r0.xy
					sample_resource(0)_sampler(0) r3.x___, r0.zw
					sample_resource(0)_sampler(0) r6.xy__, r4.xy
					mov r6.x0zw, r6.w0xy
					mov r6._y__, r3.0x00
					break
					
				case 3
					iadd r1.x, r1.x, l0.y
					udiv r4.y, r1.x, cb0[0].z
					umod r4.x, r1.x, cb0[0].z
					itof r4.xy, r4.xy
					sample_resource(0)_sampler(0) r6.___w, r0.xy
					sample_resource(0)_sampler(0) r3.xy__, r0.zw
					sample_resource(0)_sampler(0) r6.x___, r4.xy
					mov r6.x00w, r6.w00x
					mov r6._yz_, r3.0xy0
					break
									
			endswitch
			
			break
	endswitch
		
endif


; ************** part 4 **************
; output quad is stored in r7

iadd r4.w, r4.w, cb0[1].x ; y*8*xSizeDst + x + i*xSizeDst* -> actual linear index in single elements
mov r0.x, r4.w

udiv r0.y, r0.x, cb0[0].w ; line number in the input
umod r4.x, r0.x, cb0[0].w ; single element position within the line
umul r0.z, cb0[0].x, l0.x ; xPitchSrc*4
umad r0.x, r0.y, r0.z, r4.x ; single element position with account of input's padding
umod r4.y, r0.x, l0.x ; 4 components misalignment
udiv r1.x, r0.x, l0.x ; linear index in quads

; 2D input position in quads
udiv r0.y, r1.x, cb0[0].z
umod r0.x, r1.x, cb0[0].z

; increment linear index and compute 2D position of the next quad
iadd r1.x, r1.x, l0.y
udiv r0.w, r1.x, cb0[0].z
umod r0.z, r1.x, cb0[0].z
itof r0, r0

umod r1.z, cb0[0].w, l0.x ; xSizeSrc MOD 4
ieq r1.z, r1.z, r1.0 ; no padding in input
imad r4.x, r4.x, l0.z, cb0[0].w ; xSizeSrc - single element position within the line
ige r1.w, r4.x, l0.x
ior r1.z, r1.z, r1.w ; (xSizeSrc MOD 4 = 0) OR (xSizeSrc - indWithinLine >= 4)

if_logicalnz r1.z

	switch r4.y
		case 0 ; no misalignment			
			sample_resource(0)_sampler(0) r7, r0.xy
			break
		case 1			
			sample_resource(0)_sampler(0) r7._yzw, r0.xy		
			sample_resource(0)_sampler(0) r7.x___, r0.zw
			mov r7.xyzw, r7.yzwx
			break
		case 2
			sample_resource(0)_sampler(0) r7.__zw, r0.xy		
			sample_resource(0)_sampler(0) r7.xy__, r0.zw
			mov r7.xyzw, r7.zwxy
			break
		case 3
			sample_resource(0)_sampler(0) r7.___w, r0.xy		
			sample_resource(0)_sampler(0) r7.xyz_, r0.zw
			mov r7.xyzw, r7.wxyz
			break
	endswitch
	
else
	
	switch r4.y
	
		case 0 ; no misalignment
			
			switch r4.x
				case 1					
					sample_resource(0)_sampler(0) r7.x___, r0.xy
					sample_resource(0)_sampler(0) r3.xyz_, r0.zw
					mov r7._yzw, r3.0xyz
					break
				
				case 2					
					sample_resource(0)_sampler(0) r7.xy__, r0.xy
					sample_resource(0)_sampler(0) r3.xy__, r0.zw
					mov r7.__zw, r3.00xy
					break
					
				case 3
					sample_resource(0)_sampler(0) r7.xyz_, r0.xy
					sample_resource(0)_sampler(0) r3.x___, r0.zw
					mov r7.___w, r3.000x
					break	
			endswitch
			
			break
		case 1
			
			switch r4.x
				case 1					
					sample_resource(0)_sampler(0) r7._y__, r0.xy
					sample_resource(0)_sampler(0) r3.xyz_, r0.zw
					mov r7.x, r7.y
					mov r7._yzw, r3.0xyz
					break
				
				case 2					
					sample_resource(0)_sampler(0) r7._yz_, r0.xy
					sample_resource(0)_sampler(0) r3.xy__, r0.zw
					mov r7.xy00, r7.yz00
					mov r7.__zw, r3.00xy
					break
					
				case 3					
					sample_resource(0)_sampler(0) r7._yzw, r0.xy
					sample_resource(0)_sampler(0) r3.x___, r0.zw
					mov r7.xyz0, r7.yzw0
					mov r7.___w, r3.x
					break	
			endswitch
			
			break
		case 2
			
			switch r4.x
				case 1					
					sample_resource(0)_sampler(0) r7.__z_, r0.xy
					sample_resource(0)_sampler(0) r3.xyz_, r0.zw
					mov r7.x, r7.z
					mov r7._yzw, r3.0xyz
					break
				
				case 2				
					sample_resource(0)_sampler(0) r7.__zw, r0.xy
					sample_resource(0)_sampler(0) r3.xy__, r0.zw
					mov r7.xy00, r7.zw00
					mov r7.__zw, r3.00xy
					break
					
				case 3
					iadd r1.x, r1.x, l0.y
					udiv r4.y, r1.x, cb0[0].z
					umod r4.x, r1.x, cb0[0].z
					itof r4.xy, r4.xy
					sample_resource(0)_sampler(0) r7.__zw, r0.xy
					sample_resource(0)_sampler(0) r3.x___, r0.zw
					sample_resource(0)_sampler(0) r7.x___, r4.xy
					mov r7.xy0w, r7.zw0x
					mov r7.__z_, r3.00x0
					break	
									
			endswitch
			
			break
		case 3
			
			switch r4.x
				case 1					
					sample_resource(0)_sampler(0) r7.___w, r0.xy
					sample_resource(0)_sampler(0) r3.xyz_, r0.zw
					mov r7.x, r7.w
					mov r7._yzw, r3.0xyz
					break
				
				case 2
					iadd r1.x, r1.x, l0.y
					udiv r4.y, r1.x, cb0[0].z
					umod r4.x, r1.x, cb0[0].z
					itof r4.xy, r4.xy
					sample_resource(0)_sampler(0) r7.___w, r0.xy
					sample_resource(0)_sampler(0) r3.x___, r0.zw
					sample_resource(0)_sampler(0) r7.xy__, r4.xy
					mov r7.x0zw, r7.w0xy
					mov r7._y__, r3.0x00
					break
					
				case 3
					iadd r1.x, r1.x, l0.y
					udiv r4.y, r1.x, cb0[0].z
					umod r4.x, r1.x, cb0[0].z
					itof r4.xy, r4.xy
					sample_resource(0)_sampler(0) r7.___w, r0.xy
					sample_resource(0)_sampler(0) r3.xy__, r0.zw
					sample_resource(0)_sampler(0) r7.x___, r4.xy
					mov r7.x00w, r7.w00x
					mov r7._yz_, r3.0xy0
					break
									
			endswitch
			
			break
	endswitch
		
endif

; ************** part 5 **************
; output quad is stored in r8

iadd r4.w, r4.w, cb0[1].x ; y*8*xSizeDst + x + i*xSizeDst* -> actual linear index in single elements
mov r0.x, r4.w

udiv r0.y, r0.x, cb0[0].w ; line number in the input
umod r4.x, r0.x, cb0[0].w ; single element position within the line
umul r0.z, cb0[0].x, l0.x ; xPitchSrc*4
umad r0.x, r0.y, r0.z, r4.x ; single element position with account of input's padding
umod r4.y, r0.x, l0.x ; 4 components misalignment
udiv r1.x, r0.x, l0.x ; linear index in quads

; 2D input position in quads
udiv r0.y, r1.x, cb0[0].z
umod r0.x, r1.x, cb0[0].z

; increment linear index and compute 2D position of the next quad
iadd r1.x, r1.x, l0.y
udiv r0.w, r1.x, cb0[0].z
umod r0.z, r1.x, cb0[0].z
itof r0, r0

umod r1.z, cb0[0].w, l0.x ; xSizeSrc MOD 4
ieq r1.z, r1.z, r1.0 ; no padding in input
imad r4.x, r4.x, l0.z, cb0[0].w ; xSizeSrc - single element position within the line
ige r1.w, r4.x, l0.x
ior r1.z, r1.z, r1.w ; (xSizeSrc MOD 4 = 0) OR (xSizeSrc - indWithinLine >= 4)

if_logicalnz r1.z

	switch r4.y
		case 0 ; no misalignment			
			sample_resource(0)_sampler(0) r8, r0.xy
			break
		case 1			
			sample_resource(0)_sampler(0) r8._yzw, r0.xy		
			sample_resource(0)_sampler(0) r8.x___, r0.zw
			mov r8.xyzw, r8.yzwx
			break
		case 2
			sample_resource(0)_sampler(0) r8.__zw, r0.xy		
			sample_resource(0)_sampler(0) r8.xy__, r0.zw
			mov r8.xyzw, r8.zwxy
			break
		case 3
			sample_resource(0)_sampler(0) r8.___w, r0.xy		
			sample_resource(0)_sampler(0) r8.xyz_, r0.zw
			mov r8.xyzw, r8.wxyz
			break
	endswitch
	
else
	
	switch r4.y
	
		case 0 ; no misalignment
			
			switch r4.x
				case 1					
					sample_resource(0)_sampler(0) r8.x___, r0.xy
					sample_resource(0)_sampler(0) r3.xyz_, r0.zw
					mov r8._yzw, r3.0xyz
					break
				
				case 2					
					sample_resource(0)_sampler(0) r8.xy__, r0.xy
					sample_resource(0)_sampler(0) r3.xy__, r0.zw
					mov r8.__zw, r3.00xy
					break
					
				case 3
					sample_resource(0)_sampler(0) r8.xyz_, r0.xy
					sample_resource(0)_sampler(0) r3.x___, r0.zw
					mov r8.___w, r3.000x
					break	
			endswitch
			
			break
		case 1
			
			switch r4.x
				case 1					
					sample_resource(0)_sampler(0) r8._y__, r0.xy
					sample_resource(0)_sampler(0) r3.xyz_, r0.zw
					mov r8.x, r8.y
					mov r8._yzw, r3.0xyz
					break
				
				case 2					
					sample_resource(0)_sampler(0) r8._yz_, r0.xy
					sample_resource(0)_sampler(0) r3.xy__, r0.zw
					mov r8.xy00, r8.yz00
					mov r8.__zw, r3.00xy
					break
					
				case 3					
					sample_resource(0)_sampler(0) r8._yzw, r0.xy
					sample_resource(0)_sampler(0) r3.x___, r0.zw
					mov r8.xyz0, r8.yzw0
					mov r8.___w, r3.x
					break	
			endswitch
			
			break
		case 2
			
			switch r4.x
				case 1					
					sample_resource(0)_sampler(0) r8.__z_, r0.xy
					sample_resource(0)_sampler(0) r3.xyz_, r0.zw
					mov r8.x, r8.z
					mov r8._yzw, r3.0xyz
					break
				
				case 2				
					sample_resource(0)_sampler(0) r8.__zw, r0.xy
					sample_resource(0)_sampler(0) r3.xy__, r0.zw
					mov r8.xy00, r8.zw00
					mov r8.__zw, r3.00xy
					break
					
				case 3
					iadd r1.x, r1.x, l0.y
					udiv r4.y, r1.x, cb0[0].z
					umod r4.x, r1.x, cb0[0].z
					itof r4.xy, r4.xy
					sample_resource(0)_sampler(0) r8.__zw, r0.xy
					sample_resource(0)_sampler(0) r3.x___, r0.zw
					sample_resource(0)_sampler(0) r8.x___, r4.xy
					mov r8.xy0w, r8.zw0x
					mov r8.__z_, r3.00x0
					break	
									
			endswitch
			
			break
		case 3
			
			switch r4.x
				case 1					
					sample_resource(0)_sampler(0) r8.___w, r0.xy
					sample_resource(0)_sampler(0) r3.xyz_, r0.zw
					mov r8.x, r8.w
					mov r8._yzw, r3.0xyz
					break
				
				case 2
					iadd r1.x, r1.x, l0.y
					udiv r4.y, r1.x, cb0[0].z
					umod r4.x, r1.x, cb0[0].z
					itof r4.xy, r4.xy
					sample_resource(0)_sampler(0) r8.___w, r0.xy
					sample_resource(0)_sampler(0) r3.x___, r0.zw
					sample_resource(0)_sampler(0) r8.xy__, r4.xy
					mov r8.x0zw, r8.w0xy
					mov r8._y__, r3.0x00
					break
					
				case 3
					iadd r1.x, r1.x, l0.y
					udiv r4.y, r1.x, cb0[0].z
					umod r4.x, r1.x, cb0[0].z
					itof r4.xy, r4.xy
					sample_resource(0)_sampler(0) r8.___w, r0.xy
					sample_resource(0)_sampler(0) r3.xy__, r0.zw
					sample_resource(0)_sampler(0) r8.x___, r4.xy
					mov r8.x00w, r8.w00x
					mov r8._yz_, r3.0xy0
					break
									
			endswitch
			
			break
	endswitch
		
endif

; ************** part 6 **************
; output quad is stored in r9

iadd r4.w, r4.w, cb0[1].x ; y*8*xSizeDst + x + i*xSizeDst* -> actual linear index in single elements
mov r0.x, r4.w

udiv r0.y, r0.x, cb0[0].w ; line number in the input
umod r4.x, r0.x, cb0[0].w ; single element position within the line
umul r0.z, cb0[0].x, l0.x ; xPitchSrc*4
umad r0.x, r0.y, r0.z, r4.x ; single element position with account of input's padding
umod r4.y, r0.x, l0.x ; 4 components misalignment
udiv r1.x, r0.x, l0.x ; linear index in quads

; 2D input position in quads
udiv r0.y, r1.x, cb0[0].z
umod r0.x, r1.x, cb0[0].z

; increment linear index and compute 2D position of the next quad
iadd r1.x, r1.x, l0.y
udiv r0.w, r1.x, cb0[0].z
umod r0.z, r1.x, cb0[0].z
itof r0, r0

umod r1.z, cb0[0].w, l0.x ; xSizeSrc MOD 4
ieq r1.z, r1.z, r1.0 ; no padding in input
imad r4.x, r4.x, l0.z, cb0[0].w ; xSizeSrc - single element position within the line
ige r1.w, r4.x, l0.x
ior r1.z, r1.z, r1.w ; (xSizeSrc MOD 4 = 0) OR (xSizeSrc - indWithinLine >= 4)

if_logicalnz r1.z

	switch r4.y
		case 0 ; no misalignment			
			sample_resource(0)_sampler(0) r9, r0.xy
			break
		case 1			
			sample_resource(0)_sampler(0) r9._yzw, r0.xy		
			sample_resource(0)_sampler(0) r9.x___, r0.zw
			mov r9.xyzw, r9.yzwx
			break
		case 2
			sample_resource(0)_sampler(0) r9.__zw, r0.xy		
			sample_resource(0)_sampler(0) r9.xy__, r0.zw
			mov r9.xyzw, r9.zwxy
			break
		case 3
			sample_resource(0)_sampler(0) r9.___w, r0.xy		
			sample_resource(0)_sampler(0) r9.xyz_, r0.zw
			mov r9.xyzw, r9.wxyz
			break
	endswitch
	
else
	
	switch r4.y
	
		case 0 ; no misalignment
			
			switch r4.x
				case 1					
					sample_resource(0)_sampler(0) r9.x___, r0.xy
					sample_resource(0)_sampler(0) r3.xyz_, r0.zw
					mov r9._yzw, r3.0xyz
					break
				
				case 2					
					sample_resource(0)_sampler(0) r9.xy__, r0.xy
					sample_resource(0)_sampler(0) r3.xy__, r0.zw
					mov r9.__zw, r3.00xy
					break
					
				case 3
					sample_resource(0)_sampler(0) r9.xyz_, r0.xy
					sample_resource(0)_sampler(0) r3.x___, r0.zw
					mov r9.___w, r3.000x
					break	
			endswitch
			
			break
		case 1
			
			switch r4.x
				case 1					
					sample_resource(0)_sampler(0) r9._y__, r0.xy
					sample_resource(0)_sampler(0) r3.xyz_, r0.zw
					mov r9.x, r9.y
					mov r9._yzw, r3.0xyz
					break
				
				case 2					
					sample_resource(0)_sampler(0) r9._yz_, r0.xy
					sample_resource(0)_sampler(0) r3.xy__, r0.zw
					mov r9.xy00, r9.yz00
					mov r9.__zw, r3.00xy
					break
					
				case 3					
					sample_resource(0)_sampler(0) r9._yzw, r0.xy
					sample_resource(0)_sampler(0) r3.x___, r0.zw
					mov r9.xyz0, r9.yzw0
					mov r9.___w, r3.x
					break	
			endswitch
			
			break
		case 2
			
			switch r4.x
				case 1					
					sample_resource(0)_sampler(0) r9.__z_, r0.xy
					sample_resource(0)_sampler(0) r3.xyz_, r0.zw
					mov r9.x, r9.z
					mov r9._yzw, r3.0xyz
					break
				
				case 2				
					sample_resource(0)_sampler(0) r9.__zw, r0.xy
					sample_resource(0)_sampler(0) r3.xy__, r0.zw
					mov r9.xy00, r9.zw00
					mov r9.__zw, r3.00xy
					break
					
				case 3
					iadd r1.x, r1.x, l0.y
					udiv r4.y, r1.x, cb0[0].z
					umod r4.x, r1.x, cb0[0].z
					itof r4.xy, r4.xy
					sample_resource(0)_sampler(0) r9.__zw, r0.xy
					sample_resource(0)_sampler(0) r3.x___, r0.zw
					sample_resource(0)_sampler(0) r9.x___, r4.xy
					mov r9.xy0w, r9.zw0x
					mov r9.__z_, r3.00x0
					break	
									
			endswitch
			
			break
		case 3
			
			switch r4.x
				case 1					
					sample_resource(0)_sampler(0) r9.___w, r0.xy
					sample_resource(0)_sampler(0) r3.xyz_, r0.zw
					mov r9.x, r9.w
					mov r9._yzw, r3.0xyz
					break
				
				case 2
					iadd r1.x, r1.x, l0.y
					udiv r4.y, r1.x, cb0[0].z
					umod r4.x, r1.x, cb0[0].z
					itof r4.xy, r4.xy
					sample_resource(0)_sampler(0) r9.___w, r0.xy
					sample_resource(0)_sampler(0) r3.x___, r0.zw
					sample_resource(0)_sampler(0) r9.xy__, r4.xy
					mov r9.x0zw, r9.w0xy
					mov r9._y__, r3.0x00
					break
					
				case 3
					iadd r1.x, r1.x, l0.y
					udiv r4.y, r1.x, cb0[0].z
					umod r4.x, r1.x, cb0[0].z
					itof r4.xy, r4.xy
					sample_resource(0)_sampler(0) r9.___w, r0.xy
					sample_resource(0)_sampler(0) r3.xy__, r0.zw
					sample_resource(0)_sampler(0) r9.x___, r4.xy
					mov r9.x00w, r9.w00x
					mov r9._yz_, r3.0xy0
					break
									
			endswitch
			
			break
	endswitch
		
endif

; ************** part 7 **************
; output quad is stored in r10

iadd r4.w, r4.w, cb0[1].x ; y*8*xSizeDst + x + i*xSizeDst* -> actual linear index in single elements
mov r0.x, r4.w

udiv r0.y, r0.x, cb0[0].w ; line number in the input
umod r4.x, r0.x, cb0[0].w ; single element position within the line
umul r0.z, cb0[0].x, l0.x ; xPitchSrc*4
umad r0.x, r0.y, r0.z, r4.x ; single element position with account of input's padding
umod r4.y, r0.x, l0.x ; 4 components misalignment
udiv r1.x, r0.x, l0.x ; linear index in quads

; 2D input position in quads
udiv r0.y, r1.x, cb0[0].z
umod r0.x, r1.x, cb0[0].z

; increment linear index and compute 2D position of the next quad
iadd r1.x, r1.x, l0.y
udiv r0.w, r1.x, cb0[0].z
umod r0.z, r1.x, cb0[0].z
itof r0, r0

umod r1.z, cb0[0].w, l0.x ; xSizeSrc MOD 4
ieq r1.z, r1.z, r1.0 ; no padding in input
imad r4.x, r4.x, l0.z, cb0[0].w ; xSizeSrc - single element position within the line
ige r1.w, r4.x, l0.x
ior r1.z, r1.z, r1.w ; (xSizeSrc MOD 4 = 0) OR (xSizeSrc - indWithinLine >= 4)

if_logicalnz r1.z

	switch r4.y
		case 0 ; no misalignment			
			sample_resource(0)_sampler(0) r10, r0.xy
			break
		case 1			
			sample_resource(0)_sampler(0) r10._yzw, r0.xy		
			sample_resource(0)_sampler(0) r10.x___, r0.zw
			mov r10.xyzw, r10.yzwx
			break
		case 2
			sample_resource(0)_sampler(0) r10.__zw, r0.xy		
			sample_resource(0)_sampler(0) r10.xy__, r0.zw
			mov r10.xyzw, r10.zwxy
			break
		case 3
			sample_resource(0)_sampler(0) r10.___w, r0.xy		
			sample_resource(0)_sampler(0) r10.xyz_, r0.zw
			mov r10.xyzw, r10.wxyz
			break
	endswitch
	
else
	
	switch r4.y
	
		case 0 ; no misalignment
			
			switch r4.x
				case 1					
					sample_resource(0)_sampler(0) r10.x___, r0.xy
					sample_resource(0)_sampler(0) r3.xyz_, r0.zw
					mov r10._yzw, r3.0xyz
					break
				
				case 2					
					sample_resource(0)_sampler(0) r10.xy__, r0.xy
					sample_resource(0)_sampler(0) r3.xy__, r0.zw
					mov r10.__zw, r3.00xy
					break
					
				case 3
					sample_resource(0)_sampler(0) r10.xyz_, r0.xy
					sample_resource(0)_sampler(0) r3.x___, r0.zw
					mov r10.___w, r3.000x
					break	
			endswitch
			
			break
		case 1
			
			switch r4.x
				case 1					
					sample_resource(0)_sampler(0) r10._y__, r0.xy
					sample_resource(0)_sampler(0) r3.xyz_, r0.zw
					mov r10.x, r10.y
					mov r10._yzw, r3.0xyz
					break
				
				case 2					
					sample_resource(0)_sampler(0) r10._yz_, r0.xy
					sample_resource(0)_sampler(0) r3.xy__, r0.zw
					mov r10.xy00, r10.yz00
					mov r10.__zw, r3.00xy
					break
					
				case 3					
					sample_resource(0)_sampler(0) r10._yzw, r0.xy
					sample_resource(0)_sampler(0) r3.x___, r0.zw
					mov r10.xyz0, r10.yzw0
					mov r10.___w, r3.x
					break	
			endswitch
			
			break
		case 2
			
			switch r4.x
				case 1					
					sample_resource(0)_sampler(0) r10.__z_, r0.xy
					sample_resource(0)_sampler(0) r3.xyz_, r0.zw
					mov r10.x, r10.z
					mov r10._yzw, r3.0xyz
					break
				
				case 2				
					sample_resource(0)_sampler(0) r10.__zw, r0.xy
					sample_resource(0)_sampler(0) r3.xy__, r0.zw
					mov r10.xy00, r10.zw00
					mov r10.__zw, r3.00xy
					break
					
				case 3
					iadd r1.x, r1.x, l0.y
					udiv r4.y, r1.x, cb0[0].z
					umod r4.x, r1.x, cb0[0].z
					itof r4.xy, r4.xy
					sample_resource(0)_sampler(0) r10.__zw, r0.xy
					sample_resource(0)_sampler(0) r3.x___, r0.zw
					sample_resource(0)_sampler(0) r10.x___, r4.xy
					mov r10.xy0w, r10.zw0x
					mov r10.__z_, r3.00x0
					break	
									
			endswitch
			
			break
		case 3
			
			switch r4.x
				case 1					
					sample_resource(0)_sampler(0) r10.___w, r0.xy
					sample_resource(0)_sampler(0) r3.xyz_, r0.zw
					mov r10.x, r10.w
					mov r10._yzw, r3.0xyz
					break
				
				case 2
					iadd r1.x, r1.x, l0.y
					udiv r4.y, r1.x, cb0[0].z
					umod r4.x, r1.x, cb0[0].z
					itof r4.xy, r4.xy
					sample_resource(0)_sampler(0) r10.___w, r0.xy
					sample_resource(0)_sampler(0) r3.x___, r0.zw
					sample_resource(0)_sampler(0) r10.xy__, r4.xy
					mov r10.x0zw, r10.w0xy
					mov r10._y__, r3.0x00
					break
					
				case 3
					iadd r1.x, r1.x, l0.y
					udiv r4.y, r1.x, cb0[0].z
					umod r4.x, r1.x, cb0[0].z
					itof r4.xy, r4.xy
					sample_resource(0)_sampler(0) r10.___w, r0.xy
					sample_resource(0)_sampler(0) r3.xy__, r0.zw
					sample_resource(0)_sampler(0) r10.x___, r4.xy
					mov r10.x00w, r10.w00x
					mov r10._yz_, r3.0xy0
					break
									
			endswitch
			
			break
	endswitch
		
endif

; ************** part 8 **************
; output quad is stored in r11

iadd r4.w, r4.w, cb0[1].x ; y*8*xSizeDst + x + i*xSizeDst* -> actual linear index in single elements
mov r0.x, r4.w

udiv r0.y, r0.x, cb0[0].w ; line number in the input
umod r4.x, r0.x, cb0[0].w ; single element position within the line
umul r0.z, cb0[0].x, l0.x ; xPitchSrc*4
umad r0.x, r0.y, r0.z, r4.x ; single element position with account of input's padding
umod r4.y, r0.x, l0.x ; 4 components misalignment
udiv r1.x, r0.x, l0.x ; linear index in quads

; 2D input position in quads
udiv r0.y, r1.x, cb0[0].z
umod r0.x, r1.x, cb0[0].z

; increment linear index and compute 2D position of the next quad
iadd r1.x, r1.x, l0.y
udiv r0.w, r1.x, cb0[0].z
umod r0.z, r1.x, cb0[0].z
itof r0, r0

umod r1.z, cb0[0].w, l0.x ; xSizeSrc MOD 4
ieq r1.z, r1.z, r1.0 ; no padding in input
imad r4.x, r4.x, l0.z, cb0[0].w ; xSizeSrc - single element position within the line
ige r1.w, r4.x, l0.x
ior r1.z, r1.z, r1.w ; (xSizeSrc MOD 4 = 0) OR (xSizeSrc - indWithinLine >= 4)

if_logicalnz r1.z

	switch r4.y
		case 0 ; no misalignment			
			sample_resource(0)_sampler(0) r11, r0.xy
			break
		case 1			
			sample_resource(0)_sampler(0) r11._yzw, r0.xy		
			sample_resource(0)_sampler(0) r11.x___, r0.zw
			mov r11.xyzw, r11.yzwx
			break
		case 2
			sample_resource(0)_sampler(0) r11.__zw, r0.xy		
			sample_resource(0)_sampler(0) r11.xy__, r0.zw
			mov r11.xyzw, r11.zwxy
			break
		case 3
			sample_resource(0)_sampler(0) r11.___w, r0.xy		
			sample_resource(0)_sampler(0) r11.xyz_, r0.zw
			mov r11.xyzw, r11.wxyz
			break
	endswitch
	
else
	
	switch r4.y
	
		case 0 ; no misalignment
			
			switch r4.x
				case 1					
					sample_resource(0)_sampler(0) r11.x___, r0.xy
					sample_resource(0)_sampler(0) r3.xyz_, r0.zw
					mov r11._yzw, r3.0xyz
					break
				
				case 2					
					sample_resource(0)_sampler(0) r11.xy__, r0.xy
					sample_resource(0)_sampler(0) r3.xy__, r0.zw
					mov r11.__zw, r3.00xy
					break
					
				case 3
					sample_resource(0)_sampler(0) r11.xyz_, r0.xy
					sample_resource(0)_sampler(0) r3.x___, r0.zw
					mov r11.___w, r3.000x
					break	
			endswitch
			
			break
		case 1
			
			switch r4.x
				case 1					
					sample_resource(0)_sampler(0) r11._y__, r0.xy
					sample_resource(0)_sampler(0) r3.xyz_, r0.zw
					mov r11.x, r11.y
					mov r11._yzw, r3.0xyz
					break
				
				case 2					
					sample_resource(0)_sampler(0) r11._yz_, r0.xy
					sample_resource(0)_sampler(0) r3.xy__, r0.zw
					mov r11.xy00, r11.yz00
					mov r11.__zw, r3.00xy
					break
					
				case 3					
					sample_resource(0)_sampler(0) r11._yzw, r0.xy
					sample_resource(0)_sampler(0) r3.x___, r0.zw
					mov r11.xyz0, r11.yzw0
					mov r11.___w, r3.x
					break	
			endswitch
			
			break
		case 2
			
			switch r4.x
				case 1					
					sample_resource(0)_sampler(0) r11.__z_, r0.xy
					sample_resource(0)_sampler(0) r3.xyz_, r0.zw
					mov r11.x, r11.z
					mov r11._yzw, r3.0xyz
					break
				
				case 2				
					sample_resource(0)_sampler(0) r11.__zw, r0.xy
					sample_resource(0)_sampler(0) r3.xy__, r0.zw
					mov r11.xy00, r11.zw00
					mov r11.__zw, r3.00xy
					break
					
				case 3
					iadd r1.x, r1.x, l0.y
					udiv r4.y, r1.x, cb0[0].z
					umod r4.x, r1.x, cb0[0].z
					itof r4.xy, r4.xy
					sample_resource(0)_sampler(0) r11.__zw, r0.xy
					sample_resource(0)_sampler(0) r3.x___, r0.zw
					sample_resource(0)_sampler(0) r11.x___, r4.xy
					mov r11.xy0w, r11.zw0x
					mov r11.__z_, r3.00x0
					break	
									
			endswitch
			
			break
		case 3
			
			switch r4.x
				case 1					
					sample_resource(0)_sampler(0) r11.___w, r0.xy
					sample_resource(0)_sampler(0) r3.xyz_, r0.zw
					mov r11.x, r11.w
					mov r11._yzw, r3.0xyz
					break
				
				case 2
					iadd r1.x, r1.x, l0.y
					udiv r4.y, r1.x, cb0[0].z
					umod r4.x, r1.x, cb0[0].z
					itof r4.xy, r4.xy
					sample_resource(0)_sampler(0) r11.___w, r0.xy
					sample_resource(0)_sampler(0) r3.x___, r0.zw
					sample_resource(0)_sampler(0) r11.xy__, r4.xy
					mov r11.x0zw, r11.w0xy
					mov r11._y__, r3.0x00
					break
					
				case 3
					iadd r1.x, r1.x, l0.y
					udiv r4.y, r1.x, cb0[0].z
					umod r4.x, r1.x, cb0[0].z
					itof r4.xy, r4.xy
					sample_resource(0)_sampler(0) r11.___w, r0.xy
					sample_resource(0)_sampler(0) r3.xy__, r0.zw
					sample_resource(0)_sampler(0) r11.x___, r4.xy
					mov r11.x00w, r11.w00x
					mov r11._yz_, r3.0xy0
					break
									
			endswitch
			
			break
	endswitch
		
endif

iadd r1.y, r1.y, l0.y ; increment position of the output quad within the row
ieq r0.z, r1.y, cb0[0].y ; ind+1 = xPitchDst
if_logicalnz r0.z
	
	umod r0.z, cb0[1].x, l0.x ; misalignment xSizeDst MOD 4
	switch r0.z
		case 0 ; no misalignment
			break
		case 1
			mov r2, r2.x000
			mov r5, r5.x000
			mov r6, r6.x000
			mov r7, r7.x000
			mov r8, r8.x000
			mov r9, r9.x000
			mov r10, r10.x000
			mov r11, r11.x000
			break
		case 2
			mov r2, r2.xy00
			mov r5, r5.xy00
			mov r6, r6.xy00
			mov r7, r7.xy00
			mov r8, r8.xy00
			mov r9, r9.xy00
			mov r10, r10.xy00
			mov r11, r11.xy00
			break
		case 3
			mov r2, r2.xyz0
			mov r5, r5.xyz0
			mov r6, r6.xyz0
			mov r7, r7.xyz0
			mov r8, r8.xyz0
			mov r9, r9.xyz0
			mov r10, r10.xyz0
			mov r11, r11.xyz0
			break
	endswitch
	
endif

mov o0, r2
mov o1, r5
mov o2, r6
mov o3, r7
mov o4, r8
mov o5, r9
mov o6, r10
mov o7, r11
	
end
]]>
	</ILKernel>
	
<ILKernel name = "ReshapeSplit8ToVirt_LI_R0">
<![CDATA[
il_ps_2_0
;
;	Reshape a matrix splitted into 8 parts to a virtualized array
; 
;	inputs: 8
;	outputs: 1
;	data type: LONGINT, REAL
;	nComponents: 4
;	constants: 2, 2x4 (LONGINT)
;

dcl_output_generic o0
dcl_input_position_interp(linear_noperspective) vWinCoord0.xy__

dcl_cb cb0[2] ; [xPitchSrc,xPitchDst,physWidthDst,xSizeSrc], [xSizeDst,...]
; in this case xPitchSrc = physWidthSrc

dcl_resource_id(0)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(1)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(2)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(3)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(4)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(5)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(6)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(7)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)

dcl_literal l0, 4, 1, 0xFFFFFFFF, 8

ftoi r0, vWinCoord0.xy ; 2D output position in quads
umad r0.x, r0.y, cb0[0].z, r0.x ; linear index of current quad in the output
udiv r0.y, r0.x, cb0[0].y ; line number of current quad
umod r3.x, r0.x, cb0[0].y ; position of the quad within the line
umul r0.x, r3.x, l0.x ; single element position within the line
umad r0.x, r0.y, cb0[1].x, r0.x ; nLines*xSizeDst + ind -> actual linear index in single elements

; get part number, 2D quad position and misalignment
call 0
mov r4, r1

iadd r0.x, r0.x, l0.y
call 0
mov r5, r1

iadd r0.x, r0.x, l0.y
call 0
mov r6, r1

iadd r0.x, r0.x, l0.y
call 0
mov r7, r1

;itof o0.x, r4.w
;itof o0.y, r5.w
;itof o0.z, r6.w
;itof o0.w, r7.w

ieq r0.xy, r4.xy, r5.xy
ieq r1.xy, r5.xy, r6.xy
ieq r2.xy, r6.xy, r7.xy
iand r0.xy, r0.xy, r1.xy
iand r0.xy, r0.xy, r2.xy
iand r0.x, r0.x, r0.y

if_logicalnz r0.x
	
	itof r4.xy, r4.xy
	
	switch r4.z
		case 0
			sample_resource(0)_sampler(0) r3, r4.xy
			break
		case 1
			sample_resource(1)_sampler(1) r3, r4.xy
			break
		case 2
			sample_resource(2)_sampler(2) r3, r4.xy
			break
		case 3
			sample_resource(3)_sampler(3) r3, r4.xy
			break
		case 4
			sample_resource(4)_sampler(4) r3, r4.xy
			break
		case 5
			sample_resource(5)_sampler(5) r3, r4.xy
			break
		case 6
			sample_resource(6)_sampler(6) r3, r4.xy
			break
		case 7
			sample_resource(7)_sampler(7) r3, r4.xy
			break
	endswitch
else	
		
	mov r1, r4
	call 1
	mov r3.x, r2.x
	
	mov r1, r5
	call 1
	mov r3.y, r2.x
	
	mov r1, r6
	call 1
	mov r3.z, r2.x
	
	mov r1, r7
	call 1
	mov r3.w, r2.x
endif

mov o0, r3

endmain

; given linear input index in single components r0.x compute part number in r1.z, 
; 2D quad position within the part in r1.xy, and misalignment in r1.w
func 0

; these computations are based on the fact that ind = y*8*Nx + x + iPart*Nx = (y*8+iPart)*Nx + x
; where [x,y] is 2D position within the matrix part

umod r1.x, r0.x, cb0[0].w ; x = ind MOD xSizeSrc
udiv r1.z, r0.x, cb0[0].w ; y*8+iPart
udiv r1.y, r1.z, l0.w ; y = (y*8+iPart) DIV 8
umod r1.z, r1.z, l0.w ; iPart = (y*8+iPart) MOD 8
umod r1.w, r1.x, l0.x ; x MOD 4
udiv r1.x, r1.x, l0.x ; x in quads

ret
endfunc

; get data element in r2.x given part number in r1.z, 
; 2D quad position within the part in r1.xy, and misalignment in r1.w
func 1
	
	itof r1.xy, r1.xy
	
	switch r1.w
		
		case 0
			switch r1.z
				case 0
					sample_resource(0)_sampler(0) r2.x___, r1.xy
					break
				case 1
					sample_resource(1)_sampler(1) r2.x___, r1.xy
					break
				case 2
					sample_resource(2)_sampler(2) r2.x___, r1.xy
					break
				case 3
					sample_resource(3)_sampler(3) r2.x___, r1.xy
					break
				case 4
					sample_resource(4)_sampler(4) r2.x___, r1.xy
					break
				case 5
					sample_resource(5)_sampler(5) r2.x___, r1.xy
					break
				case 6
					sample_resource(6)_sampler(6) r2.x___, r1.xy
					break					
				case 7
					sample_resource(7)_sampler(7) r2.x___, r1.xy
					break	
			endswitch			
			break
		
		case 1
			switch r1.z
				case 0
					sample_resource(0)_sampler(0) r2._y__, r1.xy
					break
				case 1
					sample_resource(1)_sampler(1) r2._y__, r1.xy
					break
				case 2
					sample_resource(2)_sampler(2) r2._y__, r1.xy
					break
				case 3
					sample_resource(3)_sampler(3) r2._y__, r1.xy
					break
				case 4
					sample_resource(4)_sampler(4) r2._y__, r1.xy
					break
				case 5
					sample_resource(5)_sampler(5) r2._y__, r1.xy
					break
				case 6
					sample_resource(6)_sampler(6) r2._y__, r1.xy
					break					
				case 7
					sample_resource(7)_sampler(7) r2._y__, r1.xy
					break	
			endswitch
			mov r2.x, r2.y
			break
		
		case 2
			switch r1.z
				case 0
					sample_resource(0)_sampler(0) r2.__z_, r1.xy
					break
				case 1
					sample_resource(1)_sampler(1) r2.__z_, r1.xy
					break
				case 2
					sample_resource(2)_sampler(2) r2.__z_, r1.xy
					break
				case 3
					sample_resource(3)_sampler(3) r2.__z_, r1.xy
					break
				case 4
					sample_resource(4)_sampler(4) r2.__z_, r1.xy
					break
				case 5
					sample_resource(5)_sampler(5) r2.__z_, r1.xy
					break
				case 6
					sample_resource(6)_sampler(6) r2.__z_, r1.xy
					break					
				case 7
					sample_resource(7)_sampler(7) r2.__z_, r1.xy
					break	
			endswitch
			mov r2.x, r2.z
			break
		
		case 3
			switch r1.z
				case 0
					sample_resource(0)_sampler(0) r2.___w, r1.xy
					break
				case 1
					sample_resource(1)_sampler(1) r2.___w, r1.xy
					break
				case 2
					sample_resource(2)_sampler(2) r2.___w, r1.xy
					break
				case 3
					sample_resource(3)_sampler(3) r2.___w, r1.xy
					break
				case 4
					sample_resource(4)_sampler(4) r2.___w, r1.xy
					break
				case 5
					sample_resource(5)_sampler(5) r2.___w, r1.xy
					break
				case 6
					sample_resource(6)_sampler(6) r2.___w, r1.xy
					break					
				case 7
					sample_resource(7)_sampler(7) r2.___w, r1.xy
					break	
			endswitch
			mov r2.x, r2.w
			break
	endswitch			
	
ret
endfunc

end
]]>
	</ILKernel>

<ILKernel name = "ReshapeSplit8ToVirt_LI_R">
<![CDATA[
il_cs_2_0
dcl_num_thread_per_group 64
;
;	Reshape a matrix splitted into 8 parts to a virtualized array
; 
;	inputs: 8
;	outputs: 0
;	global buffer: yes
;	data type: LONGINT, REAL
;	nComponents: 4
;	constants: 2, 2x4 (LONGINT)
;

dcl_cb cb0[2] ; [xPitchSrc,xPitchDst,physWidthDst,xSizeSrc], [xSizeDst,...]
; in this case xPitchSrc = physWidthSrc

dcl_resource_id(0)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(1)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(2)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(3)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(4)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(5)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(6)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(7)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)

dcl_literal l0, 4, 1, 0xFFFFFFFF, 8

mov r0.x, vaTid.x

udiv r0.y, r0.x, cb0[0].y ; line number of current quad
umod r3.x, r0.x, cb0[0].y ; position of the quad within the line
umul r0.x, r3.x, l0.x ; single element position within the line
umad r0.x, r0.y, cb0[1].x, r0.x ; nLines*xSizeDst + ind -> actual linear index in single elements

; get part number, 2D quad position and misalignment
call 0
mov r4, r1

iadd r0.x, r0.x, l0.y
call 0
mov r5, r1

iadd r0.x, r0.x, l0.y
call 0
mov r6, r1

iadd r0.x, r0.x, l0.y
call 0
mov r7, r1

ieq r0.xy, r4.xy, r5.xy
ieq r1.xy, r5.xy, r6.xy
ieq r2.xy, r6.xy, r7.xy
iand r0.xy, r0.xy, r1.xy
iand r0.xy, r0.xy, r2.xy
iand r0.x, r0.x, r0.y

if_logicalnz r0.x
	
	itof r4.xy, r4.xy
	
	switch r4.z
		case 0
			sample_resource(0)_sampler(0) r3, r4.xy
			break
		case 1
			sample_resource(1)_sampler(1) r3, r4.xy
			break
		case 2
			sample_resource(2)_sampler(2) r3, r4.xy
			break
		case 3
			sample_resource(3)_sampler(3) r3, r4.xy
			break
		case 4
			sample_resource(4)_sampler(4) r3, r4.xy
			break
		case 5
			sample_resource(5)_sampler(5) r3, r4.xy
			break
		case 6
			sample_resource(6)_sampler(6) r3, r4.xy
			break
		case 7
			sample_resource(7)_sampler(7) r3, r4.xy
			break
	endswitch
else	
		
	mov r1, r4
	call 1
	mov r3.x, r2.x
	
	mov r1, r5
	call 1
	mov r3.y, r2.x
	
	mov r1, r6
	call 1
	mov r3.z, r2.x
	
	mov r1, r7
	call 1
	mov r3.w, r2.x
endif

mov g[vaTid.x], r3

endmain

; given linear input index in single components r0.x compute part number in r1.z, 
; 2D quad position within the part in r1.xy, and misalignment in r1.w
func 0

; these computations are based on the fact that ind = y*8*Nx + x + iPart*Nx = (y*8+iPart)*Nx + x
; where [x,y] is 2D position within the matrix part

umod r1.x, r0.x, cb0[0].w ; x = ind MOD xSizeSrc
udiv r1.z, r0.x, cb0[0].w ; y*8+iPart
udiv r1.y, r1.z, l0.w ; y = (y*8+iPart) DIV 8
umod r1.z, r1.z, l0.w ; iPart = (y*8+iPart) MOD 8
umod r1.w, r1.x, l0.x ; x MOD 4
udiv r1.x, r1.x, l0.x ; x in quads

ret
endfunc

; get data element in r2.x given part number in r1.z, 
; 2D quad position within the part in r1.xy, and misalignment in r1.w
func 1
	
	itof r1.xy, r1.xy
	
	switch r1.w
		
		case 0
			switch r1.z
				case 0
					sample_resource(0)_sampler(0) r2.x___, r1.xy
					break
				case 1
					sample_resource(1)_sampler(1) r2.x___, r1.xy
					break
				case 2
					sample_resource(2)_sampler(2) r2.x___, r1.xy
					break
				case 3
					sample_resource(3)_sampler(3) r2.x___, r1.xy
					break
				case 4
					sample_resource(4)_sampler(4) r2.x___, r1.xy
					break
				case 5
					sample_resource(5)_sampler(5) r2.x___, r1.xy
					break
				case 6
					sample_resource(6)_sampler(6) r2.x___, r1.xy
					break					
				case 7
					sample_resource(7)_sampler(7) r2.x___, r1.xy
					break	
			endswitch			
			break
		
		case 1
			switch r1.z
				case 0
					sample_resource(0)_sampler(0) r2._y__, r1.xy
					break
				case 1
					sample_resource(1)_sampler(1) r2._y__, r1.xy
					break
				case 2
					sample_resource(2)_sampler(2) r2._y__, r1.xy
					break
				case 3
					sample_resource(3)_sampler(3) r2._y__, r1.xy
					break
				case 4
					sample_resource(4)_sampler(4) r2._y__, r1.xy
					break
				case 5
					sample_resource(5)_sampler(5) r2._y__, r1.xy
					break
				case 6
					sample_resource(6)_sampler(6) r2._y__, r1.xy
					break					
				case 7
					sample_resource(7)_sampler(7) r2._y__, r1.xy
					break	
			endswitch
			mov r2.x, r2.y
			break
		
		case 2
			switch r1.z
				case 0
					sample_resource(0)_sampler(0) r2.__z_, r1.xy
					break
				case 1
					sample_resource(1)_sampler(1) r2.__z_, r1.xy
					break
				case 2
					sample_resource(2)_sampler(2) r2.__z_, r1.xy
					break
				case 3
					sample_resource(3)_sampler(3) r2.__z_, r1.xy
					break
				case 4
					sample_resource(4)_sampler(4) r2.__z_, r1.xy
					break
				case 5
					sample_resource(5)_sampler(5) r2.__z_, r1.xy
					break
				case 6
					sample_resource(6)_sampler(6) r2.__z_, r1.xy
					break					
				case 7
					sample_resource(7)_sampler(7) r2.__z_, r1.xy
					break	
			endswitch
			mov r2.x, r2.z
			break
		
		case 3
			switch r1.z
				case 0
					sample_resource(0)_sampler(0) r2.___w, r1.xy
					break
				case 1
					sample_resource(1)_sampler(1) r2.___w, r1.xy
					break
				case 2
					sample_resource(2)_sampler(2) r2.___w, r1.xy
					break
				case 3
					sample_resource(3)_sampler(3) r2.___w, r1.xy
					break
				case 4
					sample_resource(4)_sampler(4) r2.___w, r1.xy
					break
				case 5
					sample_resource(5)_sampler(5) r2.___w, r1.xy
					break
				case 6
					sample_resource(6)_sampler(6) r2.___w, r1.xy
					break					
				case 7
					sample_resource(7)_sampler(7) r2.___w, r1.xy
					break	
			endswitch
			mov r2.x, r2.w
			break
	endswitch			
	
ret
endfunc

end
]]>
	</ILKernel>
			
<ILKernel name = "Transpose3D_LI_R0">
<![CDATA[
il_ps_2_0
;
;	Transpose a virtualized 3D array
; 
;	inputs: 1
;	outputs: 1
;	data type: LONGINT, REAL
;	nComponents: 4
;	constants: 4x4 (LONGINT) [physWidth, newNy*newNx, newNx, 1], [tZ, tY, tX, 0], [oldNy*oldNx, oldNx, 1, 0],
;										[xPitchSrc,xPitchDst,xSizeSrc,xSizeDst]
;
dcl_cb cb0[4]
dcl_output_generic o0
dcl_input_position_interp(linear_noperspective) vWinCoord0.xy__
dcl_resource_id(0)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)

dcl_literal l0, 4, 1, 0, 0

ftoi r0, vWinCoord0.xy ; 2D output position in quads
umad r0.x, r0.y, cb0[0].x, r0.x ; linear index of current quad in the output
udiv r0.y, r0.x, cb0[3].y ; line number of current quad
umod r1.y, r0.x, cb0[3].y ; position of the quad within the line
umul r0.x, r1.y, l0.x ; single element position within the line
umad r0.x, r0.y, cb0[3].w, r0.x ; nLines*xSizeDst + ind -> actual linear index in single elements

call 0
mov r4.x, r1.x

iadd r0.x, r0.x, l0.y
call 0
mov r4.y, r1.x

iadd r0.x, r0.x, l0.y
call 0
mov r4.z, r1.x

iadd r0.x, r0.x, l0.y
call 0
mov r4.w, r1.x

mov o0, r4

endmain

; get input array element in given output index r0.x in single components, returned value is in r1.x
func 0
	
; compute z, y, x coordinates in the output
udiv r1.x, r0.x, cb0[0].y	; z := ind/(newNy*newNx)
umod r1.z, r0.x, cb0[0].y	; r1.z := ind - z*newNy*newNx
udiv r1.y, r1.z, cb0[0].z	; y := (ind - z*newNy*newNx)/newNx
umod r1.z, r1.z, cb0[0].z	; x := ind - z*newNy*newNx - y*newNx

; shuffle the coordinates

switch cb0[1].x

	default
		mov r2.x, r1.x
	break

	case 1
		mov r2.y, r1.x
	break

	case 2
		mov r2.z, r1.x
	break

endswitch

switch cb0[1].y

	default
		mov r2.x, r1.y
	break

	case 1
		mov r2.y, r1.y
	break

	case 2
		mov r2.z, r1.y
	break

endswitch

switch cb0[1].z

	default
		mov r2.x, r1.z
	break

	case 1
		mov r2.y, r1.z
	break

	case 2
		mov r2.z, r1.z
	break

endswitch

; compute linear index in the input
imul r2.xyz, r2.xyz, cb0[2].xyz	; [z*oldNy*oldNx, y*oldNx, x*1]

; horizontal add
iadd r2.x, r2.x, r2.y
iadd r2.x, r2.x, r2.z

; compute corresponding 2D index in the input
udiv r1.y, r2.x, cb0[3].z ; ind DIV xSizeSrc -> line number in the input
umod r1.x, r2.x, cb0[3].z ; single element position within the line
umul r1.z, cb0[3].x, l0.x ; xPitchSrc*4
umad r1.x, r1.y, r1.z, r1.x ; single element position with account of input's padding

umod r1.y, r1.x, l0.x ; 4 components misalignment
udiv r1.x, r1.x, l0.x ; linear index in quads

; compute 2D position in quads
udiv r3.y, r1.x, cb0[0].x
umod r3.x, r1.x, cb0[0].x
itof r3.xy, r3.xy

switch r1.y

	case 0
		sample_resource(0)_sampler(0) r1.x___, r3.xy
	break
	
	case 1
		sample_resource(0)_sampler(0) r1._y__, r3.xy
		mov r1.x, r1.y
	break
	
	case 2
		sample_resource(0)_sampler(0) r1.__z_, r3.xy
		mov r1.x, r1.z
	break
	
	case 3
		sample_resource(0)_sampler(0) r1.___w, r3.xy
		mov r1.x, r1.w
	break
	
endswitch
	
ret
endfunc

end
]]>
	</ILKernel>

<ILKernel name = "Transpose3D_LI_R">
<![CDATA[
il_cs_2_0
dcl_num_thread_per_group 64
;
;	Transpose a virtualized 3D array
; 
;	inputs: 1
;	outputs: 0
; 	global buffer: yes
;	data type: LONGINT, REAL
;	nComponents: 4
;	constants: 4x4 (LONGINT) [physWidth, newNy*newNx, newNx, 1], [tZ, tY, tX, 0], [oldNy*oldNx, oldNx, 1, 0],
;										[xPitchSrc,xPitchDst,xSizeSrc,xSizeDst]
;
dcl_cb cb0[4]
dcl_resource_id(0)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)

dcl_literal l0, 4, 1, 0, 0

mov r0.x, vaTid.x ; linear index of current quad in the output
udiv r0.y, r0.x, cb0[3].y ; line number of current quad
umod r1.y, r0.x, cb0[3].y ; position of the quad within the line
umul r0.x, r1.y, l0.x ; single element position within the line
umad r0.x, r0.y, cb0[3].w, r0.x ; nLines*xSizeDst + ind -> actual linear index in single elements

call 0
mov r4.x, r1.x

iadd r0.x, r0.x, l0.y
call 0
mov r4.y, r1.x

iadd r0.x, r0.x, l0.y
call 0
mov r4.z, r1.x

iadd r0.x, r0.x, l0.y
call 0
mov r4.w, r1.x

mov g[vaTid.x], r4

endmain

; get input array element in given output index r0.x in single components, returned value is in r1.x
func 0
	
; compute z, y, x coordinates in the output
udiv r1.x, r0.x, cb0[0].y	; z := ind/(newNy*newNx)
umod r1.z, r0.x, cb0[0].y	; r1.z := ind - z*newNy*newNx
udiv r1.y, r1.z, cb0[0].z	; y := (ind - z*newNy*newNx)/newNx
umod r1.z, r1.z, cb0[0].z	; x := ind - z*newNy*newNx - y*newNx

; shuffle the coordinates

switch cb0[1].x

	default
		mov r2.x, r1.x
	break

	case 1
		mov r2.y, r1.x
	break

	case 2
		mov r2.z, r1.x
	break

endswitch

switch cb0[1].y

	default
		mov r2.x, r1.y
	break

	case 1
		mov r2.y, r1.y
	break

	case 2
		mov r2.z, r1.y
	break

endswitch

switch cb0[1].z

	default
		mov r2.x, r1.z
	break

	case 1
		mov r2.y, r1.z
	break

	case 2
		mov r2.z, r1.z
	break

endswitch

; compute linear index in the input
imul r2.xyz, r2.xyz, cb0[2].xyz	; [z*oldNy*oldNx, y*oldNx, x*1]

; horizontal add
iadd r2.x, r2.x, r2.y
iadd r2.x, r2.x, r2.z

; compute corresponding 2D index in the input
udiv r1.y, r2.x, cb0[3].z ; ind DIV xSizeSrc -> line number in the input
umod r1.x, r2.x, cb0[3].z ; single element position within the line
umul r1.z, cb0[3].x, l0.x ; xPitchSrc*4
umad r1.x, r1.y, r1.z, r1.x ; single element position with account of input's padding

umod r1.y, r1.x, l0.x ; 4 components misalignment
udiv r1.x, r1.x, l0.x ; linear index in quads

; compute 2D position in quads
udiv r3.y, r1.x, cb0[0].x
umod r3.x, r1.x, cb0[0].x
itof r3.xy, r3.xy

switch r1.y

	case 0
		sample_resource(0)_sampler(0) r1.x___, r3.xy
	break
	
	case 1
		sample_resource(0)_sampler(0) r1._y__, r3.xy
		mov r1.x, r1.y
	break
	
	case 2
		sample_resource(0)_sampler(0) r1.__z_, r3.xy
		mov r1.x, r1.z
	break
	
	case 3
		sample_resource(0)_sampler(0) r1.___w, r3.xy
		mov r1.x, r1.w
	break
	
endswitch
	
ret
endfunc

end
]]>
	</ILKernel>	

<ILKernel name = "Transpose4D_LI_R0">
<![CDATA[
il_ps_2_0
;
;	Transpose a virtualized 4D array
; 
;	inputs: 1
;	outputs: 1
;	data type: LONGINT, REAL
;	nComponents: 4
;	constants: 1, 4x4 (LONGINT) [physWidth, newNz*newNy*newNx, newNy*newNx, newNx], 
;											[tT, tZ, tY, tX], [oldNz*oldNy*oldNx, oldNy*oldNx, oldNx, 1], [xPitchSrc,xPitchDst,xSizeSrc,xSizeDst]
dcl_cb cb0[4]
dcl_output_generic o0
dcl_input_position_interp(linear_noperspective) vWinCoord0.xy__
dcl_resource_id(0)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)

dcl_literal l0, 4, 1, 0, 0

ftoi r0, vWinCoord0.xy ; 2D output position in quads
umad r0.x, r0.y, cb0[0].x, r0.x ; linear index of current quad in the output
udiv r0.y, r0.x, cb0[3].y ; line number of current quad
umod r1.y, r0.x, cb0[3].y ; position of the quad within the line
umul r0.x, r1.y, l0.x ; single element position within the line
umad r0.x, r0.y, cb0[3].w, r0.x ; nLines*xSizeDst + ind -> actual linear index in single elements

call 0
mov r4.x, r1.x

iadd r0.x, r0.x, l0.y
call 0
mov r4.y, r1.x

iadd r0.x, r0.x, l0.y
call 0
mov r4.z, r1.x

iadd r0.x, r0.x, l0.y
call 0
mov r4.w, r1.x

mov o0, r4

endmain

; get input array element in given output index r0.x in single components, returned value is in r1.x
func 0
	
; compute t, z, y, x coordinates in the output
udiv r1.x, r0.x, cb0[0].y	; t := ind/(newNz*newNy*newNx)
umod r1.w, r0.x, cb0[0].y	; r1.w := ind - t*newNz*newNy*newNx
udiv r1.y, r1.w, cb0[0].z	; z := (ind - t*newNz*newNy*newNx)/(newNy*newNx)
umod r1.w, r1.w, cb0[0].z	; r1.w := ind - t*newNz*newNy*newNx - z*(newNy*newNx)
udiv r1.z, r1.w, cb0[0].w	; y := (ind - t*newNz*newNy*newNx - z*(newNy*newNx))/newNx
umod r1.w, r1.w, cb0[0].w	; x := (ind - t*newNz*newNy*newNx - z*(newNy*newNx)) MOD newNx

; shuffle the coordinates

switch cb0[1].x

	default
		mov r2.x, r1.x
	break

	case 1
		mov r2.y, r1.x
	break

	case 2
		mov r2.z, r1.x
	break
	
	case 3
		mov r2.w, r1.x
	break

endswitch

switch cb0[1].y

	default
		mov r2.x, r1.y
	break

	case 1
		mov r2.y, r1.y
	break

	case 2
		mov r2.z, r1.y
	break

	case 3
		mov r2.w, r1.y
	break

endswitch

switch cb0[1].z

	default
		mov r2.x, r1.z
	break

	case 1
		mov r2.y, r1.z
	break

	case 2
		mov r2.z, r1.z
	break

	case 3
		mov r2.w, r1.z
	break

endswitch

switch cb0[1].w

	default
		mov r2.x, r1.w
	break

	case 1
		mov r2.y, r1.w
	break

	case 2
		mov r2.z, r1.w
	break

	case 3
		mov r2.w, r1.w
	break

endswitch

; compute linear index in the input
imul r2.xyzw, r2.xyzw, cb0[2].xyzw	; [t*oldNz*oldNy*oldNx, z*oldNy*oldNx, y*oldNx, x*1]

; horizontal add
iadd r2.x, r2.x, r2.y
iadd r2.x, r2.x, r2.z
iadd r2.x, r2.x, r2.w

; compute corresponding 2D index in the input
udiv r1.y, r2.x, cb0[3].z ; ind DIV xSizeSrc -> line number in the input
umod r1.x, r2.x, cb0[3].z ; single element position within the line
umul r1.z, cb0[3].x, l0.x ; xPitchSrc*4
umad r1.x, r1.y, r1.z, r1.x ; single element position with account of input's padding

umod r1.y, r1.x, l0.x ; 4 components misalignment
udiv r1.x, r1.x, l0.x ; linear index in quads

; compute 2D position in quads
udiv r3.y, r1.x, cb0[0].x
umod r3.x, r1.x, cb0[0].x
itof r3.xy, r3.xy

switch r1.y

	case 0
		sample_resource(0)_sampler(0) r1.x___, r3.xy
	break
	
	case 1
		sample_resource(0)_sampler(0) r1._y__, r3.xy
		mov r1.x, r1.y
	break
	
	case 2
		sample_resource(0)_sampler(0) r1.__z_, r3.xy
		mov r1.x, r1.z
	break
	
	case 3
		sample_resource(0)_sampler(0) r1.___w, r3.xy
		mov r1.x, r1.w
	break
	
endswitch
	
ret
endfunc

end
]]>
	</ILKernel>
	
<ILKernel name = "Transpose4D_LI_R">
<![CDATA[
il_cs_2_0
dcl_num_thread_per_group 64
;
;	Transpose a virtualized 4D array
; 
;	inputs: 1
;	outputs: 0
;	global buffer: yes
;	data type: LONGINT, REAL
;	nComponents: 4
;	constants: 1, 4x4 (LONGINT) [physWidth, newNz*newNy*newNx, newNy*newNx, newNx], 
;											[tT, tZ, tY, tX], [oldNz*oldNy*oldNx, oldNy*oldNx, oldNx, 1], [xPitchSrc,xPitchDst,xSizeSrc,xSizeDst]
dcl_cb cb0[4]
dcl_resource_id(0)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)

dcl_literal l0, 4, 1, 0, 0

mov r0.x, vaTid.x
udiv r0.y, r0.x, cb0[3].y ; line number of current quad
umod r1.y, r0.x, cb0[3].y ; position of the quad within the line
umul r0.x, r1.y, l0.x ; single element position within the line
umad r0.x, r0.y, cb0[3].w, r0.x ; nLines*xSizeDst + ind -> actual linear index in single elements

call 0
mov r4.x, r1.x

iadd r0.x, r0.x, l0.y
call 0
mov r4.y, r1.x

iadd r0.x, r0.x, l0.y
call 0
mov r4.z, r1.x

iadd r0.x, r0.x, l0.y
call 0
mov r4.w, r1.x

mov g[vaTid.x], r4

endmain

; get input array element in given output index r0.x in single components, returned value is in r1.x
func 0
	
; compute t, z, y, x coordinates in the output
udiv r1.x, r0.x, cb0[0].y	; t := ind/(newNz*newNy*newNx)
umod r1.w, r0.x, cb0[0].y	; r1.w := ind - t*newNz*newNy*newNx
udiv r1.y, r1.w, cb0[0].z	; z := (ind - t*newNz*newNy*newNx)/(newNy*newNx)
umod r1.w, r1.w, cb0[0].z	; r1.w := ind - t*newNz*newNy*newNx - z*(newNy*newNx)
udiv r1.z, r1.w, cb0[0].w	; y := (ind - t*newNz*newNy*newNx - z*(newNy*newNx))/newNx
umod r1.w, r1.w, cb0[0].w	; x := (ind - t*newNz*newNy*newNx - z*(newNy*newNx)) MOD newNx

; shuffle the coordinates

switch cb0[1].x

	default
		mov r2.x, r1.x
	break

	case 1
		mov r2.y, r1.x
	break

	case 2
		mov r2.z, r1.x
	break
	
	case 3
		mov r2.w, r1.x
	break

endswitch

switch cb0[1].y

	default
		mov r2.x, r1.y
	break

	case 1
		mov r2.y, r1.y
	break

	case 2
		mov r2.z, r1.y
	break

	case 3
		mov r2.w, r1.y
	break

endswitch

switch cb0[1].z

	default
		mov r2.x, r1.z
	break

	case 1
		mov r2.y, r1.z
	break

	case 2
		mov r2.z, r1.z
	break

	case 3
		mov r2.w, r1.z
	break

endswitch

switch cb0[1].w

	default
		mov r2.x, r1.w
	break

	case 1
		mov r2.y, r1.w
	break

	case 2
		mov r2.z, r1.w
	break

	case 3
		mov r2.w, r1.w
	break

endswitch

; compute linear index in the input
imul r2.xyzw, r2.xyzw, cb0[2].xyzw	; [t*oldNz*oldNy*oldNx, z*oldNy*oldNx, y*oldNx, x*1]

; horizontal add
iadd r2.x, r2.x, r2.y
iadd r2.x, r2.x, r2.z
iadd r2.x, r2.x, r2.w

; compute corresponding 2D index in the input
udiv r1.y, r2.x, cb0[3].z ; ind DIV xSizeSrc -> line number in the input
umod r1.x, r2.x, cb0[3].z ; single element position within the line
umul r1.z, cb0[3].x, l0.x ; xPitchSrc*4
umad r1.x, r1.y, r1.z, r1.x ; single element position with account of input's padding

umod r1.y, r1.x, l0.x ; 4 components misalignment
udiv r1.x, r1.x, l0.x ; linear index in quads

; compute 2D position in quads
udiv r3.y, r1.x, cb0[0].x
umod r3.x, r1.x, cb0[0].x
itof r3.xy, r3.xy

switch r1.y

	case 0
		sample_resource(0)_sampler(0) r1.x___, r3.xy
	break
	
	case 1
		sample_resource(0)_sampler(0) r1._y__, r3.xy
		mov r1.x, r1.y
	break
	
	case 2
		sample_resource(0)_sampler(0) r1.__z_, r3.xy
		mov r1.x, r1.z
	break
	
	case 3
		sample_resource(0)_sampler(0) r1.___w, r3.xy
		mov r1.x, r1.w
	break
	
endswitch
	
ret
endfunc

end
]]>
	</ILKernel>	
	
<ILKernel name = "Matricize3DToSplit8_LI_R">
<![CDATA[
il_ps_2_0
;
;	Matricize a virtualized 3D array
; 
;	inputs: 1
;	outputs: 1
;	data type: LONGINT, REAL
;	nComponents: 4
;	constants: 4x4 (LONGINT) [physWidth, newNy*newNx, newNx, 1], [tZ, tY, tX, 0], [oldNy*oldNx, oldNx, 1, 0],
;										[xPitchSrc,xSizeSrc,xSizeDst,...]
;
dcl_cb cb0[4]
dcl_input_position_interp(linear_noperspective) vWinCoord0.xy__
dcl_output_generic o0
dcl_output_generic o1
dcl_output_generic o2
dcl_output_generic o3
dcl_output_generic o4
dcl_output_generic o5
dcl_output_generic o6
dcl_output_generic o7

dcl_resource_id(0)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)

dcl_literal l0, 4, 1, 0, 8

ftoi r0, vWinCoord0.xy ; 2D output position in quads
umul r0.x, r0.x, l0.x ; x in single elements
umul r0.y, r0.y, l0.w ; y*8
umad r0.x, r0.y, cb0[3].z, r0.x ; y*8*xSizeDst + x -> actual linear index in single elements
mov r0.w, r0.x ; remember initial index value

;*** part 1 ***
call 0
mov r5.x, r1.x
iadd r0.x, r0.x, l0.y
call 0
mov r5.y, r1.x
iadd r0.x, r0.x, l0.y
call 0
mov r5.z, r1.x
iadd r0.x, r0.x, l0.y
call 0
mov r5.w, r1.x

mov o0, r5

;*** part 2 ***
iadd r0.w, r0.w, cb0[3].z ; y*8*xSizeDst + x + i*xSizeDst* -> actual linear index in single elements
mov r0.x, r0.w

call 0
mov r5.x, r1.x
iadd r0.x, r0.x, l0.y
call 0
mov r5.y, r1.x
iadd r0.x, r0.x, l0.y
call 0
mov r5.z, r1.x
iadd r0.x, r0.x, l0.y
call 0
mov r5.w, r1.x

mov o1, r5

;*** part 3 ***
iadd r0.w, r0.w, cb0[3].z ; y*8*xSizeDst + x + i*xSizeDst* -> actual linear index in single elements
mov r0.x, r0.w

call 0
mov r5.x, r1.x
iadd r0.x, r0.x, l0.y
call 0
mov r5.y, r1.x
iadd r0.x, r0.x, l0.y
call 0
mov r5.z, r1.x
iadd r0.x, r0.x, l0.y
call 0
mov r5.w, r1.x

mov o2, r5

;*** part 4 ***
iadd r0.w, r0.w, cb0[3].z ; y*8*xSizeDst + x + i*xSizeDst* -> actual linear index in single elements
mov r0.x, r0.w

call 0
mov r5.x, r1.x
iadd r0.x, r0.x, l0.y
call 0
mov r5.y, r1.x
iadd r0.x, r0.x, l0.y
call 0
mov r5.z, r1.x
iadd r0.x, r0.x, l0.y
call 0
mov r5.w, r1.x

mov o3, r5

;*** part 5 ***
iadd r0.w, r0.w, cb0[3].z ; y*8*xSizeDst + x + i*xSizeDst* -> actual linear index in single elements
mov r0.x, r0.w

call 0
mov r5.x, r1.x
iadd r0.x, r0.x, l0.y
call 0
mov r5.y, r1.x
iadd r0.x, r0.x, l0.y
call 0
mov r5.z, r1.x
iadd r0.x, r0.x, l0.y
call 0
mov r5.w, r1.x

mov o4, r5

;*** part 6 ***
iadd r0.w, r0.w, cb0[3].z ; y*8*xSizeDst + x + i*xSizeDst* -> actual linear index in single elements
mov r0.x, r0.w

call 0
mov r5.x, r1.x
iadd r0.x, r0.x, l0.y
call 0
mov r5.y, r1.x
iadd r0.x, r0.x, l0.y
call 0
mov r5.z, r1.x
iadd r0.x, r0.x, l0.y
call 0
mov r5.w, r1.x

mov o5, r5

;*** part 7 ***
iadd r0.w, r0.w, cb0[3].z ; y*8*xSizeDst + x + i*xSizeDst* -> actual linear index in single elements
mov r0.x, r0.w

call 0
mov r5.x, r1.x
iadd r0.x, r0.x, l0.y
call 0
mov r5.y, r1.x
iadd r0.x, r0.x, l0.y
call 0
mov r5.z, r1.x
iadd r0.x, r0.x, l0.y
call 0
mov r5.w, r1.x

mov o6, r5

;*** part 8 ***
iadd r0.w, r0.w, cb0[3].z ; y*8*xSizeDst + x + i*xSizeDst* -> actual linear index in single elements
mov r0.x, r0.w

call 0
mov r5.x, r1.x
iadd r0.x, r0.x, l0.y
call 0
mov r5.y, r1.x
iadd r0.x, r0.x, l0.y
call 0
mov r5.z, r1.x
iadd r0.x, r0.x, l0.y
call 0
mov r5.w, r1.x

mov o7, r5

endmain

; get input array element in given output index r0.x in single components, returned value is in r1.x
func 0
	
; compute z, y, x coordinates in the output
udiv r1.x, r0.x, cb0[0].y	; z := ind/(newNy*newNx)
umod r1.z, r0.x, cb0[0].y	; r1.z := ind - z*newNy*newNx
udiv r1.y, r1.z, cb0[0].z	; y := (ind - z*newNy*newNx)/newNx
umod r1.z, r1.z, cb0[0].z	; x := ind - z*newNy*newNx - y*newNx

; shuffle the coordinates

switch cb0[1].x

	default
		mov r2.x, r1.x
	break

	case 1
		mov r2.y, r1.x
	break

	case 2
		mov r2.z, r1.x
	break

endswitch

switch cb0[1].y

	default
		mov r2.x, r1.y
	break

	case 1
		mov r2.y, r1.y
	break

	case 2
		mov r2.z, r1.y
	break

endswitch

switch cb0[1].z

	default
		mov r2.x, r1.z
	break

	case 1
		mov r2.y, r1.z
	break

	case 2
		mov r2.z, r1.z
	break

endswitch

; compute linear index in the input
imul r2.xyz, r2.xyz, cb0[2].xyz	; [z*oldNy*oldNx, y*oldNx, x*1]

; horizontal add
iadd r2.x, r2.x, r2.y
iadd r2.x, r2.x, r2.z

; compute corresponding 2D index in the input
udiv r1.y, r2.x, cb0[3].y ; ind DIV xSizeSrc -> line number in the input
umod r1.x, r2.x, cb0[3].y ; single element position within the line
umul r1.z, cb0[3].x, l0.x ; xPitchSrc*4
umad r1.x, r1.y, r1.z, r1.x ; single element position with account of input's padding

umod r1.y, r1.x, l0.x ; 4 components misalignment
udiv r1.x, r1.x, l0.x ; linear index in quads

; compute 2D position in quads
udiv r3.y, r1.x, cb0[0].x
umod r3.x, r1.x, cb0[0].x
itof r3.xy, r3.xy

switch r1.y

	case 0
		sample_resource(0)_sampler(0) r1.x___, r3.xy
	break
	
	case 1
		sample_resource(0)_sampler(0) r1._y__, r3.xy
		mov r1.x, r1.y
	break
	
	case 2
		sample_resource(0)_sampler(0) r1.__z_, r3.xy
		mov r1.x, r1.z
	break
	
	case 3
		sample_resource(0)_sampler(0) r1.___w, r3.xy
		mov r1.x, r1.w
	break
	
endswitch
	
ret
endfunc

end
]]>
	</ILKernel>
	
<ILKernel name = "Matricize4DToSplit8_LI_R">
<![CDATA[
il_ps_2_0
;
;	Matricize a virtualized 4D array
; 
;	inputs: 1
;	outputs: 1
;	data type: LONGINT, REAL
;	nComponents: 4
;	constants: 1, 4x4 (LONGINT) [physWidth, newNz*newNy*newNx, newNy*newNx, newNx], 
;										[tT, tZ, tY, tX], [oldNz*oldNy*oldNx, oldNy*oldNx, oldNx, 1], [xPitchSrc,xSizeSrc,xSizeDst,...]
;
dcl_cb cb0[4]
dcl_input_position_interp(linear_noperspective) vWinCoord0.xy__
dcl_output_generic o0
dcl_output_generic o1
dcl_output_generic o2
dcl_output_generic o3
dcl_output_generic o4
dcl_output_generic o5
dcl_output_generic o6
dcl_output_generic o7

dcl_resource_id(0)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)

dcl_literal l0, 4, 1, 0, 8

ftoi r0, vWinCoord0.xy ; 2D output position in quads
umul r0.x, r0.x, l0.x ; x in single elements
umul r0.y, r0.y, l0.w ; y*8
umad r0.x, r0.y, cb0[3].z, r0.x ; y*8*xSizeDst + x -> actual linear index in single elements
mov r0.w, r0.x ; remember initial index value

;*** part 1 ***
call 0
mov r5.x, r1.x
iadd r0.x, r0.x, l0.y
call 0
mov r5.y, r1.x
iadd r0.x, r0.x, l0.y
call 0
mov r5.z, r1.x
iadd r0.x, r0.x, l0.y
call 0
mov r5.w, r1.x

mov o0, r5

;*** part 2 ***
iadd r0.w, r0.w, cb0[3].z ; y*8*xSizeDst + x + i*xSizeDst* -> actual linear index in single elements
mov r0.x, r0.w

call 0
mov r5.x, r1.x
iadd r0.x, r0.x, l0.y
call 0
mov r5.y, r1.x
iadd r0.x, r0.x, l0.y
call 0
mov r5.z, r1.x
iadd r0.x, r0.x, l0.y
call 0
mov r5.w, r1.x

mov o1, r5

;*** part 3 ***
iadd r0.w, r0.w, cb0[3].z ; y*8*xSizeDst + x + i*xSizeDst* -> actual linear index in single elements
mov r0.x, r0.w

call 0
mov r5.x, r1.x
iadd r0.x, r0.x, l0.y
call 0
mov r5.y, r1.x
iadd r0.x, r0.x, l0.y
call 0
mov r5.z, r1.x
iadd r0.x, r0.x, l0.y
call 0
mov r5.w, r1.x

mov o2, r5

;*** part 4 ***
iadd r0.w, r0.w, cb0[3].z ; y*8*xSizeDst + x + i*xSizeDst* -> actual linear index in single elements
mov r0.x, r0.w

call 0
mov r5.x, r1.x
iadd r0.x, r0.x, l0.y
call 0
mov r5.y, r1.x
iadd r0.x, r0.x, l0.y
call 0
mov r5.z, r1.x
iadd r0.x, r0.x, l0.y
call 0
mov r5.w, r1.x

mov o3, r5

;*** part 5 ***
iadd r0.w, r0.w, cb0[3].z ; y*8*xSizeDst + x + i*xSizeDst* -> actual linear index in single elements
mov r0.x, r0.w

call 0
mov r5.x, r1.x
iadd r0.x, r0.x, l0.y
call 0
mov r5.y, r1.x
iadd r0.x, r0.x, l0.y
call 0
mov r5.z, r1.x
iadd r0.x, r0.x, l0.y
call 0
mov r5.w, r1.x

mov o4, r5

;*** part 6 ***
iadd r0.w, r0.w, cb0[3].z ; y*8*xSizeDst + x + i*xSizeDst* -> actual linear index in single elements
mov r0.x, r0.w

call 0
mov r5.x, r1.x
iadd r0.x, r0.x, l0.y
call 0
mov r5.y, r1.x
iadd r0.x, r0.x, l0.y
call 0
mov r5.z, r1.x
iadd r0.x, r0.x, l0.y
call 0
mov r5.w, r1.x

mov o5, r5

;*** part 7 ***
iadd r0.w, r0.w, cb0[3].z ; y*8*xSizeDst + x + i*xSizeDst* -> actual linear index in single elements
mov r0.x, r0.w

call 0
mov r5.x, r1.x
iadd r0.x, r0.x, l0.y
call 0
mov r5.y, r1.x
iadd r0.x, r0.x, l0.y
call 0
mov r5.z, r1.x
iadd r0.x, r0.x, l0.y
call 0
mov r5.w, r1.x

mov o6, r5

;*** part 8 ***
iadd r0.w, r0.w, cb0[3].z ; y*8*xSizeDst + x + i*xSizeDst* -> actual linear index in single elements
mov r0.x, r0.w

call 0
mov r5.x, r1.x
iadd r0.x, r0.x, l0.y
call 0
mov r5.y, r1.x
iadd r0.x, r0.x, l0.y
call 0
mov r5.z, r1.x
iadd r0.x, r0.x, l0.y
call 0
mov r5.w, r1.x

mov o7, r5

endmain

; get input array element in given output index r0.x in single components, returned value is in r1.x
func 0
	
; compute t, z, y, x coordinates in the output
udiv r1.x, r0.x, cb0[0].y	; t := ind/(newNz*newNy*newNx)
umod r1.w, r0.x, cb0[0].y	; r1.w := ind - t*newNz*newNy*newNx
udiv r1.y, r1.w, cb0[0].z	; z := (ind - t*newNz*newNy*newNx)/(newNy*newNx)
umod r1.w, r1.w, cb0[0].z	; r1.w := ind - t*newNz*newNy*newNx - z*(newNy*newNx)
udiv r1.z, r1.w, cb0[0].w	; y := (ind - t*newNz*newNy*newNx - z*(newNy*newNx))/newNx
umod r1.w, r1.w, cb0[0].w	; x := (ind - t*newNz*newNy*newNx - z*(newNy*newNx)) MOD newNx

; shuffle the coordinates

switch cb0[1].x

	default
		mov r2.x, r1.x
	break

	case 1
		mov r2.y, r1.x
	break

	case 2
		mov r2.z, r1.x
	break
	
	case 3
		mov r2.w, r1.x
	break

endswitch

switch cb0[1].y

	default
		mov r2.x, r1.y
	break

	case 1
		mov r2.y, r1.y
	break

	case 2
		mov r2.z, r1.y
	break

	case 3
		mov r2.w, r1.y
	break

endswitch

switch cb0[1].z

	default
		mov r2.x, r1.z
	break

	case 1
		mov r2.y, r1.z
	break

	case 2
		mov r2.z, r1.z
	break

	case 3
		mov r2.w, r1.z
	break

endswitch

switch cb0[1].w

	default
		mov r2.x, r1.w
	break

	case 1
		mov r2.y, r1.w
	break

	case 2
		mov r2.z, r1.w
	break

	case 3
		mov r2.w, r1.w
	break

endswitch

; compute linear index in the input
imul r2.xyzw, r2.xyzw, cb0[2].xyzw	; [t*oldNz*oldNy*oldNx, z*oldNy*oldNx, y*oldNx, x*1]

; horizontal add
iadd r2.x, r2.x, r2.y
iadd r2.x, r2.x, r2.z
iadd r2.x, r2.x, r2.w

; compute corresponding 2D index in the input
udiv r1.y, r2.x, cb0[3].y ; ind DIV xSizeSrc -> line number in the input
umod r1.x, r2.x, cb0[3].y ; single element position within the line
umul r1.z, cb0[3].x, l0.x ; xPitchSrc*4
umad r1.x, r1.y, r1.z, r1.x ; single element position with account of input's padding

umod r1.y, r1.x, l0.x ; 4 components misalignment
udiv r1.x, r1.x, l0.x ; linear index in quads

; compute 2D position in quads
udiv r3.y, r1.x, cb0[0].x
umod r3.x, r1.x, cb0[0].x
itof r3.xy, r3.xy

switch r1.y

	case 0
		sample_resource(0)_sampler(0) r1.x___, r3.xy
	break
	
	case 1
		sample_resource(0)_sampler(0) r1._y__, r3.xy
		mov r1.x, r1.y
	break
	
	case 2
		sample_resource(0)_sampler(0) r1.__z_, r3.xy
		mov r1.x, r1.z
	break
	
	case 3
		sample_resource(0)_sampler(0) r1.___w, r3.xy
		mov r1.x, r1.w
	break
	
endswitch
	
ret
endfunc

end
]]>
	</ILKernel>
	
<ILKernel name = "ConvolveNDX5_R">
<![CDATA[
il_cs_2_0
dcl_num_thread_per_group 64
;
;	Convolve ND virtualized array along X (last) direction with up to 5 taps FIR filter
; 
;	inputs: 1
;	outputs: 0
;	global buffer: Yes
;	data type: REAL
;	nComponents: 4
;	constants: 2, 8x4 (REAL) and 2x4 (LONGINT)
;

dcl_cb cb0[8]	; [h0,h1,h2,h3],[h4,0,0,0]
					; [0,h0,h1,h2],[h3,h4,0,0]
					; [0,0,h0,h1],[h2,h3,h4,0]
					; [0,0,0,h0],[h1,h2,h3,h4]
					
dcl_cb cb1[3]	; [hotSpot,width,physWidth,xPitch], [boundary,(width DIV 4)*4,nTotalLines,...]
					; [inpOffset,outOffset,...] input and output offsets in quads

; hotSpot - has to be aligned to be multiple of 4

dcl_resource_id(0)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)

dcl_literal l0, 4, 0xFFFFFFFF, 1, 0

ilt r0.z, vaTid.x, cb1[1].z ; check thread index!
if_logicalnz r0.z

	umul r0.x, vaTid.x, cb1[0].w ; iLine*xPitch -> index of the first line quad		
	
	imul r0.y, cb1[0].x, l0.y ; -hotSpot ; first input index
	mov r0.z, r0.x ; position of curent output quad
	
	iadd r0.x, r0.x, cb1[2].x ; account input offset
	iadd r0.z, r0.z, cb1[2].y ; account output offset
	
	udiv r0.w, cb1[0].y, l0.x
	iadd r0.w, r0.z, r0.w ; ind0+(width DIV 4) -> position of last output quad
	
	; load first input quad
	call 0
	iadd r0.y, r0.y, l0.x ; increment input index
	
	whileloop
		
		ige r1.z, r0.z, r0.w ; ind >= ind0+(width DIV 4)
		break_logicalnz r1.z
		
		mov r3, r2	
		
		call 0 ; load next input quad
		iadd r0.y, r0.y, l0.x ; increment input index	
			
		call 1 ; compute output quad
		mov g[r0.z], r30 ; store output quad
		
		iadd r0.z, r0.z, l0.z ; increment output index
	endloop
	
	umod r0.w, cb1[0].y, l0.x ; account padding -> width MOD 4
	if_logicalnz r0.w
		
		; last line quad
		mov r3, r2
		call 0 ; load next input quad
		call 1 ; compute output quad	
	
		switch r0.w
			case 1
				mov r30, r30.x000
				break
			case 2
				mov r30, r30.xy00
				break
			case 3
				mov r30, r30.xyz0
				break
		endswitch
		
		mov g[r0.z], r30 ; store output quad
	endif;
endif

endmain

; get input quad with account of boundaries
; r0.x - linear position of the first line element with account of padding, in quads
; r0.y - index of input quad within the line, in single elements
; output is returned in r2
; r1 is used for intermediate results
func 0

ige r1.z, r0.y, r0.0 ; ind >= 0
ilt r1.w, r0.y, cb1[1].y ; ind < (width DIV 4)*4
iand r1.w, r1.z, r1.w

if_logicalnz r1.w ; (ind >= 0) & (ind < (width DIV 4)*4) -> not on boundaries
	udiv r1.x, r0.y, l0.x ; index in quads
	iadd r1.x, r0.x, r1.x ; linear position of quad to load
	; 2D position of the quad
	udiv r2.y, r1.x, cb1[0].z
	umod r2.x, r1.x, cb1[0].z
	itof r2, r2
	sample_resource(0)_sampler(0) r2, r2.xy
else
	
	mov r2, r2.0000
	
	if_logicalz r1.z ; left boundary
		; currently only FiniteData boundary
	else ; right boundary		
		ige r1.z, r0.y, cb1[0].y
		if_logicalnz r1.z
			; currently only FiniteData boundary
		else
			
			; case when width is not multiple of 4 and there are still some data in the line
			
			udiv r1.x, r0.y, l0.x ; index in quads
			iadd r1.x, r0.x, r1.x ; linear position of quad to load
			; 2D position of the quad
			udiv r2.y, r1.x, cb1[0].z
			umod r2.x, r1.x, cb1[0].z
			itof r2, r2			
			
			umod r1.z, cb1[0].y, l0.x ; width MOD 4
			switch r1.z
				case 1
					sample_resource(0)_sampler(0) r2.x000, r2.xy
				break
				
				case 2
					sample_resource(0)_sampler(0) r2.xy00, r2.xy
				break
				
				case 3
					sample_resource(0)_sampler(0) r2.xyz0, r2.xy
				break
			endswitch						
		endif
	endif
	
endif

ret
endfunc

; compute output quad
; r3, r2 - input quads
; output is stored in r30
; uses r31, r32, r33 for intermediate results
func 1

mul r30, r3, cb0[0]
mad r30, r2, cb0[1], r30

mul r31, r3, cb0[2]
mad r31, r2, cb0[3], r31

mul r32, r3, cb0[4]
mad r32, r2, cb0[5], r32

mul r33, r3, cb0[6]
mad r33, r2, cb0[7], r33
	
dp4 r30.x, r30, r30.1111
dp4 r30.y, r31, r31.1111
dp4 r30.z, r32, r32.1111
dp4 r30.w, r33, r33.1111

ret
endfunc

end
]]>
	</ILKernel>	
		
<ILKernel name = "Convolve3DY5_R">
<![CDATA[
il_cs_2_0
dcl_num_thread_per_group 64
;
;	Convolve 3D virtualized array along Y direction with up to 5 taps FIR filter
; 
;	inputs: 1
;	outputs: 0
;	global buffer: Yes
;	data type: REAL
;	nComponents: 4
;	constants: 2, 8x4 (REAL) and 2x4 (LONGINT)
;

dcl_cb cb0[8]	; [h0,h1,h2,h3],[h4,0,0,0]
					; [0,h0,h1,h2],[h3,h4,0,0]
					; [0,0,h0,h1],[h2,h3,h4,0]
					; [0,0,0,h0],[h1,h2,h3,h4]
					
dcl_cb cb1[3]	; [hotSpot,width,physWidth,xPitch], [boundary,(width DIV 4)*4,Ny*xPitch,Nz]
					; [inpOffset,outOffset,...] input and output offsets in quads	

; hotSpot - has to be aligned to be multiple of 4
; width - is the line width

dcl_resource_id(0)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)

dcl_literal l0, 4, 0xFFFFFFFF, 1, 0

imul r0.x, cb1[1].w, cb1[0].w ; Nz*xpitch
ilt r0.z, vaTid.x, r0.x ; check thread index!
if_logicalnz r0.z

	; in this case we have Nz*xPitch threads, thus the thread index is represented by i*xPitch + j
	udiv r0.y, vaTid.x, cb1[0].w ; i
	umod r0.x, vaTid.x, cb1[0].w ; j
	
	; compute first quad position
	imad r0.x, r0.y, cb1[1].z, r0.x ; i*Ny*xPitch + j (in quads)		
	
	imul r0.y, cb1[0].x, l0.y ; -hotSpot ; first input index
	mov r0.z, r0.x ; position of curent output quad
	iadd r0.z, r0.z, cb1[2].y ; account output offset
	imad r0.w, cb1[1].y, cb1[0].w, r0.z ; ind0 + (width DIV 4)*4*xPitch	
	
	iadd r0.x, r0.x, cb1[2].x ; account input offset
			
	; load first 4 input quads
	call 0
	iadd r0.y, r0.y, l0.x ; increment input index
	
	whileloop
		
		ige r1.z, r0.z, r0.w ; ind >= ind0 + (width DIV 4)*4*xPitch
		break_logicalnz r1.z
		
		mov r6, r2
		mov r7, r3
		mov r8, r4
		mov r9, r5
		
		call 0 ; load next input quads
		iadd r0.y, r0.y, l0.x ; increment input index	
				
		call 1 ; compute output quads		
	
		; transpose quads
		transpose r30, r30
		
		iadd r1.x, r0.z, cb1[0].w
		iadd r1.y, r1.x, cb1[0].w
		iadd r1.z, r1.y, cb1[0].w				
		
		; write to the output		
		mov g[r0.z], r30
		mov g[r1.x], r31
		mov g[r1.y], r32
		mov g[r1.z], r33
	
		iadd r0.z, r1.z, cb1[0].w ; increment output index
	endloop
	
	umod r0.w, cb1[0].y, l0.x ; account width MOD 4 # 0
	if_logicalnz r0.w
		
		; process last quads
		
		mov r6, r2
		mov r7, r3
		mov r8, r4
		mov r9, r5
		
		call 0 ; load next input quads
		call 1 ; compute output quads				
		
		; transpose quads
		transpose r30, r30
		
		iadd r1.x, r0.z, cb1[0].w
		iadd r1.y, r1.x, cb1[0].w
	
		switch r0.w		
			case 1
				mov g[r0.z], r30
				break
			case 2
				mov g[r0.z], r30
				mov g[r1.x], r31
				break
			case 3
				mov g[r0.z], r30
				mov g[r1.x], r31
				mov g[r1.y], r32
				break
		endswitch
				
	endif
	
endif

endmain

; get input quad with account of boundaries for 4 lines at once
; r0.x - linear position of the first line element with account of padding, in quads
; r0.y - index of input quad within the line, in single elements
; output is returned in r2, r3, r4, r5
; r1 is used for intermediate results
func 0

ige r1.z, r0.y, r0.0 ; ind >= 0
ilt r1.w, r0.y, cb1[1].y ; ind < (width DIV 4)*4
iand r1.w, r1.z, r1.w

if_logicalnz r1.w ; (ind >= 0) & (ind < (width DIV 4)*4) -> not on boundaries
	
	; 2D position of quads
	imad r1.x, r0.y, cb1[0].w, r0.x ; linear position of quad to load
	udiv r2.y, r1.x, cb1[0].z
	umod r2.x, r1.x, cb1[0].z
	
	iadd r1.x, r1.x, cb1[0].w ; ind + xPitch
	udiv r3.y, r1.x, cb1[0].z
	umod r3.x, r1.x, cb1[0].z
	
	iadd r1.x, r1.x, cb1[0].w
	udiv r4.y, r1.x, cb1[0].z
	umod r4.x, r1.x, cb1[0].z
	
	iadd r1.x, r1.x, cb1[0].w
	udiv r5.y, r1.x, cb1[0].z
	umod r5.x, r1.x, cb1[0].z
	
	itof r2, r2
	itof r3, r3
	itof r4, r4
	itof r5, r5
	
	sample_resource(0)_sampler(0) r2, r2.xy
	sample_resource(0)_sampler(0) r3, r3.xy
	sample_resource(0)_sampler(0) r4, r4.xy
	sample_resource(0)_sampler(0) r5, r5.xy
else
	
	mov r2, r2.0000
	mov r3, r3.0000
	mov r4, r4.0000
	mov r5, r5.0000
	
	if_logicalz r1.z ; left boundary
		 ; currently only FiniteData boundary		
	else ; right boundary		
		ige r1.z, r0.y, cb1[0].y
		if_logicalnz r1.z
			 ; currently only FiniteData boundary
		else
			
			; case when width is not multiple of 4 and there are still some data in the line
			
			; 2D position of quads
			imad r1.x, r0.y, cb1[0].w, r0.x ; linear position of quad to load
			udiv r2.y, r1.x, cb1[0].z
			umod r2.x, r1.x, cb1[0].z
			itof r2, r2
			
			umod r1.z, cb1[0].y, l0.x ; width MOD 4
			switch r1.z
				case 1
					sample_resource(0)_sampler(0) r2, r2.xy					
				break
				
				case 2
					iadd r1.x, r1.x, cb1[0].w ; ind + xPitch
					udiv r3.y, r1.x, cb1[0].z
					umod r3.x, r1.x, cb1[0].z
					itof r3, r3
					sample_resource(0)_sampler(0) r2, r2.xy
					sample_resource(0)_sampler(0) r3, r3.xy
				break
				
				case 3
					iadd r1.x, r1.x, cb1[0].w ; ind + xPitch
					udiv r3.y, r1.x, cb1[0].z
					umod r3.x, r1.x, cb1[0].z
		
					iadd r1.x, r1.x, cb1[0].w
					udiv r4.y, r1.x, cb1[0].z
					umod r4.x, r1.x, cb1[0].z
					itof r3, r3
					itof r4, r4
					sample_resource(0)_sampler(0) r2, r2.xy
					sample_resource(0)_sampler(0) r3, r3.xy
					sample_resource(0)_sampler(0) r4, r4.xy
				break
			endswitch						
		endif
	endif
	
endif

; transpose quads
transpose r2, r2

ret
endfunc

; compute 4 output quads
; {r6,r7,r8,r9}, {r2,r3,r4,r5} - input quads
; output is stored in {r30,r31,r32,r33}
; uses r34,r35,r36 for intermediate results
func 1

mul r30, r6, cb0[0]
mad r30, r2, cb0[1], r30

mul r31, r6, cb0[2]
mad r31, r2, cb0[3], r31

mul r32, r6, cb0[4]
mad r32, r2, cb0[5], r32

mul r33, r6, cb0[6]
mad r33, r2, cb0[7], r33
	
dp4 r30.x, r30, r30.1111
dp4 r30.y, r31, r31.1111
dp4 r30.z, r32, r32.1111
dp4 r30.w, r33, r33.1111

; ****

mul r31, r7, cb0[0]
mad r31, r3, cb0[1], r31

mul r32, r7, cb0[2]
mad r32, r3, cb0[3], r32

mul r33, r7, cb0[4]
mad r33, r3, cb0[5], r33

mul r34, r7, cb0[6]
mad r34, r3, cb0[7], r34
	
dp4 r31.x, r31, r31.1111
dp4 r31.y, r32, r32.1111
dp4 r31.z, r33, r33.1111
dp4 r31.w, r34, r34.1111

; ****

mul r32, r8, cb0[0]
mad r32, r4, cb0[1], r32

mul r33, r8, cb0[2]
mad r33, r4, cb0[3], r33

mul r34, r8, cb0[4]
mad r34, r4, cb0[5], r34

mul r35, r8, cb0[6]
mad r35, r4, cb0[7], r35
	
dp4 r32.x, r32, r32.1111
dp4 r32.y, r33, r33.1111
dp4 r32.z, r34, r34.1111
dp4 r32.w, r35, r35.1111

; ****

mul r33, r9, cb0[0]
mad r33, r5, cb0[1], r33

mul r34, r9, cb0[2]
mad r34, r5, cb0[3], r34

mul r35, r9, cb0[4]
mad r35, r5, cb0[5], r35

mul r36, r9, cb0[6]
mad r36, r5, cb0[7], r36
	
dp4 r33.x, r33, r33.1111
dp4 r33.y, r34, r34.1111
dp4 r33.z, r35, r35.1111
dp4 r33.w, r36, r36.1111

ret
endfunc

end
]]>
	</ILKernel>
	
<ILKernel name = "ConvolveNDZ5_R">
<![CDATA[
il_cs_2_0
dcl_num_thread_per_group 64
;
;	Convolve ND virtualized array along Z (first) direction with up to 5 taps FIR filter
; 
;	inputs: 1
;	outputs: 0
;	global buffer: Yes
;	data type: REAL
;	nComponents: 4
;	constants: 2, 8x4 (REAL) and 2x4 (LONGINT)
;

dcl_cb cb0[8]	; [h0,h1,h2,h3],[h4,0,0,0]
					; [0,h0,h1,h2],[h3,h4,0,0]
					; [0,0,h0,h1],[h2,h3,h4,0]
					; [0,0,0,h0],[h1,h2,h3,h4]
					
dcl_cb cb1[3]	; [hotSpot,width,physWidth,xPitch], [boundary,(width DIV 4)*4,Ny*xPitch,...]
					; [inpOffset,outOffset,...] input and output offsets in quads
					
; hotSpot - has to be aligned to be multiple of 4
; width - is the line width

dcl_resource_id(0)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)

dcl_literal l0, 4, 0xFFFFFFFF, 1, 0

ilt r0.z, vaTid.x, cb1[1].z ; check thread index!
if_logicalnz r0.z

	; in this case we have Ny*xPitch threads
	mov r0.x, vaTid.x ; position of first input quad (in quads)
	imul r0.y, cb1[0].x, l0.y ; -hotSpot ; first input index
	mov r0.z, r0.x ; position of curent output quad
	iadd r0.z, r0.z, cb1[2].y ; account output offset
	imad r0.w, cb1[1].y, cb1[1].z, r0.z ; ind0 + (width DIV 4)*4*Ny*xPitch
	
	iadd r0.x, r0.x, cb1[2].x ; account input offset	
	
	; load first 4 input quads
	call 0
	iadd r0.y, r0.y, l0.x ; increment input index
	
	whileloop
				
		ige r1.z, r0.z, r0.w ; ind >= ind0 + (width DIV 4)*4*Ny*xPitch
		break_logicalnz r1.z
		
		mov r6, r2
		mov r7, r3
		mov r8, r4
		mov r9, r5
	
		call 0 ; load next input quads
		iadd r0.y, r0.y, l0.x ; increment input index
				
		call 1 ; compute output quads
		
		; transpose quads
		transpose r30, r30
		
		iadd r1.x, r0.z, cb1[1].z
		iadd r1.y, r1.x, cb1[1].z
		iadd r1.z, r1.y, cb1[1].z
		
		; write to the output
		mov g[r0.z], r30
		mov g[r1.x], r31
		mov g[r1.y], r32
		mov g[r1.z], r33
	
		iadd r0.z, r1.z, cb1[1].z ; increment output index
	endloop

	umod r0.w, cb1[0].y, l0.x ; account width MOD 4 # 0
	if_logicalnz r0.w
		
		; process last quads
		
		mov r6, r2
		mov r7, r3
		mov r8, r4
		mov r9, r5
	
		call 0 ; load next input quads
		call 1 ; compute output quads
		
		; transpose quads
		transpose r30, r30
		
		iadd r1.x, r0.z, cb1[1].z
		iadd r1.y, r1.x, cb1[1].z
	
		switch r0.w		
			case 1
				mov g[r0.z], r30
				break
			case 2
				mov g[r0.z], r30
				mov g[r1.x], r31
				break
			case 3
				mov g[r0.z], r30
				mov g[r1.x], r31
				mov g[r1.y], r32
				break
		endswitch
				
	endif;

endif; 

endmain

; get input quad with account of boundaries for 4 lines at once
; r0.x - linear position of the first line element with account of padding, in quads
; r0.y - index of input quad within the line, in single elements
; output is returned in r2, r3, r4, r5
; r1 is used for intermediate results
func 0

ige r1.z, r0.y, r0.0 ; ind >= 0
ilt r1.w, r0.y, cb1[1].y ; ind < (width DIV 4)*4
iand r1.w, r1.z, r1.w

if_logicalnz r1.w ; (ind >= 0) & (ind < (width DIV 4)*4) -> not on boundaries
	
	; 2D position of quads
	imad r1.x, r0.y, cb1[1].z, r0.x ; linear position of quad to load
	udiv r3.y, r1.x, cb1[0].z
	umod r3.x, r1.x, cb1[0].z
	
	iadd r1.x, r1.x, cb1[1].z ; ind + Ny*xPitch
	udiv r4.y, r1.x, cb1[0].z
	umod r4.x, r1.x, cb1[0].z
	
	iadd r1.x, r1.x, cb1[1].z
	udiv r5.y, r1.x, cb1[0].z
	umod r5.x, r1.x, cb1[0].z
	
	iadd r1.x, r1.x, cb1[1].z
	udiv r1.y, r1.x, cb1[0].z
	umod r1.x, r1.x, cb1[0].z
	
	itof r3, r3
	itof r4, r4
	itof r5, r5
	itof r1, r1
	
	sample_resource(0)_sampler(0) r2, r3.xy
	sample_resource(0)_sampler(0) r3, r4.xy
	sample_resource(0)_sampler(0) r4, r5.xy
	sample_resource(0)_sampler(0) r5, r1.xy
else
	
	mov r2, r2.0000
	mov r3, r3.0000
	mov r4, r4.0000
	mov r5, r5.0000
	
	if_logicalz r1.z ; left boundary
		 ; currently only FiniteData boundary		
	else ; right boundary		
		ige r1.z, r0.y, cb1[0].y
		if_logicalnz r1.z
			 ; currently only FiniteData boundary
		else
			
			; case when width is not multiple of 4 and there are still some data in the line
			
			; 2D position of quads
			imad r1.x, r0.y, cb1[1].z, r0.x ; linear position of quad to load
			udiv r2.y, r1.x, cb1[0].z
			umod r2.x, r1.x, cb1[0].z			
			itof r2, r2		
			
			umod r1.z, cb1[0].y, l0.x ; width MOD 4
			switch r1.z
				case 1					
					sample_resource(0)_sampler(0) r2, r2.xy					
				break
				
				case 2
					iadd r1.x, r1.x, cb1[1].z ; ind + Ny*xPitch			
					udiv r3.y, r1.x, cb1[0].z
					umod r3.x, r1.x, cb1[0].z
					
					itof r3, r3
					sample_resource(0)_sampler(0) r2, r2.xy
					sample_resource(0)_sampler(0) r3, r3.xy
				break
				
				case 3
					iadd r1.x, r1.x, cb1[1].z ; ind + Ny*xPitch			
					udiv r3.y, r1.x, cb1[0].z
					umod r3.x, r1.x, cb1[0].z
		
					iadd r1.x, r1.x, cb1[1].z
					udiv r4.y, r1.x, cb1[0].z
					umod r4.x, r1.x, cb1[0].z
					
					itof r3, r3
					itof r4, r4					
					sample_resource(0)_sampler(0) r2, r2.xy
					sample_resource(0)_sampler(0) r3, r3.xy
					sample_resource(0)_sampler(0) r4, r4.xy
				break
			endswitch						
		endif
	endif
	
endif

; transpose quads
transpose r2, r2

ret
endfunc

; compute 4 output quads
; {r6,r7,r8,r9}, {r2,r3,r4,r5} - input quads
; output is stored in {r30,r31,r32,r33}
; uses r34,r35,r36 for intermediate results
func 1

mul r30, r6, cb0[0]
mad r30, r2, cb0[1], r30

mul r31, r6, cb0[2]
mad r31, r2, cb0[3], r31

mul r32, r6, cb0[4]
mad r32, r2, cb0[5], r32

mul r33, r6, cb0[6]
mad r33, r2, cb0[7], r33
	
dp4 r30.x, r30, r30.1111
dp4 r30.y, r31, r31.1111
dp4 r30.z, r32, r32.1111
dp4 r30.w, r33, r33.1111

; ****

mul r31, r7, cb0[0]
mad r31, r3, cb0[1], r31

mul r32, r7, cb0[2]
mad r32, r3, cb0[3], r32

mul r33, r7, cb0[4]
mad r33, r3, cb0[5], r33

mul r34, r7, cb0[6]
mad r34, r3, cb0[7], r34
	
dp4 r31.x, r31, r31.1111
dp4 r31.y, r32, r32.1111
dp4 r31.z, r33, r33.1111
dp4 r31.w, r34, r34.1111

; ****

mul r32, r8, cb0[0]
mad r32, r4, cb0[1], r32

mul r33, r8, cb0[2]
mad r33, r4, cb0[3], r33

mul r34, r8, cb0[4]
mad r34, r4, cb0[5], r34

mul r35, r8, cb0[6]
mad r35, r4, cb0[7], r35
	
dp4 r32.x, r32, r32.1111
dp4 r32.y, r33, r33.1111
dp4 r32.z, r34, r34.1111
dp4 r32.w, r35, r35.1111

; ****

mul r33, r9, cb0[0]
mad r33, r5, cb0[1], r33

mul r34, r9, cb0[2]
mad r34, r5, cb0[3], r34

mul r35, r9, cb0[4]
mad r35, r5, cb0[5], r35

mul r36, r9, cb0[6]
mad r36, r5, cb0[7], r36
	
dp4 r33.x, r33, r33.1111
dp4 r33.y, r34, r34.1111
dp4 r33.z, r35, r35.1111
dp4 r33.w, r36, r36.1111

ret
endfunc

end
]]>
	</ILKernel>
	
<ILKernel name = "ConvolveNDX9_R">
<![CDATA[
il_cs_2_0
dcl_num_thread_per_group 64
;
;	Convolve ND virtualized array along X (last) direction with up to 9 taps FIR filter
; 
;	inputs: 1
;	outputs: 0
;	global buffer: Yes
;	data type: REAL
;	nComponents: 4
;	constants: 2, 12x4 (REAL) and 2x4 (LONGINT)
;

dcl_cb cb0[12]	; [h0,h1,h2,h3],[h4,h5,h6,h7],[h8,0,0,0]
					; [0,h0,h1,h2],[h3,h4,h5,h6],[h7,h8,0,0]
					; [0,0,h0,h1],[h2,h3,h4,h5],[h6,h7,h8,0]
					; [0,0,0,h0],[h1,h2,h3,h4],[h5,h6,h7,h8]
					
dcl_cb cb1[3]	; [hotSpot,width,physWidth,xPitch], [boundary,(width DIV 4)*4,nTotalLines,...]
					; [inpOffset,outOffset,...] input and output offsets in quads

; hotSpot - has to be aligned to be multiple of 4

dcl_resource_id(0)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)

dcl_literal l0, 4, 0xFFFFFFFF, 1, 0

ilt r0.z, vaTid.x, cb1[1].z ; check thread index!
if_logicalnz r0.z

	umul r0.x, vaTid.x, cb1[0].w ; iLine*xPitch -> index of the first line quad
	imul r0.y, cb1[0].x, l0.y ; -hotSpot ; first input index
	mov r0.z, r0.x ; position of curent output quad
	
	iadd r0.x, r0.x, cb1[2].x ; account input offset
	iadd r0.z, r0.z, cb1[2].y ; account output offset
	
	udiv r0.w, cb1[0].y, l0.x
	iadd r0.w, r0.z, r0.w ; ind0+(width DIV 4) -> position of last output quad
	
	; load first input quads
	call 0
	iadd r0.y, r0.y, l0.x ; increment input index
	mov r3, r2
	call 0
	iadd r0.y, r0.y, l0.x ; increment input index
	
	whileloop
		
		ige r1.z, r0.z, r0.w ; ind >= ind0+(width DIV 4)
		break_logicalnz r1.z
		
		mov r4, r3
		mov r3, r2
		
		call 0 ; load next input quad
		iadd r0.y, r0.y, l0.x ; increment input index	
			
		call 1 ; compute output quad
		mov g[r0.z], r30 ; store output quad
		
		iadd r0.z, r0.z, l0.z ; increment output index
	endloop
	
	umod r0.w, cb1[0].y, l0.x ; account padding -> width MOD 4
	if_logicalnz r0.w
		
		; last line quad
		mov r4, r3
		mov r3, r2
		call 0 ; load next input quad
		call 1 ; compute output quad	
	
		switch r0.w
			case 1
				mov r30, r30.x000
				break
			case 2
				mov r30, r30.xy00
				break
			case 3
				mov r30, r30.xyz0
				break
		endswitch
		
		mov g[r0.z], r30 ; store output quad
	endif;
endif

endmain

; get input quad with account of boundaries
; r0.x - linear position of the first line element with account of padding, in quads
; r0.y - index of input quad within the line, in single elements
; output is returned in r2
; r1 is used for intermediate results
func 0

ige r1.z, r0.y, r0.0 ; ind >= 0
ilt r1.w, r0.y, cb1[1].y ; ind < (width DIV 4)*4
iand r1.w, r1.z, r1.w

if_logicalnz r1.w ; (ind >= 0) & (ind < (width DIV 4)*4) -> not on boundaries
	udiv r1.x, r0.y, l0.x ; index in quads
	iadd r1.x, r0.x, r1.x ; linear position of quad to load
	; 2D position of the quad
	udiv r2.y, r1.x, cb1[0].z
	umod r2.x, r1.x, cb1[0].z
	itof r2, r2
	sample_resource(0)_sampler(0) r2, r2.xy
else
	
	mov r2, r2.0000
	
	if_logicalz r1.z ; left boundary
		; currently only FiniteData boundary
	else ; right boundary		
		ige r1.z, r0.y, cb1[0].y
		if_logicalnz r1.z
			; currently only FiniteData boundary
		else
			
			; case when width is not multiple of 4 and there are still some data in the line
			
			udiv r1.x, r0.y, l0.x ; index in quads
			iadd r1.x, r0.x, r1.x ; linear position of quad to load
			; 2D position of the quad
			udiv r2.y, r1.x, cb1[0].z
			umod r2.x, r1.x, cb1[0].z
			itof r2, r2			
			
			umod r1.z, cb1[0].y, l0.x ; width MOD 4
			switch r1.z
				case 1
					sample_resource(0)_sampler(0) r2.x000, r2.xy
				break
				
				case 2
					sample_resource(0)_sampler(0) r2.xy00, r2.xy
				break
				
				case 3
					sample_resource(0)_sampler(0) r2.xyz0, r2.xy
				break
			endswitch						
		endif
	endif
	
endif

ret
endfunc

; compute output quad
; r4, r3, r2 - input quads
; output is stored in r30
; uses r31, r32, r33 for intermediate results
func 1

mul r30, r4, cb0[0]
mad r30, r3, cb0[1], r30
mad r30, r2, cb0[2], r30

mul r31, r4, cb0[3]
mad r31, r3, cb0[4], r31
mad r31, r2, cb0[5], r31

mul r32, r4, cb0[6]
mad r32, r3, cb0[7], r32
mad r32, r2, cb0[8], r32

mul r33, r4, cb0[9]
mad r33, r3, cb0[10], r33
mad r33, r2, cb0[11], r33
	
dp4 r30.x, r30, r30.1111
dp4 r30.y, r31, r31.1111
dp4 r30.z, r32, r32.1111
dp4 r30.w, r33, r33.1111

ret
endfunc

end
]]>
	</ILKernel>
	
<ILKernel name = "Convolve3DY9_R">
<![CDATA[
il_cs_2_0
dcl_num_thread_per_group 64
;
;	Convolve 3D virtualized array along Y direction with up to 9 taps FIR filter
; 
;	inputs: 1
;	outputs: 0
;	global buffer: Yes
;	data type: REAL
;	nComponents: 4
;	constants: 2, 12x4 (REAL) and 2x4 (LONGINT)
;

dcl_cb cb0[12]	; [h0,h1,h2,h3],[h4,h5,h6,h7],[h8,0,0,0]
					; [0,h0,h1,h2],[h3,h4,h5,h6],[h7,h8,0,0]
					; [0,0,h0,h1],[h2,h3,h4,h5],[h6,h7,h8,0]
					; [0,0,0,h0],[h1,h2,h3,h4],[h5,h6,h7,h8]
					
dcl_cb cb1[3]	; [hotSpot,width,physWidth,xPitch], [boundary,(width DIV 4)*4,Ny*xPitch,Nz]
					; [inpOffset,outOffset,...] input and output offsets in quads

; hotSpot - has to be aligned to be multiple of 4
; width - is the line width

dcl_resource_id(0)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)

dcl_literal l0, 4, 0xFFFFFFFF, 1, 0

imul r0.x, cb1[1].w, cb1[0].w ; Nz*xpitch
ilt r0.z, vaTid.x, r0.x ; check thread index!
if_logicalnz r0.z

	; in this case we have Nz*xPitch threads, thus the thread index is represented by i*xPitch + j
	udiv r0.y, vaTid.x, cb1[0].w ; i
	umod r0.x, vaTid.x, cb1[0].w ; j
	
	; compute first quad position
	imad r0.x, r0.y, cb1[1].z, r0.x ; i*Ny*xPitch + j (in quads)		
	
	imul r0.y, cb1[0].x, l0.y ; -hotSpot ; first input index
	mov r0.z, r0.x ; position of curent output quad	
	iadd r0.z, r0.z, cb1[2].y ; account output offset
	imad r0.w, cb1[1].y, cb1[0].w, r0.z ; ind0 + (width DIV 4)*4*xPitch
	
	iadd r0.x, r0.x, cb1[2].x ; account input offset
			
	; load first 2x4 input quads
	call 0
	iadd r0.y, r0.y, l0.x ; increment input index
	mov r6, r2
	mov r7, r3
	mov r8, r4
	mov r9, r5
	call 0
	iadd r0.y, r0.y, l0.x ; increment input index
	
	whileloop
		
		ige r1.z, r0.z, r0.w ; ind >= ind0 + (width DIV 4)*4*xPitch
		break_logicalnz r1.z
		
		mov r10, r6
		mov r11, r7
		mov r12, r8
		mov r13, r9
		
		mov r6, r2
		mov r7, r3
		mov r8, r4
		mov r9, r5
		
		call 0 ; load next input quads
		iadd r0.y, r0.y, l0.x ; increment input index	
				
		call 1 ; compute output quads		
	
		; transpose quads
		transpose r30, r30
		
		iadd r1.x, r0.z, cb1[0].w
		iadd r1.y, r1.x, cb1[0].w
		iadd r1.z, r1.y, cb1[0].w				
		
		; write to the output		
		mov g[r0.z], r30
		mov g[r1.x], r31
		mov g[r1.y], r32
		mov g[r1.z], r33
	
	iadd r0.z, r1.z, cb1[0].w ; increment output index
	endloop
	
	umod r0.w, cb1[0].y, l0.x ; account width MOD 4 # 0
	if_logicalnz r0.w
		
		; process last quads
		
		mov r10, r6
		mov r11, r7
		mov r12, r8
		mov r13, r9
		
		mov r6, r2
		mov r7, r3
		mov r8, r4
		mov r9, r5
		
		call 0 ; load next input quads
		call 1 ; compute output quads				
		
		; transpose quads
		transpose r30, r30
		
		iadd r1.x, r0.z, cb1[0].w
		iadd r1.y, r1.x, cb1[0].w
	
		switch r0.w		
			case 1
				mov g[r0.z], r30
				break
			case 2
				mov g[r0.z], r30
				mov g[r1.x], r31
				break
			case 3
				mov g[r0.z], r30
				mov g[r1.x], r31
				mov g[r1.y], r32
				break
		endswitch
				
	endif
	
endif

endmain

; get input quad with account of boundaries for 4 lines at once
; r0.x - linear position of the first line element with account of padding, in quads
; r0.y - index of input quad within the line, in single elements
; output is returned in r2, r3, r4, r5
; r1 is used for intermediate results
func 0

ige r1.z, r0.y, r0.0 ; ind >= 0
ilt r1.w, r0.y, cb1[1].y ; ind < (width DIV 4)*4
iand r1.w, r1.z, r1.w

if_logicalnz r1.w ; (ind >= 0) & (ind < (width DIV 4)*4) -> not on boundaries
	
	; 2D position of quads
	imad r1.x, r0.y, cb1[0].w, r0.x ; linear position of quad to load
	udiv r2.y, r1.x, cb1[0].z
	umod r2.x, r1.x, cb1[0].z
	
	iadd r1.x, r1.x, cb1[0].w ; ind + xPitch
	udiv r3.y, r1.x, cb1[0].z
	umod r3.x, r1.x, cb1[0].z
	
	iadd r1.x, r1.x, cb1[0].w
	udiv r4.y, r1.x, cb1[0].z
	umod r4.x, r1.x, cb1[0].z
	
	iadd r1.x, r1.x, cb1[0].w
	udiv r5.y, r1.x, cb1[0].z
	umod r5.x, r1.x, cb1[0].z
	
	itof r2, r2
	itof r3, r3
	itof r4, r4
	itof r5, r5
	
	sample_resource(0)_sampler(0) r2, r2.xy
	sample_resource(0)_sampler(0) r3, r3.xy
	sample_resource(0)_sampler(0) r4, r4.xy
	sample_resource(0)_sampler(0) r5, r5.xy
else
	
	mov r2, r2.0000
	mov r3, r3.0000
	mov r4, r4.0000
	mov r5, r5.0000
	
	if_logicalz r1.z ; left boundary
		 ; currently only FiniteData boundary		
	else ; right boundary		
		ige r1.z, r0.y, cb1[0].y
		if_logicalnz r1.z
			 ; currently only FiniteData boundary
		else
			
			; case when width is not multiple of 4 and there are still some data in the line
			
			; 2D position of quads
			imad r1.x, r0.y, cb1[0].w, r0.x ; linear position of quad to load
			udiv r2.y, r1.x, cb1[0].z
			umod r2.x, r1.x, cb1[0].z
			itof r2, r2
			
			umod r1.z, cb1[0].y, l0.x ; width MOD 4
			switch r1.z
				case 1
					sample_resource(0)_sampler(0) r2, r2.xy					
				break
				
				case 2
					iadd r1.x, r1.x, cb1[0].w ; ind + xPitch
					udiv r3.y, r1.x, cb1[0].z
					umod r3.x, r1.x, cb1[0].z
					itof r3, r3
					sample_resource(0)_sampler(0) r2, r2.xy
					sample_resource(0)_sampler(0) r3, r3.xy
				break
				
				case 3
					iadd r1.x, r1.x, cb1[0].w ; ind + xPitch
					udiv r3.y, r1.x, cb1[0].z
					umod r3.x, r1.x, cb1[0].z
		
					iadd r1.x, r1.x, cb1[0].w
					udiv r4.y, r1.x, cb1[0].z
					umod r4.x, r1.x, cb1[0].z
					itof r3, r3
					itof r4, r4
					sample_resource(0)_sampler(0) r2, r2.xy
					sample_resource(0)_sampler(0) r3, r3.xy
					sample_resource(0)_sampler(0) r4, r4.xy
				break
			endswitch						
		endif
	endif
	
endif

; transpose quads
transpose r2, r2

ret
endfunc

; compute 4 output quads
; {r10,r11,r12,r13}, {r6,r7,r8,r9}, {r2,r3,r4,r5} - input quads
; output is stored in {r30,r31,r32,r33}
; uses r34,r35,r36 for intermediate results
func 1

mul r30, r10, cb0[0]
mad r30, r6, cb0[1], r30
mad r30, r2, cb0[2], r30

mul r31, r10, cb0[3]
mad r31, r6, cb0[4], r31
mad r31, r2, cb0[5], r31

mul r32, r10, cb0[6]
mad r32, r6, cb0[7], r32
mad r32, r2, cb0[8], r32

mul r33, r10, cb0[9]
mad r33, r6, cb0[10], r33
mad r33, r2, cb0[11], r33
	
dp4 r30.x, r30, r30.1111
dp4 r30.y, r31, r31.1111
dp4 r30.z, r32, r32.1111
dp4 r30.w, r33, r33.1111

; ****

mul r31, r11, cb0[0]
mad r31, r7, cb0[1], r31
mad r31, r3, cb0[2], r31

mul r32, r11, cb0[3]
mad r32, r7, cb0[4], r32
mad r32, r3, cb0[5], r32

mul r33, r11, cb0[6]
mad r33, r7, cb0[7], r33
mad r33, r3, cb0[8], r33

mul r34, r11, cb0[9]
mad r34, r7, cb0[10], r34
mad r34, r3, cb0[11], r34
	
dp4 r31.x, r31, r31.1111
dp4 r31.y, r32, r32.1111
dp4 r31.z, r33, r33.1111
dp4 r31.w, r34, r34.1111

; ****

mul r32, r12, cb0[0]
mad r32, r8, cb0[1], r32
mad r32, r4, cb0[2], r32

mul r33, r12, cb0[3]
mad r33, r8, cb0[4], r33
mad r33, r4, cb0[5], r33

mul r34, r12, cb0[6]
mad r34, r8, cb0[7], r34
mad r34, r4, cb0[8], r34

mul r35, r12, cb0[9]
mad r35, r8, cb0[10], r35
mad r35, r4, cb0[11], r35
	
dp4 r32.x, r32, r32.1111
dp4 r32.y, r33, r33.1111
dp4 r32.z, r34, r34.1111
dp4 r32.w, r35, r35.1111

; ****

mul r33, r13, cb0[0]
mad r33, r9, cb0[1], r33
mad r33, r5, cb0[2], r33

mul r34, r13, cb0[3]
mad r34, r9, cb0[4], r34
mad r34, r5, cb0[5], r34

mul r35, r13, cb0[6]
mad r35, r9, cb0[7], r35
mad r35, r5, cb0[8], r35

mul r36, r13, cb0[9]
mad r36, r9, cb0[10], r36
mad r36, r5, cb0[11], r36
	
dp4 r33.x, r33, r33.1111
dp4 r33.y, r34, r34.1111
dp4 r33.z, r35, r35.1111
dp4 r33.w, r36, r36.1111

ret
endfunc

end
]]>
	</ILKernel>	
	
<ILKernel name = "ConvolveNDZ9_R">
<![CDATA[
il_cs_2_0
dcl_num_thread_per_group 64
;
;	Convolve 3D virtualized array along Z (first) direction with up to 9 taps FIR filter
; 
;	inputs: 1
;	outputs: 0
;	global buffer: Yes
;	data type: REAL
;	nComponents: 4
;	constants: 2, 12x4 (REAL) and 2x4 (LONGINT)
;

dcl_cb cb0[12]	; [h0,h1,h2,h3],[h4,h5,h6,h7],[h8,0,0,0]
					; [0,h0,h1,h2],[h3,h4,h5,h6],[h7,h8,0,0]
					; [0,0,h0,h1],[h2,h3,h4,h5],[h6,h7,h8,0]
					; [0,0,0,h0],[h1,h2,h3,h4],[h5,h6,h7,h8]
					
dcl_cb cb1[3]	; [hotSpot,width,physWidth,xPitch], [boundary,(width DIV 4)*4,Ny*xPitch,...]
					; [inpOffset,outOffset,...] input and output offsets in quads

; hotSpot - has to be aligned to be multiple of 4
; width - is the line width

dcl_resource_id(0)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)

dcl_literal l0, 4, 0xFFFFFFFF, 1, 0

ilt r0.z, vaTid.x, cb1[1].z ; check thread index!
if_logicalnz r0.z

	; in this case we have Ny*xPitch threads
	mov r0.x, vaTid.x ; position of first input quad (in quads)
	imul r0.y, cb1[0].x, l0.y ; -hotSpot ; first input index
	mov r0.z, r0.x ; position of curent output quad
	iadd r0.z, r0.z, cb1[2].y ; account output offset
	imad r0.w, cb1[1].y, cb1[1].z, r0.z ; ind0 + (width DIV 4)*4*Ny*xPitch
	
	iadd r0.x, r0.x, cb1[2].x ; account input offset
	
	; load first 2x4 input quads
	call 0
	iadd r0.y, r0.y, l0.x ; increment input index
	mov r6, r2
	mov r7, r3
	mov r8, r4
	mov r9, r5
	call 0
	iadd r0.y, r0.y, l0.x ; increment input index
	
	whileloop
				
		ige r1.z, r0.z, r0.w ; ind >= ind0 + (width DIV 4)*4*Ny*xPitch
		break_logicalnz r1.z
		
		mov r10, r6
		mov r11, r7
		mov r12, r8
		mov r13, r9
		
		mov r6, r2
		mov r7, r3
		mov r8, r4
		mov r9, r5
	
		call 0 ; load next input quads
		iadd r0.y, r0.y, l0.x ; increment input index
				
		call 1 ; compute output quads
		
		; transpose quads
		transpose r30, r30
		
		iadd r1.x, r0.z, cb1[1].z
		iadd r1.y, r1.x, cb1[1].z
		iadd r1.z, r1.y, cb1[1].z
		
		; write to the output
		mov g[r0.z], r30
		mov g[r1.x], r31
		mov g[r1.y], r32
		mov g[r1.z], r33
	
		iadd r0.z, r1.z, cb1[1].z ; increment output index
	endloop

	umod r0.w, cb1[0].y, l0.x ; account width MOD 4 # 0
	if_logicalnz r0.w
		
		; process last quads
		
		mov r10, r6
		mov r11, r7
		mov r12, r8
		mov r13, r9
		
		mov r6, r2
		mov r7, r3
		mov r8, r4
		mov r9, r5
	
		call 0 ; load next input quads
		call 1 ; compute output quads
		
		; transpose quads
		transpose r30, r30
		
		iadd r1.x, r0.z, cb1[1].z
		iadd r1.y, r1.x, cb1[1].z
	
		switch r0.w
			case 1
				mov g[r0.z], r30
				break
			case 2
				mov g[r0.z], r30
				mov g[r1.x], r31
				break
			case 3
				mov g[r0.z], r30
				mov g[r1.x], r31
				mov g[r1.y], r32
				break
		endswitch
				
	endif;

endif; 

endmain

; get input quad with account of boundaries for 4 lines at once
; r0.x - linear position of the first line element with account of padding, in quads
; r0.y - index of input quad within the line, in single elements
; output is returned in r2, r3, r4, r5
; r1 is used for intermediate results
func 0

ige r1.z, r0.y, r0.0 ; ind >= 0
ilt r1.w, r0.y, cb1[1].y ; ind < (width DIV 4)*4
iand r1.w, r1.z, r1.w

if_logicalnz r1.w ; (ind >= 0) & (ind < (width DIV 4)*4) -> not on boundaries
	
	; 2D position of quads
	imad r1.x, r0.y, cb1[1].z, r0.x ; linear position of quad to load
	udiv r3.y, r1.x, cb1[0].z
	umod r3.x, r1.x, cb1[0].z
	
	iadd r1.x, r1.x, cb1[1].z ; ind + Ny*xPitch
	udiv r4.y, r1.x, cb1[0].z
	umod r4.x, r1.x, cb1[0].z
	
	iadd r1.x, r1.x, cb1[1].z
	udiv r5.y, r1.x, cb1[0].z
	umod r5.x, r1.x, cb1[0].z
	
	iadd r1.x, r1.x, cb1[1].z
	udiv r1.y, r1.x, cb1[0].z
	umod r1.x, r1.x, cb1[0].z
	
	itof r3, r3
	itof r4, r4
	itof r5, r5
	itof r1, r1
	
	sample_resource(0)_sampler(0) r2, r3.xy
	sample_resource(0)_sampler(0) r3, r4.xy
	sample_resource(0)_sampler(0) r4, r5.xy
	sample_resource(0)_sampler(0) r5, r1.xy
else
	
	mov r2, r2.0000
	mov r3, r3.0000
	mov r4, r4.0000
	mov r5, r5.0000
	
	if_logicalz r1.z ; left boundary
		 ; currently only FiniteData boundary		
	else ; right boundary		
		ige r1.z, r0.y, cb1[0].y
		if_logicalnz r1.z
			 ; currently only FiniteData boundary
		else
			
			; case when width is not multiple of 4 and there are still some data in the line
			
			; 2D position of quads
			imad r1.x, r0.y, cb1[1].z, r0.x ; linear position of quad to load
			udiv r2.y, r1.x, cb1[0].z
			umod r2.x, r1.x, cb1[0].z			
			itof r2, r2		
			
			umod r1.z, cb1[0].y, l0.x ; width MOD 4
			switch r1.z
				case 1					
					sample_resource(0)_sampler(0) r2, r2.xy					
				break
				
				case 2
					iadd r1.x, r1.x, cb1[1].z ; ind + Ny*xPitch			
					udiv r3.y, r1.x, cb1[0].z
					umod r3.x, r1.x, cb1[0].z
					
					itof r3, r3
					sample_resource(0)_sampler(0) r2, r2.xy
					sample_resource(0)_sampler(0) r3, r3.xy
				break
				
				case 3
					iadd r1.x, r1.x, cb1[1].z ; ind + Ny*xPitch			
					udiv r3.y, r1.x, cb1[0].z
					umod r3.x, r1.x, cb1[0].z
		
					iadd r1.x, r1.x, cb1[1].z
					udiv r4.y, r1.x, cb1[0].z
					umod r4.x, r1.x, cb1[0].z
					
					itof r3, r3
					itof r4, r4					
					sample_resource(0)_sampler(0) r2, r2.xy
					sample_resource(0)_sampler(0) r3, r3.xy
					sample_resource(0)_sampler(0) r4, r4.xy
				break
			endswitch						
		endif
	endif
	
endif

; transpose quads
transpose r2, r2

ret
endfunc

; compute 4 output quads
; {r10,r11,r12,r13}, {r6,r7,r8,r9}, {r2,r3,r4,r5} - input quads
; output is stored in {r30,r31,r32,r33}
; uses r34,r35,r36 for intermediate results
func 1

mul r30, r10, cb0[0]
mad r30, r6, cb0[1], r30
mad r30, r2, cb0[2], r30

mul r31, r10, cb0[3]
mad r31, r6, cb0[4], r31
mad r31, r2, cb0[5], r31

mul r32, r10, cb0[6]
mad r32, r6, cb0[7], r32
mad r32, r2, cb0[8], r32

mul r33, r10, cb0[9]
mad r33, r6, cb0[10], r33
mad r33, r2, cb0[11], r33
	
dp4 r30.x, r30, r30.1111
dp4 r30.y, r31, r31.1111
dp4 r30.z, r32, r32.1111
dp4 r30.w, r33, r33.1111

; ****

mul r31, r11, cb0[0]
mad r31, r7, cb0[1], r31
mad r31, r3, cb0[2], r31

mul r32, r11, cb0[3]
mad r32, r7, cb0[4], r32
mad r32, r3, cb0[5], r32

mul r33, r11, cb0[6]
mad r33, r7, cb0[7], r33
mad r33, r3, cb0[8], r33

mul r34, r11, cb0[9]
mad r34, r7, cb0[10], r34
mad r34, r3, cb0[11], r34
	
dp4 r31.x, r31, r31.1111
dp4 r31.y, r32, r32.1111
dp4 r31.z, r33, r33.1111
dp4 r31.w, r34, r34.1111

; ****

mul r32, r12, cb0[0]
mad r32, r8, cb0[1], r32
mad r32, r4, cb0[2], r32

mul r33, r12, cb0[3]
mad r33, r8, cb0[4], r33
mad r33, r4, cb0[5], r33

mul r34, r12, cb0[6]
mad r34, r8, cb0[7], r34
mad r34, r4, cb0[8], r34

mul r35, r12, cb0[9]
mad r35, r8, cb0[10], r35
mad r35, r4, cb0[11], r35
	
dp4 r32.x, r32, r32.1111
dp4 r32.y, r33, r33.1111
dp4 r32.z, r34, r34.1111
dp4 r32.w, r35, r35.1111

; ****

mul r33, r13, cb0[0]
mad r33, r9, cb0[1], r33
mad r33, r5, cb0[2], r33

mul r34, r13, cb0[3]
mad r34, r9, cb0[4], r34
mad r34, r5, cb0[5], r34

mul r35, r13, cb0[6]
mad r35, r9, cb0[7], r35
mad r35, r5, cb0[8], r35

mul r36, r13, cb0[9]
mad r36, r9, cb0[10], r36
mad r36, r5, cb0[11], r36
	
dp4 r33.x, r33, r33.1111
dp4 r33.y, r34, r34.1111
dp4 r33.z, r35, r35.1111
dp4 r33.w, r36, r36.1111

ret
endfunc

end
]]>
	</ILKernel>
	
<ILKernel name = "ConvolveNDX5Down2_R">
<![CDATA[
il_cs_2_0
dcl_num_thread_per_group 64
;
;	Convolve ND virtualized array along X (last) direction with up to 5 taps FIR filter and downsample by 2
; 
;	inputs: 1
;	outputs: 0
;	global buffer: Yes
;	data type: REAL
;	nComponents: 4
;	constants: 2, 8x4 (REAL) and 3x4 (LONGINT)
;

dcl_cb cb0[8]	; [h0,h1,h2,h3],[h4,0,0,0]
					; [0,h0,h1,h2],[h3,h4,0,0]
					; [0,0,h0,h1],[h2,h3,h4,0]
					; [0,0,0,h0],[h1,h2,h3,h4]
					
dcl_cb cb1[3]	; [hotSpot,widthSrc,physWidth,xPitchSrc], [boundary,(widthSrc DIV 4)*4,widthDst,xPitchDst],
					; [phase,...]

; hotSpot - has to be aligned to be multiple of 4

dcl_resource_id(0)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)

dcl_literal l0, 4, 0xFFFFFFFF, 1, 0

umul r0.x, vaTid.x, cb1[0].w ; iLine*xPitchSrc -> index of the first line quad in the input
imul r0.y, cb1[0].x, l0.y ; -hotSpot ; first input index

imul r0.z, vaTid.x, cb1[1].w ; iLine*xPitchDst -> position of curent output quad

udiv r0.w, cb1[1].z, l0.x
iadd r0.w, r0.z, r0.w ; ind0+(widthDst DIV 4) -> position of last output quad

; load first input quads
call 0
iadd r0.y, r0.y, l0.x ; increment input index

whileloop
	
	ige r1.z, r0.z, r0.w ; ind >= ind0+(widthDst DIV 4)
	break_logicalnz r1.z
	
	mov r4, r2
		
	call 0 ; load next input quad
	iadd r0.y, r0.y, l0.x ; increment input index
	mov r3, r2
	call 0 ; load next input quad
	iadd r0.y, r0.y, l0.x ; increment input index

	call 1 ; compute output quad
	mov g[r0.z], r30 ; store output quad		
	
	iadd r0.z, r0.z, l0.z ; increment output index
endloop

umod r0.w, cb1[1].z, l0.x ; account padding -> widthDst MOD 4
if_logicalnz r0.w
	
	; last line quad
	mov r4, r2
		
	call 0 ; load next input quad
	iadd r0.y, r0.y, l0.x ; increment input index
	mov r3, r2
	call 0 ; load next input quad
	
	call 1	

	switch r0.w
		case 1
			mov r30, r30.x000
			break
		case 2
			mov r30, r30.xy00
			break
		case 3
			mov r30, r30.xyz0
			break
	endswitch
	
	mov g[r0.z], r30 ; store output quad
endif;

endmain

; get input quad with account of boundaries
; r0.x - linear position of the first line element with account of padding, in quads
; r0.y - index of input quad within the line, in single elements
; output is returned in r2
; r1 is used for intermediate results
func 0

ige r1.z, r0.y, r0.0 ; ind >= 0
ilt r1.w, r0.y, cb1[1].y ; ind < (widthSrc DIV 4)*4
iand r1.w, r1.z, r1.w

if_logicalnz r1.w ; (ind >= 0) & (ind < (widthSrc DIV 4)*4) -> not on boundaries
	udiv r1.x, r0.y, l0.x ; index in quads
	iadd r1.x, r0.x, r1.x ; linear position of quad to load
	; 2D position of the quad
	udiv r2.y, r1.x, cb1[0].z
	umod r2.x, r1.x, cb1[0].z
	itof r2, r2
	sample_resource(0)_sampler(0) r2, r2.xy
else
	
	mov r2, r2.0000
	
	if_logicalz r1.z ; left boundary
		; currently only FiniteData boundary
	else ; right boundary		
		ige r1.z, r0.y, cb1[0].y ; ind >= widthSrc
		if_logicalnz r1.z
			; currently only FiniteData boundary
		else
			
			; case when width is not multiple of 4 and there are still some data in the line
			
			udiv r1.x, r0.y, l0.x ; index in quads
			iadd r1.x, r0.x, r1.x ; linear position of quad to load
			; 2D position of the quad
			udiv r2.y, r1.x, cb1[0].z
			umod r2.x, r1.x, cb1[0].z
			itof r2, r2			
			
			umod r1.z, cb1[0].y, l0.x ; widthSrc MOD 4
			switch r1.z
				case 1
					sample_resource(0)_sampler(0) r2.x000, r2.xy
				break
				
				case 2
					sample_resource(0)_sampler(0) r2.xy00, r2.xy
				break
				
				case 3
					sample_resource(0)_sampler(0) r2.xyz0, r2.xy
				break
			endswitch						
		endif
	endif
	
endif

ret
endfunc

; compute output quad
; r4, r3, r2 - input quads
; output is stored in r30
; uses r31, r32, r33 for intermediate results
func 1

switch cb1[2].x

	case 0
		mul r30, r4, cb0[0]
		mad r30, r3, cb0[1], r30
	
		mul r31, r4, cb0[4]
		mad r31, r3, cb0[5], r31
		
		mul r32, r3, cb0[0]
		mad r32, r2, cb0[1], r32
		
		mul r33, r3, cb0[4]
		mad r33, r2, cb0[5], r33
	break
	
	case 1
		mul r30, r4, cb0[2]
		mad r30, r3, cb0[3], r30
	
		mul r31, r4, cb0[6]
		mad r31, r3, cb0[7], r31
		
		mul r32, r3, cb0[2]
		mad r32, r2, cb0[3], r32
		
		mul r33, r3, cb0[6]
		mad r33, r2, cb0[7], r33
	break
endswitch	

dp4 r30.x, r30, r30.1111
dp4 r30.y, r31, r31.1111
dp4 r30.z, r32, r32.1111
dp4 r30.w, r33, r33.1111

ret
endfunc

end
]]>
	</ILKernel>
	
<ILKernel name = "ConvolveNDX9Down2_R">
<![CDATA[
il_cs_2_0
dcl_num_thread_per_group 64
;
;	Convolve ND virtualized array along X (last) direction with up to 9 taps FIR filter and downsample by 2
; 
;	inputs: 1
;	outputs: 0
;	global buffer: Yes
;	data type: REAL
;	nComponents: 4
;	constants: 2, 8x4 (REAL) and 3x4 (LONGINT)
;

dcl_cb cb0[12]	; [h0,h1,h2,h3],[h4,h5,h6,h7],[h8,0,0,0]
					; [0,h0,h1,h2],[h3,h4,h5,h6],[h7,h8,0,0]
					; [0,0,h0,h1],[h2,h3,h4,h5],[h6,h7,h8,0]
					; [0,0,0,h0],[h1,h2,h3,h4],[h5,h6,h7,h8]
					
dcl_cb cb1[3]	; [hotSpot,widthSrc,physWidth,xPitchSrc], [boundary,(widthSrc DIV 4)*4,widthDst,xPitchDst]
					; [phase,...]

; hotSpot - has to be aligned to be multiple of 4

dcl_resource_id(0)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)

dcl_literal l0, 4, 0xFFFFFFFF, 1, 0

umul r0.x, vaTid.x, cb1[0].w ; iLine*xPitchSrc -> index of the first line quad in the input
imul r0.y, cb1[0].x, l0.y ; -hotSpot ; first input index

imul r0.z, vaTid.x, cb1[1].w ; iLine*xPitchDst -> position of curent output quad

udiv r0.w, cb1[1].z, l0.x
iadd r0.w, r0.z, r0.w ; ind0+(widthDst DIV 4) -> position of last output quad

; load first input quads
call 0
iadd r0.y, r0.y, l0.x ; increment input index
mov r3, r2
call 0
iadd r0.y, r0.y, l0.x ; increment input index

whileloop
	
	ige r1.z, r0.z, r0.w ; ind >= ind0+(widthDst DIV 4)
	break_logicalnz r1.z
	
	mov r5, r3
	mov r4, r2
		
	call 0 ; load next input quad
	iadd r0.y, r0.y, l0.x ; increment input index
	mov r3, r2
	call 0 ; load next input quad
	iadd r0.y, r0.y, l0.x ; increment input index

	call 1 ; compute output quad
	mov g[r0.z], r30 ; store output quad		
	
	iadd r0.z, r0.z, l0.z ; increment output index
endloop

umod r0.w, cb1[1].z, l0.x ; account padding -> widthDst MOD 4
if_logicalnz r0.w
	
	; last line quad
	
	mov r5, r3
	mov r4, r2
		
	call 0 ; load next input quad
	iadd r0.y, r0.y, l0.x ; increment input index
	mov r3, r2
	call 0 ; load next input quad
	
	call 1	

	switch r0.w
		case 1
			mov r30, r30.x000
			break
		case 2
			mov r30, r30.xy00
			break
		case 3
			mov r30, r30.xyz0
			break
	endswitch
	
	mov g[r0.z], r30 ; store output quad
endif;

endmain

; get input quad with account of boundaries
; r0.x - linear position of the first line element with account of padding, in quads
; r0.y - index of input quad within the line, in single elements
; output is returned in r2
; r1 is used for intermediate results
func 0

ige r1.z, r0.y, r0.0 ; ind >= 0
ilt r1.w, r0.y, cb1[1].y ; ind < (widthSrc DIV 4)*4
iand r1.w, r1.z, r1.w

if_logicalnz r1.w ; (ind >= 0) & (ind < (widthSrc DIV 4)*4) -> not on boundaries
	udiv r1.x, r0.y, l0.x ; index in quads
	iadd r1.x, r0.x, r1.x ; linear position of quad to load
	; 2D position of the quad
	udiv r2.y, r1.x, cb1[0].z
	umod r2.x, r1.x, cb1[0].z
	itof r2, r2
	sample_resource(0)_sampler(0) r2, r2.xy
else
	
	mov r2, r2.0000
	
	if_logicalz r1.z ; left boundary
		; currently only FiniteData boundary
	else ; right boundary		
		ige r1.z, r0.y, cb1[0].y ; ind >= widthSrc
		if_logicalnz r1.z
			; currently only FiniteData boundary
		else
			
			; case when width is not multiple of 4 and there are still some data in the line
			
			udiv r1.x, r0.y, l0.x ; index in quads
			iadd r1.x, r0.x, r1.x ; linear position of quad to load
			; 2D position of the quad
			udiv r2.y, r1.x, cb1[0].z
			umod r2.x, r1.x, cb1[0].z
			itof r2, r2			
			
			umod r1.z, cb1[0].y, l0.x ; widthSrc MOD 4
			switch r1.z
				case 1
					sample_resource(0)_sampler(0) r2.x000, r2.xy
				break
				
				case 2
					sample_resource(0)_sampler(0) r2.xy00, r2.xy
				break
				
				case 3
					sample_resource(0)_sampler(0) r2.xyz0, r2.xy
				break
			endswitch						
		endif
	endif
	
endif

ret
endfunc

; compute output quad
; r5, r4, r3, r2 - input quads
; output is stored in r30
; uses r31, r32, r33 for intermediate results
func 1

switch cb1[2].x

	case 0
		mul r30, r5, cb0[0]
		mad r30, r4, cb0[1], r30
		mad r30, r3, cb0[2], r30

		mul r31, r5, cb0[6]
		mad r31, r4, cb0[7], r31
		mad r31, r3, cb0[8], r31

		mul r32, r4, cb0[0]
		mad r32, r3, cb0[1], r32
		mad r32, r2, cb0[2], r32

		mul r33, r4, cb0[6]
		mad r33, r3, cb0[7], r33
		mad r33, r2, cb0[8], r33
	break;
	
	case 1
		mul r30, r5, cb0[3]
		mad r30, r4, cb0[4], r30
		mad r30, r3, cb0[5], r30

		mul r31, r5, cb0[9]
		mad r31, r4, cb0[10], r31
		mad r31, r3, cb0[11], r31

		mul r32, r4, cb0[3]
		mad r32, r3, cb0[4], r32
		mad r32, r2, cb0[5], r32

		mul r33, r4, cb0[9]
		mad r33, r3, cb0[10], r33
		mad r33, r2, cb0[11], r33
	break
endswitch
	
dp4 r30.x, r30, r30.1111
dp4 r30.y, r31, r31.1111
dp4 r30.z, r32, r32.1111
dp4 r30.w, r33, r33.1111

ret
endfunc

end
]]>
	</ILKernel>
	
<ILKernel name = "Convolve3DY5Down2_R">
<![CDATA[
il_cs_2_0
dcl_num_thread_per_group 64
;
;	Convolve 3D virtualized array along Y direction with up to 5 taps FIR filter and downsampling by 2
; 
;	inputs: 1
;	outputs: 0
;	global buffer: Yes
;	data type: REAL
;	nComponents: 4
;	constants: 2, 8x4 (REAL) and 3x4 (LONGINT)
;

dcl_cb cb0[8]	; [h0,h1,h2,h3],[h4,0,0,0]
					; [0,h0,h1,h2],[h3,h4,0,0]
					; [0,0,h0,h1],[h2,h3,h4,0]
					; [0,0,0,h0],[h1,h2,h3,h4]
					
dcl_cb cb1[3]	; [hotSpot,widthSrc,physWidth,xPitch], [boundary,(widthSrc DIV 4)*4,widthDst,Nz]
					; [phase,...]

; hotSpot - has to be aligned to be multiple of 4
; widthSrc/Dst - is the line width

dcl_resource_id(0)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)

dcl_literal l0, 4, 0xFFFFFFFF, 1, 0

imul r0.x, cb1[1].w, cb1[0].w ; Nz*xPitch
ilt r0.z, vaTid.x, r0.x ; check thread index!
if_logicalnz r0.z

	; in this case we have Nz*xPitch threads, thus the thread index is represented by i*xPitch + j
	udiv r0.y, vaTid.x, cb1[0].w ; i
	umod r0.x, vaTid.x, cb1[0].w ; j
	
	; position of first output quad
	imul r0.z, cb1[1].z, cb1[0].w ; widthDst*xpitch
	imad r0.z, r0.y, r0.z, r0.x ; i*widthDst*xPitch + j (in quads)
	; last output quad
	udiv r0.w, cb1[1].z, l0.x ; widthDst DIV 4
	imul r0.w, r0.w, l0.x ; (widthDst DIV 4)*4
	imad r0.w, r0.w, cb1[0].w, r0.z ; ind0 + (widthDst DIV 4)*4*xPitch
		
	; compute first quad position in the input
	imul r1.z, cb1[0].y, cb1[0].w ; widthSrc*xpitch
	imad r0.x, r0.y, r1.z, r0.x ; i*widthSrc*xPitch + j (in quads)
	
	imul r0.y, cb1[0].x, l0.y ; -hotSpot ; first input index
			
	; load first 4 input quads
	call 0
	iadd r0.y, r0.y, l0.x ; increment input index
	
	whileloop
		
		ige r1.z, r0.z, r0.w ; ind >= ind0 + (widthDst DIV 4)*4*xPitch
		break_logicalnz r1.z
		
		mov r10, r2
		mov r11, r3
		mov r12, r4
		mov r13, r5
		
		call 0 ; load next input quads
		iadd r0.y, r0.y, l0.x ; increment input index
		mov r6, r2
		mov r7, r3
		mov r8, r4
		mov r9, r5
		call 0 ; load next input quads
		iadd r0.y, r0.y, l0.x ; increment input index
		
		call 1 ; compute output quads
	
		; transpose quads
		transpose r30, r30
		
		iadd r1.x, r0.z, cb1[0].w
		iadd r1.y, r1.x, cb1[0].w
		iadd r1.z, r1.y, cb1[0].w				
		
		; write to the output		
		mov g[r0.z], r30
		mov g[r1.x], r31
		mov g[r1.y], r32
		mov g[r1.z], r33
	
		iadd r0.z, r1.z, cb1[0].w ; increment output index
	endloop
	
	umod r0.w, cb1[1].z, l0.x ; account widthDst MOD 4 # 0
	if_logicalnz r0.w
		
		; process last quads
		
		mov r10, r2
		mov r11, r3
		mov r12, r4
		mov r13, r5
		
		call 0 ; load next input quads
		iadd r0.y, r0.y, l0.x ; increment input index
		mov r6, r2
		mov r7, r3
		mov r8, r4
		mov r9, r5
		call 0 ; load next input quads		
		
		call 1 ; compute output quads				
		
		; transpose quads
		transpose r30, r30
		
		iadd r1.x, r0.z, cb1[0].w
		iadd r1.y, r1.x, cb1[0].w
	
		switch r0.w		
			case 1
				mov g[r0.z], r30
				break
			case 2
				mov g[r0.z], r30
				mov g[r1.x], r31
				break
			case 3
				mov g[r0.z], r30
				mov g[r1.x], r31
				mov g[r1.y], r32
				break
		endswitch
				
	endif
	
endif

endmain

; get input quad with account of boundaries for 4 lines at once
; r0.x - linear position of the first line element with account of padding, in quads
; r0.y - index of input quad within the line, in single elements
; output is returned in r2, r3, r4, r5
; r1 is used for intermediate results
func 0

ige r1.z, r0.y, r0.0 ; ind >= 0
ilt r1.w, r0.y, cb1[1].y ; ind < (widthSrc DIV 4)*4
iand r1.w, r1.z, r1.w

if_logicalnz r1.w ; (ind >= 0) & (ind < (widthSrc DIV 4)*4) -> not on boundaries
	
	; 2D position of quads
	imad r1.x, r0.y, cb1[0].w, r0.x ; linear position of quad to load
	udiv r2.y, r1.x, cb1[0].z
	umod r2.x, r1.x, cb1[0].z
	
	iadd r1.x, r1.x, cb1[0].w ; ind + xPitch
	udiv r3.y, r1.x, cb1[0].z
	umod r3.x, r1.x, cb1[0].z
	
	iadd r1.x, r1.x, cb1[0].w
	udiv r4.y, r1.x, cb1[0].z
	umod r4.x, r1.x, cb1[0].z
	
	iadd r1.x, r1.x, cb1[0].w
	udiv r5.y, r1.x, cb1[0].z
	umod r5.x, r1.x, cb1[0].z
	
	itof r2, r2
	itof r3, r3
	itof r4, r4
	itof r5, r5
	
	sample_resource(0)_sampler(0) r2, r2.xy
	sample_resource(0)_sampler(0) r3, r3.xy
	sample_resource(0)_sampler(0) r4, r4.xy
	sample_resource(0)_sampler(0) r5, r5.xy
else
	
	mov r2, r2.0000
	mov r3, r3.0000
	mov r4, r4.0000
	mov r5, r5.0000
	
	if_logicalz r1.z ; left boundary
		 ; currently only FiniteData boundary		
	else ; right boundary		
		ige r1.z, r0.y, cb1[0].y
		if_logicalnz r1.z
			 ; currently only FiniteData boundary
		else
			
			; case when width is not multiple of 4 and there are still some data in the line
			
			; 2D position of quads
			imad r1.x, r0.y, cb1[0].w, r0.x ; linear position of quad to load
			udiv r2.y, r1.x, cb1[0].z
			umod r2.x, r1.x, cb1[0].z
			itof r2, r2
			
			umod r1.z, cb1[0].y, l0.x ; width MOD 4
			switch r1.z
				case 1
					sample_resource(0)_sampler(0) r2, r2.xy					
				break
				
				case 2
					iadd r1.x, r1.x, cb1[0].w ; ind + xPitch
					udiv r3.y, r1.x, cb1[0].z
					umod r3.x, r1.x, cb1[0].z
					itof r3, r3
					sample_resource(0)_sampler(0) r2, r2.xy
					sample_resource(0)_sampler(0) r3, r3.xy
				break
				
				case 3
					iadd r1.x, r1.x, cb1[0].w ; ind + xPitch
					udiv r3.y, r1.x, cb1[0].z
					umod r3.x, r1.x, cb1[0].z
		
					iadd r1.x, r1.x, cb1[0].w
					udiv r4.y, r1.x, cb1[0].z
					umod r4.x, r1.x, cb1[0].z
					itof r3, r3
					itof r4, r4
					sample_resource(0)_sampler(0) r2, r2.xy
					sample_resource(0)_sampler(0) r3, r3.xy
					sample_resource(0)_sampler(0) r4, r4.xy
				break
			endswitch						
		endif
	endif
	
endif

; transpose quads
transpose r2, r2

ret
endfunc

; compute 4 output quads
; {r10,r11,r12,r13}, {r6,r7,r8,r9}, {r2,r3,r4,r5} - input quads
; output is stored in {r30,r31,r32,r33}
; uses r34,r35,r36 for intermediate results
func 1

switch cb1[2].x

case 0
	mul r30, r10, cb0[0]
	mad r30, r6, cb0[1], r30
	
	mul r31, r10, cb0[4]
	mad r31, r6, cb0[5], r31
	
	mul r32, r6, cb0[0]
	mad r32, r2, cb0[1], r32
	
	mul r33, r6, cb0[4]
	mad r33, r2, cb0[5], r33
		
	dp4 r30.x, r30, r30.1111
	dp4 r30.y, r31, r31.1111
	dp4 r30.z, r32, r32.1111
	dp4 r30.w, r33, r33.1111
	
	; ****
	
	mul r31, r11, cb0[0]
	mad r31, r7, cb0[1], r31
	
	mul r32, r11, cb0[4]
	mad r32, r7, cb0[5], r32
	
	mul r33, r7, cb0[0]
	mad r33, r3, cb0[1], r33
	
	mul r34, r7, cb0[4]
	mad r34, r3, cb0[5], r34
		
	dp4 r31.x, r31, r31.1111
	dp4 r31.y, r32, r32.1111
	dp4 r31.z, r33, r33.1111
	dp4 r31.w, r34, r34.1111
	
	; ****
	
	mul r32, r12, cb0[0]
	mad r32, r8, cb0[1], r32
	
	mul r33, r12, cb0[4]
	mad r33, r8, cb0[5], r33
	
	mul r34, r8, cb0[0]
	mad r34, r4, cb0[1], r34
	
	mul r35, r8, cb0[4]
	mad r35, r4, cb0[5], r35
		
	dp4 r32.x, r32, r32.1111
	dp4 r32.y, r33, r33.1111
	dp4 r32.z, r34, r34.1111
	dp4 r32.w, r35, r35.1111
	
	; ****
	
	mul r33, r13, cb0[0]
	mad r33, r9, cb0[1], r33
	
	mul r34, r13, cb0[4]
	mad r34, r9, cb0[5], r34
	
	mul r35, r9, cb0[0]
	mad r35, r5, cb0[1], r35
	
	mul r36, r9, cb0[4]
	mad r36, r5, cb0[5], r36
		
	dp4 r33.x, r33, r33.1111
	dp4 r33.y, r34, r34.1111
	dp4 r33.z, r35, r35.1111
	dp4 r33.w, r36, r36.1111
break

case 1

	mul r30, r10, cb0[2]
	mad r30, r6, cb0[3], r30
	
	mul r31, r10, cb0[6]
	mad r31, r6, cb0[7], r31
	
	mul r32, r6, cb0[2]
	mad r32, r2, cb0[3], r32
	
	mul r33, r6, cb0[6]
	mad r33, r2, cb0[7], r33
		
	dp4 r30.x, r30, r30.1111
	dp4 r30.y, r31, r31.1111
	dp4 r30.z, r32, r32.1111
	dp4 r30.w, r33, r33.1111
	
	; ****
	
	mul r31, r11, cb0[2]
	mad r31, r7, cb0[3], r31
	
	mul r32, r11, cb0[6]
	mad r32, r7, cb0[7], r32
	
	mul r33, r7, cb0[2]
	mad r33, r3, cb0[3], r33
	
	mul r34, r7, cb0[6]
	mad r34, r3, cb0[7], r34
		
	dp4 r31.x, r31, r31.1111
	dp4 r31.y, r32, r32.1111
	dp4 r31.z, r33, r33.1111
	dp4 r31.w, r34, r34.1111
	
	; ****
	
	mul r32, r12, cb0[2]
	mad r32, r8, cb0[3], r32
	
	mul r33, r12, cb0[6]
	mad r33, r8, cb0[7], r33
	
	mul r34, r8, cb0[2]
	mad r34, r4, cb0[3], r34
	
	mul r35, r8, cb0[6]
	mad r35, r4, cb0[7], r35
		
	dp4 r32.x, r32, r32.1111
	dp4 r32.y, r33, r33.1111
	dp4 r32.z, r34, r34.1111
	dp4 r32.w, r35, r35.1111
	
	; ****
	
	mul r33, r13, cb0[2]
	mad r33, r9, cb0[3], r33
	
	mul r34, r13, cb0[6]
	mad r34, r9, cb0[7], r34
	
	mul r35, r9, cb0[2]
	mad r35, r5, cb0[3], r35
	
	mul r36, r9, cb0[6]
	mad r36, r5, cb0[7], r36
		
	dp4 r33.x, r33, r33.1111
	dp4 r33.y, r34, r34.1111
	dp4 r33.z, r35, r35.1111
	dp4 r33.w, r36, r36.1111
break

endswitch

ret
endfunc

end
]]>
	</ILKernel>
	
<ILKernel name = "Convolve3DY9Down2_R">
<![CDATA[
il_cs_2_0
dcl_num_thread_per_group 64
;
;	Convolve 3D virtualized array along Y direction with up to 9 taps FIR filter and downsampling by 2
; 
;	inputs: 1
;	outputs: 0
;	global buffer: Yes
;	data type: REAL
;	nComponents: 4
;	constants: 2, 12x4 (REAL) and 3x4 (LONGINT)
;

dcl_cb cb0[12]	; [h0,h1,h2,h3],[h4,h5,h6,h7],[h8,0,0,0]
					; [0,h0,h1,h2],[h3,h4,h5,h6],[h7,h8,0,0]
					; [0,0,h0,h1],[h2,h3,h4,h5],[h6,h7,h8,0]
					; [0,0,0,h0],[h1,h2,h3,h4],[h5,h6,h7,h8]	
					
dcl_cb cb1[3]	; [hotSpot,widthSrc,physWidth,xPitch], [boundary,(widthSrc DIV 4)*4,widthDst,Nz]
					; [phase,...]

; hotSpot - has to be aligned to be multiple of 4
; widthSrc/Dst - is the line width

dcl_resource_id(0)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)

dcl_literal l0, 4, 0xFFFFFFFF, 1, 0

imul r0.x, cb1[1].w, cb1[0].w ; Nz*xPitch
ilt r0.z, vaTid.x, r0.x ; check thread index!
if_logicalnz r0.z

	; in this case we have Nz*xPitch threads, thus the thread index is represented by i*xPitch + j
	udiv r0.y, vaTid.x, cb1[0].w ; i
	umod r0.x, vaTid.x, cb1[0].w ; j
	
	; position of first output quad
	imul r0.z, cb1[1].z, cb1[0].w ; widthDst*xpitch
	imad r0.z, r0.y, r0.z, r0.x ; i*widthDst*xPitch + j (in quads)
	; last output quad
	udiv r0.w, cb1[1].z, l0.x ; widthDst DIV 4
	imul r0.w, r0.w, l0.x ; (widthDst DIV 4)*4
	imad r0.w, r0.w, cb1[0].w, r0.z ; ind0 + (widthDst DIV 4)*4*xPitch
		
	; compute first quad position in the input
	imul r1.z, cb1[0].y, cb1[0].w ; widthSrc*xpitch
	imad r0.x, r0.y, r1.z, r0.x ; i*widthSrc*xPitch + j (in quads)
	
	imul r0.y, cb1[0].x, l0.y ; -hotSpot ; first input index
			
	; load first 4 input quads
	call 0
	iadd r0.y, r0.y, l0.x ; increment input index
	mov r6, r2
	mov r7, r3
	mov r8, r4
	mov r9, r5
	call 0
	iadd r0.y, r0.y, l0.x ; increment input index
	
	whileloop
		
		ige r1.z, r0.z, r0.w ; ind >= ind0 + (widthDst DIV 4)*4*xPitch
		break_logicalnz r1.z
		
		mov r14, r6
		mov r15, r7
		mov r16, r8
		mov r17, r9
		
		mov r10, r2
		mov r11, r3
		mov r12, r4
		mov r13, r5
		
		call 0 ; load next input quads
		iadd r0.y, r0.y, l0.x ; increment input index
		mov r6, r2
		mov r7, r3
		mov r8, r4
		mov r9, r5
		call 0 ; load next input quads
		iadd r0.y, r0.y, l0.x ; increment input index
		
		call 1 ; compute output quads
	
		; transpose quads
		transpose r30, r30
		
		iadd r1.x, r0.z, cb1[0].w
		iadd r1.y, r1.x, cb1[0].w
		iadd r1.z, r1.y, cb1[0].w				
		
		; write to the output		
		mov g[r0.z], r30
		mov g[r1.x], r31
		mov g[r1.y], r32
		mov g[r1.z], r33
	
		iadd r0.z, r1.z, cb1[0].w ; increment output index
	endloop
	
	umod r0.w, cb1[1].z, l0.x ; account widthDst MOD 4 # 0
	if_logicalnz r0.w
		
		; process last quads
		
		mov r14, r6
		mov r15, r7
		mov r16, r8
		mov r17, r9
		
		mov r10, r2
		mov r11, r3
		mov r12, r4
		mov r13, r5
		
		call 0 ; load next input quads
		iadd r0.y, r0.y, l0.x ; increment input index
		mov r6, r2
		mov r7, r3
		mov r8, r4
		mov r9, r5
		call 0 ; load next input quads		
		
		call 1 ; compute output quads				
		
		; transpose quads
		transpose r30, r30
		
		iadd r1.x, r0.z, cb1[0].w
		iadd r1.y, r1.x, cb1[0].w
	
		switch r0.w		
			case 1
				mov g[r0.z], r30
				break
			case 2
				mov g[r0.z], r30
				mov g[r1.x], r31
				break
			case 3
				mov g[r0.z], r30
				mov g[r1.x], r31
				mov g[r1.y], r32
				break
		endswitch
				
	endif
	
endif

endmain

; get input quad with account of boundaries for 4 lines at once
; r0.x - linear position of the first line element with account of padding, in quads
; r0.y - index of input quad within the line, in single elements
; output is returned in r2, r3, r4, r5
; r1 is used for intermediate results
func 0

ige r1.z, r0.y, r0.0 ; ind >= 0
ilt r1.w, r0.y, cb1[1].y ; ind < (widthSrc DIV 4)*4
iand r1.w, r1.z, r1.w

if_logicalnz r1.w ; (ind >= 0) & (ind < (widthSrc DIV 4)*4) -> not on boundaries
	
	; 2D position of quads
	imad r1.x, r0.y, cb1[0].w, r0.x ; linear position of quad to load
	udiv r2.y, r1.x, cb1[0].z
	umod r2.x, r1.x, cb1[0].z
	
	iadd r1.x, r1.x, cb1[0].w ; ind + xPitch
	udiv r3.y, r1.x, cb1[0].z
	umod r3.x, r1.x, cb1[0].z
	
	iadd r1.x, r1.x, cb1[0].w
	udiv r4.y, r1.x, cb1[0].z
	umod r4.x, r1.x, cb1[0].z
	
	iadd r1.x, r1.x, cb1[0].w
	udiv r5.y, r1.x, cb1[0].z
	umod r5.x, r1.x, cb1[0].z
	
	itof r2, r2
	itof r3, r3
	itof r4, r4
	itof r5, r5
	
	sample_resource(0)_sampler(0) r2, r2.xy
	sample_resource(0)_sampler(0) r3, r3.xy
	sample_resource(0)_sampler(0) r4, r4.xy
	sample_resource(0)_sampler(0) r5, r5.xy
else
	
	mov r2, r2.0000
	mov r3, r3.0000
	mov r4, r4.0000
	mov r5, r5.0000
	
	if_logicalz r1.z ; left boundary
		 ; currently only FiniteData boundary		
	else ; right boundary		
		ige r1.z, r0.y, cb1[0].y
		if_logicalnz r1.z
			 ; currently only FiniteData boundary
		else
			
			; case when width is not multiple of 4 and there are still some data in the line
			
			; 2D position of quads
			imad r1.x, r0.y, cb1[0].w, r0.x ; linear position of quad to load
			udiv r2.y, r1.x, cb1[0].z
			umod r2.x, r1.x, cb1[0].z
			itof r2, r2
			
			umod r1.z, cb1[0].y, l0.x ; width MOD 4
			switch r1.z
				case 1
					sample_resource(0)_sampler(0) r2, r2.xy					
				break
				
				case 2
					iadd r1.x, r1.x, cb1[0].w ; ind + xPitch
					udiv r3.y, r1.x, cb1[0].z
					umod r3.x, r1.x, cb1[0].z
					itof r3, r3
					sample_resource(0)_sampler(0) r2, r2.xy
					sample_resource(0)_sampler(0) r3, r3.xy
				break
				
				case 3
					iadd r1.x, r1.x, cb1[0].w ; ind + xPitch
					udiv r3.y, r1.x, cb1[0].z
					umod r3.x, r1.x, cb1[0].z
		
					iadd r1.x, r1.x, cb1[0].w
					udiv r4.y, r1.x, cb1[0].z
					umod r4.x, r1.x, cb1[0].z
					itof r3, r3
					itof r4, r4
					sample_resource(0)_sampler(0) r2, r2.xy
					sample_resource(0)_sampler(0) r3, r3.xy
					sample_resource(0)_sampler(0) r4, r4.xy
				break
			endswitch						
		endif
	endif
	
endif

; transpose quads
transpose r2, r2

ret
endfunc

; compute 4 output quads
; {r14,r15,r16,r17}, {r10,r11,r12,r13}, {r6,r7,r8,r9}, {r2,r3,r4,r5} - input quads
; output is stored in {r30,r31,r32,r33}
; uses r34,r35,r36 for intermediate results
func 1

switch cb1[2].x

case 0

	mul r30, r14, cb0[0]
	mad r30, r10, cb0[1], r30
	mad r30, r6, cb0[2], r30
	
	mul r31, r14, cb0[6]
	mad r31, r10, cb0[7], r31
	mad r31, r6, cb0[8], r31
	
	mul r32, r10, cb0[0]
	mad r32, r6, cb0[1], r32
	mad r32, r2, cb0[2], r32
	
	mul r33, r10, cb0[6]
	mad r33, r6, cb0[7], r33
	mad r33, r2, cb0[8], r33
		
	dp4 r30.x, r30, r30.1111
	dp4 r30.y, r31, r31.1111
	dp4 r30.z, r32, r32.1111
	dp4 r30.w, r33, r33.1111
	
	; ****
	
	mul r31, r15, cb0[0]
	mad r31, r11, cb0[1], r31
	mad r31, r7, cb0[2], r31
	
	mul r32, r15, cb0[6]
	mad r32, r11, cb0[7], r32
	mad r32, r7, cb0[8], r32
	
	mul r33, r11, cb0[0]
	mad r33, r7, cb0[1], r33
	mad r33, r3, cb0[2], r33
	
	mul r34, r11, cb0[6]
	mad r34, r7, cb0[7], r34
	mad r34, r3, cb0[8], r34
		
	dp4 r31.x, r31, r31.1111
	dp4 r31.y, r32, r32.1111
	dp4 r31.z, r33, r33.1111
	dp4 r31.w, r34, r34.1111
	
	; ****
	
	mul r32, r16, cb0[0]
	mad r32, r12, cb0[1], r32
	mad r32, r8, cb0[2], r32
	
	mul r33, r16, cb0[6]
	mad r33, r12, cb0[7], r33
	mad r33, r8, cb0[8], r33
	
	mul r34, r12, cb0[0]
	mad r34, r8, cb0[1], r34
	mad r34, r4, cb0[2], r34
	
	mul r35, r12, cb0[6]
	mad r35, r8, cb0[7], r35
	mad r35, r4, cb0[8], r35
		
	dp4 r32.x, r32, r32.1111
	dp4 r32.y, r33, r33.1111
		dp4 r32.z, r34, r34.1111
	dp4 r32.w, r35, r35.1111
	
	; ****
	
	mul r33, r17, cb0[0]
	mad r33, r13, cb0[1], r33
	mad r33, r9, cb0[2], r33
	
	mul r34, r17, cb0[6]
	mad r34, r13, cb0[7], r34
	mad r34, r9, cb0[8], r34
	
	mul r35, r13, cb0[0]
	mad r35, r9, cb0[1], r35
	mad r35, r5, cb0[2], r35
	
	mul r36, r13, cb0[6]
	mad r36, r9, cb0[7], r36
	mad r36, r5, cb0[8], r36
		
	dp4 r33.x, r33, r33.1111
	dp4 r33.y, r34, r34.1111
	dp4 r33.z, r35, r35.1111
	dp4 r33.w, r36, r36.1111
	break
	
case 1
	
	mul r30, r14, cb0[3]
	mad r30, r10, cb0[4], r30
	mad r30, r6, cb0[5], r30
	
	mul r31, r14, cb0[9]
	mad r31, r10, cb0[10], r31
	mad r31, r6, cb0[11], r31
	
	mul r32, r10, cb0[3]
	mad r32, r6, cb0[4], r32
	mad r32, r2, cb0[5], r32
	
	mul r33, r10, cb0[9]
	mad r33, r6, cb0[10], r33
	mad r33, r2, cb0[11], r33
		
	dp4 r30.x, r30, r30.1111
	dp4 r30.y, r31, r31.1111
	dp4 r30.z, r32, r32.1111
	dp4 r30.w, r33, r33.1111
	
	; ****
	
	mul r31, r15, cb0[3]
	mad r31, r11, cb0[4], r31
	mad r31, r7, cb0[5], r31
	
	mul r32, r15, cb0[9]
	mad r32, r11, cb0[10], r32
	mad r32, r7, cb0[11], r32
	
	mul r33, r11, cb0[3]
	mad r33, r7, cb0[4], r33
	mad r33, r3, cb0[5], r33
	
	mul r34, r11, cb0[9]
	mad r34, r7, cb0[10], r34
	mad r34, r3, cb0[11], r34
		
	dp4 r31.x, r31, r31.1111
	dp4 r31.y, r32, r32.1111
	dp4 r31.z, r33, r33.1111
	dp4 r31.w, r34, r34.1111
	
	; ****
	
	mul r32, r16, cb0[3]
	mad r32, r12, cb0[4], r32
	mad r32, r8, cb0[5], r32

	mul r33, r16, cb0[9]
	mad r33, r12, cb0[10], r33
	mad r33, r8, cb0[11], r33
	
	mul r34, r12, cb0[3]
	mad r34, r8, cb0[4], r34
	mad r34, r4, cb0[5], r34
	
	mul r35, r12, cb0[9]
	mad r35, r8, cb0[10], r35
	mad r35, r4, cb0[11], r35
		
	dp4 r32.x, r32, r32.1111
	dp4 r32.y, r33, r33.1111
	dp4 r32.z, r34, r34.1111
	dp4 r32.w, r35, r35.1111
	
	; ****
	
	mul r33, r17, cb0[3]
	mad r33, r13, cb0[4], r33
	mad r33, r9, cb0[5], r33
	
	mul r34, r17, cb0[9]
	mad r34, r13, cb0[10], r34
	mad r34, r9, cb0[11], r34
	
	mul r35, r13, cb0[3]
	mad r35, r9, cb0[4], r35
	mad r35, r5, cb0[5], r35
	
	mul r36, r13, cb0[9]
	mad r36, r9, cb0[10], r36
	mad r36, r5, cb0[11], r36
		
	dp4 r33.x, r33, r33.1111
	dp4 r33.y, r34, r34.1111
	dp4 r33.z, r35, r35.1111
	dp4 r33.w, r36, r36.1111
break

endswitch

ret
endfunc

end
]]>
	</ILKernel>
	
<ILKernel name = "ConvolveNDZ5Down2_R">
<![CDATA[
il_cs_2_0
dcl_num_thread_per_group 64
;
;	Convolve ND virtualized array along Z (first) direction with up to 5 taps FIR filter and downsampling by 2
; 
;	inputs: 1
;	outputs: 0
;	global buffer: Yes
;	data type: REAL
;	nComponents: 4
;	constants: 2, 8x4 (REAL) and 2x4 (LONGINT)
;

dcl_cb cb0[8]	; [h0,h1,h2,h3],[h4,0,0,0]
					; [0,h0,h1,h2],[h3,h4,0,0]
					; [0,0,h0,h1],[h2,h3,h4,0]
					; [0,0,0,h0],[h1,h2,h3,h4]
					
dcl_cb cb1[3]	; [hotSpot,widthSrc,physWidth,xPitch], [boundary,(widthSrc DIV 4)*4,Ny*xPitch,widthDst]
					; [phase,...]

; hotSpot - has to be aligned to be multiple of 4
; width - is the line width

dcl_resource_id(0)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)

dcl_literal l0, 4, 0xFFFFFFFF, 1, 0

ilt r0.z, vaTid.x, cb1[1].z ; check thread index!
if_logicalnz r0.z

	; in this case we have Ny*xPitch threads
	mov r0.x, vaTid.x ; position of first input quad (in quads)
	imul r0.y, cb1[0].x, l0.y ; -hotSpot ; first input index
	
	mov r0.z, r0.x ; position of curent output quad
	udiv r0.w, cb1[1].w, l0.x ; widthDst DIV 4
	imul r0.w, r0.w, l0.x ; (widthDst DIV 4)*4
	imad r0.w, r0.w, cb1[1].z, r0.z ; ind0 + (widthDst DIV 4)*4*Ny*xPitch
	
	; load first 4 input quads
	call 0
	iadd r0.y, r0.y, l0.x ; increment input index	
	
	whileloop
				
		ige r1.z, r0.z, r0.w ; ind >= ind0 + (widthDst DIV 4)*4*Ny*xPitch
		break_logicalnz r1.z
		
		mov r10, r2
		mov r11, r3
		mov r12, r4
		mov r13, r5
		
		call 0 ; load next input quads
		iadd r0.y, r0.y, l0.x ; increment input index
		mov r6, r2
		mov r7, r3
		mov r8, r4
		mov r9, r5
		call 0 ; load next input quads
		iadd r0.y, r0.y, l0.x ; increment input index
				
		call 1 ; compute output quads
		
		; transpose quads
		transpose r30, r30
		
		iadd r1.x, r0.z, cb1[1].z
		iadd r1.y, r1.x, cb1[1].z
		iadd r1.z, r1.y, cb1[1].z
		
		; write to the output
		mov g[r0.z], r30
		mov g[r1.x], r31
		mov g[r1.y], r32
		mov g[r1.z], r33
	
		iadd r0.z, r1.z, cb1[1].z ; increment output index
	endloop

	umod r0.w, cb1[1].w, l0.x ; account widthDst MOD 4 # 0
	if_logicalnz r0.w
		
		; process last quads
		
		mov r10, r2
		mov r11, r3
		mov r12, r4
		mov r13, r5
		
		call 0 ; load next input quads
		iadd r0.y, r0.y, l0.x ; increment input index
		mov r6, r2
		mov r7, r3
		mov r8, r4
		mov r9, r5
		call 0 ; load next input quads		
		
		call 1 ; compute output quads
		
		; transpose quads
		transpose r30, r30
		
		iadd r1.x, r0.z, cb1[1].z
		iadd r1.y, r1.x, cb1[1].z
	
		switch r0.w		
			case 1
				mov g[r0.z], r30
				break
			case 2
				mov g[r0.z], r30
				mov g[r1.x], r31
				break
			case 3
				mov g[r0.z], r30
				mov g[r1.x], r31
				mov g[r1.y], r32
				break
		endswitch
				
	endif;

endif; 

endmain

; get input quad with account of boundaries for 4 lines at once
; r0.x - linear position of the first line element with account of padding, in quads
; r0.y - index of input quad within the line, in single elements
; output is returned in r2, r3, r4, r5
; r1 is used for intermediate results
func 0

ige r1.z, r0.y, r0.0 ; ind >= 0
ilt r1.w, r0.y, cb1[1].y ; ind < (widthSrc DIV 4)*4
iand r1.w, r1.z, r1.w

if_logicalnz r1.w ; (ind >= 0) & (ind < (widthSrc DIV 4)*4) -> not on boundaries
	
	; 2D position of quads
	imad r1.x, r0.y, cb1[1].z, r0.x ; linear position of quad to load
	udiv r3.y, r1.x, cb1[0].z
	umod r3.x, r1.x, cb1[0].z
	
	iadd r1.x, r1.x, cb1[1].z ; ind + Ny*xPitch
	udiv r4.y, r1.x, cb1[0].z
	umod r4.x, r1.x, cb1[0].z
	
	iadd r1.x, r1.x, cb1[1].z
	udiv r5.y, r1.x, cb1[0].z
	umod r5.x, r1.x, cb1[0].z
	
	iadd r1.x, r1.x, cb1[1].z
	udiv r1.y, r1.x, cb1[0].z
	umod r1.x, r1.x, cb1[0].z
	
	itof r3, r3
	itof r4, r4
	itof r5, r5
	itof r1, r1
	
	sample_resource(0)_sampler(0) r2, r3.xy
	sample_resource(0)_sampler(0) r3, r4.xy
	sample_resource(0)_sampler(0) r4, r5.xy
	sample_resource(0)_sampler(0) r5, r1.xy
else
	
	mov r2, r2.0000
	mov r3, r3.0000
	mov r4, r4.0000
	mov r5, r5.0000
	
	if_logicalz r1.z ; left boundary
		 ; currently only FiniteData boundary		
	else ; right boundary		
		ige r1.z, r0.y, cb1[0].y
		if_logicalnz r1.z
			 ; currently only FiniteData boundary
		else
			
			; case when width is not multiple of 4 and there are still some data in the line
			
			; 2D position of quads
			imad r1.x, r0.y, cb1[1].z, r0.x ; linear position of quad to load
			udiv r2.y, r1.x, cb1[0].z
			umod r2.x, r1.x, cb1[0].z			
			itof r2, r2		
			
			umod r1.z, cb1[0].y, l0.x ; width MOD 4
			switch r1.z
				case 1					
					sample_resource(0)_sampler(0) r2, r2.xy					
				break
				
				case 2
					iadd r1.x, r1.x, cb1[1].z ; ind + Ny*xPitch			
					udiv r3.y, r1.x, cb1[0].z
					umod r3.x, r1.x, cb1[0].z
					
					itof r3, r3
					sample_resource(0)_sampler(0) r2, r2.xy
					sample_resource(0)_sampler(0) r3, r3.xy
				break
				
				case 3
					iadd r1.x, r1.x, cb1[1].z ; ind + Ny*xPitch			
					udiv r3.y, r1.x, cb1[0].z
					umod r3.x, r1.x, cb1[0].z
		
					iadd r1.x, r1.x, cb1[1].z
					udiv r4.y, r1.x, cb1[0].z
					umod r4.x, r1.x, cb1[0].z
					
					itof r3, r3
					itof r4, r4					
					sample_resource(0)_sampler(0) r2, r2.xy
					sample_resource(0)_sampler(0) r3, r3.xy
					sample_resource(0)_sampler(0) r4, r4.xy
				break
			endswitch						
		endif
	endif
	
endif

; transpose quads
transpose r2, r2

ret
endfunc

; compute 4 output quads
; {r10,r11,r12,r13}, {r6,r7,r8,r9}, {r2,r3,r4,r5} - input quads
; output is stored in {r30,r31,r32,r33}
; uses r34,r35,r36 for intermediate results
func 1

switch cb1[2].x

case 0
	mul r30, r10, cb0[0]
	mad r30, r6, cb0[1], r30
	
	mul r31, r10, cb0[4]
	mad r31, r6, cb0[5], r31
	
	mul r32, r6, cb0[0]
	mad r32, r2, cb0[1], r32
	
	mul r33, r6, cb0[4]
	mad r33, r2, cb0[5], r33
		
	dp4 r30.x, r30, r30.1111
	dp4 r30.y, r31, r31.1111
	dp4 r30.z, r32, r32.1111
	dp4 r30.w, r33, r33.1111
	
	; ****
	
	mul r31, r11, cb0[0]
	mad r31, r7, cb0[1], r31
	
	mul r32, r11, cb0[4]
	mad r32, r7, cb0[5], r32
	
	mul r33, r7, cb0[0]
	mad r33, r3, cb0[1], r33
	
	mul r34, r7, cb0[4]
	mad r34, r3, cb0[5], r34
		
	dp4 r31.x, r31, r31.1111
	dp4 r31.y, r32, r32.1111
	dp4 r31.z, r33, r33.1111
	dp4 r31.w, r34, r34.1111
	
	; ****
	
	mul r32, r12, cb0[0]
	mad r32, r8, cb0[1], r32
	
	mul r33, r12, cb0[4]
	mad r33, r8, cb0[5], r33
	
	mul r34, r8, cb0[0]
	mad r34, r4, cb0[1], r34
	
	mul r35, r8, cb0[4]
	mad r35, r4, cb0[5], r35
		
	dp4 r32.x, r32, r32.1111
	dp4 r32.y, r33, r33.1111
	dp4 r32.z, r34, r34.1111
	dp4 r32.w, r35, r35.1111
	
	; ****
	
	mul r33, r13, cb0[0]
	mad r33, r9, cb0[1], r33
	
	mul r34, r13, cb0[4]
	mad r34, r9, cb0[5], r34
	
	mul r35, r9, cb0[0]
	mad r35, r5, cb0[1], r35
	
	mul r36, r9, cb0[4]
	mad r36, r5, cb0[5], r36
		
	dp4 r33.x, r33, r33.1111
	dp4 r33.y, r34, r34.1111
	dp4 r33.z, r35, r35.1111
	dp4 r33.w, r36, r36.1111
break

case 1

	mul r30, r10, cb0[2]
	mad r30, r6, cb0[3], r30
	
	mul r31, r10, cb0[6]
	mad r31, r6, cb0[7], r31
	
	mul r32, r6, cb0[2]
	mad r32, r2, cb0[3], r32
	
	mul r33, r6, cb0[6]
	mad r33, r2, cb0[7], r33
		
	dp4 r30.x, r30, r30.1111
	dp4 r30.y, r31, r31.1111
	dp4 r30.z, r32, r32.1111
	dp4 r30.w, r33, r33.1111
	
	; ****
	
	mul r31, r11, cb0[2]
	mad r31, r7, cb0[3], r31
	
	mul r32, r11, cb0[6]
	mad r32, r7, cb0[7], r32
	
	mul r33, r7, cb0[2]
	mad r33, r3, cb0[3], r33
	
	mul r34, r7, cb0[6]
	mad r34, r3, cb0[7], r34
		
	dp4 r31.x, r31, r31.1111
	dp4 r31.y, r32, r32.1111
	dp4 r31.z, r33, r33.1111
	dp4 r31.w, r34, r34.1111
	
	; ****
	
	mul r32, r12, cb0[2]
	mad r32, r8, cb0[3], r32
	
	mul r33, r12, cb0[6]
	mad r33, r8, cb0[7], r33
	
	mul r34, r8, cb0[2]
	mad r34, r4, cb0[3], r34
	
	mul r35, r8, cb0[6]
	mad r35, r4, cb0[7], r35
		
	dp4 r32.x, r32, r32.1111
	dp4 r32.y, r33, r33.1111
	dp4 r32.z, r34, r34.1111
	dp4 r32.w, r35, r35.1111
	
	; ****
	
	mul r33, r13, cb0[2]
	mad r33, r9, cb0[3], r33
	
	mul r34, r13, cb0[6]
	mad r34, r9, cb0[7], r34
	
	mul r35, r9, cb0[2]
	mad r35, r5, cb0[3], r35
	
	mul r36, r9, cb0[6]
	mad r36, r5, cb0[7], r36
		
	dp4 r33.x, r33, r33.1111
	dp4 r33.y, r34, r34.1111
	dp4 r33.z, r35, r35.1111
	dp4 r33.w, r36, r36.1111
break

endswitch

ret
endfunc

end
]]>
	</ILKernel>
	
<ILKernel name = "ConvolveNDZ9Down2_R">
<![CDATA[
il_cs_2_0
dcl_num_thread_per_group 64
;
;	Convolve ND virtualized array along Z (first) direction with up to 9 taps FIR filter and downsampling by 2
; 
;	inputs: 1
;	outputs: 0
;	global buffer: Yes
;	data type: REAL
;	nComponents: 4
;	constants: 2, 8x4 (REAL) and 2x4 (LONGINT)
;

dcl_cb cb0[12]	; [h0,h1,h2,h3],[h4,h5,h6,h7],[h8,0,0,0]
					; [0,h0,h1,h2],[h3,h4,h5,h6],[h7,h8,0,0]
					; [0,0,h0,h1],[h2,h3,h4,h5],[h6,h7,h8,0]
					; [0,0,0,h0],[h1,h2,h3,h4],[h5,h6,h7,h8]
					
dcl_cb cb1[3]	; [hotSpot,widthSrc,physWidth,xPitch], [boundary,(widthSrc DIV 4)*4,Ny*xPitch,widthDst]
					; [phase,...]

; hotSpot - has to be aligned to be multiple of 4
; width - is the line width

dcl_resource_id(0)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)

dcl_literal l0, 4, 0xFFFFFFFF, 1, 0

ilt r0.z, vaTid.x, cb1[1].z ; check thread index!
if_logicalnz r0.z

	; in this case we have Ny*xPitch threads
	mov r0.x, vaTid.x ; position of first input quad (in quads)
	imul r0.y, cb1[0].x, l0.y ; -hotSpot ; first input index
	
	mov r0.z, r0.x ; position of curent output quad
	udiv r0.w, cb1[1].w, l0.x ; widthDst DIV 4
	imul r0.w, r0.w, l0.x ; (widthDst DIV 4)*4
	imad r0.w, r0.w, cb1[1].z, r0.z ; ind0 + (widthDst DIV 4)*4*Ny*xPitch
	
	; load first 4 input quads
	call 0
	iadd r0.y, r0.y, l0.x ; increment input index
	mov r6, r2
	mov r7, r3
	mov r8, r4
	mov r9, r5
	call 0
	iadd r0.y, r0.y, l0.x ; increment input index
	
	whileloop
				
		ige r1.z, r0.z, r0.w ; ind >= ind0 + (widthDst DIV 4)*4*Ny*xPitch
		break_logicalnz r1.z
		
		mov r14, r6
		mov r15, r7
		mov r16, r8
		mov r17, r9
		
		mov r10, r2
		mov r11, r3
		mov r12, r4
		mov r13, r5
		
		call 0 ; load next input quads
		iadd r0.y, r0.y, l0.x ; increment input index
		mov r6, r2
		mov r7, r3
		mov r8, r4
		mov r9, r5
		call 0 ; load next input quads
		iadd r0.y, r0.y, l0.x ; increment input index
				
		call 1 ; compute output quads
		
		; transpose quads
		transpose r30, r30
		
		iadd r1.x, r0.z, cb1[1].z
		iadd r1.y, r1.x, cb1[1].z
		iadd r1.z, r1.y, cb1[1].z
		
		; write to the output
		mov g[r0.z], r30
		mov g[r1.x], r31
		mov g[r1.y], r32
		mov g[r1.z], r33
	
		iadd r0.z, r1.z, cb1[1].z ; increment output index
	endloop

	umod r0.w, cb1[1].w, l0.x ; account widthDst MOD 4 # 0
	if_logicalnz r0.w
		
		; process last quads
		
		mov r14, r6
		mov r15, r7
		mov r16, r8
		mov r17, r9
		
		mov r10, r2
		mov r11, r3
		mov r12, r4
		mov r13, r5
		
		call 0 ; load next input quads
		iadd r0.y, r0.y, l0.x ; increment input index
		mov r6, r2
		mov r7, r3
		mov r8, r4
		mov r9, r5
		call 0 ; load next input quads		
		
		call 1 ; compute output quads
		
		; transpose quads
		transpose r30, r30
		
		iadd r1.x, r0.z, cb1[1].z
		iadd r1.y, r1.x, cb1[1].z
	
		switch r0.w		
			case 1
				mov g[r0.z], r30
				break
			case 2
				mov g[r0.z], r30
				mov g[r1.x], r31
				break
			case 3
				mov g[r0.z], r30
				mov g[r1.x], r31
				mov g[r1.y], r32
				break
		endswitch
				
	endif;

endif; 

endmain

; get input quad with account of boundaries for 4 lines at once
; r0.x - linear position of the first line element with account of padding, in quads
; r0.y - index of input quad within the line, in single elements
; output is returned in r2, r3, r4, r5
; r1 is used for intermediate results
func 0

ige r1.z, r0.y, r0.0 ; ind >= 0
ilt r1.w, r0.y, cb1[1].y ; ind < (widthSrc DIV 4)*4
iand r1.w, r1.z, r1.w

if_logicalnz r1.w ; (ind >= 0) & (ind < (widthSrc DIV 4)*4) -> not on boundaries
	
	; 2D position of quads
	imad r1.x, r0.y, cb1[1].z, r0.x ; linear position of quad to load
	udiv r3.y, r1.x, cb1[0].z
	umod r3.x, r1.x, cb1[0].z
	
	iadd r1.x, r1.x, cb1[1].z ; ind + Ny*xPitch
	udiv r4.y, r1.x, cb1[0].z
	umod r4.x, r1.x, cb1[0].z
	
	iadd r1.x, r1.x, cb1[1].z
	udiv r5.y, r1.x, cb1[0].z
	umod r5.x, r1.x, cb1[0].z
	
	iadd r1.x, r1.x, cb1[1].z
	udiv r1.y, r1.x, cb1[0].z
	umod r1.x, r1.x, cb1[0].z
	
	itof r3, r3
	itof r4, r4
	itof r5, r5
	itof r1, r1
	
	sample_resource(0)_sampler(0) r2, r3.xy
	sample_resource(0)_sampler(0) r3, r4.xy
	sample_resource(0)_sampler(0) r4, r5.xy
	sample_resource(0)_sampler(0) r5, r1.xy
else
	
	mov r2, r2.0000
	mov r3, r3.0000
	mov r4, r4.0000
	mov r5, r5.0000
	
	if_logicalz r1.z ; left boundary
		 ; currently only FiniteData boundary		
	else ; right boundary		
		ige r1.z, r0.y, cb1[0].y
		if_logicalnz r1.z
			 ; currently only FiniteData boundary
		else
			
			; case when width is not multiple of 4 and there are still some data in the line
			
			; 2D position of quads
			imad r1.x, r0.y, cb1[1].z, r0.x ; linear position of quad to load
			udiv r2.y, r1.x, cb1[0].z
			umod r2.x, r1.x, cb1[0].z			
			itof r2, r2		
			
			umod r1.z, cb1[0].y, l0.x ; width MOD 4
			switch r1.z
				case 1					
					sample_resource(0)_sampler(0) r2, r2.xy					
				break
				
				case 2
					iadd r1.x, r1.x, cb1[1].z ; ind + Ny*xPitch			
					udiv r3.y, r1.x, cb1[0].z
					umod r3.x, r1.x, cb1[0].z
					
					itof r3, r3
					sample_resource(0)_sampler(0) r2, r2.xy
					sample_resource(0)_sampler(0) r3, r3.xy
				break
				
				case 3
					iadd r1.x, r1.x, cb1[1].z ; ind + Ny*xPitch			
					udiv r3.y, r1.x, cb1[0].z
					umod r3.x, r1.x, cb1[0].z
		
					iadd r1.x, r1.x, cb1[1].z
					udiv r4.y, r1.x, cb1[0].z
					umod r4.x, r1.x, cb1[0].z
					
					itof r3, r3
					itof r4, r4					
					sample_resource(0)_sampler(0) r2, r2.xy
					sample_resource(0)_sampler(0) r3, r3.xy
					sample_resource(0)_sampler(0) r4, r4.xy
				break
			endswitch						
		endif
	endif
	
endif

; transpose quads
transpose r2, r2

ret
endfunc

; compute 4 output quads
; {r14,r15,r16,r17}, {r10,r11,r12,r13}, {r6,r7,r8,r9}, {r2,r3,r4,r5} - input quads
; output is stored in {r30,r31,r32,r33}
; uses r34,r35,r36 for intermediate results
func 1

switch cb1[2].x

case 0

	mul r30, r14, cb0[0]
	mad r30, r10, cb0[1], r30
	mad r30, r6, cb0[2], r30
	
	mul r31, r14, cb0[6]
	mad r31, r10, cb0[7], r31
	mad r31, r6, cb0[8], r31
	
	mul r32, r10, cb0[0]
	mad r32, r6, cb0[1], r32
	mad r32, r2, cb0[2], r32
	
	mul r33, r10, cb0[6]
	mad r33, r6, cb0[7], r33
	mad r33, r2, cb0[8], r33
		
	dp4 r30.x, r30, r30.1111
	dp4 r30.y, r31, r31.1111
	dp4 r30.z, r32, r32.1111
	dp4 r30.w, r33, r33.1111
	
	; ****
	
	mul r31, r15, cb0[0]
	mad r31, r11, cb0[1], r31
	mad r31, r7, cb0[2], r31
	
	mul r32, r15, cb0[6]
	mad r32, r11, cb0[7], r32
	mad r32, r7, cb0[8], r32
	
	mul r33, r11, cb0[0]
	mad r33, r7, cb0[1], r33
	mad r33, r3, cb0[2], r33
	
	mul r34, r11, cb0[6]
	mad r34, r7, cb0[7], r34
	mad r34, r3, cb0[8], r34
		
	dp4 r31.x, r31, r31.1111
	dp4 r31.y, r32, r32.1111
	dp4 r31.z, r33, r33.1111
	dp4 r31.w, r34, r34.1111
	
	; ****
	
	mul r32, r16, cb0[0]
	mad r32, r12, cb0[1], r32
	mad r32, r8, cb0[2], r32
	
	mul r33, r16, cb0[6]
	mad r33, r12, cb0[7], r33
	mad r33, r8, cb0[8], r33
	
	mul r34, r12, cb0[0]
	mad r34, r8, cb0[1], r34
	mad r34, r4, cb0[2], r34
	
	mul r35, r12, cb0[6]
	mad r35, r8, cb0[7], r35
	mad r35, r4, cb0[8], r35
		
	dp4 r32.x, r32, r32.1111
	dp4 r32.y, r33, r33.1111
		dp4 r32.z, r34, r34.1111
	dp4 r32.w, r35, r35.1111
	
	; ****
	
	mul r33, r17, cb0[0]
	mad r33, r13, cb0[1], r33
	mad r33, r9, cb0[2], r33
	
	mul r34, r17, cb0[6]
	mad r34, r13, cb0[7], r34
	mad r34, r9, cb0[8], r34
	
	mul r35, r13, cb0[0]
	mad r35, r9, cb0[1], r35
	mad r35, r5, cb0[2], r35
	
	mul r36, r13, cb0[6]
	mad r36, r9, cb0[7], r36
	mad r36, r5, cb0[8], r36
		
	dp4 r33.x, r33, r33.1111
	dp4 r33.y, r34, r34.1111
	dp4 r33.z, r35, r35.1111
	dp4 r33.w, r36, r36.1111
	break
	
case 1
	
	mul r30, r14, cb0[3]
	mad r30, r10, cb0[4], r30
	mad r30, r6, cb0[5], r30
	
	mul r31, r14, cb0[9]
	mad r31, r10, cb0[10], r31
	mad r31, r6, cb0[11], r31
	
	mul r32, r10, cb0[3]
	mad r32, r6, cb0[4], r32
	mad r32, r2, cb0[5], r32
	
	mul r33, r10, cb0[9]
	mad r33, r6, cb0[10], r33
	mad r33, r2, cb0[11], r33
		
	dp4 r30.x, r30, r30.1111
	dp4 r30.y, r31, r31.1111
	dp4 r30.z, r32, r32.1111
	dp4 r30.w, r33, r33.1111
	
	; ****
	
	mul r31, r15, cb0[3]
	mad r31, r11, cb0[4], r31
	mad r31, r7, cb0[5], r31
	
	mul r32, r15, cb0[9]
	mad r32, r11, cb0[10], r32
	mad r32, r7, cb0[11], r32
	
	mul r33, r11, cb0[3]
	mad r33, r7, cb0[4], r33
	mad r33, r3, cb0[5], r33
	
	mul r34, r11, cb0[9]
	mad r34, r7, cb0[10], r34
	mad r34, r3, cb0[11], r34
		
	dp4 r31.x, r31, r31.1111
	dp4 r31.y, r32, r32.1111
	dp4 r31.z, r33, r33.1111
	dp4 r31.w, r34, r34.1111
	
	; ****
	
	mul r32, r16, cb0[3]
	mad r32, r12, cb0[4], r32
	mad r32, r8, cb0[5], r32

	mul r33, r16, cb0[9]
	mad r33, r12, cb0[10], r33
	mad r33, r8, cb0[11], r33
	
	mul r34, r12, cb0[3]
	mad r34, r8, cb0[4], r34
	mad r34, r4, cb0[5], r34
	
	mul r35, r12, cb0[9]
	mad r35, r8, cb0[10], r35
	mad r35, r4, cb0[11], r35
		
	dp4 r32.x, r32, r32.1111
	dp4 r32.y, r33, r33.1111
	dp4 r32.z, r34, r34.1111
	dp4 r32.w, r35, r35.1111
	
	; ****
	
	mul r33, r17, cb0[3]
	mad r33, r13, cb0[4], r33
	mad r33, r9, cb0[5], r33
	
	mul r34, r17, cb0[9]
	mad r34, r13, cb0[10], r34
	mad r34, r9, cb0[11], r34
	
	mul r35, r13, cb0[3]
	mad r35, r9, cb0[4], r35
	mad r35, r5, cb0[5], r35
	
	mul r36, r13, cb0[9]
	mad r36, r9, cb0[10], r36
	mad r36, r5, cb0[11], r36
		
	dp4 r33.x, r33, r33.1111
	dp4 r33.y, r34, r34.1111
	dp4 r33.z, r35, r35.1111
	dp4 r33.w, r36, r36.1111
break

endswitch

ret
endfunc

end
]]>
	</ILKernel>
	
<ILKernel name = "ConvolveNDX9Up2_R0">
<![CDATA[
il_cs_2_0
dcl_num_thread_per_group 64
;
;	Convolve ND virtualized array along X (last) direction with up to 9 taps FIR filter and downsample by 2
; 
;	inputs: 1
;	outputs: 0
;	global buffer: Yes
;	data type: REAL
;	nComponents: 4
;	constants: 2, 8x4 (REAL) and 3x4 (LONGINT)
;

dcl_cb cb0[12]	; [h0,h1,h2,h3],[h4,h5,h6,h7],[h8,0,0,0]
					; [0,h0,h1,h2],[h3,h4,h5,h6],[h7,h8,0,0]
					; [0,0,h0,h1],[h2,h3,h4,h5],[h6,h7,h8,0]
					; [0,0,0,h0],[h1,h2,h3,h4],[h5,h6,h7,h8]
					
dcl_cb cb1[3]	; [hotSpot,widthSrc,physWidth,xPitchSrc], [boundary,(widthSrc DIV 4)*4,widthDst,xPitchDst],
					; [phase,nLines,...]

; hotSpot - has to be aligned to be multiple of 4

dcl_resource_id(0)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)

dcl_literal l0, 4, 0xFFFFFFFF, 1, 2
dcl_literal l1, 8, 3, 0, 0

ilt r0.z, vaTid.x, cb1[2].y ; check thread index!
if_logicalnz r0.z

	umul r0.x, vaTid.x, cb1[0].w ; iLine*xPitchSrc -> index of the first line quad in the input
	udiv r0.y, cb1[0].x, l0.w ; hotSpot DIV 2
	umod r1.y, r0.y, l0.x ; (hotSpot DIV 2) MOD 4
	imul r0.y, r0.y, l0.y ; -(hotSpot DIV 2) ; first input index	
	
	imul r0.z, vaTid.x, cb1[1].w ; iLine*xPitchDst -> position of curent output quad
	
	udiv r0.w, cb1[1].z, l1.x
	umul r0.w, r0.w, l0.w
	
	iadd r0.w, r0.z, r0.w ; ind0+(widthDst DIV 8)*2 -> position of last output quad		
	
	; load first input quads
	call 0
	iadd r0.y, r0.y, l0.x ; increment input index
	
	if_logicalnz r1.y
		mov r3, r2
		call 0
		iadd r0.y, r0.y, l0.x ; increment input index
		
		call 1
		mov g[r0.z], r31
		iadd r0.z, r0.z, l0.z ; increment output index
		iadd r0.w, r0.w, l0.y
	endif
	
	whileloop
		
		ige r1.z, r0.z, r0.w ; ind >= ind0+(widthDst DIV 8)*2 (-1)
		break_logicalnz r1.z
		
		mov r3, r2
			
		call 0 ; load next input quad
		iadd r0.y, r0.y, l0.x ; increment input index	
	
		call 1 ; compute output quads
		; store output quads
				
		mov g[r0.z], r30
		mov g[r0.z+1], r31									
		iadd r0.z, r0.z, l0.w ; increment output index
	endloop
	
	if_logicalnz r1.y ; account (hotSpot MOD 8) # 0
		mov r3, r2
		call 0 ; load next input quad
		iadd r0.y, r0.y, l0.x ; increment input index
		call 1 ; compute output quads		
		mov g[r0.z], r30
		iadd r0.z, r0.z, l0.z ; increment output index
	endif
	
	umod r0.w, cb1[1].z, l1.x ; account widthDst MOD 8 # 0
	if_logicalnz r0.w
		
;		; process last quads				
;		mov r3, r2
;		call 0 ; load next input quad
;		call 1
;								
;		switch r0.w
;			case 2
;				mov g[r0.z], r30.xy00
;				break
;			case 4
;				mov g[r0.z], r30
;				break
;			case 6
;				mov g[r0.z], r30
;				mov g[r0.z+1], r31.xy00
;				break
;		endswitch
	endif
			
;	umod r0.w, cb1[1].z, l0.x ; account padding -> widthDst MOD 4
;	if_logicalnz r0.w
;;		
;;		; last line quad
;;		mov r3, r2
;;		call 0 ; load next input quad
;;		call 1	
;;	
;;	;	switch r0.w
;;	;		case 1
;;	;			mov r30, r30.x000
;;	;			break
;;	;		case 2
;;	;			mov r30, r30.xy00
;;	;			break
;;	;		case 3
;;	;			mov r30, r30.xyz0
;;	;			break
;;	;	endswitch
;;	;	
;;	;	mov g[r0.z], r30 ; store output quad
;	
;	else
;		
;		if_logicalnz r1.y
;			mov r3, r2
;			call 0 ; load next input quad
;			iadd r0.y, r0.y, l0.x ; increment input index		
;			call 1 ; compute output quads		
;			mov g[r0.z], r30
;		endif	
;	endif;
	
endif

endmain

; get input quad with account of boundaries
; r0.x - linear position of the first line element with account of padding, in quads
; r0.y - index of input quad within the line, in single elements
; output is returned in r2
; r1 is used for intermediate results
func 0

ige r1.z, r0.y, r0.0 ; ind >= 0
;iadd r1.w, r0.y, l1.y
ilt r1.w, r0.y, cb1[1].y ; ind+3 < (widthSrc DIV 4)*4
iand r1.w, r1.z, r1.w

if_logicalnz r1.w ; (ind >= 0) & (ind+3 < (widthSrc DIV 4)*4) -> not on boundaries
	
	udiv r1.x, r0.y, l0.x ; index in quads
	iadd r1.x, r0.x, r1.x ; linear position of quad to load
	; 2D position of the quad
	udiv r2.y, r1.x, cb1[0].z
	umod r2.x, r1.x, cb1[0].z
	itof r2, r2
	sample_resource(0)_sampler(0) r2, r2.xy
else
	
	mov r2, r2.0000
	
	if_logicalz r1.z ; left boundary
		; currently only FiniteData boundary
	else ; right boundary		
		ige r1.z, r0.y, cb1[0].y ; ind >= widthSrc
		if_logicalnz r1.z
			; currently only FiniteData boundary
		else
			
			udiv r1.x, r0.y, l0.x ; index in quads
			iadd r1.x, r0.x, r1.x ; linear position of quad to load
			; 2D position of the quad
			udiv r2.y, r1.x, cb1[0].z
			umod r2.x, r1.x, cb1[0].z
			itof r2, r2
				
			imad r1.z, r0.y, l0.y, cb1[0].y ; widthSrc - ind
			switch r1.z
				case 1
					sample_resource(0)_sampler(0) r2.x000, r2.xy
					break
				
				case 2
					sample_resource(0)_sampler(0) r2.xy00, r2.xy
					break
					
				case 3
					sample_resource(0)_sampler(0) r2.xyz0, r2.xy
					break
					
				default
					sample_resource(0)_sampler(0) r2, r2.xy
					break			
			endswitch
			
;			; case when width is not multiple of 4 and there are still some data in the line
;			
;			udiv r1.x, r0.y, l0.x ; index in quads
;			iadd r1.x, r0.x, r1.x ; linear position of quad to load
;			; 2D position of the quad
;			udiv r2.y, r1.x, cb1[0].z
;			umod r2.x, r1.x, cb1[0].z
;			itof r2, r2		
;			
;			umod r1.z, cb1[0].y, l0.x ; widthSrc MOD 4
;			switch r1.z
;				case 1
;					sample_resource(0)_sampler(0) r2.x000, r2.xy
;				break
;				
;				case 2
;					sample_resource(0)_sampler(0) r2.xy00, r2.xy
;				break
;				
;				case 3
;					sample_resource(0)_sampler(0) r2.xyz0, r2.xy
;				break
;			endswitch
		endif
	endif
	
endif

ret
endfunc

; compute output quad
; r3, r2 - input quads
; output is stored in r30, r31
; uses r31, r32, r33, r34 for intermediate results
func 1

switch cb1[2].x ; phase

	case 0
		mul r30, r3.x0y0, cb0[0]
		mad r30, r3.z0w0, cb0[1], r30
		mad r30, r2.x0y0, cb0[2], r30
		
		mul r31, r3.x0y0, cb0[3]
		mad r31, r3.z0w0, cb0[4], r31
		mad r31, r2.x0y0, cb0[5], r31
		
		mul r32, r3.x0y0, cb0[6]
		mad r32, r3.z0w0, cb0[7], r32
		mad r32, r2.x0y0, cb0[8], r32
		
		mul r33, r3.x0y0, cb0[9]
		mad r33, r3.z0w0, cb0[10], r33
		mad r33, r2.x0y0, cb0[11], r33
		
		dp4 r30.x, r30, r30.1111
		dp4 r30.y, r31, r31.1111
		dp4 r30.z, r32, r32.1111
		dp4 r30.w, r33, r33.1111
		
		mul r31, r3.z0w0, cb0[0]
		mad r31, r2.x0y0, cb0[1], r31
		mad r31, r2.z0w0, cb0[2], r31
		
		mul r32, r3.z0w0, cb0[3]
		mad r32, r2.x0y0, cb0[4], r32
		mad r32, r2.z0w0, cb0[5], r32
		
		mul r33, r3.z0w0, cb0[6]
		mad r33, r2.x0y0, cb0[7], r33
		mad r33, r2.z0w0, cb0[8], r33
		
		mul r34, r3.z0w0, cb0[9]
		mad r34, r2.x0y0, cb0[10], r34
		mad r34, r2.z0w0, cb0[11], r34
		
		dp4 r31.x, r31, r31.1111
		dp4 r31.y, r32, r32.1111
		dp4 r31.z, r33, r33.1111
		dp4 r31.w, r34, r34.1111
	break
	
	case 1
		mul r30, r3.0x0y, cb0[0]
		mad r30, r3.0z0w, cb0[1], r30
		mad r30, r2.0x0y, cb0[2], r30
		
		mul r31, r3.0x0y, cb0[3]
		mad r31, r3.0z0w, cb0[4], r31
		mad r31, r2.0x0y, cb0[5], r31
		
		mul r32, r3.0x0y, cb0[6]
		mad r32, r3.0z0w, cb0[7], r32
		mad r32, r2.0x0y, cb0[8], r32
		
		mul r33, r3.0x0y, cb0[9]
		mad r33, r3.0z0w, cb0[10], r33
		mad r33, r2.0x0y, cb0[11], r33
		
		dp4 r30.x, r30, r30.1111
		dp4 r30.y, r31, r31.1111
		dp4 r30.z, r32, r32.1111
		dp4 r30.w, r33, r33.1111
		
		mul r31, r3.0z0w, cb0[0]
		mad r31, r2.0x0y, cb0[1], r31
		mad r31, r2.0z0w, cb0[2], r31
		
		mul r32, r3.0z0w, cb0[3]
		mad r32, r2.0x0y, cb0[4], r32
		mad r32, r2.0z0w, cb0[5], r32
		
		mul r33, r3.0z0w, cb0[6]
		mad r33, r2.0x0y, cb0[7], r33
		mad r33, r2.0z0w, cb0[8], r33
		
		mul r34, r3.0z0w, cb0[9]
		mad r34, r2.0x0y, cb0[10], r34
		mad r34, r2.0z0w, cb0[11], r34
		
		dp4 r31.x, r31, r31.1111
		dp4 r31.y, r32, r32.1111
		dp4 r31.z, r33, r33.1111
		dp4 r31.w, r34, r34.1111
	break
endswitch

ret
endfunc

end
]]>
	</ILKernel>
	
<ILKernel name = "ConvolveNDX9Up2_R">
<![CDATA[
il_cs_2_0
dcl_num_thread_per_group 64
;
;	Convolve ND virtualized array along X (last) direction with up to 9 taps FIR filter and downsample by 2
; 
;	inputs: 1
;	outputs: 0
;	global buffer: Yes
;	data type: REAL
;	nComponents: 4
;	constants: 2, 8x4 (REAL) and 3x4 (LONGINT)
;

dcl_cb cb0[12]	; [h0,h1,h2,h3],[h4,h5,h6,h7],[h8,0,0,0]
					; [0,h0,h1,h2],[h3,h4,h5,h6],[h7,h8,0,0]
					; [0,0,h0,h1],[h2,h3,h4,h5],[h6,h7,h8,0]
					; [0,0,0,h0],[h1,h2,h3,h4],[h5,h6,h7,h8]
					
dcl_cb cb1[3]	; [hotSpot,widthSrc,physWidth,xPitchSrc], [boundary,(widthSrc DIV 4)*4,widthDst,xPitchDst],
					; [phase,nLines,...]

; hotSpot - has to be aligned to be multiple of 4

dcl_resource_id(0)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)

dcl_literal l0, 4, 0xFFFFFFFF, 1, 2
dcl_literal l1, 8, 3, 0, 0

ilt r0.z, vaTid.x, cb1[2].y ; check thread index!
if_logicalnz r0.z

	umul r0.x, vaTid.x, cb1[0].w ; iLine*xPitchSrc -> index of the first line quad in the input
	udiv r0.y, cb1[0].x, l0.w ; hotSpot DIV 2
	umod r1.y, r0.y, l0.x ; (hotSpot DIV 2) MOD 4
	imul r0.y, r0.y, l0.y ; -(hotSpot DIV 2) ; first input index	
	
	imul r0.z, vaTid.x, cb1[1].w ; iLine*xPitchDst -> position of curent output quad
	
	udiv r0.w, cb1[1].z, l1.x
	umul r0.w, r0.w, l0.w	
	iadd r0.w, r0.z, r0.w ; ind0+(widthDst DIV 8)*2 -> position of last output quad		
	
	; load first input quad
	call 0
	iadd r0.y, r0.y, l0.x ; increment input index		
	
	whileloop
		
		ige r1.z, r0.z, r0.w ; ind >= ind0+(widthDst DIV 8)*2
		break_logicalnz r1.z
		
		mov r3, r2
			
		call 0 ; load next input quad
		iadd r0.y, r0.y, l0.x ; increment input index	
	
		call 1 ; compute output quads
		; store output quads
		
		;mov g[r0.z], r2.x0y0
		;mov g[r0.z+1], r2.z0w0
		
		mov g[r0.z], r30
		mov g[r0.z+1], r31
		iadd r0.z, r0.z, l0.w ; increment output index
	endloop
	
	umod r0.w, cb1[1].z, l1.x ; account widthDst MOD 8 # 0
	if_logicalnz r0.w
		
		; process last quads
				
		mov r3, r2			
		call 0 ; load next input quad
		iadd r0.y, r0.y, l0.x ; increment input index	
	
		call 1 ; compute output quads				
		
		switch r0.w		
			case 2
				mov g[r0.z], r30.xy00
				break
			case 4
				mov g[r0.z], r30
				break
			case 6
				mov g[r0.z], r30
				mov g[r0.z+1], r31.xy00
				break
		endswitch
				
	endif
	
endif

endmain

; get input quad with account of boundaries
; r0.x - linear position of the first line element with account of padding, in quads
; r0.y - index of input quad within the line, in single elements
; output is returned in r2
; r1, r4 used for intermediate results
func 0

ige r1.z, r0.y, r0.0 ; ind >= 0
iadd r1.w, r0.y, l1.y
ilt r1.w, r1.w, cb1[1].y ; ind+3 < (widthSrc DIV 4)*4
iand r1.w, r1.z, r1.w

if_logicalnz r1.w ; (ind >= 0) & (ind+3 < (widthSrc DIV 4)*4) -> not on boundaries		
	
	udiv r1.x, r0.y, l0.x ; index in quads
	iadd r1.x, r0.x, r1.x ; linear position of quad to load
	
	; 2D position of the quad
	udiv r2.y, r1.x, cb1[0].z
	umod r2.x, r1.x, cb1[0].z
	itof r2, r2
						
	if_logicalz r1.y				
		sample_resource(0)_sampler(0) r2, r2.xy
	else
		iadd r1.x, r1.x, l0.z
		udiv r4.y, r1.x, cb1[0].z
		umod r4.x, r1.x, cb1[0].z
		itof r4, r4
		
		sample_resource(0)_sampler(0) r2.__zw, r2.xy
		sample_resource(0)_sampler(0) r2.xy__, r4.xy
		mov r2.xyzw, r2.zwxy
	endif	
else
	
	mov r2, r2.0000
	
	if_logicalz r1.z ; left boundary
		; currently only FiniteData boundary
		
		 iadd r1.z, r0.y, l0.x ; ind + 4
		 ieq r1.z, r1.z, l0.w		 
		 if_logicalnz r1.z ; ind + 4 == 2 ; account case when (hotSpot DIV 2*4) # 0
		 		 					
			; 2D position of the quad
			udiv r2.y, r0.x, cb1[0].z
			umod r2.x, r0.x, cb1[0].z
			itof r2, r2
			
			sample_resource(0)_sampler(0) r2.xy__, r2.xy
			mov r2.00zw, r2.00xy
		 endif
		 
	else ; right boundary
		
		ige r1.z, r0.y, cb1[0].y ; ind >= widthSrc
		if_logicalnz r1.z
			; currently only FiniteData boundary
		else
		
			udiv r1.x, r0.y, l0.x ; index in quads
			iadd r1.x, r0.x, r1.x ; linear position of quad to load
	
			; 2D position of the quad
			udiv r2.y, r1.x, cb1[0].z
			umod r2.x, r1.x, cb1[0].z
			itof r2, r2
	
			imad r1.z, r0.y, l0.y, cb1[0].y ; widthSrc - ind
			switch r1.z
				
				case 1
					if_logicalz r1.y
						sample_resource(0)_sampler(0) r2.x___, r2.xy
					else
						sample_resource(0)_sampler(0) r2.__z_, r2.xy
						mov r2.x000, r2.z000 
					endif
					
					break
					
				case 2
					if_logicalz r1.y
						sample_resource(0)_sampler(0) r2.xy__, r2.xy
					else
						sample_resource(0)_sampler(0) r2.__zw, r2.xy
						mov r2.xy00, r2.zw00
					endif	
					break
					
				case 3
					if_logicalz r1.y
						sample_resource(0)_sampler(0) r2.xyz_, r2.xy
					else
						iadd r1.x, r1.x, l0.z
						udiv r4.y, r1.x, cb1[0].z
						umod r4.x, r1.x, cb1[0].z
						itof r4, r4
						sample_resource(0)_sampler(0) r2.__zw, r2.xy
						sample_resource(0)_sampler(0) r2.x___, r4.xy
						mov r2.xyz0, r2.zwx0
					endif					
					break
					
				default
					if_logicalz r1.y
						sample_resource(0)_sampler(0) r2, r2.xy
					else
						iadd r1.x, r1.x, l0.z
						udiv r4.y, r1.x, cb1[0].z
						umod r4.x, r1.x, cb1[0].z
						itof r4, r4
						sample_resource(0)_sampler(0) r2.__zw, r2.xy
						sample_resource(0)_sampler(0) r2.xy__, r4.xy
						mov r2.xyzw, r2.zwxy
					endif
					break			
			endswitch			
			
		endif
	endif
	
endif

ret
endfunc

; compute output quad
; r3, r2 - input quads
; output is stored in r30, r31
; uses r31, r32, r33, r34 for intermediate results
func 1

switch cb1[2].x ; phase

	case 0
		mul r30, r3.x0y0, cb0[0]
		mad r30, r3.z0w0, cb0[1], r30
		mad r30, r2.x0y0, cb0[2], r30
		
		mul r31, r3.x0y0, cb0[3]
		mad r31, r3.z0w0, cb0[4], r31
		mad r31, r2.x0y0, cb0[5], r31
		
		mul r32, r3.x0y0, cb0[6]
		mad r32, r3.z0w0, cb0[7], r32
		mad r32, r2.x0y0, cb0[8], r32
		
		mul r33, r3.x0y0, cb0[9]
		mad r33, r3.z0w0, cb0[10], r33
		mad r33, r2.x0y0, cb0[11], r33
		
		dp4 r30.x, r30, r30.1111
		dp4 r30.y, r31, r31.1111
		dp4 r30.z, r32, r32.1111
		dp4 r30.w, r33, r33.1111
		
		mul r31, r3.z0w0, cb0[0]
		mad r31, r2.x0y0, cb0[1], r31
		mad r31, r2.z0w0, cb0[2], r31
		
		mul r32, r3.z0w0, cb0[3]
		mad r32, r2.x0y0, cb0[4], r32
		mad r32, r2.z0w0, cb0[5], r32
		
		mul r33, r3.z0w0, cb0[6]
		mad r33, r2.x0y0, cb0[7], r33
		mad r33, r2.z0w0, cb0[8], r33
		
		mul r34, r3.z0w0, cb0[9]
		mad r34, r2.x0y0, cb0[10], r34
		mad r34, r2.z0w0, cb0[11], r34
		
		dp4 r31.x, r31, r31.1111
		dp4 r31.y, r32, r32.1111
		dp4 r31.z, r33, r33.1111
		dp4 r31.w, r34, r34.1111
	break
	
	case 1
		mul r30, r3.0x0y, cb0[0]
		mad r30, r3.0z0w, cb0[1], r30
		mad r30, r2.0x0y, cb0[2], r30
		
		mul r31, r3.0x0y, cb0[3]
		mad r31, r3.0z0w, cb0[4], r31
		mad r31, r2.0x0y, cb0[5], r31
		
		mul r32, r3.0x0y, cb0[6]
		mad r32, r3.0z0w, cb0[7], r32
		mad r32, r2.0x0y, cb0[8], r32
		
		mul r33, r3.0x0y, cb0[9]
		mad r33, r3.0z0w, cb0[10], r33
		mad r33, r2.0x0y, cb0[11], r33
		
		dp4 r30.x, r30, r30.1111
		dp4 r30.y, r31, r31.1111
		dp4 r30.z, r32, r32.1111
		dp4 r30.w, r33, r33.1111
		
		mul r31, r3.0z0w, cb0[0]
		mad r31, r2.0x0y, cb0[1], r31
		mad r31, r2.0z0w, cb0[2], r31
		
		mul r32, r3.0z0w, cb0[3]
		mad r32, r2.0x0y, cb0[4], r32
		mad r32, r2.0z0w, cb0[5], r32
		
		mul r33, r3.0z0w, cb0[6]
		mad r33, r2.0x0y, cb0[7], r33
		mad r33, r2.0z0w, cb0[8], r33
		
		mul r34, r3.0z0w, cb0[9]
		mad r34, r2.0x0y, cb0[10], r34
		mad r34, r2.0z0w, cb0[11], r34
		
		dp4 r31.x, r31, r31.1111
		dp4 r31.y, r32, r32.1111
		dp4 r31.z, r33, r33.1111
		dp4 r31.w, r34, r34.1111
	break
endswitch

ret
endfunc

end
]]>
	</ILKernel>	
	
<ILKernel name = "Convolve3DY9Up2_R">
<![CDATA[
il_cs_2_0
dcl_num_thread_per_group 64
;
;	Convolve 3D virtualized array along Y direction with up to 9 taps FIR filter and upsampling by 2
; 
;	inputs: 1
;	outputs: 0
;	global buffer: Yes
;	data type: REAL
;	nComponents: 4
;	constants: 2, 12x4 (REAL) and 3x4 (LONGINT)
;

dcl_cb cb0[12]	; [h0,h1,h2,h3],[h4,h5,h6,h7],[h8,0,0,0]
					; [0,h0,h1,h2],[h3,h4,h5,h6],[h7,h8,0,0]
					; [0,0,h0,h1],[h2,h3,h4,h5],[h6,h7,h8,0]
					; [0,0,0,h0],[h1,h2,h3,h4],[h5,h6,h7,h8]	
					
dcl_cb cb1[3]	; [hotSpot,widthSrc,physWidth,xPitch], [boundary,(widthSrc DIV 4)*4,widthDst,Nz]
					; [phase,...]

; hotSpot - has to be aligned to be multiple of 4
; widthSrc/Dst - is the line width

dcl_resource_id(0)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)

dcl_literal l0, 4, 0xFFFFFFFF, 1, 2
dcl_literal l1, 8, 3, 0, 0

imul r0.x, cb1[1].w, cb1[0].w ; Nz*xPitch
ilt r0.z, vaTid.x, r0.x ; check thread index!
if_logicalnz r0.z

	; in this case we have Nz*xPitch threads, thus the thread index is represented by i*xPitch + j
	udiv r0.y, vaTid.x, cb1[0].w ; i
	umod r0.x, vaTid.x, cb1[0].w ; j
	
	; position of first output quad
	imul r0.z, cb1[1].z, cb1[0].w ; widthDst*xpitch
	imad r0.z, r0.y, r0.z, r0.x ; i*widthDst*xPitch + j (in quads)
	
	; last output quad
	udiv r0.w, cb1[1].z, l1.x ; widthDst DIV 8
	imul r0.w, r0.w, l1.x ; (widthDst DIV 8)*8
	imad r0.w, r0.w, cb1[0].w, r0.z ; ind0 + (widthDst DIV 8)*8*xPitch
		
	; compute first quad position in the input
	imul r1.z, cb1[0].y, cb1[0].w ; widthSrc*xpitch
	imad r0.x, r0.y, r1.z, r0.x ; i*widthSrc*xPitch + j (in quads)
	
	udiv r0.y, cb1[0].x, l0.w ; hotSpot DIV 2
	imul r0.y, r0.y, l0.y ; -(hotSpot DIV 2) ; first input index
			
	; load first 4 input quads
	call 0
	iadd r0.y, r0.y, l0.x ; increment input index	
	
	whileloop
		
		ige r1.z, r0.z, r0.w ; ind >= ind0 + (widthDst DIV 8)*8*xPitch
		break_logicalnz r1.z
		
		mov r6, r2
		mov r7, r3
		mov r8, r4
		mov r9, r5
		
		call 0 ; load next input quads
		iadd r0.y, r0.y, l0.x ; increment input index
		
		call 1 ; compute output quads
	
		; transpose quads
		transpose r30, r30
		transpose r34, r34
		
		iadd r1.x, r0.z, cb1[0].w
		iadd r1.y, r1.x, cb1[0].w
		iadd r1.z, r1.y, cb1[0].w		
		
		; write to the output
		mov g[r0.z], r30
		mov g[r1.x], r31
		mov g[r1.y], r32
		mov g[r1.z], r33		
		
		iadd r1.w, r1.z, cb1[0].w
		iadd r1.x, r1.w, cb1[0].w
		iadd r1.y, r1.x, cb1[0].w
		iadd r1.z, r1.y, cb1[0].w
		
		mov g[r1.w], r34
		mov g[r1.x], r35
		mov g[r1.y], r36
		mov g[r1.z], r37
	
		iadd r0.z, r1.z, cb1[0].w ; increment output index
	endloop
	
	umod r0.w, cb1[1].z, l1.x ; account widthDst MOD 8 # 0
	if_logicalnz r0.w
		
		; process last quads				
		
		mov r6, r2
		mov r7, r3
		mov r8, r4
		mov r9, r5
		call 0 ; load next input quads		
		
		call 1 ; compute output quads
		
		; transpose quads
		transpose r30, r30
		transpose r34, r34
		
		iadd r1.x, r0.z, cb1[0].w
		iadd r1.y, r1.x, cb1[0].w
		iadd r1.z, r1.y, cb1[0].w
		iadd r1.w, r1.z, cb1[0].w
		iadd r2.x, r1.w, cb1[0].w
		iadd r2.y, r2.x, cb1[0].w
		iadd r2.z, r2.y, cb1[0].w
		
		switch r0.w		
			case 2
				mov g[r0.z], r30
				mov g[r1.x], r31
				break
			case 4
				mov g[r0.z], r30
				mov g[r1.x], r31
				mov g[r1.y], r32
				mov g[r1.z], r33
				break
			case 6
				mov g[r0.z], r30
				mov g[r1.x], r31
				mov g[r1.y], r32
				mov g[r1.z], r33
				
				mov g[r1.w], r34
				mov g[r2.x], r35				
				break
		endswitch
				
	endif
			
endif

endmain

; get input quad with account of boundaries for 4 lines at once
; r0.x - linear position of the first line element with account of padding, in quads
; r0.y - index of input quad within the line, in single elements
; output is returned in r2, r3, r4, r5
; r1 is used for intermediate results
func 0

ige r1.z, r0.y, r0.0 ; ind >= 0
iadd r1.w, r0.y, l1.y ; ind+3
ilt r1.w, r1.w, cb1[1].y ; ind+3 < (widthSrc DIV 4)*4
iand r1.w, r1.z, r1.w

if_logicalnz r1.w ; (ind >= 0) & (ind+3 < (widthSrc DIV 4)*4) -> not on boundaries
	
	; 2D position of quads
	imad r1.x, r0.y, cb1[0].w, r0.x ; linear position of quad to load
	udiv r2.y, r1.x, cb1[0].z
	umod r2.x, r1.x, cb1[0].z
	
	iadd r1.x, r1.x, cb1[0].w ; ind + xPitch
	udiv r3.y, r1.x, cb1[0].z
	umod r3.x, r1.x, cb1[0].z
	
	iadd r1.x, r1.x, cb1[0].w
	udiv r4.y, r1.x, cb1[0].z
	umod r4.x, r1.x, cb1[0].z
	
	iadd r1.x, r1.x, cb1[0].w
	udiv r5.y, r1.x, cb1[0].z
	umod r5.x, r1.x, cb1[0].z
	
	itof r2, r2
	itof r3, r3
	itof r4, r4
	itof r5, r5
	
	sample_resource(0)_sampler(0) r2, r2.xy
	sample_resource(0)_sampler(0) r3, r3.xy
	sample_resource(0)_sampler(0) r4, r4.xy
	sample_resource(0)_sampler(0) r5, r5.xy
else
	
	mov r2, r2.0000
	mov r3, r3.0000
	mov r4, r4.0000
	mov r5, r5.0000
	
	if_logicalz r1.z ; left boundary
		 ; currently only FiniteData boundary
		 		 
		 iadd r1.z, r0.y, l0.x ; ind + 4	 
		 ieq r1.z, r1.z, l0.w
		 
		 if_logicalnz r1.z ; ind + 4 == 2 ; account case when (hotSpot DIV 2*4) # 0
		 		 	
			udiv r4.y, r0.x, cb1[0].z
			umod r4.x, r0.x, cb1[0].z
			
			iadd r1.x, r0.x, cb1[0].w ; ind + xPitch
			udiv r5.y, r1.x, cb1[0].z
			umod r5.x, r1.x, cb1[0].z
						
			itof r4, r4
			itof r5, r5
			
			sample_resource(0)_sampler(0) r4, r4.xy
			sample_resource(0)_sampler(0) r5, r5.xy
		 endif
	else ; right boundary	
	
		ige r1.z, r0.y, cb1[0].y ; ind >= widthSrc
		if_logicalnz r1.z
			; currently only FiniteData boundary			 			
		else
			
			; 2D position of quads
			imad r1.x, r0.y, cb1[0].w, r0.x ; linear position of quad to load
			udiv r2.y, r1.x, cb1[0].z
			umod r2.x, r1.x, cb1[0].z
			itof r2, r2
			
			imad r1.z, r0.y, l0.y, cb1[0].y ; widthSrc - ind
			switch r1.z
				
				case 1
					sample_resource(0)_sampler(0) r2, r2.xy
					break
				
				case 2
					iadd r1.x, r1.x, cb1[0].w ; ind + xPitch
					udiv r3.y, r1.x, cb1[0].z
					umod r3.x, r1.x, cb1[0].z
					itof r3, r3
					sample_resource(0)_sampler(0) r2, r2.xy
					sample_resource(0)_sampler(0) r3, r3.xy
					break
				
				case 3
					iadd r1.x, r1.x, cb1[0].w ; ind + xPitch
					udiv r3.y, r1.x, cb1[0].z
					umod r3.x, r1.x, cb1[0].z
		
					iadd r1.x, r1.x, cb1[0].w
					udiv r4.y, r1.x, cb1[0].z
					umod r4.x, r1.x, cb1[0].z
					itof r3, r3
					itof r4, r4
					sample_resource(0)_sampler(0) r2, r2.xy
					sample_resource(0)_sampler(0) r3, r3.xy
					sample_resource(0)_sampler(0) r4, r4.xy
					break
					
				default
					iadd r1.x, r1.x, cb1[0].w ; ind + xPitch
					udiv r3.y, r1.x, cb1[0].z
					umod r3.x, r1.x, cb1[0].z
		
					iadd r1.x, r1.x, cb1[0].w
					udiv r4.y, r1.x, cb1[0].z
					umod r4.x, r1.x, cb1[0].z
					
					iadd r1.x, r1.x, cb1[0].w
					udiv r5.y, r1.x, cb1[0].z
					umod r5.x, r1.x, cb1[0].z
					
					itof r3, r3
					itof r4, r4
					itof r5, r5
					sample_resource(0)_sampler(0) r2, r2.xy
					sample_resource(0)_sampler(0) r3, r3.xy
					sample_resource(0)_sampler(0) r4, r4.xy
					sample_resource(0)_sampler(0) r5, r5.xy
					break
			endswitch 
			
		endif
	endif
	
endif

; transpose quads
transpose r2, r2

ret
endfunc

; compute 8 output quads
; {r6,r7,r8,r9}, {r2,r3,r4,r5} - input quads
; output is stored in {r30,r31,r32,r33}, {r34,r35,r36,r37}
; uses 38,39,40 for intermediate results
func 1

switch cb1[2].x

	case 0
		
		mul r30, r6.x0y0, cb0[0]
		mad r30, r6.z0w0, cb0[1], r30
		mad r30, r2.x0y0, cb0[2], r30
		
		mul r31, r6.x0y0, cb0[3]
		mad r31, r6.z0w0, cb0[4], r31
		mad r31, r2.x0y0, cb0[5], r31
		
		mul r32, r6.x0y0, cb0[6]
		mad r32, r6.z0w0, cb0[7], r32
		mad r32, r2.x0y0, cb0[8], r32
		
		mul r33, r6.x0y0, cb0[9]
		mad r33, r6.z0w0, cb0[10], r33
		mad r33, r2.x0y0, cb0[11], r33
		
		dp4 r30.x, r30, r30.1111
		dp4 r30.y, r31, r31.1111
		dp4 r30.z, r32, r32.1111
		dp4 r30.w, r33, r33.1111
		
		mul r31, r6.z0w0, cb0[0]
		mad r31, r2.x0y0, cb0[1], r31
		mad r31, r2.z0w0, cb0[2], r31
		
		mul r32, r6.z0w0, cb0[3]
		mad r32, r2.x0y0, cb0[4], r32
		mad r32, r2.z0w0, cb0[5], r32
		
		mul r33, r6.z0w0, cb0[6]
		mad r33, r2.x0y0, cb0[7], r33
		mad r33, r2.z0w0, cb0[8], r33
		
		mul r35, r6.z0w0, cb0[9]
		mad r35, r2.x0y0, cb0[10], r35
		mad r35, r2.z0w0, cb0[11], r35
		
		dp4 r34.x, r31, r31.1111
		dp4 r34.y, r32, r32.1111
		dp4 r34.z, r33, r33.1111
		dp4 r34.w, r35, r35.1111
		
		; ***
		
		mul r31, r7.x0y0, cb0[0]
		mad r31, r7.z0w0, cb0[1], r31
		mad r31, r3.x0y0, cb0[2], r31
		
		mul r32, r7.x0y0, cb0[3]
		mad r32, r7.z0w0, cb0[4], r32
		mad r32, r3.x0y0, cb0[5], r32
		
		mul r33, r7.x0y0, cb0[6]
		mad r33, r7.z0w0, cb0[7], r33
		mad r33, r3.x0y0, cb0[8], r33
		
		mul r35, r7.x0y0, cb0[9]
		mad r35, r7.z0w0, cb0[10], r35
		mad r35, r3.x0y0, cb0[11], r35
		
		dp4 r31.x, r31, r31.1111
		dp4 r31.y, r32, r32.1111
		dp4 r31.z, r33, r33.1111
		dp4 r31.w, r35, r35.1111
		
		mul r35, r7.z0w0, cb0[0]
		mad r35, r3.x0y0, cb0[1], r35
		mad r35, r3.z0w0, cb0[2], r35
		
		mul r32, r7.z0w0, cb0[3]
		mad r32, r3.x0y0, cb0[4], r32
		mad r32, r3.z0w0, cb0[5], r32
		
		mul r33, r7.z0w0, cb0[6]
		mad r33, r3.x0y0, cb0[7], r33
		mad r33, r3.z0w0, cb0[8], r33
		
		mul r36, r7.z0w0, cb0[9]
		mad r36, r3.x0y0, cb0[10], r36
		mad r36, r3.z0w0, cb0[11], r36
		
		dp4 r35.x, r35, r35.1111
		dp4 r35.y, r32, r32.1111
		dp4 r35.z, r33, r33.1111
		dp4 r35.w, r36, r36.1111
		
		; ***
		
		mul r32, r8.x0y0, cb0[0]
		mad r32, r8.z0w0, cb0[1], r32
		mad r32, r4.x0y0, cb0[2], r32
		
		mul r33, r8.x0y0, cb0[3]
		mad r33, r8.z0w0, cb0[4], r33
		mad r33, r4.x0y0, cb0[5], r33
		
		mul r36, r8.x0y0, cb0[6]
		mad r36, r8.z0w0, cb0[7], r36
		mad r36, r4.x0y0, cb0[8], r36
		
		mul r37, r8.x0y0, cb0[9]
		mad r37, r8.z0w0, cb0[10], r37
		mad r37, r4.x0y0, cb0[11], r37
		
		dp4 r32.x, r32, r32.1111
		dp4 r32.y, r33, r32.1111
		dp4 r32.z, r36, r33.1111
		dp4 r32.w, r37, r35.1111
		
		mul r36, r8.z0w0, cb0[0]
		mad r36, r4.x0y0, cb0[1], r36
		mad r36, r4.z0w0, cb0[2], r36
		
		mul r33, r8.z0w0, cb0[3]
		mad r33, r4.x0y0, cb0[4], r33
		mad r33, r4.z0w0, cb0[5], r33
		
		mul r37, r8.z0w0, cb0[6]
		mad r37, r4.x0y0, cb0[7], r37
		mad r37, r4.z0w0, cb0[8], r37
		
		mul r38, r8.z0w0, cb0[9]
		mad r38, r4.x0y0, cb0[10], r38
		mad r38, r4.z0w0, cb0[11], r38
		
		dp4 r36.x, r36, r36.1111
		dp4 r36.y, r33, r33.1111
		dp4 r36.z, r37, r37.1111
		dp4 r36.w, r38, r38.1111
		
		; ***
		
		mul r33, r9.x0y0, cb0[0]
		mad r33, r9.z0w0, cb0[1], r33
		mad r33, r5.x0y0, cb0[2], r33
		
		mul r37, r9.x0y0, cb0[3]
		mad r37, r9.z0w0, cb0[4], r37
		mad r37, r5.x0y0, cb0[5], r37
		
		mul r38, r9.x0y0, cb0[6]
		mad r38, r9.z0w0, cb0[7], r38
		mad r38, r5.x0y0, cb0[8], r38
		
		mul r39, r9.x0y0, cb0[9]
		mad r39, r9.z0w0, cb0[10], r39
		mad r39, r5.x0y0, cb0[11], r39
		
		dp4 r33.x, r33, r33.1111
		dp4 r33.y, r37, r37.1111
		dp4 r33.z, r38, r38.1111
		dp4 r33.w, r39, r39.1111
		
		mul r37, r9.z0w0, cb0[0]
		mad r37, r5.x0y0, cb0[1], r37
		mad r37, r5.z0w0, cb0[2], r37
		
		mul r38, r9.z0w0, cb0[3]
		mad r38, r5.x0y0, cb0[4], r38
		mad r38, r5.z0w0, cb0[5], r38
		
		mul r39, r9.z0w0, cb0[6]
		mad r39, r5.x0y0, cb0[7], r39
		mad r39, r5.z0w0, cb0[8], r39
		
		mul r40, r9.z0w0, cb0[9]
		mad r40, r5.x0y0, cb0[10], r40
		mad r40, r5.z0w0, cb0[11], r40
		
		dp4 r37.x, r37, r37.1111
		dp4 r37.y, r38, r38.1111
		dp4 r37.z, r39, r39.1111
		dp4 r37.w, r40, r40.1111
		
		break
	
	case 1
		
		
		break

endswitch

ret
endfunc

end
]]>
	</ILKernel>
	
<ILKernel name = "ConvolveNDZ9Up2_R">
<![CDATA[
il_cs_2_0
dcl_num_thread_per_group 64
;
;	Convolve ND virtualized array along Z (first) direction with up to 5 taps FIR filter and upsampling by 2
; 
;	inputs: 1
;	outputs: 0
;	global buffer: Yes
;	data type: REAL
;	nComponents: 4
;	constants: 2, 8x4 (REAL) and 2x4 (LONGINT)
;

dcl_cb cb0[12]	; [h0,h1,h2,h3],[h4,h5,h6,h7],[h8,0,0,0]
					; [0,h0,h1,h2],[h3,h4,h5,h6],[h7,h8,0,0]
					; [0,0,h0,h1],[h2,h3,h4,h5],[h6,h7,h8,0]
					; [0,0,0,h0],[h1,h2,h3,h4],[h5,h6,h7,h8]
					
dcl_cb cb1[3]	; [hotSpot,widthSrc,physWidth,xPitch], [boundary,(widthSrc DIV 4)*4,Ny*xPitch,widthDst]
					; [phase,...]

; hotSpot - has to be aligned to be multiple of 4
; width - is the line width

dcl_resource_id(0)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)

dcl_literal l0, 4, 0xFFFFFFFF, 1, 2
dcl_literal l1, 8, 3, 0, 0

ilt r0.z, vaTid.x, cb1[1].z ; check thread index!
if_logicalnz r0.z

	; in this case we have Ny*xPitch threads
	mov r0.x, vaTid.x ; position of first input quad (in quads)	
	udiv r0.y, cb1[0].x, l0.w ; hotSpot DIV 2
	imul r0.y, r0.y, l0.y ; -(hotSpot DIV 2) ; first input index
	
	mov r0.z, r0.x ; position of curent output quad	
	
	udiv r0.w, cb1[1].w, l1.x ; widthDst DIV 8
	imul r0.w, r0.w, l1.x ; (widthDst DIV 8)*8	
	imad r0.w, r0.w, cb1[1].z, r0.z ; ind0 + (widthDst DIV 8)*8*Ny*xPitch
	
	; load first 4 input quads
	call 0
	iadd r0.y, r0.y, l0.x ; increment input index	
	
	whileloop
				
		ige r1.z, r0.z, r0.w ; ind >= ind0 + (widthDst DIV 8)*8*Ny*xPitch
		break_logicalnz r1.z
				
		mov r6, r2
		mov r7, r3
		mov r8, r4
		mov r9, r5
		call 0 ; load next input quads
		iadd r0.y, r0.y, l0.x ; increment input index
				
		call 1 ; compute output quads
		
		; transpose quads
		transpose r30, r30
		transpose r34, r34
		
		iadd r1.x, r0.z, cb1[1].z
		iadd r1.y, r1.x, cb1[1].z
		iadd r1.z, r1.y, cb1[1].z		
		
		; write to the output
		mov g[r0.z], r30
		mov g[r1.x], r31
		mov g[r1.y], r32
		mov g[r1.z], r33		
		
		iadd r1.w, r1.z, cb1[1].z
		iadd r1.x, r1.w, cb1[1].z
		iadd r1.y, r1.x, cb1[1].z
		iadd r1.z, r1.y, cb1[1].z
		
		mov g[r1.w], r34
		mov g[r1.x], r35
		mov g[r1.y], r36
		mov g[r1.z], r37				
	
		iadd r0.z, r1.z, cb1[1].z ; increment output index
	endloop
	
	umod r0.w, cb1[1].w, l1.x ; account widthDst MOD 8 # 0
	if_logicalnz r0.w
		
		; process last quads				
		
		mov r6, r2
		mov r7, r3
		mov r8, r4
		mov r9, r5
		call 0 ; load next input quads		
		
		call 1 ; compute output quads
		
		; transpose quads
		transpose r30, r30
		transpose r34, r34
		
		iadd r1.x, r0.z, cb1[1].z
		iadd r1.y, r1.x, cb1[1].z
		iadd r1.z, r1.y, cb1[1].z
		iadd r1.w, r1.z, cb1[1].z
		iadd r2.x, r1.w, cb1[1].z
		iadd r2.y, r2.x, cb1[1].z
		iadd r2.z, r2.y, cb1[1].z
		
		switch r0.w		
			case 2
				mov g[r0.z], r30
				mov g[r1.x], r31
				break
			case 4
				mov g[r0.z], r30
				mov g[r1.x], r31
				mov g[r1.y], r32
				mov g[r1.z], r33
				break
			case 6
				mov g[r0.z], r30
				mov g[r1.x], r31
				mov g[r1.y], r32
				mov g[r1.z], r33
				
				mov g[r1.w], r34
				mov g[r2.x], r35				
				break
		endswitch
				
	endif

endif; 

endmain

; get input quad with account of boundaries for 4 lines at once
; r0.x - linear position of the first line element with account of padding, in quads
; r0.y - index of input quad within the line, in single elements
; output is returned in r2, r3, r4, r5
; r1 is used for intermediate results
func 0

ige r1.z, r0.y, r0.0 ; ind >= 0
iadd r1.w, r0.y, l1.y ; ind+3
ilt r1.w, r1.w, cb1[1].y ; ind+3 < (widthSrc DIV 4)*4
iand r1.w, r1.z, r1.w

if_logicalnz r1.w ; (ind >= 0) & (ind+3 < (widthSrc DIV 4)*4) -> not on boundaries
	
	; 2D position of quads
	imad r1.x, r0.y, cb1[1].z, r0.x ; linear position of quad to load
	udiv r3.y, r1.x, cb1[0].z
	umod r3.x, r1.x, cb1[0].z
	
	iadd r1.x, r1.x, cb1[1].z ; ind + Ny*xPitch
	udiv r4.y, r1.x, cb1[0].z
	umod r4.x, r1.x, cb1[0].z
	
	iadd r1.x, r1.x, cb1[1].z
	udiv r5.y, r1.x, cb1[0].z
	umod r5.x, r1.x, cb1[0].z
	
	iadd r1.x, r1.x, cb1[1].z
	udiv r1.y, r1.x, cb1[0].z
	umod r1.x, r1.x, cb1[0].z
	
	itof r3, r3
	itof r4, r4
	itof r5, r5
	itof r1, r1
	
	sample_resource(0)_sampler(0) r2, r3.xy
	sample_resource(0)_sampler(0) r3, r4.xy
	sample_resource(0)_sampler(0) r4, r5.xy
	sample_resource(0)_sampler(0) r5, r1.xy
else
	
	mov r2, r2.0000
	mov r3, r3.0000
	mov r4, r4.0000
	mov r5, r5.0000
	
	if_logicalz r1.z ; left boundary
		 ; currently only FiniteData boundary
		 
		 iadd r1.z, r0.y, l0.x ; ind + 4
		 ieq r1.z, r1.z, l0.w
		 
		 if_logicalnz r1.z ; ind + 4 == 2 ; account case when (hotSpot DIV 2*4) # 0
		 		 	
			udiv r4.y, r0.x, cb1[0].z
			umod r4.x, r0.x, cb1[0].z
			
			iadd r1.x, r0.x, cb1[1].z ; ind + Ny*xPitch
			udiv r5.y, r1.x, cb1[0].z
			umod r5.x, r1.x, cb1[0].z
						
			itof r4, r4
			itof r5, r5
			
			sample_resource(0)_sampler(0) r4, r4.xy
			sample_resource(0)_sampler(0) r5, r5.xy
		 endif
		 
	else ; right boundary
	
		ige r1.z, r0.y, cb1[0].y
		if_logicalnz r1.z
			 ; currently only FiniteData boundary
		else
			
			; 2D position of quads
			imad r1.x, r0.y, cb1[1].z, r0.x ; linear position of quad to load
			udiv r2.y, r1.x, cb1[0].z
			umod r2.x, r1.x, cb1[0].z			
			itof r2, r2
			
			imad r1.z, r0.y, l0.y, cb1[0].y ; widthSrc - ind
			switch r1.z
				
				case 1
					sample_resource(0)_sampler(0) r2, r2.xy
					break
				
				case 2
					iadd r1.x, r1.x, cb1[1].z ; ind + Ny*xPitch			
					udiv r3.y, r1.x, cb1[0].z
					umod r3.x, r1.x, cb1[0].z
					itof r3, r3
					sample_resource(0)_sampler(0) r2, r2.xy
					sample_resource(0)_sampler(0) r3, r3.xy
					break
				
				case 3
					iadd r1.x, r1.x, cb1[1].z ; ind + Ny*xPitch		
					udiv r3.y, r1.x, cb1[0].z
					umod r3.x, r1.x, cb1[0].z
		
					iadd r1.x, r1.x, cb1[1].z
					udiv r4.y, r1.x, cb1[0].z
					umod r4.x, r1.x, cb1[0].z
					itof r3, r3
					itof r4, r4
					sample_resource(0)_sampler(0) r2, r2.xy
					sample_resource(0)_sampler(0) r3, r3.xy
					sample_resource(0)_sampler(0) r4, r4.xy
					break
					
				default
					iadd r1.x, r1.x, cb1[1].z ; ind + Ny*xPitch		
					udiv r3.y, r1.x, cb1[0].z
					umod r3.x, r1.x, cb1[0].z
		
					iadd r1.x, r1.x, cb1[1].z
					udiv r4.y, r1.x, cb1[0].z
					umod r4.x, r1.x, cb1[0].z
					
					iadd r1.x, r1.x, cb1[1].z
					udiv r5.y, r1.x, cb1[0].z
					umod r5.x, r1.x, cb1[0].z
					itof r3, r3
					itof r4, r4
					itof r5, r5
					sample_resource(0)_sampler(0) r2, r2.xy
					sample_resource(0)_sampler(0) r3, r3.xy
					sample_resource(0)_sampler(0) r4, r4.xy
					sample_resource(0)_sampler(0) r5, r5.xy
					break	
			endswitch

		endif
	endif
	
endif

; transpose quads
transpose r2, r2

ret
endfunc

; compute 8 output quads
; {r6,r7,r8,r9}, {r2,r3,r4,r5} - input quads
; output is stored in {r30,r31,r32,r33}, {r34,r35,r36,r37}
; uses 38,39,40 for intermediate results
func 1

switch cb1[2].x

	case 0
		
		mul r30, r6.x0y0, cb0[0]
		mad r30, r6.z0w0, cb0[1], r30
		mad r30, r2.x0y0, cb0[2], r30
		
		mul r31, r6.x0y0, cb0[3]
		mad r31, r6.z0w0, cb0[4], r31
		mad r31, r2.x0y0, cb0[5], r31
		
		mul r32, r6.x0y0, cb0[6]
		mad r32, r6.z0w0, cb0[7], r32
		mad r32, r2.x0y0, cb0[8], r32
		
		mul r33, r6.x0y0, cb0[9]
		mad r33, r6.z0w0, cb0[10], r33
		mad r33, r2.x0y0, cb0[11], r33
		
		dp4 r30.x, r30, r30.1111
		dp4 r30.y, r31, r31.1111
		dp4 r30.z, r32, r32.1111
		dp4 r30.w, r33, r33.1111
		
		mul r31, r6.z0w0, cb0[0]
		mad r31, r2.x0y0, cb0[1], r31
		mad r31, r2.z0w0, cb0[2], r31
		
		mul r32, r6.z0w0, cb0[3]
		mad r32, r2.x0y0, cb0[4], r32
		mad r32, r2.z0w0, cb0[5], r32
		
		mul r33, r6.z0w0, cb0[6]
		mad r33, r2.x0y0, cb0[7], r33
		mad r33, r2.z0w0, cb0[8], r33
		
		mul r35, r6.z0w0, cb0[9]
		mad r35, r2.x0y0, cb0[10], r35
		mad r35, r2.z0w0, cb0[11], r35
		
		dp4 r34.x, r31, r31.1111
		dp4 r34.y, r32, r32.1111
		dp4 r34.z, r33, r33.1111
		dp4 r34.w, r35, r35.1111
		
		; ***
		
		mul r31, r7.x0y0, cb0[0]
		mad r31, r7.z0w0, cb0[1], r31
		mad r31, r3.x0y0, cb0[2], r31
		
		mul r32, r7.x0y0, cb0[3]
		mad r32, r7.z0w0, cb0[4], r32
		mad r32, r3.x0y0, cb0[5], r32
		
		mul r33, r7.x0y0, cb0[6]
		mad r33, r7.z0w0, cb0[7], r33
		mad r33, r3.x0y0, cb0[8], r33
		
		mul r35, r7.x0y0, cb0[9]
		mad r35, r7.z0w0, cb0[10], r35
		mad r35, r3.x0y0, cb0[11], r35
		
		dp4 r31.x, r31, r31.1111
		dp4 r31.y, r32, r32.1111
		dp4 r31.z, r33, r33.1111
		dp4 r31.w, r35, r35.1111
		
		mul r35, r7.z0w0, cb0[0]
		mad r35, r3.x0y0, cb0[1], r35
		mad r35, r3.z0w0, cb0[2], r35
		
		mul r32, r7.z0w0, cb0[3]
		mad r32, r3.x0y0, cb0[4], r32
		mad r32, r3.z0w0, cb0[5], r32
		
		mul r33, r7.z0w0, cb0[6]
		mad r33, r3.x0y0, cb0[7], r33
		mad r33, r3.z0w0, cb0[8], r33
		
		mul r36, r7.z0w0, cb0[9]
		mad r36, r3.x0y0, cb0[10], r36
		mad r36, r3.z0w0, cb0[11], r36
		
		dp4 r35.x, r35, r35.1111
		dp4 r35.y, r32, r32.1111
		dp4 r35.z, r33, r33.1111
		dp4 r35.w, r36, r36.1111
		
		; ***
		
		mul r32, r8.x0y0, cb0[0]
		mad r32, r8.z0w0, cb0[1], r32
		mad r32, r4.x0y0, cb0[2], r32
		
		mul r33, r8.x0y0, cb0[3]
		mad r33, r8.z0w0, cb0[4], r33
		mad r33, r4.x0y0, cb0[5], r33
		
		mul r36, r8.x0y0, cb0[6]
		mad r36, r8.z0w0, cb0[7], r36
		mad r36, r4.x0y0, cb0[8], r36
		
		mul r37, r8.x0y0, cb0[9]
		mad r37, r8.z0w0, cb0[10], r37
		mad r37, r4.x0y0, cb0[11], r37
		
		dp4 r32.x, r32, r32.1111
		dp4 r32.y, r33, r32.1111
		dp4 r32.z, r36, r33.1111
		dp4 r32.w, r37, r35.1111
		
		mul r36, r8.z0w0, cb0[0]
		mad r36, r4.x0y0, cb0[1], r36
		mad r36, r4.z0w0, cb0[2], r36
		
		mul r33, r8.z0w0, cb0[3]
		mad r33, r4.x0y0, cb0[4], r33
		mad r33, r4.z0w0, cb0[5], r33
		
		mul r37, r8.z0w0, cb0[6]
		mad r37, r4.x0y0, cb0[7], r37
		mad r37, r4.z0w0, cb0[8], r37
		
		mul r38, r8.z0w0, cb0[9]
		mad r38, r4.x0y0, cb0[10], r38
		mad r38, r4.z0w0, cb0[11], r38
		
		dp4 r36.x, r36, r36.1111
		dp4 r36.y, r33, r33.1111
		dp4 r36.z, r37, r37.1111
		dp4 r36.w, r38, r38.1111
		
		; ***
		
		mul r33, r9.x0y0, cb0[0]
		mad r33, r9.z0w0, cb0[1], r33
		mad r33, r5.x0y0, cb0[2], r33
		
		mul r37, r9.x0y0, cb0[3]
		mad r37, r9.z0w0, cb0[4], r37
		mad r37, r5.x0y0, cb0[5], r37
		
		mul r38, r9.x0y0, cb0[6]
		mad r38, r9.z0w0, cb0[7], r38
		mad r38, r5.x0y0, cb0[8], r38
		
		mul r39, r9.x0y0, cb0[9]
		mad r39, r9.z0w0, cb0[10], r39
		mad r39, r5.x0y0, cb0[11], r39
		
		dp4 r33.x, r33, r33.1111
		dp4 r33.y, r37, r37.1111
		dp4 r33.z, r38, r38.1111
		dp4 r33.w, r39, r39.1111
		
		mul r37, r9.z0w0, cb0[0]
		mad r37, r5.x0y0, cb0[1], r37
		mad r37, r5.z0w0, cb0[2], r37
		
		mul r38, r9.z0w0, cb0[3]
		mad r38, r5.x0y0, cb0[4], r38
		mad r38, r5.z0w0, cb0[5], r38
		
		mul r39, r9.z0w0, cb0[6]
		mad r39, r5.x0y0, cb0[7], r39
		mad r39, r5.z0w0, cb0[8], r39
		
		mul r40, r9.z0w0, cb0[9]
		mad r40, r5.x0y0, cb0[10], r40
		mad r40, r5.z0w0, cb0[11], r40
		
		dp4 r37.x, r37, r37.1111
		dp4 r37.y, r38, r38.1111
		dp4 r37.z, r39, r39.1111
		dp4 r37.w, r40, r40.1111
		
		break
	
	case 1
		
		
		break

endswitch

ret
endfunc

end
]]>
	</ILKernel>	
	
<ILKernel name = "InnerProdReduce_LI_R_LR">
<![CDATA[
il_cs_2_0
dcl_num_thread_per_group 64
;
;	Reduction used for inner product
; 
;	inputs: 2
;	outputs: 0
;	global buffer: Yes
;	data type: REAL
;	nComponents: 4
;	constants: 1,1x4 (LONGINT)
;
dcl_cb cb0[1]	; [physWidth,dType,blockSize,incFlag]

; blockSize is given in quads and has to be multiple of 4!

dcl_resource_id(0)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(1)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)

dcl_literal l0, 1, 64, 0, 0

; compute linear index of first element
imul r0.xy, vaTid.x, cb0[0].z ; account blockSize quads per thread
iadd r0.z, r0.x, cb0[0].z

if_logicalnz cb0[0].w
	mov r30, g[vaTid.x] ; do increment!
else
	mov r30, r30.0000
endif	

whileloop

	ige r0.w, r0.x, r0.z ; ind >= ind+blockSize
	break_logicalnz r0.w
		
	; compute 2D position of the next quad
	udiv r1.y, r0.x, cb0[0].x
	umod r1.x, r0.x, cb0[0].x
	iadd r0.x, r0.x, l0.x ; increment linear index

	udiv r1.w, r0.x, cb0[0].x
	umod r1.z, r0.x, cb0[0].x
	iadd r0.x, r0.x, l0.x ; increment linear index
	
	udiv r2.y, r0.x, cb0[0].x
	umod r2.x, r0.x, cb0[0].x
	iadd r0.x, r0.x, l0.x ; increment linear index
	
	udiv r2.w, r0.x, cb0[0].x
	umod r2.z, r0.x, cb0[0].x
	iadd r0.x, r0.x, l0.x ; increment linear index
	
	itof r1, r1
	itof r2, r2
	
	; load input elements
	sample_resource(0)_sampler(0) r3, r1.xy
	sample_resource(0)_sampler(0) r4, r1.zw
	sample_resource(0)_sampler(0) r5, r2.xy
	sample_resource(0)_sampler(0) r6, r2.zw
	
	sample_resource(1)_sampler(1) r7, r1.xy
	sample_resource(1)_sampler(1) r8, r1.zw
	sample_resource(1)_sampler(1) r9, r2.xy
	sample_resource(1)_sampler(1) r10, r2.zw
	
	switch cb0[0].y
	
		case 3 ; LONGINT
			imad r30, r3, r7, r30
			imad r30, r4, r8, r30
			imad r30, r5, r9, r30
			imad r30, r6, r10, r30
			break
			
		case 5 ; REAL
			mad r30, r3, r7, r30
			mad r30, r4, r8, r30
			mad r30, r5, r9, r30
			mad r30, r6, r10, r30
			break
			
		case 6 ; LONGREAL
			dmad r30, r3, r7, r30
			dmad r30, r4, r8, r30
			dmad r30, r5, r9, r30
			dmad r30, r6, r10, r30
			break
	endswitch
				
endloop

mov g[vaTid.x], r30

end
]]>
	</ILKernel>

<ILKernel name = "Sum_LI_R_LR">
<![CDATA[
il_cs_2_0
dcl_num_thread_per_group 1
;
;	sum of a small array
; 
;	inputs: 1
;	outputs: 0
;	global buffer: Yes
;	data type: REAL
;	nComponents: 4
;	constants: 1,1x4 (LONGINT)
;
dcl_cb cb0[1]	; [physWidth,dType,length,...]

dcl_resource_id(0)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)

dcl_literal l0, 1, 0, 0, 0

if_logicalz vaTid.x ; only one thread!

	mov r0.x, r0.0
	mov r30, r30.0000
	
	whileloop
	
		ige r0.w, r0.x, cb0[0].z ; ind >= length
		break_logicalnz r0.w
			
		; compute 2D position of the next quads
		udiv r1.y, r0.x, cb0[0].x
		umod r1.x, r0.x, cb0[0].x
		iadd r0.x, r0.x, l0.x ; increment linear index
		
		udiv r1.w, r0.x, cb0[0].x
		umod r1.z, r0.x, cb0[0].x
		iadd r0.x, r0.x, l0.x ; increment linear index
		
		udiv r2.y, r0.x, cb0[0].x
		umod r2.x, r0.x, cb0[0].x
		iadd r0.x, r0.x, l0.x ; increment linear index
		
		udiv r2.w, r0.x, cb0[0].x
		umod r2.z, r0.x, cb0[0].x
		iadd r0.x, r0.x, l0.x ; increment linear index
		
		itof r1, r1
		itof r2, r2
		
		; load input elements
		sample_resource(0)_sampler(0) r3, r1.xy
		sample_resource(0)_sampler(0) r4, r1.zw
		sample_resource(0)_sampler(0) r5, r2.xy
		sample_resource(0)_sampler(0) r6, r2.zw	
		
		switch cb0[0].y
		
			case 3 ; LONGINT
				iadd r30, r30, r3
				iadd r30, r30, r4
				iadd r30, r30, r5
				iadd r30, r30, r6
				break
				
			case 5 ; REAL
				add r30, r30, r3
				add r30, r30, r4
				add r30, r30, r5
				add r30, r30, r6
				break
				
			case 6 ; LONGREAL
				dadd r30, r30, r3
				dadd r30, r30, r4
				dadd r30, r30, r5
				dadd r30, r30, r6
				break
		endswitch
					
	endloop
	
	dp4 r30.x000, r30, r30.1111
	
endif	

mov g[0], r30

end
]]>
	</ILKernel>
	
<ILKernel name = "Advect3D_R0">
<![CDATA[
il_cs_2_0
dcl_num_thread_per_group 64
;
;	Advection for a 3D scalar field
; 
;	inputs: 4 (u,v,w,gsource)
;	outputs: 0
;	global buffer: Yes
;	data type: REAL
;	nComponents: 4
;	constants: 1, 1x4 (LONGINT), 1x4 (REAL)
;

dcl_cb cb0[1]	; [physWidth,Nx,Ny,Nz]
dcl_cb cb1[1]	; [dt/ds,...]

dcl_resource_id(0)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(1)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(2)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(3)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)

dcl_literal l0, 1, 2, 3, 4
dcl_literal l1, 0.5f, -1.0f, 0.0f, 0.0f
dcl_literal l2, 0xFFFFFFFE, 0xFFFFFFFF, 0, 0

imul r0.x, vaTid.x, l0.w ; single element position of first element of the quad
iadd r0.xyzw, r0.xxxx, l0.0xyz ; single elem positions of 4 elements

; compute x,y,z in the target grid

; ind = z*Ny*Nx + y*Nx + x
imul r8, cb0[0].yyyy, cb0[0].zzzz ; [Ny*Nx,Ny*Nx,Ny*Nx,Ny*Nx]
udiv r1, r0, r8 ; [z0,z1,z2,z3]
umod r2, r0, r8 ; [y0*Nx+x0,y1*Nx+x1,y2*Nx+x2,y3*Nx+x3]
umod r3, r2, cb0[0].yyyy ; [x0,x1,x2,x3]
udiv r2, r2, cb0[0].yyyy ; [y0,y1,y2,y3]

itof r1, r1
itof r2, r2
itof r3, r3

; compute 2D positions for velocities
udiv r0.y, vaTid.x, cb0[0].x
umod r0.x, vaTid.x, cb0[0].x
itof r0.xy, r0.xy
; load velocities
sample_resource(0)_sampler(0) r4, r0.xy ; u
sample_resource(1)_sampler(1) r5, r0.xy ; v
sample_resource(2)_sampler(2) r6, r0.xy ; w

mul r0, cb1[0].xxxx, l1.yyyy ; [-dt/ds,-dt/ds,-dt/ds,-dt/ds]

; ox := ENTIER(x-(dt/ds)*u+0.5)
mad r3, r0, r4, r3
add r3, r3, l1.x
flr r3, r3
ftoi r3, r3

; oy := ENTIER(y-(dt/ds)*v+0.5)
mad r2, r0, r5, r2
add r2, r2, l1.x
flr r2, r2
ftoi r2, r2

; oz := ENTIER(z-(dt/ds)*w+0.5)
mad r1, r0, r6, r1
add r1, r1, l1.x
flr r1, r1
ftoi r1, r1

; apply boundaries

; x
ige r0, r3, r3.0000
iand r3, r3, r0

iadd r4, cb0[0].yyyy, l2.xxxx ; Nx-2
iadd r5, cb0[0].yyyy, l2.yyyy ; Nx-1
ilt r0, r3, r5 ; r3 < Nx-1
if_logicalz r0.x
	mov r3.x, r4.x
endif
if_logicalz r0.y
	mov r3.y, r4.y
endif
if_logicalz r0.z
	mov r3.z, r4.z
endif
if_logicalz r0.w
	mov r3.w, r4.w
endif

; y
ige r0, r2, r2.0000
iand r2, r2, r0

iadd r4, cb0[0].zzzz, l2.xxxx ; Ny-2
iadd r5, cb0[0].zzzz, l2.yyyy ; Ny-1
ilt r0, r2, r5 ; r2 < Ny-1
if_logicalz r0.x
	mov r2.x, r4.x
endif
if_logicalz r0.y
	mov r2.y, r4.y
endif
if_logicalz r0.z
	mov r2.z, r4.z
endif
if_logicalz r0.w
	mov r2.w, r4.w
endif

; z
ige r0, r1, r1.0000
iand r1, r1, r0

iadd r4, cb0[0].wwww, l2.xxxx ; Nz-2
iadd r5, cb0[0].wwww, l2.yyyy ; Nz-1
ilt r0, r1, r5 ; r1 < Nz-1
if_logicalz r0.x
	mov r1.x, r4.x
endif
if_logicalz r0.y
	mov r1.y, r4.y
endif
if_logicalz r0.z
	mov r1.z, r4.z
endif
if_logicalz r0.w
	mov r1.w, r4.w
endif

; compute single elem positions for the source target
imul r0, r1, r8 ; [z0,z1,z2,z3].*[Ny*Nx,Ny*Nx,Ny*Nx,Ny*Nx]
imad r0, r2, cb0[0].yyyy, r0
iadd r0, r0, r3

mov r1.x, r0.x
call 0
mov r3.x, r2.x

mov r1.x, r0.y
call 0
mov r3.y, r2.x

mov r1.x, r0.z
call 0
mov r3.z, r2.x

mov r1.x, r0.w
call 0
mov r3.w, r2.x

mov g[vaTid.x], r3

endmain

; load a single element given by its single element position in r1.x
; output is in r2.x
; uses r4
func 0
	
	; quad position
	udiv r4.x, r1.x, l0.w
	umod r4.z, r1.x, l0.w
	
	; 2D position
	udiv r4.y, r4.x, cb0[0].x
	umod r4.x, r4.x, cb0[0].x
	itof r4.xy, r4.xy
	
	switch r4.z
	
		case 0
			sample_resource(3)_sampler(3) r2.x___, r4.xy
		break
		
		case 1
			sample_resource(3)_sampler(3) r2._y__, r4.xy
			mov r2.x, r2.y
		break
		
		case 2
			sample_resource(3)_sampler(3) r2.__z_, r4.xy
			mov r2.x, r2.z
		break
		
		case 3
			sample_resource(3)_sampler(3) r2.___w, r4.xy
			mov r2.x, r2.w
		break
		
	endswitch
ret
endfunc

end
]]>
	</ILKernel>
	
<ILKernel name = "Advect3D_R">
<![CDATA[
il_cs_2_0
dcl_num_thread_per_group 64
;
;	Advection for a 3D scalar field
; 
;	inputs: 4 (u,v,w,gsource)
;	outputs: 0
;	global buffer: Yes
;	data type: REAL
;	nComponents: 4
;	constants: 1, 1x4 (LONGINT), 1x4 (REAL)
;

dcl_cb cb0[1]	; [physWidth,Nx,Ny,Nz]
dcl_cb cb1[1]	; [dt/ds,...]

dcl_resource_id(0)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(1)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(2)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_resource_id(3)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)

dcl_literal l0, 1, 2, 3, 4
dcl_literal l1, 0.5f, -1.0f, 0.0f, 0.0f
dcl_literal l2, 0xFFFFFFFE, 0xFFFFFFFF, 0, 0

umod r10.z, cb0[0].y, l0.w
if_logicalnz r10.z
	iadd r10.x, cb0[0].y, l0.z
	udiv r10.x, r10.x, l0.w ; xPitch in quads
	udiv r10.y, vaTid.x, r10.x ; number of lines in current output position
	imad r10.z, r10.z, l2.y, l0.w
	; compute delta due to padding
	imul r10.z, r10.z, r10.y
	imul r10.x, r10.x, l0.w ; xPitch in single elements
endif

imul r0.x, vaTid.x, l0.w ; single element position of first element of the quad
imad r0.x, r10.z, l2.y, r0.x ; r0.x - delta
iadd r0.xyzw, r0.xxxx, l0.0xyz ; single elem positions of 4 elements

; compute x,y,z in the target grid

; ind = z*Ny*Nx + y*Nx + x
imul r8, cb0[0].yyyy, cb0[0].zzzz ; [Ny*Nx,Ny*Nx,Ny*Nx,Ny*Nx]
udiv r1, r0, r8 ; [z0,z1,z2,z3]
umod r2, r0, r8 ; [y0*Nx+x0,y1*Nx+x1,y2*Nx+x2,y3*Nx+x3]
umod r3, r2, cb0[0].yyyy ; [x0,x1,x2,x3]
udiv r2, r2, cb0[0].yyyy ; [y0,y1,y2,y3]

itof r1, r1
itof r2, r2
itof r3, r3

; compute 2D positions for velocities
udiv r0.y, vaTid.x, cb0[0].x
umod r0.x, vaTid.x, cb0[0].x
itof r0.xy, r0.xy
; load velocities
sample_resource(0)_sampler(0) r4, r0.xy ; u
sample_resource(1)_sampler(1) r5, r0.xy ; v
sample_resource(2)_sampler(2) r6, r0.xy ; w

mul r0, cb1[0].xxxx, l1.yyyy ; [-dt/ds,-dt/ds,-dt/ds,-dt/ds]

; ox := ENTIER(x-(dt/ds)*u+0.5)
mad r3, r0, r4, r3
add r3, r3, l1.x
flr r3, r3
ftoi r3, r3

; oy := ENTIER(y-(dt/ds)*v+0.5)
mad r2, r0, r5, r2
add r2, r2, l1.x
flr r2, r2
ftoi r2, r2

; oz := ENTIER(z-(dt/ds)*w+0.5)
mad r1, r0, r6, r1
add r1, r1, l1.x
flr r1, r1
ftoi r1, r1

; apply boundaries

; x
ige r0, r3, r3.0000
iand r3, r3, r0

iadd r4, cb0[0].yyyy, l2.xxxx ; Nx-2
iadd r5, cb0[0].yyyy, l2.yyyy ; Nx-1
ilt r0, r3, r5 ; r3 < Nx-1
if_logicalz r0.x
	mov r3.x, r4.x
endif
if_logicalz r0.y
	mov r3.y, r4.y
endif
if_logicalz r0.z
	mov r3.z, r4.z
endif
if_logicalz r0.w
	mov r3.w, r4.w
endif

; y
ige r0, r2, r2.0000
iand r2, r2, r0

iadd r4, cb0[0].zzzz, l2.xxxx ; Ny-2
iadd r5, cb0[0].zzzz, l2.yyyy ; Ny-1
ilt r0, r2, r5 ; r2 < Ny-1
if_logicalz r0.x
	mov r2.x, r4.x
endif
if_logicalz r0.y
	mov r2.y, r4.y
endif
if_logicalz r0.z
	mov r2.z, r4.z
endif
if_logicalz r0.w
	mov r2.w, r4.w
endif

; z
ige r0, r1, r1.0000
iand r1, r1, r0

iadd r4, cb0[0].wwww, l2.xxxx ; Nz-2
iadd r5, cb0[0].wwww, l2.yyyy ; Nz-1
ilt r0, r1, r5 ; r1 < Nz-1
if_logicalz r0.x
	mov r1.x, r4.x
endif
if_logicalz r0.y
	mov r1.y, r4.y
endif
if_logicalz r0.z
	mov r1.z, r4.z
endif
if_logicalz r0.w
	mov r1.w, r4.w
endif

; compute single elem positions for the source target
imul r0, r1, r8 ; [z0,z1,z2,z3].*[Ny*Nx,Ny*Nx,Ny*Nx,Ny*Nx]
imad r0, r2, cb0[0].yyyy, r0
iadd r0, r0, r3

mov r1.x, r0.x
call 0
mov r3.x, r2.x

mov r1.x, r0.y
call 0
mov r3.y, r2.x

mov r1.x, r0.z
call 0
mov r3.z, r2.x

mov r1.x, r0.w
call 0
mov r3.w, r2.x

mov g[vaTid.x], r3

endmain

; load a single element given by its single element position in r1.x
; output is in r2.x
; uses r4
func 0
	
	if_logicalz r10.z
		udiv r4.x, r1.x, l0.w
		umod r4.z, r1.x, l0.w
	else				
		; quad position with account of padding		
		udiv r4.y, r1.x, cb0[0].y ; number of lines				
		umod r4.x, r1.x, cb0[0].y ; position within the line
		imad r4.x, r4.y, r10.x, r4.x ; position with account of padding
		
		umod r4.z, r4.x, l0.w
		udiv r4.x, r4.x, l0.w
	endif	
	
	; 2D position
	udiv r4.y, r4.x, cb0[0].x
	umod r4.x, r4.x, cb0[0].x
	itof r4.xy, r4.xy
	
	switch r4.z
	
		case 0
			sample_resource(3)_sampler(3) r2.x___, r4.xy
		break
		
		case 1
			sample_resource(3)_sampler(3) r2._y__, r4.xy
			mov r2.x, r2.y
		break
		
		case 2
			sample_resource(3)_sampler(3) r2.__z_, r4.xy
			mov r2.x, r2.z
		break
		
		case 3
			sample_resource(3)_sampler(3) r2.___w, r4.xy
			mov r2.x, r2.w
		break
		
	endswitch
ret
endfunc

end
]]>
	</ILKernel>
	
<ILKernel name = "CompareWithScalar_LI_R_LR">
<![CDATA[
il_cs_2_0
dcl_num_thread_per_group 64
;
;	Elementwise comparison with a scalar
; 
;	inputs: 1
;	global buffer: yes
;	data type: LONGINT,REAL,LONGREAL
;	nComponents: 4/(2 for LONGREAL)
;	constants: 1, 1x4 (LONGINT), 1x4 (varaable type)
;

dcl_cb cb0[1]	; [physWidth,dType,opCode,..]
dcl_cb cb1[1]	; [...]

dcl_resource_id(0)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)

dcl_literal l0, 4, 1, 0xFFFFFFFF, 0
dcl_literal l1, 0xBFF00000, 0, 0xBFF00000, 0 ; [-1, -1] in doubles

; compute linear index of first element
imul r0.xy, vaTid.xx, l0.xx ; account 4 quads per thread

; compute 2D positions of 4 adjacent quads
udiv r1.y, r0.x, cb0[0].x
umod r1.x, r0.x, cb0[0].x
iadd r0.x, r0.x, l0.y ; increment linear index

udiv r1.w, r0.x, cb0[0].x
umod r1.z, r0.x, cb0[0].x
iadd r0.x, r0.x, l0.y

udiv r2.y, r0.x, cb0[0].x
umod r2.x, r0.x, cb0[0].x
iadd r0.x, r0.x, l0.y

udiv r2.w, r0.x, cb0[0].x
umod r2.z, r0.x, cb0[0].x

itof r1, r1
itof r2, r2

; load input elements
sample_resource(0)_sampler(0) r3, r1.xy
sample_resource(0)_sampler(0) r4, r1.zw
sample_resource(0)_sampler(0) r5, r2.xy
sample_resource(0)_sampler(0) r6, r2.zw

switch cb0[0].z ; opCode
	
	case 12 ; OpLt
		
		switch cb0[0].y ; dType
			
			case 3 ; TLONGINT
				
				break
			
			case 5 ; TREAL
				
				break
			
			case 6 ; TLONGREAL
				
				break
			
		endswitch
		
		break
	
	case 13 ; OpGt
		
		switch cb0[0].y ; dType
			
			case 3 ; TLONGINT
				
				break
			
			case 5 ; TREAL
				
				break
			
			case 6 ; TLONGREAL
				
				break
			
		endswitch
		
		break
	
	case 14 ; OpEq
		
		switch cb0[0].y ; dType
			
			case 3 ; TLONGINT
				
				break
			
			case 5 ; TREAL
				
				break
			
			case 6 ; TLONGREAL
				
				break
			
		endswitch
		
		break	
	
endswitch

; store to the output
mov g[r0.y], r3

end		
]]>
	</ILKernel>
	
</Kernels>

