MODULE Partitions IN Oberon;
	IMPORT Kernel, Modules, Disks, Files, Fonts, Texts, Input, Oberon, In;
CONST 
	Trace = TRUE; 
	ShowReserved = FALSE; 
	BS = 512; 
	BootLoaderName = \"OBL.Bin"\; 
	BootFileName = \"IDE.Bin"\; 
	MinPartSize = 64; 
	N2KSS = 2048; 
	N2KBPS = (N2KSS DIV BS); 
	N2KDirMark = LONGINT(9B1EA38DH); 
	AosSSLog2 = 12; 
	AosSS = ASH(1, AosSSLog2); 
	AosBPS = (AosSS DIV BS); 
	AosSF = 29; 
	AosSTS = 128; 
	AosXS = (AosSS DIV 4); 
	AosHS = 568; 
	AosDirMark = LONGINT(9B1EA38DH); 
	AosType = 76; 
	NativeType1 = 79; 
	NativeType2 = 80; 
	FSID = 559107905; 
	FSID0 = 1380270671; 
	FSIDOBL = 1145652297; 
	FSVer = 2; 
	FSRes = ((640 * 1024) DIV BS); 
	LoaderSize = 4; 
	Read = Disks.Read; 
	Write = Disks.Write; 
	Ok = Disks.Ok; 
	NumFlop = 2; 
	MaxConfig = 2000; 
	WholeDisk = 256; 
	FreeSpace =  -1; 
	ReservedSpace =  -2; 
	NoSpaceAvailable = 9001; 
	CoreMismatch = 9002; 
	CoreChecksumError = 9003; 
	OutOfSlots = 9004; 
	PartitionTooSmall = 9005; 
	Interrupted = MAX(LONGINT); 
	DisketteLimit = 2880; 
TYPE 
	ConfigTable = POINTER TO ARRAY OF CHAR; 
VAR 
	w: Texts.Writer; 
	hex: ARRAY 17 OF CHAR; 
	safe: BOOLEAN; 

	PROCEDURE ^ WriteType(VAR w: Texts.Writer; type: LONGINT); 
	PROCEDURE ^ WriteErrorMsg(VAR w: Texts.Writer; res: LONGINT); 
	PROCEDURE ^ WriteTransferError(VAR w: Texts.Writer; dev: Disks.Device; op, start, res: LONGINT); 
	PROCEDURE ^ IsDOS(type: LONGINT): BOOLEAN; 
	PROCEDURE ^ WriteK(VAR W: Texts.Writer; k: LONGINT); 
	PROCEDURE ^ Progress(t: Texts.Text; now, max: LONGINT; VAR next: LONGINT); 
	PROCEDURE ^ UserInterrupt(VAR ch: CHAR): BOOLEAN; 
	PROCEDURE ^ ShowDevice(VAR w: Texts.Writer; d: Disks.Device; verbose: BOOLEAN; VAR res: LONGINT); 
	PROCEDURE ^ WritePart(VAR w: Texts.Writer; dev: Disks.Device; part: LONGINT); 
	PROCEDURE ^ WriteTable(VAR w: Texts.Writer; d: Disks.Device; table: Disks.PartitionTable; verbose: BOOLEAN; VAR dosnum: LONGINT); 
	PROCEDURE ^ GetTableGeometry(dev: Disks.Device; VAR hds, spt: LONGINT): BOOLEAN; 
	PROCEDURE ^ GetGeometry(dev: Disks.Device; VAR geo: Disks.GetGeometryMsg; VAR res: LONGINT); 
	PROCEDURE ^ Extended(type: LONGINT): BOOLEAN; 
	PROCEDURE ^ NewFree(type: LONGINT; VAR table: Disks.PartitionTable; start, size, ptblock: LONGINT; flags: SET); 
	PROCEDURE ^ FindFreePrimary(VAR table: Disks.PartitionTable; spt, hds: LONGINT); 
	PROCEDURE ^ FindFreeExtended(VAR table: Disks.PartitionTable; spt, hds: LONGINT); 
	PROCEDURE ^ FindReserved(VAR table: Disks.PartitionTable); 
	PROCEDURE ^ Contains(table: Disks.PartitionTable; i, x: LONGINT): BOOLEAN; 
	PROCEDURE ^ PartitionsOverlap(table: Disks.PartitionTable; i, j: LONGINT): BOOLEAN; 
	PROCEDURE ^ CheckTable(dev: Disks.Device; table: Disks.PartitionTable): BOOLEAN; 
	PROCEDURE ^ FindFreeSpace(dev: Disks.Device; VAR table: Disks.PartitionTable; spt, hds: LONGINT); 
	PROCEDURE ^ Show*; 
	PROCEDURE ^ Put2(VAR b: ARRAY OF CHAR; i, val: LONGINT); 
	PROCEDURE ^ Put4(VAR b: ARRAY OF CHAR; i, val: LONGINT); 
	PROCEDURE ^ Get2(VAR b: ARRAY OF CHAR; i: LONGINT): LONGINT; 
	PROCEDURE ^ Get4(VAR b: ARRAY OF CHAR; i: LONGINT): LONGINT; 
	PROCEDURE ^ GetDriveNum(dev: Disks.Device): CHAR; 
	PROCEDURE ^ InitOBL(dev: Disks.Device; part, flag: LONGINT; VAR res: LONGINT); 
	PROCEDURE ^ InitAosFS(dev: Disks.Device; part, fsres, flag: LONGINT; VAR res: LONGINT); 
	PROCEDURE ^ InitNativeFS(dev: Disks.Device; part, fsres, flag: LONGINT; VAR res: LONGINT); 
	PROCEDURE ^ DetectFS(dev: Disks.Device; part: LONGINT): LONGINT; 
	PROCEDURE ^ CheckDiskette(name: ARRAY OF CHAR); 
	PROCEDURE ^ ScanOpenPart(VAR dev: Disks.Device; check: BOOLEAN; VAR part: LONGINT); 
	PROCEDURE ^ Random(VAR seed: LONGINT; N: LONGINT): LONGINT; 
	PROCEDURE ^ CheckPartition(dev: Disks.Device; part: LONGINT; VAR res: LONGINT); 
	PROCEDURE ^ GetVars(dev: Disks.Device; part: LONGINT; VAR tsize, reserved, fsOfs, res: LONGINT); 
	PROCEDURE ^ GetTable(dev: Disks.Device; part: LONGINT; VAR table: ConfigTable; VAR res: LONGINT); 
	PROCEDURE ^ PutTable(dev: Disks.Device; part: LONGINT; table: ConfigTable; VAR res: LONGINT); 
	PROCEDURE ^ FindEntry(table: ConfigTable; i, type: LONGINT): LONGINT; 
	PROCEDURE ^ AddEntry(table: ConfigTable; type, dsize: LONGINT; VAR data: ARRAY OF CHAR); 
	PROCEDURE ^ DeleteEntry(table: ConfigTable; i: LONGINT); 
	PROCEDURE ^ WriteFile(f: Files.File; dev: Disks.Device; pos: LONGINT; VAR sum, res: LONGINT); 
	PROCEDURE ^ CheckFile(f: Files.File; dev: Disks.Device; pos: LONGINT; sum: LONGINT; VAR res: LONGINT); 
	PROCEDURE ^ InitBootFile(dev: Disks.Device; part: LONGINT; f: Files.File; VAR res: LONGINT); 
	PROCEDURE ^ NativeType(type: LONGINT): BOOLEAN; 
	PROCEDURE ^ Format*; 
	PROCEDURE ^ UpdateBootFile*; 
	PROCEDURE ^ GetConfig*; 
	PROCEDURE ^ IsHex(ch: CHAR): BOOLEAN; 
	PROCEDURE ^ HexVal(ch: CHAR): LONGINT; 
	PROCEDURE ^ UnQuote(VAR config: ARRAY OF CHAR; VAR len: LONGINT); 
	PROCEDURE ^ ParseConfig(table: ConfigTable): BOOLEAN; 
	PROCEDURE ^ SetConfig*; 
	PROCEDURE ^ Check*; 
	PROCEDURE ^ ChangePartType(dev: Disks.Device; part: LONGINT; oldtype, newtype: LONGINT; VAR res: LONGINT); 
	PROCEDURE ^ ChangeType*; 
	PROCEDURE ^ DeletePrimary(dev: Disks.Device; part: LONGINT; type: LONGINT; VAR res: LONGINT); 
	PROCEDURE ^ Delete*; 
	PROCEDURE ^ CreatePrimary(dev: Disks.Device; table: Disks.PartitionTable; part, size, spt, hds, type: LONGINT; VAR res: LONGINT); 
	PROCEDURE ^ Create*; 
	PROCEDURE ^ SetFlag(on: BOOLEAN); 
	PROCEDURE ^ Activate*; 
	PROCEDURE ^ Deactivate*; 
	PROCEDURE ^ FileToPartition*; 
	PROCEDURE ^ PartitionToFile*; 
	PROCEDURE ^ WriteMBR*; 
	PROCEDURE ^ UpdateOBL(dev: Disks.Device; part: LONGINT; f: Files.File; VAR res: LONGINT); 
	PROCEDURE ^ UpdateBootLoader*; 
	PROCEDURE ^ WriteHex(VAR wr: Texts.Writer; x, w: LONGINT); 
	PROCEDURE ^ WriteHexDump(VAR w: Texts.Writer; VAR buf: ARRAY OF CHAR; ofs, size, base: LONGINT); 
	PROCEDURE ^ ShowBlocks*; 
	PROCEDURE ^ Unsafe*; 
	PROCEDURE ^ Safe*; 
	PROCEDURE ^ ShowAosFSLimits*; 
	PROCEDURE ^ Eject*; 
BEGIN
END Partitions.
