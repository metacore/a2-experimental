MODULE PCC;
	IMPORT SYSTEM, PCDebug, PCM, PCBT, PCLIR, PCS, PCT;
CONST 
	Trace = FALSE; 
	Statistics = FALSE; 
	setfn* = 200; 
	absfn* = 201; 
	capfn* = 202; 
	oddfn* = 203; 
	ashfn* = 204; 
	lshfn* = 205; 
	rotfn* = 206; 
	bitfn* = 207; 
	True = 1; 
	False = 0; 
	Nil = 0; 
	Abs = 1; 
	Var = 2; 
	Ref = 3; 
	Const = 4; 
	Reg = 5; 
	RegRel = 6; 
	CC = 7; 
	Proc = 8; 
	Case = 9; 
	ccNone = 0; 
	ccAlways = 1; 
	ccNever = 2; 
	ccEQ = 3; 
	ccNE = 4; 
	ccGT = 5; 
	ccGE = 6; 
	ccLT = 7; 
	ccLE = 8; 
	ccB = 9; 
	ccBE = 10; 
	ccA = 11; 
	ccAE = 12; 
	ccF = 13; 
	ccNF = 14; 
	none* = PCLIR.none; 
	BaseTypesTable =  -2; 
	MethodTable =  -18; 
	IntfMethodTable = 1; 
	ArrayFirstElem = 2; 
	ArrayDimTable = 3; 
	TensorFlag* = 0; 
	RangeFlag* = 1; 
	StackFlag* = 2; 
	Descr_PtrOffs* = 0; 
	Descr_AdrOffs* = 1; 
	Descr_FlagsOffs* = 2; 
	Descr_DimOffs* = 3; 
	Descr_SizeOffs* = 4; 
	Descr_LenOffs* = 5; 
	Descr_IncOffs* = 6; 
	SysDataArrayOffset* = 8; 
	ArrDataArrayOffset* = 16; 
	SmallMatrixFlag* = 3; 
	SmallVectorFlag* = 3; 
TYPE 
	Item* = RECORD 
		mode, level: SHORTINT; 
		deref: BOOLEAN; 
		adr, offs, value: LONGINT; 
		breg, boffs: LONGINT; 
		tlist, flist: LONGINT; 
		proc: PCBT.Procedure; 
		var: PCBT.GlobalVariable; 
		type-: PCT.Struct; 
	END; 

	Label* = LONGINT; 

	Code* = PCLIR.Code; 
VAR 
	delegate*, hdptr*: PCT.Record; 
	anyarr*: ARRAY 32 OF PCT.Record; 
	range*: PCT.Record; 
	topscope*: PCT.ModScope; 
	CCTab, InvCCTab, SetCCTab: ARRAY 15 OF PCLIR.Opcode; 
	InvCC: ARRAY 15 OF SHORTINT; 
	MethodType: PCT.Delegate; 
	AParArray, AParBasic, AParProc, AParRec: LONGINT; 
	AAssBasic, AAssRec, AAssArray, AAssProc: LONGINT; 
	ARetBasic, ARetRec, ARetStaticArray, ARetOpenArray, ARetElse: LONGINT; 

	PROCEDURE ^ IsString(t: PCT.Struct): BOOLEAN; 
	PROCEDURE ^ GetActivationFrame(code: Code; level: SHORTINT; VAR reg: LONGINT); 
	PROCEDURE ^ Load*(code: Code; VAR x: Item); 
	PROCEDURE ^ LoadAdr(code: Code; VAR x: Item); 
	PROCEDURE ^ LoadArrayAdr*(code: Code; VAR descr, array: Item); 
	PROCEDURE ^ DerefTensor*(code: Code; VAR x: Item); 
	PROCEDURE ^ GetDelegateSelfReg(code: Code; x: Item; modeBeforeLoad: LONGINT): PCLIR.Register; 
	PROCEDURE ^ NilCheck(code: Code; VAR x: Item); 
	PROCEDURE ^ MakeItem*(VAR x: Item; o: PCT.Symbol; deltaLevel: SHORTINT); 
	PROCEDURE ^ MakeStackItem*(VAR x: Item; type: PCT.Struct); 
	PROCEDURE ^ MakeConst*(VAR x: Item; o: PCT.Const; type: PCT.Struct); 
	PROCEDURE ^ MakeIntConst*(VAR x: Item; val: LONGINT; type: PCT.Struct); 
	PROCEDURE ^ MakeSizeConst*(VAR x: Item; val: LONGINT); 
	PROCEDURE ^ SetType*(VAR x: Item; type: PCT.Struct); 
	PROCEDURE ^ MakeTD*(VAR x: Item; type: PCT.Record); 
	PROCEDURE ^ GetStaticSize*(t: PCT.Struct): LONGINT; 
	PROCEDURE ^ GetArrayBaseSize(code: Code; VAR size: Item; arr: Item); 
	PROCEDURE ^ ArrayDim(code: Code; VAR res, arr: Item; dim: LONGINT); 
	PROCEDURE ^ EnhArrayLen(code: Code; VAR res, arr: Item; dim: LONGINT); 
	PROCEDURE ^ EnhArrayInc(code: Code; VAR res, arr: Item; dim: LONGINT); 
	PROCEDURE ^ GetTD(code: Code; r: Item; VAR td: Item; superclass: BOOLEAN); 
	PROCEDURE ^ TypeCheck*(code: Code; VAR r: Item; str: PCT.Struct; trap, equal: BOOLEAN); 
	PROCEDURE ^ Incr*(code: Code; VAR arr, dim: Item); 
	PROCEDURE ^ Dim*(code: Code; VAR arr: Item); 
	PROCEDURE ^ Len*(code: Code; VAR arr, dim: Item); 
	PROCEDURE ^ GenConv(code: Code; op: PCLIR.Opcode; VAR x: Item; size: PCLIR.Size; signed: BOOLEAN); 
	PROCEDURE ^ Enter*(code: Code; callconv: LONGINT; adr: PCM.Attribute); 
	PROCEDURE ^ Leave*(code: Code; callconv: LONGINT; proc: PCT.Proc; adr: PCM.Attribute); 
	PROCEDURE ^ StackAllocate(code: Code; size: LONGINT; VAR tos: Item); 
	PROCEDURE ^ FreeStack*(code: Code; type: PCT.Struct); 
	PROCEDURE ^ RemoveArys*(code: Code; aryNbr: LONGINT); 
	PROCEDURE ^ ReturnProc(code: Code; x: Item; proc: PCT.Proc); 
	PROCEDURE ^ ReturnArray(code: Code; x: Item; proc: PCT.Proc); 
	PROCEDURE ^ CopyEnhArray(code: Code; src, dest: Item; copy: PCT.Proc); 
	PROCEDURE ^ MakeReturnItem*(code: Code; VAR dst: Item; proc: PCT.Proc); 
	PROCEDURE ^ GetDims*(t: PCT.Struct): LONGINT; 
	PROCEDURE ^ LocalArray*(code: Code; par: PCT.Parameter); 
	PROCEDURE ^ LocalEnhArray*(code: Code; par: PCT.Parameter; copy: PCT.Proc); 
	PROCEDURE ^ PushStaticArray*(code: Code; t: PCT.EnhArray); 
	PROCEDURE ^ AllocateLocalArray*(code: Code; p: PCT.LocalVar; size: Item); 
	PROCEDURE ^ PushRetDesc*(code: Code; i: Item); 
	PROCEDURE ^ PushRetDesc1*(code: Code; fp: PCT.Symbol); 
	PROCEDURE ^ PushRetDesc2*(code: Code; proc: PCT.Proc); 
	PROCEDURE ^ PushOpenAryRetDesc*(code: Code; t: PCT.Struct); 
	PROCEDURE ^ PushStatAryRetDesc*(code: Code; ary: PCT.Struct); 
	PROCEDURE ^ PushOpenAryParams*(code: Code; formal, actual: PCT.Struct; VAR ofs: LONGINT; parNbr: LONGINT); 
	PROCEDURE ^ PushResultTensor*(code: Code; proc: PCT.Proc); 
	PROCEDURE ^ WriteBackResultTensor*(code: Code; proc: PCT.Proc); 
	PROCEDURE ^ WriteBackResult*(code: Code; proc: PCT.Proc; VAR spoffset: LONGINT); 
	PROCEDURE ^ PrepStackTensor*(code: Code); 
	PROCEDURE ^ PrepStackEnhArray*(code: Code; formal, actual: PCT.Struct); 
	PROCEDURE ^ PrepStack*(code: Code; formal, actual: PCT.Struct); 
	PROCEDURE ^ FixRetDesc*(code: Code; type: PCT.Struct; openAryParams: LONGINT; VAR ofs: LONGINT); 
	PROCEDURE ^ CopyBlock(code: Code; VAR dst, src: Item; size: LONGINT); 
	PROCEDURE ^ MoveBlock*(code: Code; VAR dstAdr, srcAdr, size: Item); 
	PROCEDURE ^ MoveConvertString(code: Code; VAR src, dst, size: PCLIR.Register; srcSize, dstSize: PCLIR.Size); 
	PROCEDURE ^ MoveString*(code: Code; VAR src, dst: Item); 
	PROCEDURE ^ GetHWReg*(code: Code; VAR x: Item; reg: SHORTINT); 
	PROCEDURE ^ SetHWReg*(code: Code; VAR x: Item; reg: SHORTINT); 
	PROCEDURE ^ GetMemory*(code: Code; VAR adr: Item; type: PCT.Struct); 
	PROCEDURE ^ WriteHWPort*(code: Code; VAR x, y: Item); 
	PROCEDURE ^ ReadHWPort*(code: Code; VAR x, y: Item); 
	PROCEDURE ^ InitCC(VAR a: Item; cc: LONGINT; r1, r2: PCLIR.Register); 
	PROCEDURE ^ LoadCC(code: Code; VAR a: Item); 
	PROCEDURE ^ CondOr*(code: Code; VAR a: Item); 
	PROCEDURE ^ Or*(code: Code; VAR a, b: Item); 
	PROCEDURE ^ CondAnd*(code: Code; VAR a: Item); 
	PROCEDURE ^ And*(code: Code; VAR a, b: Item); 
	PROCEDURE ^ MOp*(code: Code; f: LONGINT; VAR a: Item); 
	PROCEDURE ^ MinMax*(code: Code; fcc: LONGINT; VAR a, b: Item); 
	PROCEDURE ^ Swap*(code: Code; VAR a, b: Item); 
	PROCEDURE ^ DOp*(code: Code; f: LONGINT; VAR a, b: Item); 
	PROCEDURE ^ StringCmp(code: Code; cc: SHORTINT; VAR cond: Item; a, b: Item); 
	PROCEDURE ^ RelOp*(code: Code; operand: LONGINT; VAR a, b: Item); 
	PROCEDURE ^ Convert*(code: Code; VAR x: Item; type: PCT.Struct; typeOnly: BOOLEAN); 
	PROCEDURE ^ Deref*(code: Code; VAR x: Item); 
	PROCEDURE ^ Range*(code: Code; rangeover: PCT.EnhArray; VAR descr, x, from, to, by: Item; dim: LONGINT); 
	PROCEDURE ^ EIndex*(code: Code; VAR descr, x, index: Item; dim: LONGINT); 
	PROCEDURE ^ TensorIndex*(code: Code; VAR descr, x, index: Item; d: LONGINT); 
	PROCEDURE ^ TensorFiller*(code: Code; VAR descr, x: Item; before, after: LONGINT); 
	PROCEDURE ^ TensorRange*(code: Code; VAR descr, x, from, to, by: Item; d: LONGINT); 
	PROCEDURE ^ Index*(code: Code; VAR x, index: Item); 
	PROCEDURE ^ Field*(code: Code; VAR x: Item; fld: PCT.Field); 
	PROCEDURE ^ Method*(code: Code; VAR x: Item; self: Item; mth: PCT.Method; supercall: BOOLEAN); 
	PROCEDURE ^ InterfaceLookup(code: Code; VAR self: Item; intf: PCT.Record; VAR vtable: Item); 
	PROCEDURE ^ SysNewRec*(code: Code; VAR x: Item); 
	PROCEDURE ^ SysNewBlock*(code: Code; x, size: Item); 
	PROCEDURE ^ SysNewEnhArray*(code: Code; VAR ptr: Item; btyp: PCT.Struct; nofElem: Item); 
	PROCEDURE ^ SysNewDescriptor*(code: Code; VAR x: Item; dim: LONGINT); 
	PROCEDURE ^ TensorSysNew*(code: Code; VAR descr: Item; btyp: PCT.Struct; nofElem: Item; nofDims: LONGINT); 
	PROCEDURE ^ SysNewArray*(code: Code; VAR ptr: Item; btyp: PCT.Struct; nofElem: Item; nofDims: LONGINT); 
	PROCEDURE ^ SetEnhArrayLen*(code: Code; VAR ptr, inc: Item; nofDims, dim: LONGINT); 
	PROCEDURE ^ SetEnhArrayDim*(code: Code; VAR ptr: Item; dim: LONGINT); 
	PROCEDURE ^ SetEnhArrayFlags*(code: Code; VAR ptr: Item; flags: SET); 
	PROCEDURE ^ SetSmallMatrixFlags*(code: Code; VAR ptr: Item); 
	PROCEDURE ^ SetSmallVectorFlags*(code: Code; VAR ptr: Item); 
	PROCEDURE ^ SetEnhArraySize*(code: Code; VAR ptr: Item; elementsize: LONGINT); 
	PROCEDURE ^ TensorSetAdr*(code: Code; VAR ptr: Item; hasPointers: BOOLEAN); 
	PROCEDURE ^ TensorSetDim*(code: Code; VAR ptr: Item; nofDims: LONGINT); 
	PROCEDURE ^ TensorSetSize*(code: Code; VAR ptr: Item; elementsize: LONGINT); 
	PROCEDURE ^ TensorSetFlags*(code: Code; VAR ptr: Item; flags: SET); 
	PROCEDURE ^ PopLen*(code: Code; VAR len: Item); 
	PROCEDURE ^ DescriptorSetLen*(code: Code; VAR ptr, len: Item; dim: LONGINT); 
	PROCEDURE ^ DescriptorSetInc*(code: Code; VAR ptr, inc: Item; dim: LONGINT); 
	PROCEDURE ^ TensorGetDesc(code: Code; VAR res, arr, dim: Item; offs: LONGINT); 
	PROCEDURE ^ TensorGetDim*(code: Code; VAR res, arr: Item); 
	PROCEDURE ^ TensorGetSize*(code: Code; VAR res, arr: Item); 
	PROCEDURE ^ TensorGetFlags*(code: Code; VAR res, arr: Item); 
	PROCEDURE ^ TensorCheckDim(code: Code; VAR res, arr, dim: Item); 
	PROCEDURE ^ TensorCheckDims*(code: Code; VAR x: Item; dims: LONGINT); 
	PROCEDURE ^ TensorGetLen(code: Code; VAR res, arr, dim: Item; checkDim: BOOLEAN); 
	PROCEDURE ^ TensorGetInc(code: Code; VAR res, arr, dim: Item; checkDim: BOOLEAN); 
	PROCEDURE ^ StaticPrepStack*(code: Code; a: Item; tensor: BOOLEAN); 
	PROCEDURE ^ TensorPrepStack*(code: Code; a: Item; ref: BOOLEAN); 
	PROCEDURE ^ EnhArrayPointerToStack*(code: Code; a: Item); 
	PROCEDURE ^ TensorUseStack*(code: Code; ofs: LONGINT; parNbr: LONGINT); 
	PROCEDURE ^ TensorUseStackItem*(code: Code; ofs: LONGINT; parNbr: LONGINT; VAR i: Item; type: PCT.Struct); 
	PROCEDURE ^ TensorDescriptorToStack*(code: Code; VAR arr: Item; dim: LONGINT); 
	PROCEDURE ^ SetArrayDim*(code: Code; VAR ptr: Item; nofDims, dim: LONGINT); 
	PROCEDURE ^ SysLock*(code: Code; self: Item; lock: BOOLEAN); 
	PROCEDURE ^ SysStart*(code: Code; body: PCT.Method; self: Item); 
	PROCEDURE ^ SysGetProcedure*(code: Code; moduleName, procedureName, entryAdr: Item; procScope: PCT.ProcScope; returnType: PCT.Struct); 
	PROCEDURE ^ NewInstr*(code: Code; pos: LONGINT); 
	PROCEDURE ^ Assign*(code: Code; VAR dest, source: Item); 
	PROCEDURE ^ GenTrap*(code: Code; nr: LONGINT); 
	PROCEDURE ^ Return*(code: Code; x: Item; proc: PCT.Proc; rtypeAddr: LONGINT); 
	PROCEDURE ^ SYScopy*(code: Code; x, y: Item; get: BOOLEAN); 
	PROCEDURE ^ SYSaddress*(code: Code; VAR x: Item); 
	PROCEDURE ^ Inc*(code: Code; VAR x, y: Item; dec: BOOLEAN); 
	PROCEDURE ^ Inline*(code: Code; VAR x: PCM.Attribute); 
	PROCEDURE ^ AwaitEnter*(code: Code; VAR adr: PCM.Attribute); 
	PROCEDURE ^ AwaitExit*(code: Code; cond: Item); 
	PROCEDURE ^ Await*(code: Code; self: Item; adr: PCM.Attribute); 
	PROCEDURE ^ PushSL*(code: Code; deltaLevel: SHORTINT); 
	PROCEDURE ^ SaveRegisters*(code: Code); 
	PROCEDURE ^ RestoreRegisters*(code: Code); 
	PROCEDURE ^ ParamArray(code: Code; VAR ap: Item; formaltype: PCT.Struct; reference, notag: BOOLEAN); 
	PROCEDURE ^ AdrToStack*(code: Code; VAR ptr: Item); 
	PROCEDURE ^ PushStaticEnhArray*(code: Code; VAR ap: Item; formaltype: PCT.Struct; reference: BOOLEAN); 
	PROCEDURE ^ ParamTensor(code: Code; VAR ap: Item; formaltype: PCT.Struct; reference: BOOLEAN); 
	PROCEDURE ^ RangeDescriptorHead*(code: Code; VAR ap, dim, descr: Item); 
	PROCEDURE ^ ArrayDescriptorToStack*(code: Code; VAR arr: Item); 
	PROCEDURE ^ ParamEnhArray*(code: Code; VAR ap: Item; formaltype: PCT.Struct; reference: BOOLEAN; VAR spoffset: LONGINT); 
	PROCEDURE ^ PushStackRelAddress*(code: Code; offset: LONGINT); 
	PROCEDURE ^ MakeStackEnhArrayItem*(code: Code; VAR i: Item; type: PCT.Struct); 
	PROCEDURE ^ RevertStack*(code: Code; offset: LONGINT); 
	PROCEDURE ^ Param*(code: Code; VAR ap: Item; formaltype: PCT.Struct; reference, notag: BOOLEAN); 
	PROCEDURE ^ Call*(code: Code; VAR x: Item); 
	PROCEDURE ^ Result*(code: Code; VAR x: Item; type: PCT.Struct); 
	PROCEDURE ^ DefFinallyLabel*(code: Code; obj: PCT.Symbol); 
	PROCEDURE ^ DefLabel*(code: Code; VAR pc: Label); 
	PROCEDURE ^ Jmp*(code: Code; VAR pc: Label); 
	PROCEDURE ^ Jcc*(code: Code; VAR pc: Label; VAR cond: Item); 
	PROCEDURE ^ FixJmp*(code: Code; VAR pc: Label); 
	PROCEDURE ^ CaseStat*(code: Code; VAR case: Item; x: Item); 
	PROCEDURE ^ CaseLine*(code: Code; case: Item; low, high: LONGINT); 
	PROCEDURE ^ CaseElse*(code: Code; case: Item); 
	PROCEDURE ^ InitInterface*(code: Code; rec, intf: PCT.Record); 
	PROCEDURE ^ Init; 
	PROCEDURE ^ Cleanup*; 
BEGIN
END PCC.
