MODULE OPP IN Oberon;
	IMPORT OPT, OPS, OPM, OPB, OPA;
CONST 
	char = 1; 
	integer = 2; 
	real = 3; 
	longreal = 4; 
	null = OPS.null; 
	times = OPS.times; 
	slash = OPS.slash; 
	div = OPS.div; 
	mod = OPS.mod; 
	and = OPS.and; 
	plus = OPS.plus; 
	minus = OPS.minus; 
	or = OPS.or; 
	eql = OPS.eql; 
	neq = OPS.neq; 
	lss = OPS.lss; 
	leq = OPS.leq; 
	gtr = OPS.gtr; 
	geq = OPS.geq; 
	in = OPS.in; 
	is = OPS.is; 
	arrow = OPS.arrow; 
	period = OPS.period; 
	comma = OPS.comma; 
	colon = OPS.colon; 
	upto = OPS.upto; 
	rparen = OPS.rparen; 
	rbrak = OPS.rbrak; 
	rbrace = OPS.rbrace; 
	of = OPS.of; 
	then = OPS.then; 
	do = OPS.do; 
	to = OPS.to; 
	by = OPS.by; 
	lparen = OPS.lparen; 
	lbrak = OPS.lbrak; 
	lbrace = OPS.lbrace; 
	not = OPS.not; 
	becomes = OPS.becomes; 
	number = OPS.number; 
	nil = OPS.nil; 
	true = OPS.true; 
	false = OPS.false; 
	string = OPS.string; 
	ident = OPS.ident; 
	semicolon = OPS.semicolon; 
	bar = OPS.bar; 
	end = OPS.end; 
	else = OPS.else; 
	elsif = OPS.elsif; 
	until = OPS.until; 
	if = OPS.if; 
	case = OPS.case; 
	while = OPS.while; 
	repeat = OPS.repeat; 
	for = OPS.for; 
	loop = OPS.loop; 
	with = OPS.with; 
	exit = OPS.exit; 
	return = OPS.return; 
	array = OPS.array; 
	object = OPS.object; 
	record = OPS.record; 
	pointer = OPS.pointer; 
	begin = OPS.begin; 
	code = OPS.code; 
	const = OPS.const; 
	type = OPS.type; 
	var = OPS.var; 
	procedure = OPS.procedure; 
	import = OPS.import; 
	module = OPS.module; 
	eof = OPS.eof; 
	finally = OPS.finally; 
	Var = 1; 
	VarPar = 2; 
	Con = 3; 
	Fld = 4; 
	Typ = 5; 
	LProc = 6; 
	XProc = 7; 
	SProc = 8; 
	CProc = 9; 
	IProc = 10; 
	Mod = 11; 
	Head = 12; 
	TProc = 13; 
	Undef = 0; 
	Byte = 1; 
	Bool = 2; 
	Char = 3; 
	SInt = 4; 
	Int = 5; 
	LInt = 6; 
	Real = 7; 
	LReal = 8; 
	Set = 9; 
	String = 10; 
	NilTyp = 11; 
	NoTyp = 12; 
	Pointer = 13; 
	ProcTyp = 14; 
	Comp = 15; 
	intSet = {SInt .. LInt}; 
	Basic = 1; 
	StaticArr = 2; 
	SDynArr = 3; 
	DynArr = 4; 
	OpenArr = 5; 
	Record = 6; 
	ArraySet = {StaticArr, SDynArr, DynArr, OpenArr}; 
	haltfn = 0; 
	newfn = 1; 
	sizefn = 12; 
	incfn = 13; 
	lenfn = 17; 
	sysnewfn = 30; 
	awaitfn = 64; 
	Nvar = 0; 
	Nvarpar = 1; 
	Nfield = 2; 
	Nderef = 3; 
	Nindex = 4; 
	Nguard = 5; 
	Neguard = 6; 
	Nconst = 7; 
	Ntype = 8; 
	Nproc = 9; 
	Nupto = 10; 
	Nmop = 11; 
	Ndop = 12; 
	Ncall = 13; 
	Ninittd = 14; 
	Nif = 15; 
	Ncaselse = 16; 
	Ncasedo = 17; 
	Nenter = 18; 
	Nassign = 19; 
	Nifelse = 20; 
	Ncase = 21; 
	Nwhile = 22; 
	Nrepeat = 23; 
	Nloop = 24; 
	Nexit = 25; 
	Nreturn = 26; 
	Nwith = 27; 
	Ntrap = 28; 
	Nassembler = 29; 
	Ncode = 30; 
	Nfinally = 40; 
	super = 1; 
	internal = 0; 
	external = 1; 
	externalR = 2; 
	hasBody = 1; 
	isRedef = 2; 
	slNeeded = 3; 
	locked = 6; 
	asmProc = 7; 
	operatorFlag = 8; 
	checkOverwriting = 31; 
	protectedObj = 4; 
	activeObj = 5; 
	safe = 8; 
	notag = 1; 
	stdcall = 2; 
	cdecl = 3; 
	untraced = 4; 
	delegate = 5; 
	systemtype = 6; 
	HiddenSelf = \"@SELF"\; 
	FTarget = 1; 
	FExpr = 2; 
	FAssign = 3; 
	FCall = 4; 
	FCond = 5; 
	FParam = 6; 
	FPassExpr = 7; 
	FReturn = 9; 
TYPE 
	CaseTable = ARRAY OPM.MaxCases OF RECORD 
		low, high: LONGINT; 
	END; 

	FixPtr = POINTER TO FixDesc; 

	FixDesc = RECORD 
		mode: LONGINT; 
		scope: OPT.Object; 
		level: SHORTINT; 
		node: OPT.Node; 
		stream: OPS.TokenStream; 
		next: FixPtr; 
	END; 

	TypeFix = RECORD 
		pos: LONGINT; 
		name: OPS.Name; 
		scope: OPT.Object; 
		level: SHORTINT; 
	END; 

	ObjFixDesc = RECORD (TypeFix)
		obj: OPT.Object; 
	END; 

	StructFixDesc = RECORD (TypeFix)
		typ: OPT.Struct; 
	END; 

	; 

	; 
VAR 
	SignOnMessage*: ARRAY 80 OF CHAR; 
	sym, level: SHORTINT; 
	LoopLevel: INTEGER; 
	TDinit, lastTDinit: OPT.Node; 
	RecInit, lastRecInit: OPT.Node; 
	CondNodes: OPT.Node; 
	CondCount: SHORTINT; 
	UndefFlag, FixPhase: BOOLEAN; 
	UndefObj: OPT.Object; 
	scopeLock: BOOLEAN; 
	retcount: LONGINT; 
	fincount: LONGINT; 
	FixList, FixLast: FixPtr; 
	ExtObj: OPT.Object; 
	inc: OPT.Object; 
	ptrToRec: OPT.Struct; 
	ObjFix: ARRAY 128 OF ObjFixDesc; 
	ObjCheck: ARRAY 256 OF RECORD 
		obj: OPT.Object; 
		level: SHORTINT; 
	END; 
	TypFix: ARRAY 128 OF StructFixDesc; 
	nofCheck, nofObjFix, nofTypFix: LONGINT; 

	PROCEDURE ^ err(n: INTEGER); 
	PROCEDURE ^ CheckSym(s: INTEGER); 
	PROCEDURE ^ IsModuleScope(): BOOLEAN; 
	PROCEDURE ^ IsObjectScope(): BOOLEAN; 
	PROCEDURE ^ IsRecordScope(): BOOLEAN; 
	PROCEDURE ^ SetFlags(obj: OPT.Object; flag: SET); 
	PROCEDURE ^ GetFlags(obj: OPT.Object): SET; 
	PROCEDURE ^ DumpScope(o: OPT.Object); 
	PROCEDURE ^ GetSelf(): OPT.Object; 
	PROCEDURE ^ InsertFix(mode: LONGINT; stream: OPS.TokenStream; node: OPT.Node); 
	PROCEDURE ^ NewFix(VAR f: TypeFix; name: OPS.Name); 
	PROCEDURE ^ NewCheck(obj: OPT.Object); 
	PROCEDURE ^ NewType(obj: OPT.Object); 
	PROCEDURE ^ CheckRecord(typ: OPT.Struct); 
	PROCEDURE ^ CheckArray(typ: OPT.Struct); 
	PROCEDURE ^ CheckPointer(typ: OPT.Struct); 
	PROCEDURE ^ CheckProcedure(typ: OPT.Struct); 
	PROCEDURE ^ CheckStruct(str: OPT.Struct); 
	PROCEDURE ^ CheckObj(obj: OPT.Object); 
	PROCEDURE ^ qualident(VAR id: OPT.Object); 
	PROCEDURE ^ ConstExpression(VAR x: OPT.Node); 
	PROCEDURE ^ CheckMark(VAR vis: SHORTINT; rdonlyAllowed: BOOLEAN); 
	PROCEDURE ^ CheckSysFlag(VAR sysflag: SHORTINT; default: SHORTINT; allowed: SET); 
	PROCEDURE ^ BlockMode(VAR flag: SET; local: BOOLEAN; VAR lock: BOOLEAN); 
	PROCEDURE ^ RecordType(VAR typ, banned: OPT.Struct; owner: OPT.Object); 
	PROCEDURE ^ OwnScope(VAR obj: OPT.Object); 
	PROCEDURE ^ ArrayType(VAR typ, banned: OPT.Struct); 
	PROCEDURE ^ ObjectType(VAR typ, banned: OPT.Struct); 
	PROCEDURE ^ PointerType(VAR typ, banned: OPT.Struct); 
	PROCEDURE ^ FormalParameters(VAR firstPar: OPT.Object; VAR resTyp: OPT.Struct; sysflag: SHORTINT); 
	PROCEDURE ^ CheckAndFix(typ: OPT.Struct); 
	PROCEDURE ^ TypeDecl(VAR typ, banned: OPT.Struct; owner: OPT.Object); 
	PROCEDURE ^ selector(VAR x: OPT.Node); 
	PROCEDURE ^ ActualParameters(VAR aparlist: OPT.Node; fpar: OPT.Object); 
	PROCEDURE ^ Await(VAR x: OPT.Node; VAR n: INTEGER); 
	PROCEDURE ^ StandProcCall(VAR x: OPT.Node); 
	PROCEDURE ^ InlineProc(VAR x: OPT.Node; VAR apar: OPT.Node; fpar: OPT.Object); 
	PROCEDURE ^ Element(VAR x: OPT.Node); 
	PROCEDURE ^ Sets(VAR x: OPT.Node); 
	PROCEDURE ^ Resolve(VAR obj: OPT.Object; name: ARRAY OF CHAR; VAR x, y: OPT.Node); 
	PROCEDURE ^ OpCall(VAR op: OPT.Object; VAR x: OPT.Node; y: OPT.Node); 
	PROCEDURE ^ Factor(VAR x: OPT.Node); 
	PROCEDURE ^ Term(VAR x: OPT.Node); 
	PROCEDURE ^ SimpleExpression(VAR x: OPT.Node); 
	PROCEDURE ^ Expression(VAR x: OPT.Node); 
	PROCEDURE ^ ProcedureDeclaration(VAR x: OPT.Node); 
	PROCEDURE ^ CaseLabelList(VAR lab: OPT.Node; LabelForm: INTEGER; VAR n: INTEGER; VAR tab: CaseTable); 
	PROCEDURE ^ CheckBool(VAR x: OPT.Node); 
	PROCEDURE ^ DoFixes; 
	PROCEDURE ^ StatSeq(VAR stat: OPT.Node; local: BOOLEAN); 
	PROCEDURE ^ StatBlock(VAR statseq: OPT.Node; local: BOOLEAN); 
	PROCEDURE ^ AddTraceCode(owner: OPT.Object; VAR statseq: OPT.Node); 
	PROCEDURE ^ Block(VAR procdec, statseq: OPT.Node); 
	PROCEDURE ^ CreateHiddenStructs; 
	PROCEDURE ^ FullName(VAR fullname: OPS.Name); 
	PROCEDURE ^ Module*(VAR prog: OPT.Node; VAR modName: OPS.Name); 
BEGIN
END OPP.
