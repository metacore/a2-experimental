MODULE OberonFS;
	IMPORT SYSTEM, Machine, KernelLog, Modules, Clock, Files;
CONST 
	MinVolSize = 4; 
	SF = 29; 
	FnLength = 32; 
	STS = 64; 
	ETS = 12; 
	SS = 2048; 
	XS = (SS DIV 4); 
	HS = 352; 
	DirRootAdr = (1 * SF); 
	DirPgSize = 50; 
	N = (DirPgSize DIV 2); 
	DirMark = LONGINT(9B1EA38DH); 
	HeaderMark = LONGINT(9BA71D86H); 
	FillerSize = 36; 
	MapIndexSize = ((SS - 4) DIV 4); 
	MapSize = (SS DIV SIZEOF(SET)); 
	MapMark = LONGINT(9C2F977FH); 
	MaxBufs = 4; 
	InitHint = (200 * SF); 
	Closed = 0X; 
	Opening = 1X; 
	Opened = 2X; 
	Closing = 3X; 
	SetSize = (MAX(SET) + 1); 
TYPE 
	DiskSector = RECORD 
	END; 

	DiskSectorArr = ARRAY SS OF CHAR; 

	DiskAdr = LONGINT; 

	FileName = ARRAY FnLength OF CHAR; 

	SectorTable = ARRAY STS OF DiskAdr; 

	ExtensionTable = ARRAY ETS OF DiskAdr; 

	FileHeader = RECORD (DiskSector)
		mark: LONGINT; 
		name: FileName; 
		aleng, bleng: INTEGER; 
		date, time: LONGINT; 
		ext: ExtensionTable; 
		sec: SectorTable; 
		data: ARRAY (SS - HS) OF CHAR; 
	END; 

	IndexSector = RECORD (DiskSector)
		x: ARRAY XS OF DiskAdr; 
	END; 

	DataSector = RECORD (DiskSector)
		B: ARRAY SS OF CHAR; 
	END; 

	DirEntry = RECORD 
		name: FileName; 
		adr: DiskAdr; 
		p: DiskAdr; 
	END; 

	DirPage = RECORD (DiskSector)
		mark: LONGINT; 
		m: INTEGER; 
		p0: DiskAdr; 
		fill: ARRAY FillerSize OF CHAR; 
		e: ARRAY DirPgSize OF DirEntry; 
	END; 

	MapIndex = RECORD (DiskSector)
		mark: LONGINT; 
		index: ARRAY MapIndexSize OF DiskAdr; 
	END; 

	MapSector = RECORD (DiskSector)
		map: ARRAY MapSize OF SET; 
	END; 

	FileHd = POINTER TO FileHeader; 

	Buffer = POINTER TO RECORD (Files.Hint)
		apos, lim: LONGINT; 
		mod: BOOLEAN; 
		next: Buffer; 
		data: DataSector; 
	END; 

	Index = POINTER TO RECORD 
		adr: DiskAdr; 
		mod: BOOLEAN; 
		sec: IndexSector; 
	END; 

	Directory = OBJECT {EXCLUSIVE} 
	VAR 
		vol: Files.Volume; 
		state: CHAR; 
		lastSectorReserved: BOOLEAN; 

		PROCEDURE ^ Search(VAR name: FileName; VAR A: DiskAdr); 
		PROCEDURE ^ insert(VAR name: FileName; dpg0: DiskAdr; VAR h: BOOLEAN; VAR v: DirEntry; fad: DiskAdr); 
		PROCEDURE ^ Insert(VAR name: FileName; fad: DiskAdr); 
		PROCEDURE ^ underflow(VAR c: DirPage; dpg0: DiskAdr; s: LONGINT; VAR h: BOOLEAN); 
		PROCEDURE ^ delete(VAR name: FileName; dpg0: DiskAdr; VAR h: BOOLEAN; VAR fad: DiskAdr); 
		PROCEDURE ^ Delete(VAR name: FileName; VAR fad: DiskAdr); 
		PROCEDURE ^ Startup; 
		PROCEDURE ^  & Init*(vol: Files.Volume); 
		PROCEDURE ^ Cleanup; 
	END Directory; 

	FileSystem = OBJECT {EXCLUSIVE} (Files.FileSystem)
	VAR 
		dir: Directory; 

		PROCEDURE ^ New0*(name: ARRAY OF CHAR): Files.File; 
		PROCEDURE ^ Old0*(name: ARRAY OF CHAR): Files.File; 
		PROCEDURE ^ Delete0*(name: ARRAY OF CHAR; VAR key, res: LONGINT); 
		PROCEDURE ^ Rename0*(old, new: ARRAY OF CHAR; f: Files.File; VAR res: LONGINT); 
		PROCEDURE ^ Enumerate0*(mask: ARRAY OF CHAR; flags: SET; enum: Files.Enumerator); 
		PROCEDURE ^ FileKey*(name: ARRAY OF CHAR): LONGINT; 
		PROCEDURE ^ Finalize*; 
	END FileSystem; 

	File = OBJECT {EXCLUSIVE} (Files.File)
	VAR 
		aleng, bleng: LONGINT; 
		nofbufs: LONGINT; 
		modH, registered: BOOLEAN; 
		firstbuf: Buffer; 
		sechint: DiskAdr; 
		name: FileName; 
		time, date: LONGINT; 
		ext: ARRAY ETS OF Index; 
		sec: SectorTable; 

		PROCEDURE ^ Set*(VAR r: Files.Rider; pos: LONGINT); 
		PROCEDURE ^ Pos*(VAR r: Files.Rider): LONGINT; 
		PROCEDURE ^ Read*(VAR r: Files.Rider; VAR x: CHAR); 
		PROCEDURE ^ ReadBytes*(VAR r: Files.Rider; VAR x: ARRAY OF CHAR; ofs, len: LONGINT); 
		PROCEDURE ^ Write*(VAR r: Files.Rider; x: CHAR); 
		PROCEDURE ^ WriteBytes*(VAR r: Files.Rider; CONST x: ARRAY OF CHAR; ofs, len: LONGINT); 
		PROCEDURE ^ Length*(): LONGINT; 
		PROCEDURE ^ GetDate*(VAR t, d: LONGINT); 
		PROCEDURE ^ SetDate*(t, d: LONGINT); 
		PROCEDURE ^ GetName*(VAR name: ARRAY OF CHAR); 
		PROCEDURE ^ Register0*(VAR res: LONGINT); 
		PROCEDURE ^ Update*; 
	END File; 

	PROCEDURE ^ GetSector(vol: Files.Volume; src: DiskAdr; VAR dest: DiskSector); 
	PROCEDURE ^ PutSector(vol: Files.Volume; dest: DiskAdr; VAR src: DiskSector); 
	PROCEDURE ^ AllocSector(vol: Files.Volume; hint: DiskAdr; VAR sec: DiskAdr); 
	PROCEDURE ^ MarkSector(vol: Files.Volume; sec: LONGINT); 
	PROCEDURE ^ FreeSector(vol: Files.Volume; sec: LONGINT); 
	PROCEDURE ^ Marked(vol: Files.Volume; sec: LONGINT): BOOLEAN; 
	PROCEDURE ^ MatchPrefix(VAR mask, name: ARRAY OF CHAR; VAR pos, diff: LONGINT); 
	PROCEDURE ^ Match(pos: LONGINT; VAR pat, name: ARRAY OF CHAR): BOOLEAN; 
	PROCEDURE ^ enumerate(fs: Files.FileSystem; VAR mask: ARRAY OF CHAR; dpg: DiskAdr; flags: SET; enum: Files.Enumerator; VAR continue: BOOLEAN; VAR fh: FileHeader; VAR fn: ARRAY OF CHAR); 
	PROCEDURE ^ Check(VAR s: ARRAY OF CHAR; VAR name: FileName; VAR res: LONGINT); 
	PROCEDURE ^ UpdateHeader(f: File; VAR h: FileHeader); 
	PROCEDURE ^ ReadBuf(f: File; buf: Buffer; pos: LONGINT); 
	PROCEDURE ^ WriteBuf(f: File; buf: Buffer); 
	PROCEDURE ^ SearchBuf(f: File; pos: LONGINT): Buffer; 
	PROCEDURE ^ GetBuf(f: File; pos: LONGINT): Buffer; 
	PROCEDURE ^ Unbuffer(f: File); 
	PROCEDURE ^ NewExt(f: File); 
	PROCEDURE ^ NewFS*(context: Files.Parameters); 
	PROCEDURE ^ Cleanup; 
BEGIN
END OberonFS.
