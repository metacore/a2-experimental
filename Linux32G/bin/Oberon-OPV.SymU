MODULE OPV IN Oberon;
	IMPORT SYSTEM, OPS, OPT, OPL, OPO, OPC, OPM, Oberon;
CONST 
	InitOPI = \"OPI.Init"\; 
	DumpCode = \"OPI.DumpCode"\; 
	Var = 1; 
	VarPar = 2; 
	Con = 3; 
	Fld = 4; 
	Typ = 5; 
	LProc = 6; 
	XProc = 7; 
	SProc = 8; 
	CProc = 9; 
	IProc = 10; 
	Mod = 11; 
	Head = 12; 
	TProc = 13; 
	Abs = OPO.Abs; 
	times = 1; 
	slash = 2; 
	div = 3; 
	mod = 4; 
	and = 5; 
	plus = 6; 
	minus = 7; 
	or = 8; 
	eql = 9; 
	neq = 10; 
	lss = 11; 
	leq = 12; 
	gtr = 13; 
	geq = 14; 
	in = 15; 
	is = 16; 
	ash = 17; 
	msk = 18; 
	len = 19; 
	conv = 20; 
	abs = 21; 
	cap = 22; 
	odd = 23; 
	not = 33; 
	adr = 24; 
	cc = 25; 
	bit = 26; 
	lsh = 27; 
	rot = 28; 
	val = 29; 
	get8 = 30; 
	get16 = 31; 
	get32 = 32; 
	type = 34; 
	Undef = 0; 
	Byte = 1; 
	Bool = 2; 
	Char = 3; 
	SInt = 4; 
	Int = 5; 
	LInt = 6; 
	Real = 7; 
	LReal = 8; 
	Set = 9; 
	String = 10; 
	NilTyp = 11; 
	NoTyp = 12; 
	Pointer = 13; 
	ProcTyp = 14; 
	Comp = 15; 
	Basic = 1; 
	StaticArr = 2; 
	SDynArr = 3; 
	DynArr = 4; 
	OpenArr = 5; 
	Record = 6; 
	StaticEnhArr = 7; 
	SDynEnhArr = 8; 
	DynEnhArr = 9; 
	OpenEnhArr = 10; 
	Tensor = 11; 
	ArraySet = {StaticArr, SDynArr, DynArr, OpenArr, StaticEnhArr, SDynEnhArr, DynEnhArr, OpenEnhArr, Tensor}; 
	static = 0; 
	dynamic = 1; 
	sdynamic = 2; 
	Nvar = 0; 
	Nvarpar = 1; 
	Nfield = 2; 
	Nderef = 3; 
	Nindex = 4; 
	Nguard = 5; 
	Neguard = 6; 
	Nconst = 7; 
	Ntype = 8; 
	Nproc = 9; 
	Nupto = 10; 
	Nmop = 11; 
	Ndop = 12; 
	Ncall = 13; 
	Ninittd = 14; 
	Nif = 15; 
	Ncaselse = 16; 
	Ncasedo = 17; 
	Nenter = 18; 
	Nassign = 19; 
	Nifelse = 20; 
	Ncase = 21; 
	Nwhile = 22; 
	Nrepeat = 23; 
	Nloop = 24; 
	Nexit = 25; 
	Nreturn = 26; 
	Nwith = 27; 
	Ntrap = 28; 
	Nassembler = 29; 
	Nret = 32; 
	Nfinally = 40; 
	assign = 0; 
	newfn = 1; 
	incfn = 13; 
	decfn = 14; 
	inclfn = 15; 
	exclfn = 16; 
	copyfn = 18; 
	assertfn = 32; 
	awaitfn = 64; 
	lockfn = 66; 
	getfn = 24; 
	putfn = 25; 
	getrfn = 26; 
	putrfn = 27; 
	sysnewfn = 30; 
	movefn = 31; 
	stifn = 33; 
	clifn = 34; 
	poutfn = 35; 
	pinfn = 36; 
	internal = 0; 
	external = 1; 
	externalR = 2; 
	hasBody = 1; 
	isRedef = 2; 
	slNeeded = 3; 
	asmProc = 7; 
	notag = 1; 
	winapi = 2; 
	cdecl = 3; 
	delegate = 5; 
	systemtype = 6; 
	MaxAdr = OPM.MaxLInt; 
	MinAdr = OPM.MinLInt; 
	VarParSize = OPM.PointerSize; 
	RecVarParSize = 8; 
	LProcOffSL = 12; 
	LProcOff = 8; 
	ExtProcOff = 8; 
TYPE 
	ParamAdrProc = PROCEDURE (VAR firstPar: OPT.Object; VAR psize, dsize: LONGINT; TProc, Inline, allocDesc: BOOLEAN); 
VAR 
	dumpCode*: BOOLEAN; 
	ProcName*: OPS.Name; 
	EntryNr*: INTEGER; 
	ExitChain: OPC.Label; 
	UnlockOnExit: BOOLEAN; 
	allocTd: BOOLEAN; 
	dummy: OPC.Item; 
	ParamAdr: ARRAY 6 OF ParamAdrProc; 

	PROCEDURE ^ Init*(bpc: LONGINT); 
	PROCEDURE ^ IncAdr(VAR adr: LONGINT; s: LONGINT); 
	PROCEDURE ^ AlignFld(VAR offset: LONGINT; elemsize: LONGINT); 
	PROCEDURE ^ AllocFld(VAR offset, this: LONGINT; elemsize: LONGINT); 
	PROCEDURE ^ AlignRec(VAR size: LONGINT); 
	PROCEDURE ^ AlignPar(VAR elemsize: LONGINT); 
	PROCEDURE ^ AllocPar(VAR adr, this: LONGINT; elemsize: LONGINT); 
	PROCEDURE ^ AlignVar(VAR adr: LONGINT; elemsize: LONGINT); 
	PROCEDURE ^ AllocVar(VAR adr, this: LONGINT; elemsize: LONGINT); 
	PROCEDURE ^ AlignBlock(adr: LONGINT; VAR dsize: LONGINT); 
	PROCEDURE ^ RecursionTest(typ: OPT.Struct; mode: LONGINT): BOOLEAN; 
	PROCEDURE ^ TypSize*(typ: OPT.Struct; allocDesc: BOOLEAN); 
	PROCEDURE ^ ParamAdrLR(VAR firstPar: OPT.Object; VAR psize, dsize: LONGINT; TProc, Inline, allocDesc: BOOLEAN); 
	PROCEDURE ^ ParamAdrRL(VAR firstPar: OPT.Object; VAR psize, dsize: LONGINT; TProc, Inline, allocDesc: BOOLEAN); 
	PROCEDURE ^ VarAdr(var: OPT.Object; VAR dsize: LONGINT); 
	PROCEDURE ^ ArgSize(par: OPT.Object): LONGINT; 
	PROCEDURE ^ ProcSize0(obj: OPT.Object; firstpass: BOOLEAN); 
	PROCEDURE ^ ProcSize(obj: OPT.Object; firstpass: BOOLEAN); 
	PROCEDURE ^ FindMth(curmod: LONGINT; VAR name: OPS.Name; typ: OPT.Struct; VAR res: OPT.Object); 
	PROCEDURE ^ VisitTProcs(obj: OPT.Object); 
	PROCEDURE ^ Traverse(obj: OPT.Object; exported: BOOLEAN); 
	PROCEDURE ^ AssignTent(obj: OPT.Object); 
	PROCEDURE ^ AssignEntries*(obj: OPT.Object; browse: BOOLEAN); 
	PROCEDURE ^ AssignOwnEntries(obj: OPT.Object); 
	PROCEDURE ^ AllocAddEntries(obj: OPT.Object); 
	PROCEDURE ^ AdrAndSize*(topScope: OPT.Object); 
	PROCEDURE ^ Designator(n: OPT.Node; VAR x: OPC.Item); 
	PROCEDURE ^ CallLR(proc: OPT.Node; VAR res: OPC.Item; assignment: BOOLEAN); 
	PROCEDURE ^ CallRL(proc: OPT.Node; VAR res: OPC.Item; assignment: BOOLEAN); 
	PROCEDURE ^ Call(proc: OPT.Node; VAR res: OPC.Item; assignment: BOOLEAN); 
	PROCEDURE ^ Expression(n: OPT.Node; VAR z: OPC.Item; selfForUnlock: OPT.Node); 
	PROCEDURE ^ IfStat(n, selfForUnlock: OPT.Node; VAR Lfix, Lcfix: OPC.Label; else: BOOLEAN); 
	PROCEDURE ^ CaseStat(n, selfForUnlock: OPT.Node); 
	PROCEDURE ^ Dim(VAR z, nofelem: OPC.Item; n: OPT.Node; typ: OPT.Struct; nofdim: LONGINT); 
	PROCEDURE ^ Statement(n, selfForUnlock: OPT.Node); 
	PROCEDURE ^ Module*(prog: OPT.Node); 
BEGIN
END OPV.
