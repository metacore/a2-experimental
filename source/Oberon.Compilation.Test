# Oberon language test and validation suite
# options --command="Compiler.Compile TesterInput.txt" --result="Oberon.Compilation.Test.Diff"

# Syntax tests
# =====================================

# plain modules

negative: missing module name

	MODULE END.

negative: unmatched module name

	MODULE Test; END tseT.

negative: missing semicolon in module definition

	MODULE Test END Test.

negative: missing END in module definition

	MODULE Test; Test.

negative: missing concluding dot

	MODULE Test; END Test

positive: empty module

	MODULE Test; END Test.

negative: module named system

	MODULE SYSTEM; END SYSTEM.


# identifiers

negative: number as identifier

	MODULE Test;
	CONST 007 = 0;
	END Test.

negative: keyword as identifier

	MODULE Test;
	CONST THEN = 0;
	END Test.

negative: string as identifier

	MODULE Test;
	CONST "Test" = 0;
	END Test.

positive: single character identifier

	MODULE Test;
	CONST T = 0;
	END Test.

positive: long identifiers

	MODULE Test;
	CONST IncrediblyLongModuleNameLikeSupercalifragilisticexpialidocious = 0;
	END Test.

positive: underscore in identifier

	MODULE Test;
	CONST Test_Module = 0;
	END Test.


# comments

negative: comment only

	(* MODULE *)

positive: comment in front of module definition

	(* comment *)
	MODULE Test; END Test.

positive: comment within module definition

	MODULE Test;
	(* comment *)
	END Test.

positive: comment after module definition

	MODULE Test;
	END Test.
	(* comment *)

positive: plain text after module definition

	MODULE Test;
	END Test.

	plain text

negative: invalid closing of comment

	MODULE Test; *) END Test.

negative: missing closing of comment

	MODULE Test; (* END Test.

positive: comment spanning several lines

	MODULE Test;
	(*
		this comment spans
		several text lines
	*)
	END Test.

positive: comment as whitespace

	MODULE(*whitespace*)Test;END(*whitespace*)Test.


# nested comments

positive: nested comment

	(* (* nested comment *) *)
	MODULE Test; END Test.

negative: invalid closing of nested comment

	(* nested comment *) *)
	MODULE Test; END Test.

negative: missing closing of nested comment

	(* (* nested comment *)
	MODULE Test; END Test.

positive: double nested comments

	(* (* extremely (* nested comment *) *) *)
	MODULE Test; END Test.

positive: multiple nested comments

	MODULE Test;
	(* (* multiple *) nested (* comments (* over (* four *) levels *) *) *)
	END Test.

negative: invalid multiple nested comments

	MODULE Test;
	(* invalid (* multiple *) nested (* comments (* over *) (* four *) levels *) *) *)
	END Test.


# import section

positive: dummy module for import section tests

	MODULE Dummy; END Dummy.

negative: empty import list

	MODULE Test;
	IMPORT;
	END Test.

negative: single module import without concluding semicolon

	MODULE Test;
	IMPORT Dummy
	END Test.

positive: single module import

	MODULE Test;
	IMPORT Dummy;
	END Test.

positive: single module import with alias

	MODULE Test;
	IMPORT Alias := Dummy;
	END Test.

negative: double module import missing second module name

	MODULE Test;
	IMPORT Dummy, ;
	END Test.

negative: double module import without separating comma

	MODULE Test;
	IMPORT A := Dummy B := Dummy;
	END Test.

negative: double module import with separating semicolon

	MODULE Test;
	IMPORT A := Dummy; B := Dummy;
	END Test.

negative: double module import without concluding semicolon

	MODULE Test;
	IMPORT A := Dummy, B := Dummy
	END Test.

positive: double module import

	MODULE Test;
	IMPORT A := Dummy, B := Dummy;
	END Test.

positive: multiple module import

	MODULE Test;
	IMPORT A := Dummy, B := Dummy, C := Dummy, D := Dummy;
	END Test.

positive: multiple import lists

	MODULE Test;
	IMPORT A := Dummy;
	IMPORT B := Dummy;
	END Test.


# const section

positive: empty const section

	MODULE Test;
	CONST
	END Test.

positive: const section without declarations

	MODULE Test;
	CONST ;;;;
	END Test.

positive: repeated empty const sections

	MODULE Test;
	CONST CONST CONST
	CONST ; CONST ; CONST
	END Test.

negative: single constant declaration missing equal sign

	MODULE Test;
	CONST Constant 5;
	END Test.

negative: single constant declaration missing value

	MODULE Test;
	CONST Constant =
	END Test.

positive: single constant declaration

	MODULE Test;
	CONST Constant = 5
	END Test.

negative: double constant declaration without separating semicolon

	MODULE Test;
	CONST A = 5 B = 10
	END Test.

positive: double constant declaration

	MODULE Test;
	CONST A = 5; B = 10
	END Test.


# literals

positive: boolean literal FALSE

	MODULE Test;
	CONST Boolean = TRUE
	END Test.

positive: boolean literal TRUE

	MODULE Test;
	CONST Boolean = FALSE
	END Test.

# legacy behaviour
positive: character literal using '

	MODULE Test;
	CONST Character = 'a'
	END Test.

# legacy behaviour
positive: character literal using "

	MODULE Test;
	CONST Character = "b"
	END Test.

negative: unclosed character literal

	MODULE Test;
	CONST Character = 't
	END Test.

positive: uppercase hexadecimal character literal

	MODULE Test;
	CONST Character = 0ABX
	END Test.

negative: lowercase hexadecimal character literal

	MODULE Test;
	CONST Character = 0efX
	END Test.

negative: hexadecimal character literal beginning with letter

	MODULE Test;
	CONST Character = CDX
	END Test.

negative: hexadecimal character literal missing concluding X

	MODULE Test;
	CONST Character = 9A
	END Test.

negative: hexadecimal character literal with concluding x

	MODULE Test;
	CONST Character = 0CAx
	END Test.

positive: integer literal

	MODULE Test;
	CONST Integer = 25
	END Test.

positive: uppercase hexadecimal integer literal

	MODULE Test;
	CONST Integer = 1EDH
	END Test.

negative: lowercase hexadecimal integer literal

	MODULE Test;
	CONST Integer = 4faH
	END Test.

negative: hexadecimal integer literal beginning with letter

	MODULE Test;
	CONST Integer = EFH
	END Test.

negative: hexadecimal integer literal missing concluding H

	MODULE Test;
	CONST Integer = 42F
	END Test.

negative: hexadecimal integer literal with concluding h

	MODULE Test;
	CONST Integer = 89h
	END Test.

positive: real literal

	MODULE Test;
	CONST Real = 25.3
	END Test.

positive: real literal with concluding dot

	MODULE Test;
	CONST Real = 7.
	END Test.

negative: real literal beginning with dot

	MODULE Test;
	CONST Real = .4
	END Test.

negative: real literal with comma instead of dot

	MODULE Test;
	CONST Real = 12,1
	END Test.

positive: real literal with scale factor

	MODULE Test;
	CONST Real = 1.2E5
	END Test.

positive: real literal with positive scale factor

	MODULE Test;
	CONST Real = 0.3E+8
	END Test.

negative: real literal with positive too large scale factor

	MODULE Test;
	CONST Real= 0.3E+80;
	END Test.

positive: real literal with negative scale factor

	MODULE Test;
	CONST Real = 0.E-30
	END Test.

negative: real literal with too small negative scale factor

	MODULE Test;
	CONST Real = 0.E-54
	END Test.

negative: real literal with scale factor without number

	MODULE Test;
	CONST Real = 6354.9E+
	END Test.

negative: real literal with scale factor without number and sign

	MODULE Test;
	CONST Real = 9.1E
	END Test.

negative: real literal with lowercase scale factor

	MODULE Test;
	CONST Real = 24.e97
	END Test.

negative: real literal with hexadecimal scale factor

	MODULE Test;
	CONST Real = 1.97E1AB
	END Test.

negative: real literal with whitespace sepatared scale factor

	MODULE Test;
	CONST Real = 12.3 E-4
	END Test.

negative: real literal with scale factor with whitespace sepatared number

	MODULE Test;
	CONST Real = 0.1E 2
	END Test.

negative: real literal with scale factor without decimal point

	MODULE Test;
	CONST Real = 5E+2
	END Test.

positive: long real literal with scale factor

	MODULE Test;
	CONST Real = 0.77D24
	END Test.

positive: long real literal with positive scale factor

	MODULE Test;
	CONST Real = 0.1D+9
	END Test.

positive: long real literal with negative scale factor

	MODULE Test;
	CONST Real = 1.D-14
	END Test.

negative: long real literal with lowercase scale factor

	MODULE Test;
	CONST Real = 24.d97
	END Test.

positive: set literal

	MODULE Test;
	CONST Set = {}
	END Test.

negative: unclosed set literal

	MODULE Test;
	CONST Set = {
	END Test.

negative: unopened set literal

	MODULE Test;
	CONST Set = }
	END Test.

# legacy behaviour

#temporarily removed
#negative: string literal using '
#
#	MODULE Test;
#	CONST String = 'abc'
#	END Test.

positive: string literal using "

	MODULE Test;
	CONST String = "ABC"
	END Test.

negative: unclosed string literal

	MODULE Test;
	CONST Character = "string
	END Test.

positive: string literal holding printable ASCII character set

	MODULE Test;
	CONST String = " !#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~"
	BEGIN ASSERT (String = String)
	END Test.


# type section

positive: empty type section

	MODULE Test;
	TYPE
	END Test.

positive: type section without declarations

	MODULE Test;
	TYPE ;;;;
	END Test.

positive: repeated empty type sections

	MODULE Test;
	TYPE TYPE TYPE
	TYPE ; TYPE ; TYPE
	END Test.

negative: single type declaration missing equal sign

	MODULE Test;
	TYPE Type RECORD END;
	END Test.

negative: single type declaration missing type

	MODULE Test;
	TYPE Type =
	END Test.

positive: single type declaration

	MODULE Test;
	TYPE Type = OBJECT;
	END Test.

negative: double type declaration without separating semicolon

	MODULE Test;
	TYPE A = RECORD END B = OBJECT;
	END Test.

positive: double type declaration

	MODULE Test;
	TYPE A = OBJECT; B = RECORD END
	END Test.


# types

negative: array without of

	MODULE Test;
	TYPE Array = ARRAY 10 OBJECT;
	END Test.

negative: array without base type

	MODULE Test;
	TYPE Array = ARRAY 15 OF;
	END Test.

positive: basic array of objects

	MODULE Test;
	TYPE Array = ARRAY 5 OF OBJECT;
	END Test.

negative: record without end

	MODULE Test;
	TYPE Record = RECORD;
	END Test.

positive: simple record

	MODULE Test;
	TYPE Record = RECORD END;
	END Test.

negative: record with empty base record

	MODULE Test;
	TYPE Record = RECORD () END;
	END Test.

negative: record with explicitly defined base record

	MODULE Test;
	TYPE Record = RECORD (RECORD END) END;
	END Test.

negative: record with variable declaration

	MODULE Test;
	TYPE Record = RECORD VAR f: OBJECT; END;
	END Test.

negative: missing matching object name

	MODULE Test;
	TYPE Object = OBJECT END;
	END Test;

negative: unmatched object name

	MODULE Test;
	TYPE Object = OBJECT END tcejbO;
	END Test;

negative: object without end

	MODULE Test;
	TYPE Object = OBJECT Object;
	END Test.

positive: simple object

	MODULE Test;
	TYPE Object = OBJECT END Object;
	END Test.

negative: object with empty base object

	MODULE Test;
	TYPE Object = OBJECT () END;
	END Test.

negative: record with explicit base object

	MODULE Test;
	TYPE Record = RECORD (OBJECT) END;
	END Test.

negative: record with explicitly defined base object

	MODULE Test;
	TYPE Record = RECORD (OBJECT END) END;
	END Test.

negative: object with field declaration

	MODULE Test;
	TYPE Object = OBJECT f: OBJECT; END Object;
	END Test.

negative: pointer missing pointer keyword

	MODULE Test;
	TYPE Pointer = TO RECORD END;
	END Test.

negative: pointer missing to

	MODULE Test;
	TYPE Pointer = POINTER RECORD END;
	END Test.

negative: pointer missing base type

	MODULE Test;
	TYPE Pointer = POINTER TO;
	END Test.

positive: plain procedure type without parentheses

	MODULE Test;
	TYPE Procedure = PROCEDURE;
	END Test.

positive: plain procedure type with parentheses

	MODULE Test;
	TYPE Procedure = PROCEDURE ();
	END Test.

negative: procedure type missing return type

	MODULE Test;
	TYPE Procedure = PROCEDURE ():;
	END Test.

negative: procedure type with return type missing parentheses

	MODULE Test;
	TYPE Procedure = PROCEDURE: BOOLEAN;
	END Test.

negative: procedure type with return type missing colon

	MODULE Test;
	TYPE Procedure = PROCEDURE () BOOLEAN;
	END Test.

positive: procedure type with empty parameter list

	MODULE Test;
	TYPE Procedure = PROCEDURE ();
	END Test.

negative: procedure type with parameter list missing parameter section

	MODULE Test;
	TYPE Procedure = PROCEDURE (;);
	END Test.

negative: procedure type with parameter missing name

	MODULE Test;
	TYPE Procedure = PROCEDURE (: SET);
	END Test.

negative: procedure type with parameter missing colon

	MODULE Test;
	TYPE Procedure = PROCEDURE (parameter SET);
	END Test.

negative: procedure type with parameter missing type

	MODULE Test;
	TYPE Procedure = PROCEDURE (parameter:);
	END Test.


# var section

positive: empty var section

	MODULE Test;
	VAR
	END Test.

positive: var section without declarations

	MODULE Test;
	VAR ;;;;
	END Test.

positive: repeated empty var sections

	MODULE Test;
	VAR VAR VAR
	VAR ; VAR ; VAR
	END Test.

negative: single variable declaration missing colon

	MODULE Test;
	VAR variable RECORD END;
	END Test.

negative: single variable declaration missing type

	MODULE Test;
	VAR variable: ;
	END Test.

positive: single variable declaration

	MODULE Test;
	VAR variable: RECORD END;
	END Test.

negative: double variable declaration without separating semicolon

	MODULE Test;
	VAR a: RECORD END b: OBJECT;
	END Test.

positive: double variable declaration

	MODULE Test;
	VAR a: ARRAY 10 OF CHAR; b: RECORD END;
	END Test.


# procedure section

positive: plain procedure without parentheses

	MODULE Test;
	PROCEDURE Procedure;
	END Procedure;
	END Test.

negative: procedure missing name

	MODULE Test;
	PROCEDURE;
	END Procedure;
	END Test.

negative: procedure missing separating semicolon

	MODULE Test;
	PROCEDURE Procedure
	END Procedure;
	END Test.

negative: procedure missing end

	MODULE Test;
	PROCEDURE Procedure;
	Procedure;
	END Test.

negative: procedure missing matching name

	MODULE Test;
	PROCEDURE Procedure;
	END;
	END Test.

negative: unmatched procedure name

	MODULE Test;
	PROCEDURE Procedure;
	END erudecorP;
	END Test.

positive: procedure missing concluding semicolon

	MODULE Test;
	PROCEDURE Procedure;
	END Procedure
	END Test.

positive: plain procedure with parentheses

	MODULE Test;
	PROCEDURE Procedure ();
	END Procedure;
	END Test.

negative: procedure missing return type

	MODULE Test;
	PROCEDURE Procedure ():;
	END Procedure;
	END Test.

negative: procedure with return type missing parentheses

	MODULE Test;
	PROCEDURE Procedure: BOOLEAN;
	END Procedure;
	END Test.

negative: procedure with return type missing colon

	MODULE Test;
	PROCEDURE Procedure () BOOLEAN;
	END Procedure;
	END Test.

positive: procedure with empty parameter list

	MODULE Test;
	PROCEDURE Procedure ();
	END Procedure;
	END Test.

negative: procedure with parameter list missing parameter section

	MODULE Test;
	PROCEDURE Procedure (;);
	END Procedure;
	END Test.

negative: procedure with parameter missing name

	MODULE Test;
	PROCEDURE Procedure (: SET);
	END Procedure;
	END Test.

negative: procedure with parameter missing colon

	MODULE Test;
	PROCEDURE Procedure (parameter SET);
	END Procedure;
	END Test.

negative: procedure with parameter missing type

	MODULE Test;
	PROCEDURE Procedure (parameter:);
	END Procedure;
	END Test.


# intermixed section types

positive: import section before import section

	MODULE Test;
	IMPORT A := Dummy;
	IMPORT B := Dummy;
	END Test.

positive: import section before const section

	MODULE Test;
	IMPORT Import := Dummy;
	CONST Constant = 0;
	END Test.

positive: import section before type section

	MODULE Test;
	IMPORT Import := Dummy;
	TYPE Type = RECORD END;
	END Test.

positive: import section before var section

	MODULE Test;
	IMPORT Import := Dummy;
	VAR variable: RECORD END;
	END Test.

positive: import section before procedure section

	MODULE Test;
	IMPORT Import := Dummy;
	PROCEDURE Procedure; END Procedure;
	END Test.

negative: const section before import section

	MODULE Test;
	CONST Constant = 0;
	IMPORT Import := Dummy;
	END Test.

positive: const section before const section

	MODULE Test;
	CONST A = 0;
	CONST B = 0;
	END Test.

positive: const section before type section

	MODULE Test;
	CONST Constant = 0;
	TYPE Type = RECORD END;
	END Test.

positive: const section before var section

	MODULE Test;
	CONST Constant = 0;
	VAR variable: RECORD END;
	END Test.

positive: const section before procedure section

	MODULE Test;
	CONST Constant = 0;
	PROCEDURE Procedure; END Procedure;
	END Test.

negative: type section before import section

	MODULE Test;
	TYPE Type = RECORD END;
	IMPORT Import := Dummy;
	END Test.

positive: type section before const section

	MODULE Test;
	TYPE Type = RECORD END;
	CONST Constant = 0;
	END Test.

positive: type section before type section

	MODULE Test;
	TYPE A = RECORD END;
	TYPE B = RECORD END;
	END Test.

positive: type section before var section

	MODULE Test;
	TYPE Type = RECORD END;
	VAR variable: RECORD END;
	END Test.

positive: type section before procedure section

	MODULE Test;
	TYPE Type = RECORD END;
	PROCEDURE Procedure; END Procedure;
	END Test.

negative: var section before import section

	MODULE Test;
	VAR variable: RECORD END;
	IMPORT Import := Dummy;
	END Test.

positive: var section before const section

	MODULE Test;
	VAR variable: RECORD END;
	CONST Constant = 0;
	END Test.

positive: var section before type section

	MODULE Test;
	VAR variable: RECORD END;
	TYPE Type = RECORD END;
	END Test.

positive: var section before var section

	MODULE Test;
	VAR a: RECORD END;
	VAR b: RECORD END;
	END Test.

positive: var section before procedure section

	MODULE Test;
	VAR variable: RECORD END;
	PROCEDURE Procedure; END Procedure;
	END Test.

negative: procedure section before import section

	MODULE Test;
	PROCEDURE Procedure; END Procedure;
	IMPORT Import := Dummy;
	END Test.

positive: procedure section before const section

	MODULE Test;
	PROCEDURE Procedure; END Procedure;
	CONST Constant = 0;
	END Test.

positive: procedure section before type section

	MODULE Test;
	PROCEDURE Procedure; END Procedure;
	TYPE Type = RECORD END;
	END Test.

positive: procedure section before var section

	MODULE Test;
	PROCEDURE Procedure; END Procedure;
	VAR variable: RECORD END;
	END Test.

positive: procedure section before procedure section

	MODULE Test;
	PROCEDURE A; END A;
	PROCEDURE B; END B;
	END Test.


# bodies

positive: omitted module body

	MODULE Test;
	END Test.

positive: empty module body

	MODULE Test;
	BEGIN
	END Test.

positive: omitted procedure body

	MODULE Test;
	PROCEDURE Procedure;
	END Procedure;
	END Test.

positive: empty procedure body

	MODULE Test;
	PROCEDURE Procedure;
	BEGIN
	END Procedure;
	END Test.

positive: omitted object body

	MODULE Test;
	TYPE Object = OBJECT
	END Object;
	END Test.

positive: empty object body

	MODULE Test;
	TYPE Object = OBJECT
	BEGIN
	END Object;
	END Test.


# statements

positive: statement with semicolon

	MODULE Test;
	BEGIN BEGIN END;
	END Test.

positive: statement without semicolon

	MODULE Test;
	BEGIN BEGIN END
	END Test.

positive: empty statements at the beginning

	MODULE Test;
	BEGIN ;;;; BEGIN END
	END Test.

positive: empty statements between statements

	MODULE Test;
	BEGIN BEGIN END ;;;; BEGIN END
	END Test.

positive: empty statements at the end

	MODULE Test;
	BEGIN BEGIN END ;;;;
	END Test.

positive: nested empty statements at the beginning

	MODULE Test;
	BEGIN BEGIN ;;;; BEGIN END END
	END Test.

positive: nested empty statements between statements

	MODULE Test;
	BEGIN BEGIN BEGIN END ;;;; BEGIN END END
	END Test.

positive: nested empty statements at the end

	MODULE Test;
	BEGIN BEGIN BEGIN END ;;;; END
	END Test.

negative: two consecutive statements without semicolon

	MODULE Test;
	BEGIN BEGIN END BEGIN END
	END Test.

negative: two nested consecutive statements without semicolon

	MODULE Test;
	BEGIN BEGIN BEGIN END BEGIN END END
	END Test.

negative: three consecutive statements without semicolon

	MODULE Test;
	BEGIN BEGIN END BEGIN END BEGIN END
	END Test.

negative: three nested consecutive statements without semicolon

	MODULE Test;
	BEGIN BEGIN BEGIN END BEGIN END BEGIN END END
	END Test.

negative: unclosed block

	MODULE Test;
	BEGIN BEGIN
	END Test.

negative: unclosed nested block

	MODULE Test;
	BEGIN BEGIN BEGIN END
	END Test.

negative: unopened block

	MODULE Test;
	BEGIN END
	END Test.

negative: unopened nested block

	MODULE Test;
	BEGIN BEGIN END END
	END Test.

positive: empty block modifier

	MODULE Test;
	BEGIN {}
	END Test.

positive: empty nested block modifier

	MODULE Test;
	BEGIN BEGIN {} END
	END Test.

positive: single block modifier

	MODULE Test;
	BEGIN {EXCLUSIVE}
	END Test.

positive: multiple block modifiers

	MODULE Test;
	TYPE Object = OBJECT
	BEGIN {ACTIVE, EXCLUSIVE}
	END Object;
	END Test.

negative: multiple block modifiers missing separating comma

	MODULE Test;
	TYPE Object = OBJECT
	BEGIN {ACTIVE EXCLUSIVE}
	END Object;
	END Test.

negative: empty block modifier with separating comma

	MODULE Test;
	TYPE Object = OBJECT
	BEGIN {,}
	END Object;
	END Test.

negative: exported block modifier

	MODULE Test;
	BEGIN {EXCLUSIVE*}
	END Test.

negative: while statement missing while

	MODULE Test;
	VAR condition: BOOLEAN;
	BEGIN condition DO END
	END Test.

negative: while statement missing condition

	MODULE Test;
	BEGIN WHILE DO END
	END Test.

negative: while statement missing do

	MODULE Test;
	VAR condition: BOOLEAN;
	BEGIN WHILE condition END
	END Test.

negative: while statement missing end

	MODULE Test;
	VAR condition: BOOLEAN;
	BEGIN WHILE condition DO
	END Test.

positive: nested while statement

	MODULE Test;
	VAR condition: BOOLEAN;
	BEGIN WHILE condition DO WHILE condition DO END END
	END Test.

negative: repeat statement missing repeat

	MODULE Test;
	VAR condition: BOOLEAN;
	BEGIN UNTIL condition
	END Test.

negative: repeat statement missing until

	MODULE Test;
	VAR condition: BOOLEAN;
	BEGIN REPEAT condition
	END Test.

negative: repeat statement missing condition

	MODULE Test;
	BEGIN REPEAT UNTIL
	END Test.

positive: nested repeat statement

	MODULE Test;
	VAR condition: BOOLEAN;
	BEGIN REPEAT REPEAT UNTIL condition UNTIL condition
	END Test.

negative: loop statement missing loop

	MODULE Test;
	BEGIN END
	END Test.

negative: loop statement missing end

	MODULE Test;
	BEGIN LOOP
	END Test.

positive: nested loop statement

	MODULE Test;
	BEGIN LOOP LOOP END END
	END Test.

negative: await statement missing parentheses

	MODULE Test;
	VAR condition: BOOLEAN;
	BEGIN {EXCLUSIVE} AWAIT condition
	END Test;

negative: await statement missing closing parenthesis

	MODULE Test;
	VAR condition: BOOLEAN;
	BEGIN {EXCLUSIVE} AWAIT (condition
	END Test;

negative: await statement missing opening parenthesis

	MODULE Test;
	VAR condition: BOOLEAN;
	BEGIN {EXCLUSIVE} AWAIT condition)
	END Test;

negative: await statement missing condition with parentheses

	MODULE Test;
	VAR condition: BOOLEAN;
	BEGIN {EXCLUSIVE} AWAIT ()
	END Test;

negative: await statement missing condition without parentheses

	MODULE Test;
	VAR condition: BOOLEAN;
	BEGIN {EXCLUSIVE} AWAIT
	END Test;

negative: assignment missing left hand side

	MODULE Test;
	VAR variable: SIGNED16;
	BEGIN := 0;
	END Test;

negative: assignment missing assign

	MODULE Test;
	VAR variable: SIGNED16;
	BEGIN variable 0;
	END Test;

negative: assignment missing right hand side

	MODULE Test;
	VAR variable: SIGNED16;
	BEGIN variable := ;
	END Test;

negative: cascaded assignment

	MODULE Test;
	VAR variable: SIGNED16;
	BEGIN variable := variable := 5;
	END Test;

negative: for statement missing counter

	MODULE Test;
	BEGIN FOR := 0 TO 10 DO END
	END Test.

negative: for statement missing assignment

	MODULE Test;
	VAR i: SIGNED16;
	BEGIN FOR i 0 TO 10 DO END
	END Test.

negative: for statement missing start counter

	MODULE Test;
	VAR i: SIGNED16;
	BEGIN FOR i := TO 10 DO END
	END Test.

negative: for statement missing to

	MODULE Test;
	VAR i: SIGNED16;
	BEGIN FOR i := 0 10 DO END
	END Test.

negative: for statement missing end counter

	MODULE Test;
	VAR i: SIGNED16;
	BEGIN FOR i := 0 TO DO END
	END Test.

negative: for statement missing do

	MODULE Test;
	VAR i: SIGNED16;
	BEGIN FOR i := 0 TO 10 END
	END Test.

negative: for statement missing end

	MODULE Test;
	VAR i: SIGNED16;
	BEGIN FOR i := 0 TO 10 DO
	END Test.

positive: for statement without increment

	MODULE Test;
	VAR i: SIGNED16;
	BEGIN FOR i := 0 TO 10 DO END
	END Test.

negative: for statement with increment missing by

	MODULE Test;
	VAR i: SIGNED16;
	BEGIN FOR i := 0 TO 10 1 DO END
	END Test.

negative: for statement with increment missing increment

	MODULE Test;
	VAR i: SIGNED16;
	BEGIN FOR i := 0 TO 10 BY DO END
	END Test.

negative: plain assert statement

	MODULE Test;
	BEGIN ASSERT
	END Test.

negative: assert statement missing condition

	MODULE Test;
	BEGIN ASSERT ()
	END Test.

negative: assert statement missing opening parenthesis

	MODULE Test;
	BEGIN ASSERT TRUE)
	END Test.

negative: assert statement missing closing parenthesis

	MODULE Test;
	BEGIN ASSERT (TRUE
	END Test.

negative: assert statement missing comma

	MODULE Test;
	BEGIN ASSERT (TRUE 5)
	END Test.

negative: assert statement missing number

	MODULE Test;
	BEGIN ASSERT (TRUE,)
	END Test.

negative: if statement missing if

	MODULE Test;
	VAR condition: BOOLEAN;
	BEGIN condition THEN END
	END Test.

negative: if statement missing condition

	MODULE Test;
	BEGIN IF THEN END
	END Test.

negative: if statement missing then

	MODULE Test;
	VAR condition: BOOLEAN;
	BEGIN IF condition END
	END Test.

negative: if statement missing end

	MODULE Test;
	VAR condition: BOOLEAN;
	BEGIN IF condition THEN
	END Test.

negative: if statement with else missing then

	MODULE Test;
	VAR condition: BOOLEAN;
	BEGIN IF condition ELSE END
	END Test.

negative: if statement with else missing end

	MODULE Test;
	VAR condition: BOOLEAN;
	BEGIN IF condition THEN ELSE
	END Test.

positive: nested if statement in then part

	MODULE Test;
	VAR condition: BOOLEAN;
	BEGIN IF condition THEN IF condition THEN END END
	END Test.

positive: nested if statement in else part

	MODULE Test;
	VAR condition: BOOLEAN;
	BEGIN IF condition THEN ELSE IF condition THEN END END
	END Test.

negative: else if statement missing elsif

	MODULE Test;
	VAR condition: BOOLEAN;
	BEGIN IF TRUE THEN condition THEN END
	END Test.

negative: else if statement missing condition

	MODULE Test;
	VAR condition: BOOLEAN;
	BEGIN IF TRUE THEN ELSIF THEN END
	END Test.

negative: else if statement missing then

	MODULE Test;
	VAR condition: BOOLEAN;
	BEGIN IF TRUE THEN ELSIF condition END
	END Test.

negative: else if statement missing end

	MODULE Test;
	VAR condition: BOOLEAN;
	BEGIN IF TRUE THEN ELSIF condition THEN
	END Test.

negative: else if statement with else missing then

	MODULE Test;
	VAR condition: BOOLEAN;
	BEGIN IF TRUE THEN ELSIF condition ELSE END
	END Test.

negative: else if statement with else missing end

	MODULE Test;
	VAR condition: BOOLEAN;
	BEGIN IF TRUE THEN ELSIF condition THEN ELSE
	END Test.

positive: nested else if statement in then part

	MODULE Test;
	VAR condition: BOOLEAN;
	BEGIN IF TRUE THEN ELSIF condition THEN IF TRUE THEN ELSIF condition THEN END END
	END Test.

positive: nested else if statement in else part

	MODULE Test;
	VAR condition: BOOLEAN;
	BEGIN IF TRUE THEN ELSIF condition THEN ELSE IF TRUE THEN ELSIF condition THEN END END
	END Test.

positive: multiple else if statements

	MODULE Test;
	VAR condition: BOOLEAN;
	BEGIN IF TRUE THEN ELSIF condition THEN ELSIF condition THEN ELSIF condition THEN ELSIF condition THEN END
	END Test.

positive: multiple else if statements with else

	MODULE Test;
	VAR condition: BOOLEAN;
	BEGIN IF TRUE THEN ELSIF condition THEN ELSIF condition THEN ELSIF condition THEN ELSIF condition THEN ELSE END
	END Test.

negative: plain halt statement

	MODULE Test;
	BEGIN HALT
	END Test.

negative: halt statement missing number

	MODULE Test;
	BEGIN HALT ()
	END Test.

negative: halt statement missing opening parenthesis

	MODULE Test;
	BEGIN HALT 5)
	END Test.

negative: halt statement missing closing parenthesis

	MODULE Test;
	BEGIN HALT (5
	END Test.

negative: empty case statement

	MODULE Test;
	BEGIN CASE 0 OF END
	END Test.

negative: empty case statement with else

	MODULE Test;
	BEGIN CASE 0 OF ELSE END
	END Test.

negative: empty case statement missing case

	MODULE Test;
	BEGIN 0 OF END
	END Test.

negative: empty case statement missing value

	MODULE Test;
	BEGIN CASE OF END
	END Test.

negative: empty case statement missing of

	MODULE Test;
	BEGIN CASE 0 END
	END Test.

negative: empty case statement missing end

	MODULE Test;
	BEGIN CASE 0 OF
	END Test.

positive: case statement with simple case

	MODULE Test;
	BEGIN CASE 0 OF 0: END
	END Test.

positive: case statement with simple case with leading bar

	MODULE Test;
	BEGIN CASE 0 OF | 0: END
	END Test.

negative: case statement with simple case with leading bars

	MODULE Test;
	BEGIN CASE 0 OF || 0: END
	END Test.

negative: case statement with simple case with trailing bar

	MODULE Test;
	BEGIN CASE 0 OF 0: | END
	END Test.

negative: case statement with simple case with trailing bars

	MODULE Test;
	BEGIN CASE 0 OF 0: || END
	END Test.

positive: case statement with simple case with else

	MODULE Test;
	BEGIN CASE 0 OF 0: ELSE END
	END Test.

negative: case statement with simple case missing case

	MODULE Test;
	BEGIN 0 OF 0: END
	END Test.

negative: case statement with simple case missing value

	MODULE Test;
	BEGIN CASE OF 0: END
	END Test.

negative: case statement with simple case missing of

	MODULE Test;
	BEGIN CASE 0 0: END
	END Test.

negative: case statement with simple case missing value in case

	MODULE Test;
	BEGIN CASE 0 OF : END
	END Test.

negative: case statement with simple case missing colon in case

	MODULE Test;
	BEGIN CASE 0 OF 0 END
	END Test.

negative: case statement with simple case missing end

	MODULE Test;
	BEGIN CASE 0 OF 0:
	END Test.

positive: case statement with simple case range

	MODULE Test;
	BEGIN CASE 0 OF 0..1: END
	END Test.

positive: case statement with simple case range with else

	MODULE Test;
	BEGIN CASE 0 OF 0..1: ELSE END
	END Test.

negative: case statement with simple case range missing first case

	MODULE Test;
	BEGIN 0 OF ..1: END
	END Test.

negative: case statement with simple case range missing range

	MODULE Test;
	BEGIN 0 OF 0 1: END
	END Test.

negative: case statement with simple case range missing last case

	MODULE Test;
	BEGIN 0 OF 0..: END
	END Test.

negative: case statement with simple case range of multiple values

	MODULE Test;
	BEGIN CASE 0 OF 0..1..2: END
	END Test.

positive: case statement with complex case

	MODULE Test;
	BEGIN CASE 0 OF 0, 1, 2: END
	END Test.

positive: case statement with complex case with else

	MODULE Test;
	BEGIN CASE 0 OF 0, 1, 2: ELSE END
	END Test.

negative: case statement with complex case missing first value in case

	MODULE Test;
	BEGIN CASE 0 OF , 1: END
	END Test.

negative: case statement with complex case missing comma in case

	MODULE Test;
	BEGIN CASE 0 OF 0, : END
	END Test.

negative: case statement with complex case missing second value in case

	MODULE Test;
	BEGIN CASE 0 OF 0, : END
	END Test.

positive: case statement with complex case range

	MODULE Test;
	BEGIN CASE 0 OF 0..1, 2..3, 4..5: END
	END Test.

positive: case statement with complex case range with else

	MODULE Test;
	BEGIN CASE 0 OF 0..1, 2..3, 4..5: ELSE END
	END Test.

negative: case statement with complex case range missing first case

	MODULE Test;
	BEGIN 0 OF 0..1, ..3: END
	END Test.

negative: case statement with complex case range missing range

	MODULE Test;
	BEGIN 0 OF 0..1, 2 3: END
	END Test.

negative: case statement with complex case range missing last case

	MODULE Test;
	BEGIN 0 OF 0..1, 2..: END
	END Test.

positive: case statement with two cases

	MODULE Test;
	BEGIN CASE 0 OF 0: | 1: END
	END Test.

positive: case statement with two cases with else

	MODULE Test;
	BEGIN CASE 0 OF 0: | 1: END
	END Test.

positive: case statement with two cases missing first case

	MODULE Test;
	BEGIN CASE 0 OF | 0: END
	END Test.

negative: case statement with two cases missing bar

	MODULE Test;
	BEGIN CASE 0 OF 0: 1: END
	END Test.

negative: case statement with two cases missing second case

	MODULE Test;
	BEGIN CASE 0 OF 0: | END
	END Test.

positive: case statement with three cases

	MODULE Test;
	BEGIN CASE 0 OF 0: | 1: | 2: END
	END Test.

positive: case statement with three cases with else

	MODULE Test;
	BEGIN CASE 0 OF 0: | 1: | 2: ELSE END
	END Test.

negative: with statement missing with

	MODULE Test;
	TYPE Type = OBJECT;
	VAR value: Type;
	BEGIN value : Type DO END
	END Test.

negative: with statement missing value

	MODULE Test;
	TYPE Type = OBJECT;
	BEGIN WITH : Type DO END
	END Test.

negative: with statement missing colon

	MODULE Test;
	TYPE Type = OBJECT;
	VAR value: Type;
	BEGIN WITH value Type DO END
	END Test.

negative: with statement missing type

	MODULE Test;
	VAR value: OBJECT;
	BEGIN WITH value : DO END
	END Test.

negative: with statement missing do

	MODULE Test;
	TYPE Type = OBJECT;
	VAR value: Type;
	BEGIN WITH value : Type END
	END Test.

negative: with statement missing end

	MODULE Test;
	TYPE Type = OBJECT;
	VAR value: Type;
	BEGIN WITH value : Type DO
	END Test.

negative: plain new statement

	MODULE Test;
	VAR object: OBJECT END;
	BEGIN NEW;
	END Test.

negative: new statement missing new

	MODULE Test;
	VAR object: OBJECT END;
	BEGIN (object);
	END Test.

negative: new statement missing opening parenthesis

	MODULE Test;
	VAR object: OBJECT END;
	BEGIN NEW object);
	END Test.

negative: new statement missing reference

	MODULE Test;
	BEGIN NEW ();
	END Test.

negative: new statement missing closing parenthesis

	MODULE Test;
	VAR object: OBJECT END;
	BEGIN NEW (object;
	END Test.

negative: plain increment statement

	MODULE Test;
	BEGIN INC
	END Test.

negative: increment statement missing integer

	MODULE Test;
	BEGIN INC ()
	END Test.

negative: increment statement missing opening parenthesis

	MODULE Test;
	VAR integer: SIGNED16;
	BEGIN INC integer)
	END Test.

negative: increment statement missing closing parenthesis

	MODULE Test;
	VAR integer: SIGNED16;
	BEGIN INC (integer
	END Test.

negative: increment statement missing comma

	MODULE Test;
	VAR integer: SIGNED16;
	BEGIN INC (integer 5)
	END Test.

negative: increment statement missing increment

	MODULE Test;
	VAR integer: SIGNED16;
	BEGIN INC (integer,)
	END Test.

positive: increment statement missing increment and comma

	MODULE Test;
	VAR integer: SIGNED16;
	BEGIN INC (integer)
	END Test.

negative: plain decrement statement

	MODULE Test;
	BEGIN DEC
	END Test.

negative: decrement statement missing integer

	MODULE Test;
	BEGIN DEC ()
	END Test.

negative: decrement statement missing opening parenthesis

	MODULE Test;
	VAR integer: SIGNED16;
	BEGIN DEC integer)
	END Test.

negative: decrement statement missing closing parenthesis

	MODULE Test;
	VAR integer: SIGNED16;
	BEGIN DEC (integer
	END Test.

negative: decrement statement missing comma

	MODULE Test;
	VAR integer: SIGNED16;
	BEGIN DEC (integer 5)
	END Test.

negative: decrement statement missing increment

	MODULE Test;
	VAR integer: SIGNED16;
	BEGIN DEC (integer,)
	END Test.

positive: decrement statement missing increment and comma

	MODULE Test;
	VAR integer: SIGNED16;
	BEGIN DEC (integer)
	END Test.

negative: plain include statement

	MODULE Test;
	BEGIN INCL
	END Test.

negative: include statement missing set

	MODULE Test;
	BEGIN INCL ()
	END Test.

negative: include statement missing opening parenthesis

	MODULE Test;
	VAR set: SET;
	BEGIN INCL set)
	END Test.

negative: include statement missing closing parenthesis

	MODULE Test;
	VAR set: SET;
	BEGIN INCL (set
	END Test.

negative: include statement missing comma

	MODULE Test;
	VAR set: SET;
	BEGIN INCL (set 5)
	END Test.

negative: include statement missing element

	MODULE Test;
	VAR set: SET;
	BEGIN INCL (set,)
	END Test.

negative: include statement missing element and comma

	MODULE Test;
	VAR set: SET;
	BEGIN INCL (set)
	END Test.

negative: plain exclude statement

	MODULE Test;
	BEGIN EXCL
	END Test.

negative: exclude statement missing set

	MODULE Test;
	BEGIN EXCL ()
	END Test.

negative: exclude statement missing opening parenthesis

	MODULE Test;
	VAR set: SET;
	BEGIN EXCL set)
	END Test.

negative: exclude statement missing closing parenthesis

	MODULE Test;
	VAR set: SET;
	BEGIN EXCL (set
	END Test.

negative: exclude statement missing comma

	MODULE Test;
	VAR set: SET;
	BEGIN EXCL (set 5)
	END Test.

negative: exclude statement missing element

	MODULE Test;
	VAR set: SET;
	BEGIN EXCL (set,)
	END Test.

negative: exclude statement missing element and comma

	MODULE Test;
	VAR set: SET;
	BEGIN EXCL (set)
	END Test.

negative: plain copy statement

	MODULE Test;
	BEGIN COPY
	END Test.

negative: copy statement missing source

	MODULE Test;
	BEGIN COPY ()
	END Test.

negative: copy statement missing opening parenthesis

	MODULE Test;
	VAR source: ARRAY 10 OF CHAR;
	BEGIN COPY source)
	END Test.

negative: copy statement missing closing parenthesis

	MODULE Test;
	VAR source: ARRAY 10 OF CHAR;
	BEGIN COPY (source
	END Test.

negative: copy statement missing comma

	MODULE Test;
	VAR source, dest: ARRAY 10 OF CHAR;
	BEGIN COPY (source dest)
	END Test.

negative: copy statement missing destination

	MODULE Test;
	VAR source: ARRAY 10 OF CHAR;
	BEGIN COPY (source,)
	END Test.

negative: copy statement missing destination and comma

	MODULE Test;
	VAR source: ARRAY 10 OF CHAR;
	BEGIN COPY (source)
	END Test.


# predefined identifiers

negative: redefining abs

	MODULE Test;
	CONST ABS = 0;
	END Test.

negative: redefining array

	MODULE Test;
	CONST ARRAY = 0;
	END Test.

negative: redefining ash

	MODULE Test;
	CONST ASH = 0;
	END Test.

negative: redefining assert

	MODULE Test;
	CONST ASSERT = 0;
	END Test.

negative: redefining await

	MODULE Test;
	CONST AWAIT = 0;
	END Test.

negative: redefining begin

	MODULE Test;
	CONST BEGIN = 0;
	END Test.

negative: redefining boolean

	MODULE Test;
	CONST BOOLEAN = 0;
	END Test.

negative: redefining by

	MODULE Test;
	CONST BY = 0;
	END Test.

negative: redefining cap

	MODULE Test;
	CONST CAP = 0;
	END Test.

negative: redefining case

	MODULE Test;
	CONST CASE = 0;
	END Test.

negative: redefining char

	MODULE Test;
	CONST CHAR = 0;
	END Test.

negative: redefining chr

	MODULE Test;
	CONST CHR = 0;
	END Test.

negative: redefining const

	MODULE Test;
	VAR CONST: SET;
	END Test.

negative: redefining copy

	MODULE Test;
	CONST COPY = 0;
	END Test.

negative: redefining dec

	MODULE Test;
	CONST DEC = 0;
	END Test.

negative: redefining definition

	MODULE Test;
	CONST DEFINITION = 0;
	END Test.

negative: redefining div

	MODULE Test;
	CONST DIV = 0;
	END Test.

negative: redefining do

	MODULE Test;
	CONST DO = 0;
	END Test.

negative: redefining else

	MODULE Test;
	CONST ELSE = 0;
	END Test.

negative: redefining elseif

	MODULE Test;
	CONST ELSIF = 0;
	END Test.

negative: redefining end

	MODULE Test;
	CONST END = 0;
	END Test.

negative: redefining entier

	MODULE Test;
	CONST ENTIER = 0;
	END Test.

negative: redefining excl

	MODULE Test;
	CONST EXCL = 0;
	END Test.

negative: redefining exit

	MODULE Test;
	CONST EXIT = 0;
	END Test.

negative: redefining false

	MODULE Test;
	CONST FALSE = 0;
	END Test.

negative: redefining finally

	MODULE Test;
	CONST FINALLY = 0;
	END Test.

negative: redefining for

	MODULE Test;
	CONST FOR = 0;
	END Test.

negative: redefining halt

	MODULE Test;
	CONST HALT = 0;
	END Test.

negative: redefining hugeint

	MODULE Test;
	CONST SIGNED64 = 0;
	END Test.

negative: redefining if

	MODULE Test;
	CONST IF = 0;
	END Test.

negative: redefining ignore

	MODULE Test;
	CONST IF = 0;
	END Test.

negative: redefining import

	MODULE Test;
	CONST IMPORT = 0;
	END Test.

negative: redefining in

	MODULE Test;
	CONST IN = 0;
	END Test.

negative: redefining inc

	MODULE Test;
	CONST INC = 0;
	END Test.

negative: redefining incl

	MODULE Test;
	CONST INCL = 0;
	END Test.

negative: redefining integer

	MODULE Test;
	CONST SIGNED16 = 0;
	END Test.

negative: redefining is

	MODULE Test;
	CONST IS = 0;
	END Test.

negative: redefining len

	MODULE Test;
	CONST LEN = 0;
	END Test.

negative: redefining long

	MODULE Test;
	CONST LONG = 0;
	END Test.

negative: redefining longint

	MODULE Test;
	CONST SIGNED32 = 0;
	END Test.

negative: redefining longreal

	MODULE Test;
	CONST FLOAT64 = 0;
	END Test.

negative: redefining loop

	MODULE Test;
	CONST LOOP = 0;
	END Test.

negative: redefining max

	MODULE Test;
	CONST MAX = 0;
	END Test.

negative: redefining min

	MODULE Test;
	CONST MIN = 0;
	END Test.

negative: redefining mod

	MODULE Test;
	CONST MOD = 0;
	END Test.

negative: redefining module

	MODULE Test;
	CONST MODULE = 0;
	END Test.

negative: redefining new

	MODULE Test;
	CONST NEW = 0;
	END Test.

negative: redefining nil

	MODULE Test;
	CONST NIL = 0;
	END Test.

negative: redefining object

	MODULE Test;
	CONST OBJECT = 0;
	END Test.

negative: redefining odd

	MODULE Test;
	CONST ODD = 0;
	END Test.

negative: redefining of

	MODULE Test;
	CONST OF = 0;
	END Test.

negative: redefining or

	MODULE Test;
	CONST OR = 0;
	END Test.

negative: redefining ord

	MODULE Test;
	CONST ORD = 0;
	END Test.

negative: redefining pointer

	MODULE Test;
	CONST POINTER = 0;
	END Test.

negative: redefining procedure

	MODULE Test;
	CONST PROCEDURE = 0;
	END Test.

negative: redefining real

	MODULE Test;
	CONST FLOAT32 = 0;
	END Test.

negative: redefining record

	MODULE Test;
	CONST RECORD = 0;
	END Test.

negative: redefining repeat

	MODULE Test;
	CONST REPEAT = 0;
	END Test.

negative: redefining return

	MODULE Test;
	CONST RETURN = 0;
	END Test.

negative: redefining self

	MODULE Test;
	CONST SELF = 0;
	END Test.

negative: redefining set

	MODULE Test;
	CONST SET = 0;
	END Test.

negative: redefining short

	MODULE Test;
	CONST SHORT = 0;
	END Test.

negative: redefining shortint

	MODULE Test;
	CONST SIGNED8 = 0;
	END Test.

negative: redefining then

	MODULE Test;
	CONST THEN = 0;
	END Test.

negative: redefining to

	MODULE Test;
	CONST TO = 0;
	END Test.

negative: redefining true

	MODULE Test;
	CONST TRUE = 0;
	END Test.

negative: redefining type

	MODULE Test;
	CONST TYPE = 0;
	END Test.

negative: redefining until

	MODULE Test;
	CONST UNTIL = 0;
	END Test.

negative: redefining var

	MODULE Test;
	CONST VAR = 0;
	END Test.

negative: redefining while

	MODULE Test;
	CONST WHILE = 0;
	END Test.

negative: redefining with

	MODULE Test;
	CONST WITH = 0;
	END Test.


# Semantic tests
# =====================================

# imports

positive: dummy module

	MODULE Dummy; END Dummy.

positive: single import

	MODULE Test;
	IMPORT Dummy;
	END Test.

negative: import marked as exported

	MODULE Test;
	IMPORT Dummy*;
	END Test.

negative: import marked as read-only

	MODULE Test;
	IMPORT Dummy-;
	END Test.

positive: single import with different alias

	MODULE Test;
	IMPORT Alias := Dummy;
	END Test.

positive: single import with same alias

	MODULE Test;
	IMPORT Dummy := Dummy;
	END Test.

negative: duplicated import

	MODULE Test;
	IMPORT Dummy, Dummy;
	END Test.

positive: duplicated import with different alias

	MODULE Test;
	IMPORT A := Dummy, B := Dummy;
	END Test.

negative: duplicated import with same alias

	MODULE Test;
	IMPORT A := Dummy, A := Dummy;
	END Test.

negative: import within procedure

	MODULE Test;
	PROCEDURE Procedure;
		IMPORT Import := Dummy;
	END Procedure;
	END Test.

negative: import within nested procedure

	MODULE Test;
	PROCEDURE Procedure;
		PROCEDURE Procedure;
			IMPORT Import := Dummy;
		END Procedure;
	END Procedure;
	END Test.

negative: import within object

	MODULE Test;
	TYPE Object = OBJECT
		IMPORT Import := Dummy;
	END Object;
	END Test.

negative: import within object in procedure

	MODULE Test;
	PROCEDURE Procedure;
		TYPE Object = OBJECT
			IMPORT Import := Dummy;
		END Object;
	END Object;
	END Test.

negative: import within procedure in object

	MODULE Test;
	TYPE Object = OBJECT
		PROCEDURE Procedure;
			IMPORT Import := Dummy;
		END Procedure;
	END Object;
	END Test.

positive: dummy empty module

	MODULE Test; END Test.

positive: dummy module with import

	MODULE Dummy;
	IMPORT Test;
	END Dummy.

negative: module importing itself directly

	MODULE Test;
	IMPORT Test;
	END Test.

negative: module importing itself directly with alias

	MODULE Test;
	IMPORT Import := Test;
	END Test.

negative: module importing itself indirectly

	MODULE Test;
	IMPORT Dummy;
	END Test.

negative: module importing itself indirectly with alias

	MODULE Test;
	IMPORT Import := Dummy;
	END Test.

negative: constant as import

	MODULE Test;
	IMPORT Import := Constant;
	CONST Constant = 0;
	END Test.

negative: type as import

	MODULE Test;
	IMPORT Import := Type;
	TYPE Type = SIGNED16;
	END Test.

negative: variable as import

	MODULE Test;
	IMPORT Import := variable;
	VAR variable: SIGNED16;
	END Test.

negative: procedure as import

	MODULE Test;
	IMPORT Import := Procedure;
	PROCEDURE Procedure; SIGNED16;
	END Test.

negative: parameter as import

	MODULE Test;
	PROCEDURE Procedure (parameter: SIGNED16);
	IMPORT Import := parameter;
	END Procedure;
	END Test.


# constants

positive: unmarked constant

	MODULE Test;
	CONST Constant = 54;
	END Test.

positive: unmarked constant within procedure

	MODULE Test;
	PROCEDURE Procedure;
		CONST Constant = 54;
	END Procedure;
	END Test.

positive: unmarked constant within nested procedure

	MODULE Test;
	PROCEDURE Procedure;
		PROCEDURE Procedure;
			CONST Constant = 54;
		END Procedure;
	END Procedure;
	END Test.

positive: unmarked constant within object

	MODULE Test;
	TYPE Object = OBJECT
		CONST Constant = 54;
	END Object;
	END Test.

positive: unmarked constant within object in procedure

	MODULE Test;
	PROCEDURE Procedure;
		TYPE Object = OBJECT
			CONST Constant = 54;
		END Object;
	END Procedure;
	END Test.

positive: unmarked constant within procedure in object

	MODULE Test;
	TYPE Object = OBJECT
		PROCEDURE Procedure;
			CONST Constant = 54;
		END Procedure;
	END Object;
	END Test.

positive: constant marked as exported

	MODULE Test;
	CONST Constant* = 54;
	END Test.

negative: constant marked as exported within procedure

	MODULE Test;
	PROCEDURE Procedure;
		CONST Constant* = 54;
	END Procedure;
	END Test.

negative: constant marked as exported within nested procedure

	MODULE Test;
	PROCEDURE Procedure;
		PROCEDURE Procedure;
			CONST Constant* = 54;
		END Procedure;
	END Procedure;
	END Test.

positive: constant marked as exported within object

	MODULE Test;
	TYPE Object = OBJECT
		CONST Constant* = 54;
	END Object;
	END Test.

negative: constant marked as exported within object in procedure

	MODULE Test;
	PROCEDURE Procedure;
		TYPE Object = OBJECT
			CONST Constant* = 54;
		END Object;
	END Procedure;
	END Test.

negative: constant marked as exported within procedure in object

	MODULE Test;
	TYPE Object = OBJECT
		PROCEDURE Procedure;
			CONST Constant* = 54;
		END Procedure;
	END Object;
	END Test.

negative: constant marked as read-only

	MODULE Test;
	CONST Constant- = TRUE;
	END Test.

negative: constant marked as read-only within procedure

	MODULE Test;
	PROCEDURE Procedure;
		CONST Constant- = TRUE;
	END Procedure;
	END Test.

negative: constant marked as read-only within nested procedure

	MODULE Test;
	PROCEDURE Procedure;
		PROCEDURE Procedure;
			CONST Constant- = TRUE;
		END Procedure;
	END Procedure;
	END Test.

negative: constant marked as read-only within object

	MODULE Test;
	TYPE Object = OBJECT
		CONST Constant- = TRUE;
	END Object;
	END Test.

negative: constant marked as read-only within object in procedure

	MODULE Test;
	PROCEDURE Procedure;
		TYPE Object = OBJECT
			CONST Constant- = TRUE;
		END Object;
	END Procedure;
	END Test.

negative: constant marked as read-only within procedure in object

	MODULE Test;
	TYPE Object = OBJECT
		PROCEDURE Procedure;
			CONST Constant- = TRUE;
		END Procedure;
	END Object;
	END Test.

negative: duplicated constant

	MODULE Test;
	CONST Constant = TRUE;
	CONST Constant = FALSE;
	END Test.

negative: duplicated constant within procedure

	MODULE Test;
	PROCEDURE Procedure;
		CONST Constant = TRUE;
		CONST Constant = FALSE;
	END Procedure;
	END Test.

negative: duplicated constant within nested procedure

	MODULE Test;
	PROCEDURE Procedure;
		PROCEDURE Procedure;
			CONST Constant = TRUE;
			CONST Constant = FALSE;
		END Procedure;
	END Procedure;
	END Test.

negative: duplicated constant within object

	MODULE Test;
	TYPE Object = OBJECT
		CONST Constant = TRUE;
		CONST Constant = FALSE;
	END Object;
	END Test.

negative: duplicated constant within object in procedure

	MODULE Test;
	TYPE Object = OBJECT
		PROCEDURE Procedure;
			CONST Constant = TRUE;
			CONST Constant = FALSE;
		END Procedure;
	END Object;
	END Test.

negative: duplicated constant within procedure in object

	MODULE Test;
	PROCEDURE Procedure;
		TYPE Object = OBJECT
			CONST Constant = TRUE;
			CONST Constant = FALSE;
		END Object;
	END Procedure;
	END Test.

positive: backwards referencing constant

	MODULE Test;
	CONST A = 0; B = A;
	END Test.

positive: backwards referencing constant within procedure

	MODULE Test;
	PROCEDURE Procedure;
		CONST A = 0; B = A;
	END Procedure;
	END Test.

positive: backwards referencing constant within nested procedure

	MODULE Test;
	PROCEDURE Procedure;
		PROCEDURE Procedure;
			CONST A = 0; B = A;
		END Procedure;
	END Procedure;
	END Test.

positive: backwards referencing constant within object

	MODULE Test;
	TYPE Object = OBJECT
		CONST A = 0; B = A;
	END Object;
	END Test.

positive: backwards referencing constant within object in procedure

	MODULE Test;
	PROCEDURE Procedure;
		TYPE Object = OBJECT
			CONST A = 0; B = A;
		END Object;
	END Procedure;
	END Test.

positive: backwards referencing constant within procedure in object

	MODULE Test;
	TYPE Object = OBJECT
		PROCEDURE Procedure;
			CONST A = 0; B = A;
		END Procedure;
	END Object;
	END Test.

positive: forwards referencing constant

	MODULE Test;
	CONST A = B; B = 0;
	END Test.

positive: forwards referencing constant within procedure

	MODULE Test;
	PROCEDURE Procedure;
		CONST A = B; B = 0;
	END Procedure;
	END Test.

positive: forwards referencing constant within nested procedure

	MODULE Test;
	PROCEDURE Procedure;
		PROCEDURE Procedure;
			CONST A = B; B = 0;
		END Procedure;
	END Procedure;
	END Test.

positive: forwards referencing constant within object

	MODULE Test;
	TYPE Object = OBJECT
		CONST A = B; B = 0;
	END Object;
	END Test.

positive: forwards referencing constant within object in procedure

	MODULE Test;
	PROCEDURE Procedure;
		TYPE Object = OBJECT
			CONST A = B; B = 0;
		END Object;
	END Procedure;
	END Test.

positive: forwards referencing constant within procedure in object

	MODULE Test;
	TYPE Object = OBJECT
		PROCEDURE Procedure;
			CONST A = B; B = 0;
		END Procedure;
	END Object;
	END Test.

negative: cyclic referencing constants

	MODULE Test;
	CONST A = B; B = A;
	END Test.

negative: cyclic referencing constants within procedure

	MODULE Test;
	PROCEDURE Procedure;
		CONST A = B; B = A;
	END Procedure;
	END Test.

negative: cyclic referencing constants within nested procedure

	MODULE Test;
	PROCEDURE Procedure;
		PROCEDURE Procedure;
			CONST A = B; B = A;
		END Procedure;
	END Procedure;
	END Test.

negative: cyclic referencing constants within object

	MODULE Test;
	TYPE Object = OBJECT
		CONST A = B; B = A;
	END Object;
	END Test.

negative: cyclic referencing constants within object in procedure

	MODULE Test;
	PROCEDURE Procedure;
		TYPE Object = OBJECT
			CONST A = B; B = A;
		END Object;
	END Procedure;
	END Test.

negative: cyclic referencing constants within procedure in object

	MODULE Test;
	TYPE Object = OBJECT
		PROCEDURE Procedure;
			CONST A = B; B = A;
		END Procedure;
	END Object;
	END Test.

negative: self referencing constant

	MODULE Test;
	CONST Constant = Constant;
	END Test.

negative: self referencing constant within procedure

	MODULE Test;
	PROCEDURE Procedure;
		CONST Constant = Constant;
	END Procedure;
	END Test.

negative: self referencing constant within nested procedure

	MODULE Test;
	PROCEDURE Procedure;
		PROCEDURE Procedure;
			CONST Constant = Constant;
		END Procedure;
	END Procedure;
	END Test.

negative: self referencing constant within object

	MODULE Test;
	TYPE Object = OBJECT
		CONST Constant = Constant;
	END Object;
	END Test.

negative: self referencing constant within object in procedure

	MODULE Test;
	TYPE Object = OBJECT
		PROCEDURE Procedure;
			CONST Constant = Constant;
		END Procedure;
	END Object;
	END Test.

negative: self referencing constant within procedure in object

	MODULE Test;
	PROCEDURE Procedure;
		TYPE Object = OBJECT
			CONST Constant = Constant;
		END Object;
	END Procedure;
	END Test.

positive: dummy module exporting constants

	MODULE Dummy;
	CONST Exported* = 5;
	CONST Private = 5;
	END Dummy.

positive: importing exported constant

	MODULE Test;
	IMPORT Dummy;
	CONST Constant = Dummy.Exported;
	BEGIN ASSERT (Constant = 5);
	END Test.

negative: importing private constant

	MODULE Test;
	IMPORT Dummy;
	CONST Constant = Dummy.Private;
	END Test.

negative: importing invalid constant

	MODULE Test;
	IMPORT Dummy;
	CONST Constant = Dummy.Invalid;
	END Test.

negative: import as constant

	MODULE Test;
	IMPORT Import := Dummy;
	CONST Constant = Import;
	END Test.

negative: type as constant

	MODULE Test;
	CONST Constant = Type;
	TYPE Type = SIGNED16;
	END Test.

negative: variable as constant

	MODULE Test;
	CONST Constant = variable;
	VAR variable: SIGNED16;
	END Test.

negative: procedure as constant

	MODULE Test;
	CONST Constant = Procedure;
	PROCEDURE Procedure; SIGNED16;
	END Test.

negative: parameter as constant

	MODULE Test;
	PROCEDURE Procedure (parameter: SIGNED16);
	CONST Constant = parameter;
	END Procedure;
	END Test.

negative: const parameter as constant

	MODULE Test;
	PROCEDURE Procedure (CONST parameter: SIGNED16);
	CONST Constant = parameter;
	END Procedure;
	END Test.


# constant booleans

negative: arithmetic negation on constant boolean

	MODULE Test;
	CONST Result = -TRUE;
	END Test.

positive: logical negation on constant boolean

	MODULE Test;
	CONST Result = ~FALSE;
	BEGIN ASSERT (Result = TRUE);
	END Test.

positive: multiple logical negations on constant boolean

	MODULE Test;
	CONST Result = ~~~~FALSE;
	BEGIN ASSERT (Result = FALSE);
	END Test.

negative: dereferencing constant boolean

	MODULE Test;
	CONST Result = FALSE^;
	END Test.

negative: dereferencing constant boolean indirectly

	MODULE Test;
	CONST Constant = FALSE;
	CONST Result = Constant^;
	END Test.

negative: addition on constant booleans

	MODULE Test;
	CONST Result = TRUE + FALSE;
	END Test.

negative: subtraction on constant booleans

	MODULE Test;
	CONST Result = FALSE - TRUE
	END Test.

negative: multiplication on constant booleans

	MODULE Test;
	CONST Result = FALSE * TRUE
	END Test.

negative: integer division on constant booleans

	MODULE Test;
	CONST Result = TRUE DIV TRUE
	END Test.

negative: real division on constant booleans

	MODULE Test;
	CONST Result = TRUE / FALSE
	END Test.

negative: modulo on constant booleans

	MODULE Test;
	CONST Result = FALSE MOD TRUE
	END Test.

positive: equal relation on constant booleans

	MODULE Test;
	CONST Result = TRUE = FALSE
	BEGIN ASSERT (Result = FALSE);
	END Test.

positive: unequal relation on constant booleans

	MODULE Test;
	CONST Result = TRUE # TRUE
	BEGIN ASSERT (Result = FALSE);
	END Test.

negative: less relation on constant booleans

	MODULE Test;
	CONST Result = TRUE < FALSE
	END Test.

negative: less or equal relation on constant booleans

	MODULE Test;
	CONST Result = FALSE <= FALSE
	END Test.

negative: greater relation on constant booleans

	MODULE Test;
	CONST Result = FALSE > TRUE
	END Test.

negative: greater or equal relation on constant booleans

	MODULE Test;
	CONST Result = FALSE >= TRUE
	END Test.

negative: set membership on constant booleans

	MODULE Test;
	CONST Result = TRUE IN FALSE
	END Test.

negative: type test on constant booleans

	MODULE Test;
	CONST Result = TRUE IS FALSE
	END Test.

negative: type test on constant boolean

	MODULE Test;
	CONST Result = TRUE IS BOOLEAN
	END Test.

negative: type test on constant boolean type

	MODULE Test;
	TYPE Type = BOOLEAN;
	CONST Result = TRUE IS Type
	END Test.

negative: type guard on constant booleans

	MODULE Test;
	CONST Result = TRUE(FALSE)
	END Test.

negative: indirect type guard on constant booleans

	MODULE Test;
	CONST Constant = TRUE
	CONST Result = Constant(Constant)
	END Test.

negative: type guard on constant boolean

	MODULE Test;
	CONST Result = TRUE(BOOLEAN)
	END Test.

negative: indirect type guard on constant boolean

	MODULE Test;
	CONST Constant = TRUE
	CONST Result = Constant(BOOLEAN)
	END Test.

negative: type guard on constant boolean type

	MODULE Test;
	TYPE Type = BOOLEAN;
	CONST Result = TRUE(Type)
	END Test.

negative: indirect type guard on constant boolean type

	MODULE Test;
	CONST Constant = TRUE
	TYPE Type = BOOLEAN;
	CONST Result = Constant(Type)
	END Test.

positive: logical and on constant booleans

	MODULE Test;
	CONST Result = TRUE & FALSE
	BEGIN ASSERT (Result = FALSE);
	END Test.

positive: logical or on constant booleans

	MODULE Test;
	CONST Result = FALSE OR TRUE
	BEGIN ASSERT (Result = TRUE);
	END Test.

negative: ordinal value of constant boolean

	MODULE Test;
	CONST Result = ORD (TRUE)
	END Test.

negative: character value of constant boolean

	MODULE Test;
	CONST Result = CHR (FALSE)
	END Test.

negative: absolute value of constant boolean

	MODULE Test;
	CONST Result = ABS (FALSE)
	END Test.

negative: odd test on constant boolean

	MODULE Test;
	CONST Result = ODD (FALSE)
	END Test.

negative: capital letter of constant boolean

	MODULE Test;
	CONST Result = CAP (TRUE)
	END Test.

negative: minimal value of boolean

	MODULE Test;
	CONST Result = MIN (BOOLEAN)
	END Test.

negative: maximal value of boolean

	MODULE Test;
	CONST Result = MAX (BOOLEAN)
	END Test.

negative: arithmetic shift of constant booleans

	MODULE Test;
	CONST Result = ASH (TRUE, FALSE)
	END Test.

negative: short on constant boolean

	MODULE Test;
	CONST Result = SHORT (FALSE)
	END Test.

negative: long on constant boolean

	MODULE Test;
	CONST Result = LONG (FALSE)
	END Test.

negative: entier on constant boolean

	MODULE Test;
	CONST Result = ENTIER (FALSE)
	END Test.

negative: unary length of constant boolean

	MODULE Test;
	CONST Result = LEN (FALSE)
	END Test.

negative: binary length of constant boolean

	MODULE Test;
	CONST Result = LEN (FALSE, 0)
	END Test.

negative: indexing constant boolean

	MODULE Test;
	CONST Result = TRUE[0]
	END Test.

negative: indexing constant boolean indirectly

	MODULE Test;
	CONST Constant = TRUE;
	CONST Result = Constant[0]
	END Test.

negative: constant boolean as index

	MODULE Test;
	VAR array: ARRAY 10 OF CHAR; result: CHAR;
	BEGIN result := array[TRUE]
	END Test.

negative: member selection on constant boolean

	MODULE Test;
	CONST Result = TRUE.member
	END Test.

negative: indirect member selection on constant boolean

	MODULE Test;
	CONST Constant = TRUE;
	CONST Result = Constant.member
	END Test.

negative: calling constant boolean

	MODULE Test;
	BEGIN TRUE ()
	END Test.

negative: calling constant boolean indirectly

	MODULE Test;
	CONST Constant = TRUE;
	BEGIN Constant
	END Test.

negative: calling constant boolean indirectly with parentheses

	MODULE Test;
	CONST Constant = TRUE;
	BEGIN Constant ()
	END Test.

positive: calling procedure with parameter and constant boolean argument

	MODULE Test;
	PROCEDURE Procedure (value: BOOLEAN); END Procedure;
	BEGIN Procedure (TRUE);
	END Test.

negative: calling procedure with variable parameter and constant boolean argument

	MODULE Test;
	PROCEDURE Procedure (VAR value: BOOLEAN); END Procedure;
	BEGIN Procedure (TRUE);
	END Test.

positive: calling procedure with constant parameter and constant boolean argument

	MODULE Test;
	PROCEDURE Procedure (CONST value: BOOLEAN); END Procedure;
	BEGIN Procedure (TRUE);
	END Test.


# constant characters

negative: constant character exceeding valid range

	MODULE Test;
	CONST Result = 1234X;
	END Test.

positive: ordering of constant character ordinals

	MODULE Test;
	BEGIN ASSERT (0X < 0FFX)
	END Test.

negative: arithmetic negation on constant character

	MODULE Test;
	CONST Result = -'a';
	END Test.

negative: logical negation on constant character

	MODULE Test;
	CONST Result = ~5X;
	END Test.

negative: dereferencing constant character

	MODULE Test;
	CONST Result = 't'^;
	END Test.

negative: dereferencing constant character indirectly

	MODULE Test;
	CONST Constant = 't';
	CONST Result = Constant^;
	END Test.

negative: addition on constant characters

	MODULE Test;
	CONST Result = 45X + 'r';
	END Test.

negative: subtraction on constant characters

	MODULE Test;
	CONST Result = '3' - 'a'
	END Test.

negative: multiplication on constant characters

	MODULE Test;
	CONST Result = '9' * 4FX
	END Test.

negative: integer division on constant characters

	MODULE Test;
	CONST Result = '@' DIV 'g'
	END Test.

negative: real division on constant characters

	MODULE Test;
	CONST Result = 'a' / 'b'
	END Test.

negative: modulo on constant characters

	MODULE Test;
	CONST Result = 8X MOD 2X
	END Test.

positive: equal relation on constant characters

	MODULE Test;
	CONST Result = 'r' = 'l'
	BEGIN ASSERT (Result = FALSE);
	END Test.

positive: unequal relation on constant characters

	MODULE Test;
	CONST Result = 4AX # 'z'
	BEGIN ASSERT (Result = TRUE);
	END Test.

positive: less relation on constant characters

	MODULE Test;
	CONST Result = 's' < 64X
	BEGIN ASSERT (Result = FALSE);
	END Test.

positive: less or equal relation on constant characters

	MODULE Test;
	CONST Result = 'e' <= 9X
	BEGIN ASSERT (Result = FALSE);
	END Test.

positive: greater relation on constant characters

	MODULE Test;
	CONST Result = 'r' > 'a'
	BEGIN ASSERT (Result = TRUE);
	END Test.

positive: greater or equal relation on constant characters

	MODULE Test;
	CONST Result = 'h' >= 0DX
	BEGIN ASSERT (Result = TRUE);
	END Test.

negative: set membership on constant characters

	MODULE Test;
	CONST Result = 1DX IN 'z'
	END Test.

negative: type test on constant characters

	MODULE Test;
	CONST Result = '0' IS 0X
	END Test.

negative: type test on constant character

	MODULE Test;
	CONST Result = '0' IS CHAR
	END Test.

negative: type test on constant character type

	MODULE Test;
	TYPE Type = CHAR;
	CONST Result = '0' IS Type
	END Test.

negative: type guard on constant characters

	MODULE Test;
	CONST Result = '0'(0X)
	END Test.

negative: indirect type guard on constant characters

	MODULE Test;
	CONST Constant = '0'
	CONST Result = Constant(Constant)
	END Test.

negative: type guard on constant character

	MODULE Test;
	CONST Result = '0'(CHAR)
	END Test.

negative: indirect type guard on constant character

	MODULE Test;
	CONST Constant = '0'
	CONST Result = Constant(CHAR)
	END Test.

negative: type guard on constant character type

	MODULE Test;
	TYPE Type = CHAR;
	CONST Result = '0'(Type)
	END Test.

negative: indirect guard test on constant character type

	MODULE Test;
	CONST Constant = '0'
	TYPE Type = CHAR;
	CONST Result = Constant(Type)
	END Test.

negative: logical and on constant characters

	MODULE Test;
	CONST Result = 'A' & 't'
	END Test.

negative: logical or on constant characters

	MODULE Test;
	CONST Result = 0X OR 1X
	END Test.

positive: ordinal value of constant character

	MODULE Test;
	CONST Result = ORD (10X)
	BEGIN ASSERT (Result = 10H)
	END Test.

negative: character value of constant character

	MODULE Test;
	CONST Result = CHR (23X)
	END Test.

negative: absolute value of constant character

	MODULE Test;
	CONST Result = ABS (0X)
	END Test.

negative: odd test on constant character

	MODULE Test;
	CONST Result = ODD ('2')
	END Test.

positive: capital letter of constant character

	MODULE Test;
	CONST Result = CAP ('a')
	BEGIN ASSERT (Result = 'A')
	END Test.

positive: minimal value of character

	MODULE Test;
	CONST Result = MIN (CHAR)
	BEGIN ASSERT (Result = 0X);
	END Test.

positive: maximal value of character

	MODULE Test;
	CONST Result = MAX (CHAR)
	BEGIN ASSERT (Result = 0FFX);
	END Test.

negative: arithmetic shift of constant characters

	MODULE Test;
	CONST Result = ASH ('5', '9')
	END Test.

negative: short on constant character

	MODULE Test;
	CONST Result = SHORT ('t')
	END Test.

negative: long on constant character

	MODULE Test;
	CONST Result = LONG ('t')
	END Test.

negative: entier on constant character

	MODULE Test;
	CONST Result = ENTIER ('t')
	END Test.

negative: unary length of constant character

	MODULE Test;
	CONST Result = LEN (0X)
	END Test.

negative: binary length of constant character

	MODULE Test;
	CONST Result = LEN (0X, 0)
	END Test.

negative: indexing constant character

	MODULE Test;
	CONST Result = 'a'[0]
	END Test.

negative: indexing constant character indirectly

	MODULE Test;
	CONST Constant = 'a';
	CONST Result = Constant[0]
	END Test.

negative: constant character as index

	MODULE Test;
	VAR array: ARRAY 10 OF CHAR; result: CHAR;
	BEGIN result := array['a']
	END Test.

negative: member selection on constant character

	MODULE Test;
	CONST Result = '3'.member
	END Test.

negative: indirect member selection on constant character

	MODULE Test;
	CONST Constant = '3';
	CONST Result = Constant.member
	END Test.

negative: calling constant character

	MODULE Test;
	BEGIN 'o' ()
	END Test.

negative: calling constant character indirectly

	MODULE Test;
	CONST Constant = 'o';
	BEGIN Constant
	END Test.

negative: calling constant character indirectly with parentheses

	MODULE Test;
	CONST Constant = 'o';
	BEGIN Constant ()
	END Test.

positive: calling procedure with parameter and constant character argument

	MODULE Test;
	PROCEDURE Procedure (value: CHAR); END Procedure;
	BEGIN Procedure ('a');
	END Test.

negative: calling procedure with variable parameter and constant character argument

	MODULE Test;
	PROCEDURE Procedure (VAR value: CHAR); END Procedure;
	BEGIN Procedure (54X);
	END Test.

positive: calling procedure with constant parameter and constant character argument

	MODULE Test;
	PROCEDURE Procedure (CONST value: CHAR); END Procedure;
	BEGIN Procedure (0AX);
	END Test.


# constant integers

negative: constant integer exceeding valid range

	MODULE Test;
	CONST Result = 123456789012345678901234567890;
	END Test.

positive: arithmetic negation on constant integer

	MODULE Test;
	CONST Result = -5;
	BEGIN ASSERT (Result = -5);
	END Test.

positive: multiple arithmetic negations on constant integer

	MODULE Test;
	CONST Result = -(-(-9));
	BEGIN ASSERT (Result = -9);
	END Test.

negative: logical negation on constant integer

	MODULE Test;
	CONST Result = ~788;
	END Test.

negative: dereferencing constant integer

	MODULE Test;
	CONST Result = 7^;
	END Test.

negative: dereferencing constant integer indirectly

	MODULE Test;
	CONST Constant = 7;
	CONST Result = Constant^;
	END Test.

positive: addition on constant integers

	MODULE Test;
	CONST Result = 1 + 057H;
	BEGIN ASSERT (Result = 88);
	END Test.

positive: subtraction on constant integers

	MODULE Test;
	CONST Result = 0 - 1
	BEGIN ASSERT (Result = -1);
	END Test.

positive: multiplication on constant integers

	MODULE Test;
	CONST Result = 1AH * 10
	BEGIN ASSERT (Result = 260);
	END Test.

positive: integer division on constant integers

	MODULE Test;
	CONST Divisor = -2147483648; Dividend = 131072; Result = Divisor DIV Dividend;
	BEGIN ASSERT (Result = -16384);
	END Test.

negative: integer division on constant integers by zero

	MODULE Test;
	CONST Result = 10 DIV 0
	END Test.

positive: real division on constant integers

	MODULE Test;
	CONST Result = 680 / 16
	BEGIN ASSERT (Result = 42.5);
	END Test.

negative: real division on constant integers by zero

	MODULE Test;
	CONST Result = 1ACH / 0
	END Test.

positive: modulo on constant integers

	MODULE Test;
	CONST Divisor = -2147483648; Dividend = 131072; Result = Divisor MOD Dividend;
	BEGIN ASSERT (Result = 0);
	END Test.

negative: modulo on constant integers by zero

	MODULE Test;
	CONST Result = 15H MOD 0
	END Test.

positive: equal relation on constant integers

	MODULE Test;
	CONST Result = 54 = 8
	BEGIN ASSERT (Result = FALSE);
	END Test.

positive: unequal relation on constant integers

	MODULE Test;
	CONST Result = 0 # 9
	BEGIN ASSERT (Result = TRUE);
	END Test.

positive: less relation on constant integers

	MODULE Test;
	CONST Result = 5 < 687H
	BEGIN ASSERT (Result = TRUE);
	END Test.

positive: less or equal relation on constant integers

	MODULE Test;
	CONST Result = 0 <= 1321
	BEGIN ASSERT (Result = TRUE);
	END Test.

positive: greater relation on constant integers

	MODULE Test;
	CONST Result = 0EFH > 54
	BEGIN ASSERT (Result = TRUE);
	END Test.

positive: greater or equal relation on constant integers

	MODULE Test;
	CONST Result = 131 >= 9
	BEGIN ASSERT (Result = TRUE);
	END Test.

negative: set membership on constant integers

	MODULE Test;
	CONST Result = 5 IN 9
	END Test.

negative: type test on constant integers

	MODULE Test;
	CONST Result = 4 IS 0
	END Test.

positive: type test on constant integer

	MODULE Test;
	CONST Result = 4 IS SIGNED16
	BEGIN ASSERT (Result = TRUE);
	END Test.

positive: type test on constant integer type

	MODULE Test;
	TYPE Type = SIGNED16;
	CONST Result = 4 IS Type
	BEGIN ASSERT (Result = TRUE);
	END Test.

negative: type guard on constant integers

	MODULE Test;
	CONST Result = 5(0)
	END Test.

negative: indirect type guard on constant integers

	MODULE Test;
	CONST Constant = 5
	CONST Result = Constant(Constant)
	END Test.

positive: type guard on constant integer

	MODULE Test;
	CONST Result = 5(SIGNED16)
	END Test.

positive: indirect type guard on constant integer

	MODULE Test;
	CONST Constant = 5
	CONST Result = Constant(SIGNED16)
	BEGIN ASSERT (Result = 5);
	END Test.

positive: type guard on constant integer type

	MODULE Test;
	TYPE Type = SIGNED16;
	CONST Result = 5(Type)
	END Test.

positive: indirect guard test on constant integer type

	MODULE Test;
	CONST Constant = 5
	TYPE Type = SIGNED16;
	CONST Result = Constant(Type)
	BEGIN ASSERT (Result = 5);
	END Test.

negative: logical and on constant integers

	MODULE Test;
	CONST Result = 123 & 3AH
	END Test.

negative: logical or on constant integers

	MODULE Test;
	CONST Result = 0 OR 685
	END Test.

negative: ordinal value of constant integer

	MODULE Test;
	CONST Result = ORD (99)
	END Test.

positive: character value of constant integer

	MODULE Test;
	CONST Result = CHR (65H)
	BEGIN ASSERT (Result = 65X)
	END Test.

positive: absolute value of constant integer

	MODULE Test;
	CONST Result = ABS (-5)
	BEGIN ASSERT (Result >= 0)
	END Test.

positive: odd test on constant integer

	MODULE Test;
	CONST Result = ODD (5)
	BEGIN ASSERT (Result)
	END Test.

negative: capital letter of constant integer

	MODULE Test;
	CONST Result = CAP (6)
	END Test.

positive: minimal value of integer

	MODULE Test;
	CONST A = MIN (SIGNED8); B = MIN (SIGNED16); C = MIN (SIGNED32); D = MIN (SIGNED64)
	END Test.

positive: maximal value of integer

	MODULE Test;
	CONST A = MAX (SIGNED8); B = MAX (SIGNED16); C = MAX (SIGNED32); D = MAX (SIGNED64)
	END Test.

positive: arithmetic left shift of constant integers

	MODULE Test;
	CONST Result = ASH (13, 6)
	BEGIN ASSERT (Result = 13 * (2 * 2 * 2 * 2 * 2 * 2));
	END Test.

positive: arithmetic right shift of constant integers

	MODULE Test;
	CONST Result = ASH (2379, -6)
	BEGIN ASSERT (Result = 2379 DIV (2 * 2 * 2 * 2 * 2 * 2));
	END Test.

positive: short on constant integer

	MODULE Test;
	CONST Result = SHORT (3215)
	END Test.

negative: short on constant short integer

	MODULE Test;
	CONST Result = SHORT (5)
	END Test.

positive: long on constant integer

	MODULE Test;
	CONST Result = LONG (5)
	END Test.

negative: long on constant huge integer

	MODULE Test;
	CONST Result = LONG (32154878786668)
	END Test.

negative: entier on constant integer

	MODULE Test;
	CONST Result = ENTIER (654)
	END Test.

negative: unary length of constant integer

	MODULE Test;
	CONST Result = LEN (6548)
	END Test.

negative: binary length of constant integer

	MODULE Test;
	CONST Result = LEN (6548, 0)
	END Test.

negative: indexing constant integer

	MODULE Test;
	CONST Result = 5[0]
	END Test.

negative: indexing constant integer indirectly

	MODULE Test;
	CONST Constant = 5;
	CONST Result = Constant[0]
	END Test.

positive: constant integer as index

	MODULE Test;
	VAR array: ARRAY 10 OF CHAR; result: CHAR;
	BEGIN result := array[5]
	END Test.

positive: zero as index

	MODULE Test;
	VAR array: ARRAY 10 OF CHAR; result: CHAR;
	BEGIN result := array[0]
	END Test.

negative: negative constant integer as index

	MODULE Test;
	VAR array: ARRAY 10 OF CHAR; result: CHAR;
	BEGIN result := array[-10]
	END Test.

negative: array size as index

	MODULE Test;
	VAR array: ARRAY 10 OF CHAR; result: CHAR;
	BEGIN result := array[10]
	END Test.

negative: constant integer as index exceeding valid range

	MODULE Test;
	VAR array: ARRAY 5, 10 OF CHAR; result: CHAR;
	BEGIN result := array[2, 20]
	END Test.

positive: zero as index in two-dimensional array

	MODULE Test;
	VAR array: ARRAY 5, 10 OF CHAR; result: CHAR;
	BEGIN result := array[2, 0]
	END Test.

negative: negative constant integer as index in two-dimensional array

	MODULE Test;
	VAR array: ARRAY 5, 10 OF CHAR; result: CHAR;
	BEGIN result := array[2, -10]
	END Test.

negative: array size as index in two-dimensional array

	MODULE Test;
	VAR array: ARRAY 5, 10 OF CHAR; result: CHAR;
	BEGIN result := array[2, 10]
	END Test.

negative: constant integer as index exceeding valid range in two-dimensional array

	MODULE Test;
	VAR array: ARRAY 5, 10 OF CHAR; result: CHAR;
	BEGIN result := array[2, 20]
	END Test.

negative: member selection on constant integer

	MODULE Test;
	CONST Result = 654.member
	END Test.

negative: indirect member selection on constant integer

	MODULE Test;
	CONST Constant = 654;
	CONST Result = Constant.member
	END Test.

negative: calling constant integer

	MODULE Test;
	BEGIN 007 ()
	END Test.

negative: calling constant integer indirectly

	MODULE Test;
	CONST Constant = 007;
	BEGIN Constant
	END Test.

negative: calling constant integer indirectly with parentheses

	MODULE Test;
	CONST Constant = 007;
	BEGIN Constant ()
	END Test.

positive: calling procedure with parameter and constant integer argument

	MODULE Test;
	PROCEDURE Procedure (value: SIGNED16); END Procedure;
	BEGIN Procedure (0);
	END Test.

negative: calling procedure with variable parameter and constant integer argument

	MODULE Test;
	PROCEDURE Procedure (VAR value: SIGNED16); END Procedure;
	BEGIN Procedure (1);
	END Test.

positive: calling procedure with constant parameter and constant integer argument

	MODULE Test;
	PROCEDURE Procedure (CONST value: SIGNED16); END Procedure;
	BEGIN Procedure (2);
	END Test.


# constant reals

positive: constant real in valid real range

	MODULE Test;
	CONST Result = 1.E10;
	END Test.

positive: constant long real in valid long real range

	MODULE Test;
	CONST Result = 1.D10;
	END Test.

negative: constant real exceeding valid real range

	MODULE Test;
	CONST Result = 1.E100;
	END Test.

positive: constant long real exceeding valid real range

	MODULE Test;
	CONST Result = 1.D100;
	END Test.

negative: constant real exceeding valid long range

	MODULE Test;
	CONST Result = 1.E500;
	END Test.

negative: constant long real exceeding valid long real range

	MODULE Test;
	CONST Result = 1.D500;
	END Test.

positive: arithmetic negation on constant real

	MODULE Test;
	CONST Result = -1.0;
	BEGIN ASSERT (Result = -1);
	END Test.

positive: multiple arithmetic negations on constant real

	MODULE Test;
	CONST Result = -(-(-1.0));
	BEGIN ASSERT (Result = -1);
	END Test.

negative: logical negation on constant real

	MODULE Test;
	CONST Result = ~1.D4;
	END Test.

negative: dereferencing constant real

	MODULE Test;
	CONST Result = 2.7^;
	END Test.

negative: dereferencing constant real indirectly

	MODULE Test;
	CONST Constant = 2.7;
	CONST Result = Constant^;
	END Test.

positive: addition on constant reals

	MODULE Test;
	CONST Result = 1.75 + 87.25;
	BEGIN ASSERT (Result = 89);
	END Test.

positive: subtraction on constant reals

	MODULE Test;
	CONST Result = 25.E-2 - 0.75
	BEGIN ASSERT (Result = -0.5);
	END Test.

positive: multiplication on constant reals

	MODULE Test;
	CONST Result = 0.5 * 1.5
	BEGIN ASSERT (Result = 0.75);
	END Test.

negative: integer division on constant reals

	MODULE Test;
	CONST Result = 3.E9 DIV 1.
	END Test.

positive: real division on constant reals

	MODULE Test;
	CONST Result = 0.75 / 0.5
	BEGIN ASSERT (Result = 1.5);
	END Test.

negative: real division on constant reals by zero

	MODULE Test;
	CONST Result = 0.5 / 0.0
	END Test.

negative: modulo on constant reals

	MODULE Test;
	CONST Result = 8.9 MOD 7.1
	END Test.

positive: equal relation on constant reals

	MODULE Test;
	CONST Result = 1.0 = 5.E32
	BEGIN ASSERT (Result = FALSE);
	END Test.

positive: unequal relation on constant reals

	MODULE Test;
	CONST Result = 0.001 # 9.
	BEGIN ASSERT (Result = TRUE);
	END Test.

positive: less relation on constant reals

	MODULE Test;
	CONST Result = 1.0 < 97.4
	BEGIN ASSERT (Result = TRUE);
	END Test.

positive: less or equal relation on constant reals

	MODULE Test;
	CONST Result = 464.1 <= 9.E+7
	BEGIN ASSERT (Result = TRUE);
	END Test.

positive: greater relation on constant reals

	MODULE Test;
	CONST Result = 0.1 > 1.54
	BEGIN ASSERT (Result = FALSE);
	END Test.

positive: greater or equal relation on constant reals

	MODULE Test;
	CONST Result = 9.E9 >= 0.0
	BEGIN ASSERT (Result = TRUE);
	END Test.

negative: set membership on constant reals

	MODULE Test;
	CONST Result = 9.1 IN 1.0
	END Test.

negative: type test on constant reals

	MODULE Test;
	CONST Result = 4.E9 IS 1.
	END Test.

negative: type test on constant real

	MODULE Test;
	CONST Result = 4.E9 IS Real
	END Test.

positive: type test on constant real type

	MODULE Test;
	TYPE Type = FLOAT32;
	CONST Result = 4.E9 IS Type
	BEGIN ASSERT (Result = TRUE);
	END Test.

negative: type guard on constant reals

	MODULE Test;
	CONST Result = 5.0(0.0)
	END Test.

negative: indirect type guard on constant reals

	MODULE Test;
	CONST Constant = 5.0
	CONST Result = Constant(Constant)
	END Test.

positive: type guard on constant real

	MODULE Test;
	CONST Result = 5.0(FLOAT32)
	END Test.

positive: indirect type guard on constant real

	MODULE Test;
	CONST Constant = 5.0
	CONST Result = Constant(FLOAT32)
	BEGIN ASSERT (Result = 5.0);
	END Test.

positive: type guard on constant real type

	MODULE Test;
	TYPE Type = FLOAT32;
	CONST Result = 5.0(Type)
	END Test.

positive: indirect type guard on constant real type

	MODULE Test;
	CONST Constant = 5.0
	TYPE Type = FLOAT32;
	CONST Result = Constant(Type)
	BEGIN ASSERT (Result = 5.0);
	END Test.

negative: logical and on constant reals

	MODULE Test;
	CONST Result = 9.D54 & 1.974D+9
	END Test.

negative: logical or on constant reals

	MODULE Test;
	CONST Result = 0.4 OR 0.
	END Test.

negative: ordinal value of constant real

	MODULE Test;
	CONST Result = ORD (84.4)
	END Test.

negative: character value of constant real

	MODULE Test;
	CONST Result = CHR (67.4)
	END Test.

positive: absolute value of constant real

	MODULE Test;
	CONST Result = ABS (-67.4)
	BEGIN ASSERT (Result >= 0);
	END Test.

negative: odd test on constant real

	MODULE Test;
	CONST Result = ODD (2.5)
	END Test.

negative: capital letter of constant real

	MODULE Test;
	CONST Result = CAP (-0.5)
	END Test.

positive: minimal value of real

	MODULE Test;
	CONST A = MIN (FLOAT32); B = MIN (FLOAT64)
	END Test.

positive: maximal value of real

	MODULE Test;
	CONST A = MAX (FLOAT32); B = MAX (FLOAT64)
	END Test.

negative: arithmetic shift of constant reals

	MODULE Test;
	CONST Result = ASH (64.5, 3.4)
	END Test.

negative: short on constant real

	MODULE Test;
	CONST Result = SHORT (5.4)
	END Test.

positive: short on constant long real

	MODULE Test;
	CONST Result = SHORT (5.0D300)
	END Test.

positive: long on constant real

	MODULE Test;
	CONST Result = LONG (5.4)
	END Test.

negative: long on constant long real

	MODULE Test;
	CONST Result = LONG (5.0D300)
	END Test.

positive: entier on constant real

	MODULE Test;
	CONST Result = ENTIER (5.4)
	END Test.

positive: entier on constant long real

	MODULE Test;
	CONST Result = ENTIER (5.0D300)
	END Test.

negative: unary length of constant real

	MODULE Test;
	CONST Result = LEN (0.123)
	END Test.

negative: binary length of constant real

	MODULE Test;
	CONST Result = LEN (0.123, 0)
	END Test.

negative: indexing constant real

	MODULE Test;
	CONST Result = 9.7[0]
	END Test.

negative: indexing constant real indirectly

	MODULE Test;
	CONST Constant = 9.7;
	CONST Result = Constant[0]
	END Test.

negative: constant real as index

	MODULE Test;
	VAR array: ARRAY 10 OF CHAR; result: CHAR;
	BEGIN result := array[9.7]
	END Test.

negative: member selection on constant real

	MODULE Test;
	CONST Result = 654.654.member
	END Test.

negative: indirect member selection on constant real

	MODULE Test;
	CONST Constant = 654.654;
	CONST Result = Constant.member
	END Test.

negative: calling constant real

	MODULE Test;
	BEGIN 1.23 ()
	END Test.

negative: calling constant real indirectly

	MODULE Test;
	CONST Constant = 1.23;
	BEGIN Constant
	END Test.

negative: calling constant real indirectly with parentheses

	MODULE Test;
	CONST Constant = 1.23;
	BEGIN Constant ()
	END Test.

positive: calling procedure with parameter and constant real argument

	MODULE Test;
	PROCEDURE Procedure (value: FLOAT32); END Procedure;
	BEGIN Procedure (0.0);
	END Test.

negative: calling procedure with variable parameter and constant real argument

	MODULE Test;
	PROCEDURE Procedure (VAR value: FLOAT32); END Procedure;
	BEGIN Procedure (1.1);
	END Test.

positive: calling procedure with constant parameter and constant real argument

	MODULE Test;
	PROCEDURE Procedure (CONST value: FLOAT32); END Procedure;
	BEGIN Procedure (2.2);
	END Test.


# constant set

positive: empty constant set

	MODULE Test;
	CONST Result = {};
	END Test.

negative: constant boolean as set element

	MODULE Test;
	CONST Result = {FALSE};
	END Test.

negative: constant character as set element

	MODULE Test;
	CONST Result = {'a'};
	END Test.

positive: constant integer constant as set element

	MODULE Test;
	CONST Result = {10};
	BEGIN ASSERT (Result = {10});
	END Test.

negative: constant real as set element

	MODULE Test;
	CONST Result = {45.4};
	END Test.

negative: constant set as set element

	MODULE Test;
	CONST Result = {{}};
	END Test.

negative: constant string as set element

	MODULE Test;
	CONST Result = {"string"};
	END Test.

negative: constant set element exceeding valid range

	MODULE Test;
	CONST Result = {100};
	END Test.

negative: negative constant set element

	MODULE Test;
	CONST Result = {-1};
	END Test.

positive: several equal constant set elements

	MODULE Test;
	CONST Result = {0, 0, 0};
	BEGIN ASSERT (Result = {0});
	END Test.

positive: several different constant set elements

	MODULE Test;
	CONST Result = {0, 1, 2};
	BEGIN ASSERT (Result = {0..2});
	END Test.

positive: constant set element range

	MODULE Test;
	CONST Result = {5..6};
	BEGIN ASSERT (Result = {5, 6});
	END Test.

positive: constant set element range with single element

	MODULE Test;
	CONST Result = {6..6};
	BEGIN ASSERT (Result = {6});
	END Test.

positive: empty constant set element range

	MODULE Test;
	CONST Result = {3..2};
	BEGIN ASSERT (Result = {});
	END Test.

negative: empty constant set element range with negative start element

	MODULE Test;
	CONST Result = {-1..2};
	END Test.

negative: empty constant set element range with negative end element

	MODULE Test;
	CONST Result = {3..-4};
	END Test.

positive: relations on constant sets

	MODULE Test;
	BEGIN
		ASSERT ({1..3,5} <= {1..3,5});
		ASSERT (~({1..3,5,6} < {1..3,5,8}));
		ASSERT (~({1..3,5,6} <= {1..3,5,8}));
		ASSERT (~({1..3,5,6} > {1..3,5,8}));
		ASSERT (~({1..3,5,6} >= {1..3,5,8}));
		ASSERT ({1..3,5} < {1..3,5,7});
		ASSERT ({1..3,5} > {1..3});
		ASSERT ({1..3,5,7} >= {1..3,5,7});
		ASSERT ({1..3,5} = {1..3,5});
		ASSERT ({1..3,5,8} # {1..3,5,7});
	END Test.

positive: complement on constant set

	MODULE Test;
	CONST Result = -{4, 9};
	BEGIN ASSERT (Result = -{4, 9});
	END Test.

positive: multiple complements on constant set

	MODULE Test;
	CONST Result = -(-(-{5}));
	BEGIN ASSERT (Result = -{5});
	END Test.

negative: logical negation on constant set

	MODULE Test;
	CONST Result = ~{};
	END Test.

negative: dereferencing constant set

	MODULE Test;
	CONST Result = {2..5}^;
	END Test.

negative: dereferencing constant set indirectly

	MODULE Test;
	CONST Constant = {2..5};
	CONST Result = Constant^;
	END Test.

positive: union on constant sets

	MODULE Test;
	CONST Result = {4, 6} + {9};
	BEGIN ASSERT (Result = {4, 6, 9});
	END Test.

positive: difference on constant sets

	MODULE Test;
	CONST Result = {7, 2} - {2..1}
	BEGIN ASSERT (Result = {2, 7});
	END Test.

positive: intersection on constant sets

	MODULE Test;
	CONST Result = {7..9} * {6..7}
	BEGIN ASSERT (Result = {7});
	END Test.

negative: integer division on constant sets

	MODULE Test;
	CONST Result = {8} DIV {}
	END Test.

positive: symmetric difference on constant sets

	MODULE Test;
	CONST Result = {4..9} / {5,4,3,2,1}
	BEGIN ASSERT (Result = {1..3, 6..9});
	END Test.

negative: modulo on constant sets

	MODULE Test;
	CONST Result = {7} MOD {0}
	END Test.

positive: equal relation on constant sets

	MODULE Test;
	CONST Result = {4} = {}
	BEGIN ASSERT (Result = FALSE);
	END Test.

positive: unequal relation on constant sets

	MODULE Test;
	CONST Result = {9, 5} # {0..5}
	BEGIN ASSERT (Result = TRUE);
	END Test.

positive: less relation on constant sets

	MODULE Test;
	CONST Result = {9} < {7}
	BEGIN ASSERT (Result = FALSE);
	END Test.

positive: less or equal relation on constant sets

	MODULE Test;
	CONST Result = {8} <= {8}
	BEGIN ASSERT (Result = TRUE);
	END Test.

positive: greater relation on constant sets

	MODULE Test;
	CONST Result = {0..5} > {0..2}
	BEGIN ASSERT (Result = TRUE);
	END Test.

positive: greater or equal relation on constant sets

	MODULE Test;
	CONST Result = {4} >= {4..4}
	BEGIN ASSERT (Result = TRUE);
	END Test.

negative: set membership on constant sets

	MODULE Test;
	CONST Result = {9} IN {1}
	END Test.

positive: set membership on integer and constant set

	MODULE Test;
	CONST Result = 3 IN {2}
	BEGIN ASSERT (Result = FALSE);
	END Test.

negative: type test on constant sets

	MODULE Test;
	CONST Result = {7} IS {}
	END Test.

negative: type test on constant set

	MODULE Test;
	CONST Result = {7} IS Set
	END Test.

negative: type test on constant set type

	MODULE Test;
	TYPE Type = Set;
	CONST Result = {7} IS Type
	END Test.

negative: type guard on constant sets

	MODULE Test;
	CONST Result = {}({4})
	END Test.

negative: indirect type guard on constant sets

	MODULE Test;
	CONST Constant = {}
	CONST Result = Constant(Constant)
	END Test.

negative: type guard on constant set

	MODULE Test;
	CONST Result = {}(SET)
	END Test.

negative: indirect type guard on constant set

	MODULE Test;
	CONST Constant = {}
	CONST Result = Constant(SET)
	END Test.

negative: type guard on constant set type

	MODULE Test;
	TYPE Type = SET;
	CONST Result = {}(Type)
	END Test.

negative: indirect type guard on constant set type

	MODULE Test;
	CONST Constant = {}
	TYPE Type = SET;
	CONST Result = Constant(Type)
	END Test.

negative: logical and on constant sets

	MODULE Test;
	CONST Result = {0..7} & {7}
	END Test.

negative: logical or on constant sets

	MODULE Test;
	CONST Result = {8} OR {}
	END Test.

negative: ordinal value of constant set

	MODULE Test;
	CONST Result = ORD ({5})
	END Test.

negative: character value of constant set

	MODULE Test;
	CONST Result = CHR ({1..4})
	END Test.

negative: absolute value of constant set

	MODULE Test;
	CONST Result = ABS ({1..4})
	END Test.

negative: odd test on constant set

	MODULE Test;
	CONST Result = ODD ({})
	END Test.

negative: capital letter of constant set

	MODULE Test;
	CONST Result = CAP ({2..9})
	END Test.

positive: minimal value of set

	MODULE Test;
	CONST Result = MIN (SET)
	BEGIN ASSERT (Result = 0);
	END Test.

positive: maximal value of set

	MODULE Test;
	CONST Result = MAX (SET)
	BEGIN ASSERT (Result = SIZEOF (SET) * 8 - 1)
	END Test.

negative: arithmetic shift of constant set

	MODULE Test;
	CONST Result = ASH ({6}, {})
	END Test.

negative: short on constant set

	MODULE Test;
	CONST Result = SHORT ({4, 2})
	END Test.

negative: long on constant set

	MODULE Test;
	CONST Result = LONG ({4, 2})
	END Test.

negative: entier on constant set

	MODULE Test;
	CONST Result = ENTIER ({4, 2})
	END Test.

negative: unary length of constant set

	MODULE Test;
	CONST Result = LEN ({0,3})
	END Test.

negative: binary length of constant set

	MODULE Test;
	CONST Result = LEN ({0,3}, 0)
	END Test.

negative: indexing constant set

	MODULE Test;
	CONST Result = {1}[0]
	END Test.

negative: indexing constant set indirectly

	MODULE Test;
	CONST Constant = {1};
	CONST Result = Constant[0]
	END Test.

negative: constant set as index

	MODULE Test;
	VAR array: ARRAY 10 OF CHAR; result: CHAR;
	BEGIN result := array[{1}]
	END Test.

negative: member selection on constant set

	MODULE Test;
	CONST Result = {2}.member
	END Test.

negative: indirect member selection on constant set

	MODULE Test;
	CONST Constant = {2};
	CONST Result = Constant.member
	END Test.

negative: calling constant set

	MODULE Test;
	BEGIN {} ()
	END Test.

negative: calling constant set indirectly

	MODULE Test;
	CONST Constant = {};
	BEGIN Constant
	END Test.

negative: calling constant set indirectly with parentheses

	MODULE Test;
	CONST Constant = {};
	BEGIN Constant ()
	END Test.

positive: calling procedure with parameter and constant set argument

	MODULE Test;
	PROCEDURE Procedure (value: SET); END Procedure;
	BEGIN Procedure ({0});
	END Test.

negative: calling procedure with variable parameter and constant set argument

	MODULE Test;
	PROCEDURE Procedure (VAR value: SET); END Procedure;
	BEGIN Procedure ({4..6});
	END Test.

positive: calling procedure with constant parameter and constant set argument

	MODULE Test;
	PROCEDURE Procedure (CONST value: SET); END Procedure;
	BEGIN Procedure ({1,2});
	END Test.


# constant strings

positive: empty constant string

	MODULE Test;
	CONST Result = "";
	END Test.

negative: arithmetic negation on constant string

	MODULE Test;
	CONST Result = -"123";
	END Test.

negative: logical negation on constant string

	MODULE Test;
	CONST Result = ~"invalid";
	END Test.

negative: dereferencing constant string

	MODULE Test;
	CONST Result = "string"^;
	END Test.

negative: dereferencing constant string indirectly

	MODULE Test;
	CONST Constant = "string";
	CONST Result = Constant^;
	END Test.

negative: addition on constant strings

	MODULE Test;
	CONST Result = "hello" + "world";
	END Test.

negative: subtraction on constant strings

	MODULE Test;
	CONST Result = "nice" - "try"
	END Test.

negative: multiplication on constant strings

	MODULE Test;
	CONST Result = "multiplication" * "disallowed"
	END Test.

negative: integer division on constant strings

	MODULE Test;
	CONST Result = "abc" DIV "ABC"
	END Test.

negative: real division on constant strings

	MODULE Test;
	CONST Result = "007" / "008"
	END Test.

negative: modulo on constant strings

	MODULE Test;
	CONST Result = "one" MOD "two"
	END Test.

positive: equal relation on constant strings

	MODULE Test;
	CONST Result = "string" = "gnirts"
	BEGIN ASSERT (Result = FALSE);
	END Test.

positive: unequal relation on constant strings

	MODULE Test;
	CONST Result = "qwerty" # "ytrewq"
	BEGIN ASSERT (Result = TRUE);
	END Test.

positive: less relation on constant strings

	MODULE Test;
	CONST Result = "av" < "bv"
	BEGIN ASSERT (Result = TRUE);
	END Test.

positive: less or equal relation on constant strings

	MODULE Test;
	CONST Result = "word1" <= "word2"
	BEGIN ASSERT (Result = TRUE);
	END Test.

positive: greater relation on constant strings

	MODULE Test;
	CONST Result = "lower" > "UPPER"
	BEGIN ASSERT (Result = TRUE);
	END Test.

positive: greater or equal relation on constant strings

	MODULE Test;
	CONST Result = "number" >= "text"
	BEGIN ASSERT (Result = FALSE);
	END Test.

negative: set membership on constant strings

	MODULE Test;
	CONST Result = "name" IN "ninety"
	END Test.

negative: type test on constant strings

	MODULE Test;
	CONST Result = "not" IS "supported"
	END Test.

negative: type test on constant string

	MODULE Test;
	CONST Result = "not" IS ARRAY OF CHAR
	END Test.

negative: type test on string type

	MODULE Test;
	TYPE Type = ARRAY OF CHAR;
	CONST Result = "not" IS Type
	END Test.

negative: type guard on constant strings

	MODULE Test;
	CONST Result = "type"("guard")
	END Test.

negative: indirect type guard on constant strings

	MODULE Test;
	CONST Constant = "type"
	CONST Result = Constant(Constant)
	END Test.

negative: type guard on constant string

	MODULE Test;
	CONST Result = "type"(ARRAY OF CHAR)
	END Test.

negative: indirect type guard on constant string

	MODULE Test;
	CONST Constant = "type"
	CONST Result = Constant(ARRAY OF CHAR)
	END Test.

negative: type guard on string type

	MODULE Test;
	TYPE Type = ARRAY OF CHAR;
	CONST Result = "type"(Type)
	END Test.

negative: indirect type guard on string type

	MODULE Test;
	CONST Constant = "type"
	TYPE Type = ARRAY OF CHAR;
	CONST Result = Constant(Type)
	END Test.

negative: logical and on constant strings

	MODULE Test;
	CONST Result = "oh" & "dear"
	END Test.

negative: logical or on constant strings

	MODULE Test;
	CONST Result = "last" OR "one"
	END Test.

negative: ordinal value of constant string

	MODULE Test;
	CONST Result = ORD ("ORD")
	END Test.

negative: character value of constant string

	MODULE Test;
	CONST Result = CHR ("CHR")
	END Test.

negative: absolute value of constant string

	MODULE Test;
	CONST Result = ABS ("ABS")
	END Test.

negative: odd test on constant string

	MODULE Test;
	CONST Result = ODD ("ODD")
	END Test.

negative: capital letter of constant string

	MODULE Test;
	CONST Result = CAP ("lowercase")
	END Test.

negative: arithmetic shift of constant string

	MODULE Test;
	CONST Result = ASH ("shift", "me")
	END Test.

negative: short on constant string

	MODULE Test;
	CONST Result = SHORT ("integer")
	END Test.

negative: long on constant string

	MODULE Test;
	CONST Result = LONG ("integer")
	END Test.

negative: entier on constant string

	MODULE Test;
	CONST Result = ENTIER ("real")
	END Test.

negative: unary length of constant string

	MODULE Test;
	CONST Result = LEN ("abc")
	END Test.

negative: binary length of constant string

	MODULE Test;
	CONST Result = LEN ("abc", 0)
	END Test.

negative: indexing constant string

	MODULE Test;
	CONST Result = "string"[0]
	END Test.

negative: indexing constant string indirectly

	MODULE Test;
	CONST Constant = "string";
	CONST Result = Constant[0]
	END Test.

negative: constant string as index

	MODULE Test;
	VAR array: ARRAY 10 OF CHAR; result: CHAR;
	BEGIN result := array["string"]
	END Test.

negative: member selection on constant string

	MODULE Test;
	CONST Result = "record".member
	END Test.

negative: indirect member selection on constant string

	MODULE Test;
	CONST Constant = "record";
	CONST Result = Constant.member
	END Test.

negative: calling constant string

	MODULE Test;
	BEGIN "asdf" ()
	END Test.

negative: calling constant string indirectly

	MODULE Test;
	CONST Constant = "asdf";
	BEGIN Constant
	END Test.

negative: calling constant string indirectly with parentheses

	MODULE Test;
	CONST Constant = "asdf";
	BEGIN Constant ()
	END Test.

positive: calling procedure with parameter and constant string argument

	MODULE Test;
	PROCEDURE Procedure (value: ARRAY OF CHAR); END Procedure;
	BEGIN Procedure ("argument");
	END Test.

negative: calling procedure with variable parameter and constant string argument

	MODULE Test;
	PROCEDURE Procedure (VAR value: ARRAY OF CHAR); END Procedure;
	BEGIN Procedure ("argument");
	END Test.

positive: calling procedure with constant parameter and constant string argument

	MODULE Test;
	PROCEDURE Procedure (CONST value: ARRAY OF CHAR); END Procedure;
	BEGIN Procedure ("argument");
	END Test.


# constant nil pointers

negative: arithmetic negation on nil pointer

	MODULE Test;
	CONST Result = -NIL;
	END Test.

negative: logical negation on nil pointer

	MODULE Test;
	CONST Result = ~NIL;
	END Test.

negative: multiple logical negations on nil pointer

	MODULE Test;
	CONST Result = ~~~~NIL;
	END Test.

negative: dereferencing nil pointer

	MODULE Test;
	CONST Result = NIL^;
	END Test.

negative: dereferencing constant nil pointer indirectly

	MODULE Test;
	CONST Constant = NIL;
	CONST Result = Constant^;
	END Test.

negative: addition on nil pointer

	MODULE Test;
	CONST Result = NIL + NIL;
	END Test.

negative: subtraction on nil pointer

	MODULE Test;
	CONST Result = NIL - NIL
	END Test.

negative: multiplication on nil pointer

	MODULE Test;
	CONST Result = NIL * NIL
	END Test.

negative: integer division on nil pointer

	MODULE Test;
	CONST Result = NIL DIV NIL
	END Test.

negative: real division on nil pointer

	MODULE Test;
	CONST Result = NIL / NIL
	END Test.

negative: modulo on nil pointer

	MODULE Test;
	CONST Result = NIL MOD NIL
	END Test.

positive: equal relation on nil pointer

	MODULE Test;
	CONST Result = NIL = NIL
	BEGIN ASSERT (Result = TRUE);
	END Test.

positive: unequal relation on nil pointer

	MODULE Test;
	CONST Result = NIL # NIL
	BEGIN ASSERT (Result = FALSE);
	END Test.

negative: less relation on nil pointer

	MODULE Test;
	CONST Result = NIL < NIL
	END Test.

negative: less or equal relation on nil pointer

	MODULE Test;
	CONST Result = NIL <= NIL
	END Test.

negative: greater relation on nil pointer

	MODULE Test;
	CONST Result = NIL > NIL
	END Test.

negative: greater or equal relation on nil pointer

	MODULE Test;
	CONST Result = NIL >= NIL
	END Test.

negative: set membership on nil pointer

	MODULE Test;
	CONST Result = NIL IN NIL
	END Test.

negative: type test on nil pointers

	MODULE Test;
	CONST Result = NIL IS NIL
	END Test.

negative: type test on nil pointer

	MODULE Test;
	CONST Result = NIL IS OBJECT
	END Test.

negative: type test on nil pointer type

	MODULE Test;
	TYPE Type = OBJECT;
	CONST Result = NIL IS Type
	END Test.

negative: type guard on nil pointers

	MODULE Test;
	CONST Result = NIL(NIL)
	END Test.

negative: indirect type guard on nil pointers

	MODULE Test;
	CONST Constant = NIL
	CONST Result = Constant(Constant)
	END Test.

negative: type guard on nil pointer

	MODULE Test;
	CONST Result = NIL(OBJECT)
	END Test.

negative: indirect type guard on nil pointer

	MODULE Test;
	CONST Constant = NIL
	CONST Result = Constant(NIL)
	END Test.

negative: type guard on nil pointer type

	MODULE Test;
	TYPE Type = OBJECT;
	CONST Result = NIL(Type)
	END Test.

negative: indirect type guard on nil pointer type

	MODULE Test;
	CONST Constant = NIL
	TYPE Type = OBJECT;
	CONST Result = Constant(Type)
	END Test.

negative: logical and on nil pointer

	MODULE Test;
	CONST Result = NIL & NIL
	END Test.

negative: logical or on nil pointer

	MODULE Test;
	CONST Result = NIL OR NIL
	END Test.

negative: ordinal value of nil pointer

	MODULE Test;
	CONST Result = ORD (NIL)
	END Test.

negative: character value of nil pointer

	MODULE Test;
	CONST Result = CHR (NIL)
	END Test.

negative: absolute value of nil pointer

	MODULE Test;
	CONST Result = ABS (NIL)
	END Test.

negative: odd test on nil pointer

	MODULE Test;
	CONST Result = ODD (NIL)
	END Test.

negative: capital letter of nil pointer

	MODULE Test;
	CONST Result = CAP (NIL)
	END Test.

negative: arithmetic shift of nil pointer

	MODULE Test;
	CONST Result = ASH (NIL, NIL)
	END Test.

negative: short on nil pointer

	MODULE Test;
	CONST Result = SHORT (NIL)
	END Test.

negative: long on nil pointer

	MODULE Test;
	CONST Result = LONG (NIL)
	END Test.

negative: entier on nil pointer

	MODULE Test;
	CONST Result = ENTIER (NIL)
	END Test.

negative: unary length of nil pointer

	MODULE Test;
	CONST Result = LEN (NIL)
	END Test.

negative: binary length of nil pointer

	MODULE Test;
	CONST Result = LEN (NIL, 0)
	END Test.

negative: indexing nil pointer

	MODULE Test;
	CONST Result = NIL[0]
	END Test.

negative: indexing nil pointer indirectly

	MODULE Test;
	CONST Constant = NIL;
	CONST Result = Constant[0]
	END Test.

negative: nil pointer as index

	MODULE Test;
	VAR array: ARRAY 10 OF CHAR; result: CHAR;
	BEGIN result := array[NIL]
	END Test.

negative: member selection on nil pointer

	MODULE Test;
	CONST Result = NIL.member
	END Test.

negative: indirect member selection on nil pointer

	MODULE Test;
	CONST Constant = NIL;
	CONST Result = Constant.member
	END Test.

negative: calling nil pointer

	MODULE Test;
	BEGIN NIL ()
	END Test.

negative: calling nil pointer indirectly

	MODULE Test;
	CONST Constant = NIL;
	BEGIN Constant
	END Test.

negative: calling nil pointer indirectly with parentheses

	MODULE Test;
	CONST Constant = NIL;
	BEGIN Constant ()
	END Test.

positive: calling procedure with parameter and nil pointer argument

	MODULE Test;
	PROCEDURE Procedure (value: OBJECT); END Procedure;
	BEGIN Procedure (NIL);
	END Test.

negative: calling procedure with variable parameter and nil pointer argument

	MODULE Test;
	PROCEDURE Procedure (VAR value: OBJECT); END Procedure;
	BEGIN Procedure (NIL);
	END Test.

positive: calling procedure with constant parameter and nil pointer argument

	MODULE Test;
	PROCEDURE Procedure (CONST value: OBJECT); END Procedure;
	BEGIN Procedure (NIL);
	END Test.


# implicit constant conversions

positive: implicit constant short to integer conversion

	MODULE Test;
	CONST Result = 10H + 1000H
	END Test.

positive: implicit constant short to long integer conversion

	MODULE Test;
	CONST Result = 10H * 100000H
	END Test.

positive: implicit constant short to huge integer conversion

	MODULE Test;
	CONST Result = 10H DIV 100000000H
	END Test.

positive: implicit constant integer to long integer conversion

	MODULE Test;
	CONST Result = 1000H - 100000H
	END Test.

positive: implicit constant integer to huge integer conversion

	MODULE Test;
	CONST Result = 1000H * 100000000H
	END Test.

positive: implicit constant long to huge integer conversion

	MODULE Test;
	CONST Result = 100000H + 100000000H
	END Test.

positive: implicit constant integer to real conversion

	MODULE Test;
	CONST Result = 4 + 5.0
	END Test.

positive: implicit constant integer to long real conversion

	MODULE Test;
	CONST Result = 4.5D127 / 54
	END Test.

positive: implicit constant real to long real conversion

	MODULE Test;
	CONST Result = 1.2 * 1.7D247
	END Test.

negative: implicit conversion between constant boolean and character

	MODULE Test;
	CONST Result = TRUE = 's'
	END Test.

negative: implicit conversion between constant boolean and integer

	MODULE Test;
	CONST Result = TRUE # 5
	END Test.

negative: implicit conversion between constant boolean and real

	MODULE Test;
	CONST Result = FALSE = 1.0E4
	END Test.

negative: implicit conversion between constant boolean and set

	MODULE Test;
	CONST Result = TRUE = {3}
	END Test.

negative: implicit conversion between constant boolean and string

	MODULE Test;
	CONST Result = TRUE = "adsf"
	END Test.

negative: implicit conversion between constant boolean and nil pointer

	MODULE Test;
	CONST Result = FALSE = NIL
	END Test.

negative: implicit conversion between constant character and integer

	MODULE Test;
	CONST Result = 's' # 2
	END Test.

negative: implicit conversion between constant character and real

	MODULE Test;
	CONST Result = 't' # 1.0
	END Test.

negative: implicit conversion between constant character and set

	MODULE Test;
	CONST Result = 0X = {}
	END Test.

negative: implicit conversion between constant character and string

	MODULE Test;
	CONST Result = 0X # "string"
	END Test.

negative: implicit conversion between constant character and nil pointer

	MODULE Test;
	CONST Result = 45X # NIL
	END Test.

positive: implicit conversion between constant integer and real

	MODULE Test;
	CONST Result = 54 # 2.0
	END Test.

negative: implicit conversion between constant integer and set

	MODULE Test;
	CONST Result = 0 = {5}
	END Test.

negative: implicit conversion between constant integer and string

	MODULE Test;
	CONST Result = 9 # "text"
	END Test.

negative: implicit conversion between constant integer and nil pointer

	MODULE Test;
	CONST Result = 5 # NIL
	END Test.

negative: implicit conversion between constant real and set

	MODULE Test;
	CONST Result = 54.1 = {0..4}
	END Test.

negative: implicit conversion between constant real and string

	MODULE Test;
	CONST Result = 0.0 = "zero"
	END Test.

negative: implicit conversion between constant real and nil pointer

	MODULE Test;
	CONST Result = 5.5 = NIL
	END Test.

negative: implicit conversion between constant set and string

	MODULE Test;
	CONST Result = {9} # "value"
	END Test.

negative: implicit conversion between constant set and nil pointer

	MODULE Test;
	CONST Result = {} # NIL
	END Test.

negative: implicit conversion between constant string and nil pointer

	MODULE Test;
	CONST Result = "NIL" # NIL
	END Test.


# explicit constant conversions

positive: explicit constant short integer to integer conversion

	MODULE Test;
	CONST Result = LONG (12H)
	BEGIN ASSERT (Result = 12H)
	END Test.

positive: explicit constant short to long integer conversion

	MODULE Test;
	CONST Result = LONG (LONG (12H))
	BEGIN ASSERT (Result = 12H)
	END Test.

positive: explicit constant short to huge integer conversion

	MODULE Test;
	CONST Result = LONG (LONG (LONG (12H)))
	BEGIN ASSERT (Result = 12H)
	END Test.

positive: explicit constant integer to short integer conversion

	MODULE Test;
	CONST Result = SHORT (1234H)
	BEGIN ASSERT (Result = 34H)
	END Test.

positive: explicit constant integer to long integer conversion

	MODULE Test;
	CONST Result = LONG (1234H)
	BEGIN ASSERT (Result = 1234H)
	END Test.

positive: explicit constant integer to huge integer conversion

	MODULE Test;
	CONST Result = LONG (LONG (1234H))
	BEGIN ASSERT (Result = 1234H)
	END Test.

positive: explicit constant long to short integer conversion

	MODULE Test;
	CONST Result = SHORT (SHORT (123456H))
	BEGIN ASSERT (Result = 56H)
	END Test.

positive: explicit constant long integer to integer conversion

	MODULE Test;
	CONST Result = SHORT (123456H)
	BEGIN ASSERT (Result = 3456H)
	END Test.

positive: explicit constant long to huge integer conversion

	MODULE Test;
	CONST Result = LONG (123456H)
	BEGIN ASSERT (Result = 123456H)
	END Test.

positive: explicit constant huge to short integer conversion

	MODULE Test;
	CONST Result = SHORT (SHORT (SHORT (123456777H)))
	BEGIN ASSERT (Result = 77H)
	END Test.

positive: explicit constant huge integer to integer conversion

	MODULE Test;
	CONST Result = SHORT (SHORT (123456789H))
	BEGIN ASSERT (Result = 6789H)
	END Test.

positive: explicit constant huge to long integer conversion

	MODULE Test;
	CONST Result = SHORT (123456789H)
	BEGIN ASSERT (Result = 23456789H)
	END Test.

positive: explicit positive constant real to integer conversion

	MODULE Test;
	CONST Result = ENTIER (5.9)
	BEGIN ASSERT (Result = 5)
	END Test.

positive: explicit negative constant real to integer conversion

	MODULE Test;
	CONST Result = ENTIER (-5.1E0)
	BEGIN ASSERT (Result = -6)
	END Test.

positive: explicit positive constant long real to integer conversion

	MODULE Test;
	CONST Result = ENTIER (5.9D0)
	BEGIN ASSERT (Result = 5)
	END Test.

positive: explicit negative constant long real to integer conversion

	MODULE Test;
	CONST Result = ENTIER (-5.1D0)
	BEGIN ASSERT (Result = -6)
	END Test.


# types

positive: unmarked type

	MODULE Test;
	TYPE Type = RECORD END;
	END Test.

positive: unmarked type within procedure

	MODULE Test;
	PROCEDURE Procedure;
		TYPE Type = RECORD END;
	END Procedure;
	END Test.

positive: unmarked type within nested procedure

	MODULE Test;
	PROCEDURE Procedure;
		PROCEDURE Procedure;
			TYPE Type = RECORD END;
		END Procedure;
	END Procedure;
	END Test.

positive: unmarked type within object

	MODULE Test;
	TYPE Object = OBJECT
		TYPE Type = RECORD END;
	END Object;
	END Test.

positive: unmarked type within object in procedure

	MODULE Test;
	PROCEDURE Procedure;
		TYPE Object = OBJECT
			TYPE Type = RECORD END;
		END Object;
	END Procedure;
	END Test.

positive: unmarked type within procedure in object

	MODULE Test;
	TYPE Object = OBJECT
		PROCEDURE Procedure;
			TYPE Type = RECORD END;
		END Procedure;
	END Object;
	END Test.

positive: type marked as exported

	MODULE Test;
	TYPE Type* = RECORD END;
	END Test.

negative: type marked as exported within procedure

	MODULE Test;
	PROCEDURE Procedure;
		TYPE Type* = RECORD END;
	END Procedure;
	END Test.

negative: type marked as exported within nested procedure

	MODULE Test;
	PROCEDURE Procedure;
		PROCEDURE Procedure;
			TYPE Type* = RECORD END;
		END Procedure;
	END Procedure;
	END Test.

positive: type marked as exported within object

	MODULE Test;
	TYPE Object = OBJECT
		TYPE Type* = RECORD END;
	END Object;
	END Test.

negative: type marked as exported within object in procedure

	MODULE Test;
	PROCEDURE Procedure;
		TYPE Object = OBJECT
			TYPE Type* = RECORD END;
		END Object;
	END Procedure;
	END Test.

negative: type marked as exported within procedure in object

	MODULE Test;
	TYPE Object = OBJECT
		PROCEDURE Procedure;
			TYPE Type* = RECORD END;
		END Procedure;
	END Object;
	END Test.

negative: type marked as read-only

	MODULE Test;
	TYPE Type- = OBJECT;
	END Test.

negative: type marked as read-only within procedure

	MODULE Test;
	PROCEDURE Procedure;
		TYPE Type- = OBJECT;
	END Procedure;
	END Test.

negative: type marked as read-only within nested procedure

	MODULE Test;
	PROCEDURE Procedure;
		PROCEDURE Procedure;
			TYPE Type- = OBJECT;
		END Procedure;
	END Procedure;
	END Test.

negative: type marked as read-only within object

	MODULE Test;
	TYPE Object = OBJECT
		TYPE Type- = OBJECT;
	END Object;
	END Test.

negative: type marked as read-only within object in procedure

	MODULE Test;
	PROCEDURE Procedure;
		TYPE Object = OBJECT
			TYPE Type- = OBJECT;
		END Object;
	END Procedure;
	END Test.

negative: type marked as read-only within procedure in object

	MODULE Test;
	TYPE Object = OBJECT
		PROCEDURE Procedure;
			TYPE Type- = OBJECT;
		END Procedure;
	END Object;
	END Test.

negative: duplicated type

	MODULE Test;
	TYPE Type = RECORD END;
	TYPE Type = OBJECT END Type;
	END Test.

negative: duplicated type within procedure

	MODULE Test;
	PROCEDURE Procedure;
		TYPE Type = RECORD END;
		TYPE Type = OBJECT END Type;
	END Procedure;
	END Test.

negative: duplicated type within nested procedure

	MODULE Test;
	PROCEDURE Procedure;
		PROCEDURE Procedure;
			TYPE Type = RECORD END;
			TYPE Type = OBJECT END Type;
		END Procedure;
	END Procedure;
	END Test.

negative: duplicated type within object

	MODULE Test;
	TYPE Object = OBJECT
		TYPE Type = RECORD END;
		TYPE Type = OBJECT END Type;
	END Object;
	END Test.

negative: duplicated type within object in procedure

	MODULE Test;
	PROCEDURE Procedure;
		TYPE Object = OBJECT
			TYPE Type = RECORD END;
			TYPE Type = OBJECT END Type;
		END Object;
	END Procedure;
	END Test.

negative: duplicated type within procedure in object

	MODULE Test;
	TYPE Object = OBJECT
		PROCEDURE Procedure;
			TYPE Type = RECORD END;
			TYPE Type = OBJECT END Type;
		END Procedure;
	END Object;
	END Test.

positive: backwards referencing type

	MODULE Test;
	TYPE A = RECORD END; B = A;
	END Test.

positive: backwards referencing type within procedure

	MODULE Test;
	PROCEDURE Procedure;
		TYPE A = RECORD END; B = A;
	END Procedure;
	END Test.

positive: backwards referencing type within nested procedure

	MODULE Test;
	PROCEDURE Procedure;
		PROCEDURE Procedure;
			TYPE A = RECORD END; B = A;
		END Procedure;
	END Procedure;
	END Test.

positive: backwards referencing type within object

	MODULE Test;
	TYPE Object = OBJECT
		TYPE A = RECORD END; B = A;
	END Object;
	END Test.

positive: backwards referencing type within object in procedure

	MODULE Test;
	PROCEDURE Procedure;
		TYPE Object = OBJECT
			TYPE A = RECORD END; B = A;
		END Object;
	END Procedure;
	END Test.

positive: backwards referencing type within procedure in object

	MODULE Test;
	TYPE Object = OBJECT
		PROCEDURE Procedure;
			TYPE A = RECORD END; B = A;
		END Procedure;
	END Object;
	END Test.

positive: forwards referencing type

	MODULE Test;
	TYPE A = B; B = RECORD END;
	END Test.

positive: forwards referencing type within procedure

	MODULE Test;
	PROCEDURE Procedure;
		TYPE A = B; B = RECORD END;
	END Procedure;
	END Test.

positive: forwards referencing type within nested procedure

	MODULE Test;
	PROCEDURE Procedure;
		PROCEDURE Procedure;
			TYPE A = B; B = RECORD END;
		END Procedure;
	END Procedure;
	END Test.

positive: forwards referencing type within object

	MODULE Test;
	TYPE Object = OBJECT
		TYPE A = B; B = RECORD END;
	END Object;
	END Test.

positive: forwards referencing type within object in procedure

	MODULE Test;
	PROCEDURE Procedure;
		TYPE Object = OBJECT
			TYPE A = B; B = RECORD END;
		END Object;
	END Procedure;
	END Test.

positive: forwards referencing type within procedure in object

	MODULE Test;
	TYPE Object = OBJECT
		PROCEDURE Procedure;
			TYPE A = B; B = RECORD END;
		END Procedure;
	END Object;
	END Test.

negative: cyclic referencing types

	MODULE Test;
	TYPE A = B; B = A;
	END Test.

negative: cyclic referencing types within procedure

	MODULE Test;
	PROCEDURE Procedure;
		TYPE A = B; B = A;
	END Procedure;
	END Test.

negative: cyclic referencing types within nested procedure

	MODULE Test;
	PROCEDURE Procedure;
		PROCEDURE Procedure;
			TYPE A = B; B = A;
		END Procedure;
	END Procedure;
	END Test.

negative: cyclic referencing types within object

	MODULE Test;
	TYPE Object = OBJECT
		TYPE A = B; B = A;
	END Object;
	END Test.

negative: cyclic referencing types within object in procedure

	MODULE Test;
	PROCEDURE Procedure;
		TYPE Object = OBJECT
			TYPE A = B; B = A;
		END Object;
	END Procedure;
	END Test.

negative: cyclic referencing types within procedure in object

	MODULE Test;
	TYPE Object = OBJECT
		PROCEDURE Procedure;
			TYPE A = B; B = A;
		END Procedure;
	END Object;
	END Test.

negative: self referencing type

	MODULE Test;
	TYPE Type = Type;
	END Test.

negative: self referencing type within procedure

	MODULE Test;
	PROCEDURE Procedure;
		TYPE Type = Type;
	END Procedure;
	END Test.

negative: self referencing type within nested procedure

	MODULE Test;
	PROCEDURE Procedure;
		PROCEDURE Procedure;
			TYPE Type = Type;
		END Procedure;
	END Procedure;
	END Test.

negative: self referencing type within object

	MODULE Test;
	TYPE Object = OBJECT
		TYPE Type = Type;
	END Object;
	END Test.

negative: self referencing type within object in procedure

	MODULE Test;
	PROCEDURE Procedure;
		TYPE Object = OBJECT
			TYPE Type = Type;
		END Object;
	END Procedure;
	END Test.

negative: self referencing type within procedure in object

	MODULE Test;
	TYPE Object = OBJECT
		PROCEDURE Procedure;
			TYPE Type = Type;
		END Procedure;
	END Object;
	END Test.

positive: dummy module exporting types

	MODULE Dummy;
	TYPE Exported* = RECORD END;
	TYPE Private = RECORD END;
	END Dummy.

positive: importing exported type

	MODULE Test;
	IMPORT Dummy;
	TYPE Type = Dummy.Exported;
	END Test.

negative: importing private type

	MODULE Test;
	IMPORT Dummy;
	TYPE Type = Dummy.Private;
	END Test.

negative: importing invalid type

	MODULE Test;
	IMPORT Dummy;
	TYPE Type = Dummy.Invalid;
	END Test.

negative: import as type

	MODULE Test;
	IMPORT Import := Dummy;
	TYPE Type = Import;
	END Test.

negative: constant as type

	MODULE Test;
	CONST Constant = 0;
	TYPE Type = Constant;
	END Test.

negative: variable as type

	MODULE Test;
	TYPE Type = variable;
	VAR variable: SIGNED16;
	END Test.

negative: procedure as type

	MODULE Test;
	TYPE Type = Procedure;
	PROCEDURE Procedure; END Procedure;
	END Test.

negative: parameter as type

	MODULE Test;
	PROCEDURE Procedure (parameter: SIGNED16);
	TYPE Type = parameter;
	END Procedure;
	END Test.


# basic types

positive: predefined basic character type

	MODULE Test;
	TYPE BasicType = CHAR;
	END Test.

positive: predefined basic boolean type

	MODULE Test;
	TYPE BasicType = BOOLEAN;
	END Test.

positive: predefined basic short integer type

	MODULE Test;
	TYPE BasicType = SIGNED8;
	END Test.

positive: predefined basic integer type

	MODULE Test;
	TYPE BasicType = SIGNED16;
	END Test.

positive: predefined basic long integer type

	MODULE Test;
	TYPE BasicType = SIGNED32;
	END Test.

positive: predefined basic huge integer type

	MODULE Test;
	TYPE BasicType = SIGNED64;
	END Test.

positive: predefined basic real type

	MODULE Test;
	TYPE BasicType = FLOAT32;
	END Test.

positive: predefined basic long real type

	MODULE Test;
	TYPE BasicType = FLOAT64;
	END Test.

positive: predefined basic set type

	MODULE Test;
	TYPE BasicType = SET;
	END Test.


# arrays

positive: open array type definition

	MODULE Test;
	TYPE Array = ARRAY OF RECORD END;
	END Test.

positive: two-dimensional open array type definition

	MODULE Test;
	TYPE Array = ARRAY OF ARRAY OF RECORD END;
	END Test.

negative: fixed size array with open array element type

	MODULE Test;
	TYPE Array = ARRAY 10 OF ARRAY OF RECORD END;
	END Test.

negative: array with negative size

	MODULE Test;
	TYPE Array = ARRAY -1 OF RECORD END;
	END Test.

negative: multidimensional array with negative size

	MODULE Test;
	TYPE Array = ARRAY 5, 3, -1 OF RECORD END;
	END Test.

positive: array with size zero

	MODULE Test;
	TYPE Array = ARRAY 0 OF RECORD END;
	END Test.

positive: multidimensional array with size zero

	MODULE Test;
	TYPE Array = ARRAY 2, 7, 0 OF RECORD END;
	END Test.

positive: array with positive size

	MODULE Test;
	TYPE Array = ARRAY 5 OF RECORD END;
	END Test.

positive: multidimensional array with positive size

	MODULE Test;
	TYPE Array = ARRAY 2, 4, 6 OF RECORD END;
	END Test.

negative: array with size of type real

	MODULE Test;
	TYPE Array = ARRAY 5.4 OF RECORD END;
	END Test.

negative: array with constant base type

	MODULE Test;
	CONST Base = 5;
	TYPE Array = ARRAY 5 OF Base;
	END Test.

negative: fixed size array of open array

	MODULE Test;
	TYPE Array = ARRAY 10 OF ARRAY OF RECORD END;
	END Test.

positive: open array of fixed size array

	MODULE Test;
	TYPE Array = ARRAY OF ARRAY 10 OF RECORD END;
	END Test.

negative: self referencing array type

	MODULE Test;
	TYPE Array = ARRAY 10 OF Array;
	END Test.

negative: indirectly self referencing array type

	MODULE Test;
	TYPE A = ARRAY 10 OF B;
	TYPE B = ARRAY 10 OF A;
	END Test.

positive: self referencing array type with pointer

	MODULE Test;
	TYPE A = ARRAY 10 OF POINTER TO A;
	END Test.

positive: indirectly self referencing array type with pointer

	MODULE Test;
	TYPE A = ARRAY 10 OF B;
	TYPE B = ARRAY 10 OF POINTER TO A;
	END Test.

positive: array of basic character type

	MODULE Test;
	TYPE Array = ARRAY 10 OF CHAR;
	END Test.

positive: array of basic boolean type

	MODULE Test;
	TYPE Array = ARRAY 10 OF BOOLEAN;
	END Test.

positive: array of basic short integer type

	MODULE Test;
	TYPE Array = ARRAY 10 OF SIGNED8;
	END Test.

positive: array of basic integer type

	MODULE Test;
	TYPE Array = ARRAY 10 OF SIGNED16;
	END Test.

positive: array of basic long integer type

	MODULE Test;
	TYPE Array = ARRAY 10 OF SIGNED32;
	END Test.

positive: array of basic huge integer type

	MODULE Test;
	TYPE Array = ARRAY 10 OF SIGNED64;
	END Test.

positive: array of basic real type

	MODULE Test;
	TYPE Array = ARRAY 10 OF FLOAT32;
	END Test.

positive: array of basic long real type

	MODULE Test;
	TYPE Array = ARRAY 10 OF FLOAT64;
	END Test.

positive: array of basic set type

	MODULE Test;
	TYPE Array = ARRAY 10 OF SET;
	END Test.

negative: array of basic nil pointer type

	MODULE Test;
	TYPE Array = ARRAY 10 OF NIL;
	END Test.

positive: array of records

	MODULE Test;
	TYPE Array = ARRAY 10 OF RECORD END;
	END Test.

positive: array of objects

	MODULE Test;
	TYPE Array = ARRAY 10 OF OBJECT;
	END Test.

positive: array of pointers

	MODULE Test;
	TYPE Array = ARRAY 10 OF POINTER TO RECORD END;
	END Test.

positive: array of procedures

	MODULE Test;
	TYPE Array = ARRAY 10 OF PROCEDURE;
	END Test.


# records

negative: record extending itself

	MODULE Test;
	TYPE Record = RECORD (Record) END;
	END Test.

negative: record extending itself indirectly

	MODULE Test;
	TYPE A = RECORD (B) END; B = RECORD (A) END;
	END Test.

negative: record extending a constant

	MODULE Test;
	CONST Constant = 5;
	TYPE Record = RECORD (Constant) END;
	END Test.

negative: record extending a variable

	MODULE Test;
	TYPE Record = RECORD (variable) END;
	VAR variable: Record;
	END Test.

negative: record extending a basic type

	MODULE Test;
	TYPE Record = RECORD (SIGNED32) END;
	END Test.

negative: record extending an array

	MODULE Test;
	TYPE Array = ARRAY 10 OF OBJECT; Record = RECORD (Array) END;
	END Test.

positive: record extending a record

	MODULE Test;
	TYPE A = RECORD END; B = RECORD (A) END;
	END Test.

positive: record extending a record from outer scope

	MODULE Test;
	TYPE Outer = RECORD END;
	PROCEDURE Procedure;
		TYPE Inner = RECORD (Outer) END;
	END Procedure;
	END Test.

negative: record extending a record from inner scope

	MODULE Test;
	TYPE Outer = RECORD (Inner) END;
	PROCEDURE Procedure;
		TYPE Inner = RECORD END;
	END Procedure;
	END Test.

negative: record extending an object

	MODULE Test;
	TYPE Object = OBJECT; Record = RECORD (Object) END;
	END Test.

negative: record extending a pointer

	MODULE Test;
	TYPE Pointer = POINTER TO RECORD END; Record = RECORD (Pointer) END;
	END Test.

negative: record extending a procedure

	MODULE Test;
	TYPE Procedure = PROCEDURE; Record = RECORD (Procedure) END;
	END Test.

negative: record containing itself

	MODULE Test;
	TYPE Record = RECORD r: Record END;
	END Test.

positive: record containing pointer to itself

	MODULE Test;
	TYPE Record = RECORD r: POINTER TO Record END;
	END Test.

negative: record containing itself indirectly

	MODULE Test;
	TYPE A = RECORD b: B END;
	TYPE B = RECORD a: A END;
	END Test.

positive: record containing pointer to itself indirectly

	MODULE Test;
	TYPE A = RECORD b: POINTER TO B END;
	TYPE B = RECORD a: A END;
	END Test.

positive: record containing pointer in declaration to itself indirectly

	MODULE Test;
	TYPE A = RECORD b: B END;
	TYPE B = POINTER TO RECORD a: A END;
	END Test.

positive: record containing backward referenced type

	MODULE Test;
	TYPE A = RECORD END;
	TYPE B = RECORD a: A END;
	END Test.

positive: record containing forward referenced type

	MODULE Test;
	TYPE A = RECORD b: B END;
	TYPE B = OBJECT;
	END Test.

positive: record containing anonymous records

	MODULE Test;
	TYPE Record = RECORD r: RECORD r: RECORD r: RECORD END END END END;
	END Test.

positive: deeply nested records

	MODULE Test;
	TYPE A = RECORD b: B END;
	TYPE F = RECORD END;
	TYPE B = RECORD c: C END;
	TYPE E = RECORD f: F END;
	TYPE D = RECORD e: E END;
	TYPE C = RECORD d: D END;
	END Test.

negative: record containing itself deeply indirectly

	MODULE Test;
	TYPE A = RECORD b: B END;
	TYPE F = RECORD a: A END;
	TYPE B = RECORD c: C END;
	TYPE E = RECORD f: F END;
	TYPE D = RECORD e: E END;
	TYPE C = RECORD d: D END;
	END Test.

negative: nested record containing itself indirectly

	MODULE Test;
	TYPE A = RECORD b: B END;
	TYPE B = RECORD c: C END;
	TYPE C = RECORD d: D END;
	TYPE D = RECORD b: B END;
	END Test.

positive: record containing pointer to record

	MODULE Test;
	TYPE Record = RECORD p: POINTER TO RECORD END END;
	END Test.

positive: record containing pointer to record containing the first record

	MODULE Test;
	TYPE Record = RECORD p: POINTER TO RECORD r: Record END END;
	END Test.

positive: record containing record containing pointer to record containing the first record

	MODULE Test;
	TYPE A = RECORD b: B END;
	TYPE B = RECORD p: POINTER TO RECORD a: A END END;
	END Test.

positive: pointer to record containing record containing record containing the pointer

	MODULE Test;
	TYPE A = POINTER TO RECORD b: B END;
	TYPE B = RECORD r: RECORD a: A END END;
	END Test.

positive: record containing basic types

	MODULE Test;
	TYPE Record = RECORD i: SIGNED16; s: SET; b: BOOLEAN END;
	END Test.

positive: record containing an array

	MODULE Test;
	TYPE Record = RECORD a: ARRAY 10 OF OBJECT; END;
	END Test.

negative: record containing an open array

	MODULE Test;
	TYPE Record = RECORD a: ARRAY OF RECORD END END;
	END Test.

positive: record containing an object

	MODULE Test;
	TYPE Record = RECORD o: OBJECT; END;
	END Test.

positive: record containing a procedure

	MODULE Test;
	TYPE Record = RECORD p: PROCEDURE END;
	END Test.

negative: record with variable with same name as its type

	MODULE Test;
	TYPE Type = RECORD END;
	TYPE Record = RECORD Type: Type END;
	END Test.


# objects

negative: object extending itself

	MODULE Test;
	TYPE Object = OBJECT (Object) END Object;
	END Test.

negative: object extending itself indirectly

	MODULE Test;
	TYPE A = OBJECT (B) END A; B = OBJECT (A) END B;
	END Test.

negative: object extending a constant

	MODULE Test;
	CONST Constant = 5;
	TYPE Object = OBJECT (Constant) END Object;
	END Test.

negative: object extending a variable

	MODULE Test;
	TYPE Object = OBJECT (variable) END Object;
	VAR variable: Object;
	END Test.

negative: object extending a basic type

	MODULE Test;
	TYPE Object = OBJECT (SIGNED32) END Object;
	END Test.

negative: object extending an array

	MODULE Test;
	TYPE Array = ARRAY 10 OF OBJECT; Object = OBJECT (Array) END Object;
	END Test.

negative: object extending a record

	MODULE Test;
	TYPE Record = RECORD END; Object = OBJECT (Record) END Object;
	END Test.

positive: object extending an object

	MODULE Test;
	TYPE A = OBJECT; B = OBJECT (A) END B;
	END Test.

negative: object extending the base object

	MODULE Test;
	TYPE Object = OBJECT (OBJECT) END Object;
	END Test.

positive: object extending a pointer to record

	MODULE Test;
	TYPE Pointer = POINTER TO RECORD END; Object = OBJECT (Pointer) END Object;
	END Test.

negative: object extending a procedure

	MODULE Test;
	TYPE Procedure = PROCEDURE; Object = OBJECT (Procedure) END Object;
	END Test.

positive: object containing itself

	MODULE Test;
	TYPE Object = OBJECT VAR o: Object END Object;
	END Test.

positive: object containing itself indirectly

	MODULE Test;
	TYPE A = OBJECT VAR b: B END A;
	TYPE B = OBJECT VAR a: A END B;
	END Test.

positive: object containing backward referenced type

	MODULE Test;
	TYPE A = OBJECT;
	TYPE B = OBJECT VAR a: A END B;
	END Test.

positive: object containing forward referenced type

	MODULE Test;
	TYPE A = OBJECT VAR b: B END A;
	TYPE B = OBJECT;
	END Test.

positive: object containing anonymous records

	MODULE Test;
	TYPE Object = OBJECT VAR r: RECORD r: RECORD r: RECORD END END END END Object;
	END Test.

positive: deeply nested objects

	MODULE Test;
	TYPE A = OBJECT VAR b: B END A;
	TYPE F = OBJECT;
	TYPE B = OBJECT VAR c: C END B;
	TYPE E = OBJECT VAR f: F END E;
	TYPE D = OBJECT VAR e: E END D;
	TYPE C = OBJECT VAR d: D END C;
	END Test.

positive: object containing itself deeply indirectly

	MODULE Test;
	TYPE A = OBJECT VAR b: B END A;
	TYPE F = OBJECT VAR a: A END F;
	TYPE B = OBJECT VAR c: C END B;
	TYPE E = OBJECT VAR f: F END E;
	TYPE D = OBJECT VAR e: E END D;
	TYPE C = OBJECT VAR d: D END C;
	END Test.

positive: nested object containing itself indirectly

	MODULE Test;
	TYPE A = OBJECT VAR b: B END A;
	TYPE B = OBJECT VAR c: C END B;
	TYPE C = OBJECT VAR d: D END C;
	TYPE D = OBJECT VAR b: B END D;
	END Test.

positive: object containing basic types

	MODULE Test;
	TYPE Object = OBJECT VAR i: SIGNED16; s: SET; b: BOOLEAN END Object;
	END Test.

positive: object containing an array

	MODULE Test;
	TYPE Object = OBJECT VAR a: ARRAY 10 OF OBJECT; END Object;
	END Test.

negative: object containing an open array

	MODULE Test;
	TYPE Object = OBJECT VAR a: ARRAY OF OBJECT; END Object;
	END Test.

positive: object containing an object

	MODULE Test;
	TYPE Object = OBJECT VAR o: OBJECT; END Object;
	END Test.

positive: object containing a procedure

	MODULE Test;
	TYPE Object = OBJECT VAR p: PROCEDURE END Object;
	END Test.

positive: object referenced in procedure variable

	MODULE Test;
	TYPE Object = OBJECT PROCEDURE Object; END Object; END Object;
	VAR procedure : PROCEDURE (object: Object);
	END Test.

positive: local object accessing local constant

	MODULE Test;
	PROCEDURE P;
	CONST Constant = TRUE;
	VAR o: OBJECT VAR v: BOOLEAN BEGIN v := Constant END;
	END P;
	END Test.

positive: local object accessing local type

	MODULE Test;
	PROCEDURE P;
	TYPE Type = BOOLEAN;
	VAR o: OBJECT VAR v: Type END;
	END P;
	END Test.

negative: local object accessing local variable

	MODULE Test;
	PROCEDURE P;
	VAR o: OBJECT BEGIN v := TRUE END; v: BOOLEAN;
	END P;
	END Test.

negative: local object accessing local procedure

	MODULE Test;
	PROCEDURE P;
	VAR o: OBJECT BEGIN Procedure END;
	PROCEDURE Procedure; END Procedure;
	END P;
	END Test.

negative: local object accessing local parameter

	MODULE Test;
	PROCEDURE P (p: BOOLEAN);
	VAR o: OBJECT BEGIN p := TRUE END;
	END P;
	END Test.

positive: local object accessing global constant

	MODULE Test;
	CONST Constant = TRUE;
	PROCEDURE P;
	VAR o: OBJECT VAR v: BOOLEAN BEGIN v := Constant END;
	END P;
	END Test.

positive: local object accessing global type

	MODULE Test;
	TYPE Type = BOOLEAN;
	PROCEDURE P;
	VAR o: OBJECT VAR v: Type END;
	END P;
	END Test.

positive: local object accessing global variable

	MODULE Test;
	VAR v: BOOLEAN;
	PROCEDURE P;
	VAR o: OBJECT BEGIN v := TRUE END;
	END P;
	END Test.

positive: local object accessing global procedure

	MODULE Test;
	PROCEDURE P;
	VAR o: OBJECT BEGIN Procedure END;
	END P;
	PROCEDURE Procedure; END Procedure;
	END Test.


# pointers

negative: pointer to basic character type

	MODULE Test;
	TYPE Pointer = POINTER TO CHAR;
	END Test.

negative: pointer to basic boolean type

	MODULE Test;
	TYPE Pointer = POINTER TO BOOLEAN;
	END Test.

negative: pointer to basic short integer type

	MODULE Test;
	TYPE Pointer = POINTER TO SIGNED8;
	END Test.

negative: pointer to basic integer type

	MODULE Test;
	TYPE Pointer = POINTER TO SIGNED16;
	END Test.

negative: pointer to basic long integer type

	MODULE Test;
	TYPE Pointer = POINTER TO SIGNED32;
	END Test.

negative: pointer to basic huge integer type

	MODULE Test;
	TYPE Pointer = POINTER TO SIGNED64;
	END Test.

negative: pointer to basic real type

	MODULE Test;
	TYPE Pointer = POINTER TO FLOAT32;
	END Test.

negative: pointer to basic long real type

	MODULE Test;
	TYPE Pointer = POINTER TO FLOAT64;
	END Test.

negative: pointer to basic set type

	MODULE Test;
	TYPE Pointer = POINTER TO SET;
	END Test.

positive: pointer to record

	MODULE Test;
	TYPE Pointer = POINTER TO RECORD END;
	END Test.

positive: pointer to record from outer scope

	MODULE Test;
	TYPE Record = RECORD END;
	PROCEDURE Procedure;
		TYPE Pointer = POINTER TO Record;
	END Procedure;
	END Test.

positive: pointer to record from with variable of nested type

	MODULE Test;
	PROCEDURE Procedure;
		TYPE Pointer = POINTER TO RECORD pointer: Pointer END;
	END Procedure;
	END Test.

negative: pointer to record inside object

	MODULE Test;
	TYPE Pointer = POINTER TO Record;
	TYPE Object = OBJECT
		TYPE Record = RECORD END;
	END Object;
	END Test.

negative: pointer to record inside procedure

	MODULE Test;
	TYPE Pointer = POINTER TO Record;
	PROCEDURE Procedure;
		TYPE Record = RECORD END;
	END Procedure;
	END Test.

positive: pointer to array

	MODULE Test;
	TYPE Pointer = POINTER TO ARRAY 10 OF RECORD END;
	END Test.

positive: pointer to open array

	MODULE Test;
	TYPE Pointer = POINTER TO ARRAY OF RECORD END;
	END Test.

positive: pointer to array of same pointer

	MODULE Test;
	TYPE Pointer = POINTER TO ARRAY 10 OF Pointer;
	END Test.

positive: pointers to array of same pointer

	MODULE Test;
	TYPE A = POINTER TO ARRAY 10 OF B;
	TYPE B = POINTER TO ARRAY 10 OF C;
	TYPE C = POINTER TO ARRAY 10 OF D;
	TYPE D = POINTER TO ARRAY 10 OF A;
	END Test.

positive: pointer to open array of same pointer

	MODULE Test;
	TYPE Pointer = POINTER TO ARRAY OF Pointer;
	END Test.

positive: pointers to open array of same pointer

	MODULE Test;
	TYPE A = POINTER TO ARRAY OF B;
	TYPE B = POINTER TO ARRAY OF C;
	TYPE C = POINTER TO ARRAY OF D;
	TYPE D = POINTER TO ARRAY OF A;
	END Test.

negative: pointer to pointer

	MODULE Test;
	TYPE Pointer = POINTER TO POINTER TO RECORD END;
	END Test.

negative: pointer to object

	MODULE Test;
	TYPE Pointer = POINTER TO OBJECT;
	END Test.

negative: pointer to procedure

	MODULE Test;
	TYPE Pointer = POINTER TO PROCEDURE;
	END Test.


# procedure types

positive: plain procedure type

	MODULE Test;
	TYPE Procedure = PROCEDURE;
	END Test.

positive: procedure type returning basic character type

	MODULE Test;
	TYPE Procedure = PROCEDURE (): CHAR;
	END Test.

positive: procedure type returning basic boolean type

	MODULE Test;
	TYPE Procedure = PROCEDURE (): BOOLEAN;
	END Test.

positive: procedure type returning basic short integer type

	MODULE Test;
	TYPE Procedure = PROCEDURE (): SIGNED8;
	END Test.

positive: procedure type returning basic integer type

	MODULE Test;
	TYPE Procedure = PROCEDURE (): SIGNED16;
	END Test.

positive: procedure type returning basic long integer type

	MODULE Test;
	TYPE Procedure = PROCEDURE (): SIGNED32;
	END Test.

positive: procedure type returning basic huge integer type

	MODULE Test;
	TYPE Procedure = PROCEDURE (): SIGNED64;
	END Test.

positive: procedure type returning basic real type

	MODULE Test;
	TYPE Procedure = PROCEDURE (): FLOAT32;
	END Test.

positive: procedure type returning basic long real type

	MODULE Test;
	TYPE Procedure = PROCEDURE (): FLOAT64;
	END Test.

positive: procedure type returning basic set type

	MODULE Test;
	TYPE Procedure = PROCEDURE (): SET;
	END Test.

positive: procedure type returning record type

	MODULE Test;
	TYPE Record = RECORD END;
	TYPE Procedure = PROCEDURE (): Record;
	END Test.

positive: procedure type returning anonymous record type

	MODULE Test;
	TYPE Procedure = PROCEDURE (): RECORD END;
	END Test.

positive: procedure type returning array type

	MODULE Test;
	TYPE Array = ARRAY 10 OF RECORD END;
	TYPE Procedure = PROCEDURE (): Array;
	END Test.

positive: procedure type returning anonymous array type

	MODULE Test;
	TYPE Procedure = PROCEDURE (): ARRAY 10 OF RECORD END;
	END Test.

negative: procedure type returning open array type

	MODULE Test;
	TYPE Array = ARRAY OF RECORD END;
	TYPE Procedure = PROCEDURE (): Array;
	END Test.

negative: procedure type returning anonymous open array type

	MODULE Test;
	TYPE Procedure = PROCEDURE (): ARRAY OF RECORD END;
	END Test.

positive: procedure type returning object type

	MODULE Test;
	TYPE Object = OBJECT;
	TYPE Procedure = PROCEDURE (): Object;
	END Test.

positive: procedure type returning anonymous object type

	MODULE Test;
	TYPE Procedure = PROCEDURE (): OBJECT;
	END Test.

positive: procedure type returning pointer type

	MODULE Test;
	TYPE Pointer = POINTER TO RECORD END;
	TYPE Procedure = PROCEDURE (): Pointer;
	END Test.

positive: procedure type returning anonymous pointer type

	MODULE Test;
	TYPE Procedure = PROCEDURE (): POINTER TO RECORD END;
	END Test.

positive: procedure type returning procedure type

	MODULE Test;
	TYPE Proc = PROCEDURE;
	TYPE Procedure = PROCEDURE (): Proc;
	END Test.

positive: procedure type returning anonymous procedure type

	MODULE Test;
	TYPE Procedure = PROCEDURE (): PROCEDURE;
	END Test.

positive: procedure type returning anonymous procedure returning anonymous procedure

	MODULE Test;
	TYPE Procedure = PROCEDURE (): PROCEDURE (): PROCEDURE;
	END Test.

positive: procedure type returning itself

	MODULE Test;
	TYPE Procedure = PROCEDURE (): Procedure;
	END Test.

positive: procedure types returning themselves

	MODULE Test;
	TYPE A = PROCEDURE (): B;
	TYPE B = PROCEDURE (): C;
	TYPE C = PROCEDURE (): D;
	TYPE D = PROCEDURE (): A;
	END Test.

positive: procedure type with parameter of same type

	MODULE Test;
	TYPE Procedure = PROCEDURE (procedure: Procedure);
	END Test.

positive: procedure types with parameters of same type

	MODULE Test;
	TYPE A = PROCEDURE (b: B);
	TYPE B = PROCEDURE (c: C);
	TYPE C = PROCEDURE (d: D);
	TYPE D = PROCEDURE (a: A);
	END Test.

negative: procedure type with multiple variable parameter

	MODULE Test;
	TYPE Procedure = PROCEDURE (VAR VAR parameter: SET);
	END Test.

negative: procedure type with multiple constant parameter

	MODULE Test;
	TYPE Procedure = PROCEDURE (CONST CONST parameter: SET);
	END Test.

negative: procedure type with variable and constant parameter

	MODULE Test;
	TYPE Procedure = PROCEDURE (VAR CONST parameter: SET);
	END Test.

negative: procedure type with constant and variable parameter

	MODULE Test;
	TYPE Procedure = PROCEDURE (VAR CONST parameter: SET);
	END Test.

negative: procedure type with parameter marked as exported

	MODULE Test;
	TYPE Procedure = PROCEDURE (parameter*: CHAR);
	END Test.

negative: procedure type with parameter marked as read-only

	MODULE Test;
	TYPE Procedure = PROCEDURE (parameter-: CHAR);
	END Test.

positive: procedure type with a parameter of basic character type

	MODULE Test;
	TYPE Procedure = PROCEDURE (parameter: CHAR);
	END Test.

positive: procedure type with parameters of basic character type

	MODULE Test;
	TYPE Procedure = PROCEDURE (a, b, c: CHAR);
	END Test.

positive: procedure type with a parameter of variable character type

	MODULE Test;
	TYPE Procedure = PROCEDURE (VAR parameter: CHAR);
	END Test.

positive: procedure type with parameters of variable character type

	MODULE Test;
	TYPE Procedure = PROCEDURE (VAR a, b, c: CHAR);
	END Test.

positive: procedure type with a parameter of constant character type

	MODULE Test;
	TYPE Procedure = PROCEDURE (CONST parameter: CHAR);
	END Test.

positive: procedure type with parameters of constant character type

	MODULE Test;
	TYPE Procedure = PROCEDURE (CONST a, b, c: CHAR);
	END Test.

positive: procedure type with intermixed parameters of character type

	MODULE Test;
	TYPE Procedure = PROCEDURE (a: CHAR; VAR b: CHAR; CONST c: CHAR);
	END Test.

positive: procedure type with a parameter of basic boolean type

	MODULE Test;
	TYPE Procedure = PROCEDURE (parameter: BOOLEAN);
	END Test.

positive: procedure type with parameters of basic boolean type

	MODULE Test;
	TYPE Procedure = PROCEDURE (a, b, c: BOOLEAN);
	END Test.

positive: procedure type with a parameter of variable boolean type

	MODULE Test;
	TYPE Procedure = PROCEDURE (VAR parameter: BOOLEAN);
	END Test.

positive: procedure type with parameters of variable boolean type

	MODULE Test;
	TYPE Procedure = PROCEDURE (VAR a, b, c: BOOLEAN);
	END Test.

positive: procedure type with a parameter of constant boolean type

	MODULE Test;
	TYPE Procedure = PROCEDURE (CONST parameter: BOOLEAN);
	END Test.

positive: procedure type with parameters of constant boolean type

	MODULE Test;
	TYPE Procedure = PROCEDURE (CONST a, b, c: BOOLEAN);
	END Test.

positive: procedure type with intermixed parameters of boolean type

	MODULE Test;
	TYPE Procedure = PROCEDURE (a: BOOLEAN; VAR b: BOOLEAN; CONST c: BOOLEAN);
	END Test.

positive: procedure type with a parameter of basic short integer type

	MODULE Test;
	TYPE Procedure = PROCEDURE (parameter: SIGNED8);
	END Test.

positive: procedure type with parameters of basic short integer type

	MODULE Test;
	TYPE Procedure = PROCEDURE (a, b, c: SIGNED8);
	END Test.

positive: procedure type with a parameter of variable short integer type

	MODULE Test;
	TYPE Procedure = PROCEDURE (VAR parameter: SIGNED8);
	END Test.

positive: procedure type with parameters of variable short integer type

	MODULE Test;
	TYPE Procedure = PROCEDURE (VAR a, b, c: SIGNED8);
	END Test.

positive: procedure type with a parameter of constant short integer type

	MODULE Test;
	TYPE Procedure = PROCEDURE (CONST parameter: SIGNED8);
	END Test.

positive: procedure type with parameters of constant short integer type

	MODULE Test;
	TYPE Procedure = PROCEDURE (CONST a, b, c: SIGNED8);
	END Test.

positive: procedure type with intermixed parameters of short integer type

	MODULE Test;
	TYPE Procedure = PROCEDURE (a: SIGNED8; VAR b: SIGNED8; CONST c: SIGNED8);
	END Test.

positive: procedure type with a parameter of basic integer type

	MODULE Test;
	TYPE Procedure = PROCEDURE (parameter: SIGNED16);
	END Test.

positive: procedure type with parameters of basic integer type

	MODULE Test;
	TYPE Procedure = PROCEDURE (a, b, c: SIGNED16);
	END Test.

positive: procedure type with a parameter of variable integer type

	MODULE Test;
	TYPE Procedure = PROCEDURE (VAR parameter: SIGNED16);
	END Test.

positive: procedure type with parameters of variable integer type

	MODULE Test;
	TYPE Procedure = PROCEDURE (VAR a, b, c: SIGNED16);
	END Test.

positive: procedure type with a parameter of constant integer type

	MODULE Test;
	TYPE Procedure = PROCEDURE (CONST parameter: SIGNED16);
	END Test.

positive: procedure type with parameters of constant integer type

	MODULE Test;
	TYPE Procedure = PROCEDURE (CONST a, b, c: SIGNED16);
	END Test.

positive: procedure type with intermixed parameters of integer type

	MODULE Test;
	TYPE Procedure = PROCEDURE (a: SIGNED16; VAR b: SIGNED16; CONST c: SIGNED16);
	END Test.

positive: procedure type with a parameter of basic long integer type

	MODULE Test;
	TYPE Procedure = PROCEDURE (parameter: SIGNED32);
	END Test.

positive: procedure type with parameters of basic long integer type

	MODULE Test;
	TYPE Procedure = PROCEDURE (a, b, c: SIGNED32);
	END Test.

positive: procedure type with a parameter of variable long integer type

	MODULE Test;
	TYPE Procedure = PROCEDURE (VAR parameter: SIGNED32);
	END Test.

positive: procedure type with parameters of variable long integer type

	MODULE Test;
	TYPE Procedure = PROCEDURE (VAR a, b, c: SIGNED32);
	END Test.

positive: procedure type with a parameter of constant long integer type

	MODULE Test;
	TYPE Procedure = PROCEDURE (CONST parameter: SIGNED32);
	END Test.

positive: procedure type with parameters of constant long integer type

	MODULE Test;
	TYPE Procedure = PROCEDURE (CONST a, b, c: SIGNED32);
	END Test.

positive: procedure type with intermixed parameters of long integer type

	MODULE Test;
	TYPE Procedure = PROCEDURE (a: SIGNED32; VAR b: SIGNED32; CONST c: SIGNED32);
	END Test.

positive: procedure type with a parameter of basic huge integer type

	MODULE Test;
	TYPE Procedure = PROCEDURE (parameter: SIGNED64);
	END Test.

positive: procedure type with parameters of basic huge integer type

	MODULE Test;
	TYPE Procedure = PROCEDURE (a, b, c: SIGNED64);
	END Test.

positive: procedure type with a parameter of variable huge integer type

	MODULE Test;
	TYPE Procedure = PROCEDURE (VAR parameter: SIGNED64);
	END Test.

positive: procedure type with parameters of variable huge integer type

	MODULE Test;
	TYPE Procedure = PROCEDURE (VAR a, b, c: SIGNED64);
	END Test.

positive: procedure type with a parameter of constant huge integer type

	MODULE Test;
	TYPE Procedure = PROCEDURE (CONST parameter: SIGNED64);
	END Test.

positive: procedure type with parameters of constant huge integer type

	MODULE Test;
	TYPE Procedure = PROCEDURE (CONST a, b, c: SIGNED64);
	END Test.

positive: procedure type with intermixed parameters of huge integer type

	MODULE Test;
	TYPE Procedure = PROCEDURE (a: SIGNED64; VAR b: SIGNED64; CONST c: SIGNED64);
	END Test.

positive: procedure type with a parameter of basic real type

	MODULE Test;
	TYPE Procedure = PROCEDURE (parameter: FLOAT32);
	END Test.

positive: procedure type with parameters of basic real type

	MODULE Test;
	TYPE Procedure = PROCEDURE (a, b, c: FLOAT32);
	END Test.

positive: procedure type with a parameter of variable real type

	MODULE Test;
	TYPE Procedure = PROCEDURE (VAR parameter: FLOAT32);
	END Test.

positive: procedure type with parameters of variable real type

	MODULE Test;
	TYPE Procedure = PROCEDURE (VAR a, b, c: FLOAT32);
	END Test.

positive: procedure type with a parameter of constant real type

	MODULE Test;
	TYPE Procedure = PROCEDURE (CONST parameter: FLOAT32);
	END Test.

positive: procedure type with parameters of constant real type

	MODULE Test;
	TYPE Procedure = PROCEDURE (CONST a, b, c: FLOAT32);
	END Test.

positive: procedure type with intermixed parameters of real type

	MODULE Test;
	TYPE Procedure = PROCEDURE (a: FLOAT32; VAR b: FLOAT32; CONST c: FLOAT32);
	END Test.

positive: procedure type with a parameter of basic long real type

	MODULE Test;
	TYPE Procedure = PROCEDURE (parameter: FLOAT64);
	END Test.

positive: procedure type with parameters of basic long real type

	MODULE Test;
	TYPE Procedure = PROCEDURE (a, b, c: FLOAT64);
	END Test.

positive: procedure type with a parameter of variable long real type

	MODULE Test;
	TYPE Procedure = PROCEDURE (VAR parameter: FLOAT64);
	END Test.

positive: procedure type with parameters of variable long real type

	MODULE Test;
	TYPE Procedure = PROCEDURE (VAR a, b, c: FLOAT64);
	END Test.

positive: procedure type with a parameter of constant long real type

	MODULE Test;
	TYPE Procedure = PROCEDURE (CONST parameter: FLOAT64);
	END Test.

positive: procedure type with parameters of constant long real type

	MODULE Test;
	TYPE Procedure = PROCEDURE (CONST a, b, c: FLOAT64);
	END Test.

positive: procedure type with intermixed parameters of long real type

	MODULE Test;
	TYPE Procedure = PROCEDURE (a: FLOAT64; VAR b: FLOAT64; CONST c: FLOAT64);
	END Test.

positive: procedure type with a parameter of basic set type

	MODULE Test;
	TYPE Procedure = PROCEDURE (parameter: SET);
	END Test.

positive: procedure type with parameters of basic set type

	MODULE Test;
	TYPE Procedure = PROCEDURE (a, b, c: SET);
	END Test.

positive: procedure type with a parameter of variable set type

	MODULE Test;
	TYPE Procedure = PROCEDURE (VAR parameter: SET);
	END Test.

positive: procedure type with parameters of variable set type

	MODULE Test;
	TYPE Procedure = PROCEDURE (VAR a, b, c: SET);
	END Test.

positive: procedure type with a parameter of constant set type

	MODULE Test;
	TYPE Procedure = PROCEDURE (CONST parameter: SET);
	END Test.

positive: procedure type with parameters of constant set type

	MODULE Test;
	TYPE Procedure = PROCEDURE (CONST a, b, c: SET);
	END Test.

positive: procedure type with intermixed parameters of set type

	MODULE Test;
	TYPE Procedure = PROCEDURE (a: SET; VAR b: SET; CONST c: SET);
	END Test.

positive: procedure type with a parameter of record type

	MODULE Test;
	TYPE Record = RECORD END;
	TYPE Procedure = PROCEDURE (parameter: Record);
	END Test.

positive: procedure type with parameters of record type

	MODULE Test;
	TYPE Record = RECORD END;
	TYPE Procedure = PROCEDURE (a, b, c: Record);
	END Test.

positive: procedure type with a parameter of variable record type

	MODULE Test;
	TYPE Record = RECORD END;
	TYPE Procedure = PROCEDURE (VAR parameter: Record);
	END Test.

positive: procedure type with parameters of variable record type

	MODULE Test;
	TYPE Record = RECORD END;
	TYPE Procedure = PROCEDURE (VAR a, b, c: Record);
	END Test.

positive: procedure type with a parameter of constant record type

	MODULE Test;
	TYPE Record = RECORD END;
	TYPE Procedure = PROCEDURE (CONST parameter: Record);
	END Test.

positive: procedure type with parameters of constant record type

	MODULE Test;
	TYPE Record = RECORD END;
	TYPE Procedure = PROCEDURE (CONST a, b, c: Record);
	END Test.

positive: procedure type with intermixed parameters of record type

	MODULE Test;
	TYPE Record = RECORD END;
	TYPE Procedure = PROCEDURE (a: Record; VAR b: Record; CONST c: Record);
	END Test.

positive: procedure type with a parameter of anonymous record type

	MODULE Test;
	TYPE Record = RECORD END;
	TYPE Procedure = PROCEDURE (parameter: RECORD END);
	END Test.

positive: procedure type with parameters of anonymous record type

	MODULE Test;
	TYPE Procedure = PROCEDURE (a, b, c: RECORD END);
	END Test.

positive: procedure type with a parameter of variable anonymous record type

	MODULE Test;
	TYPE Procedure = PROCEDURE (VAR parameter: RECORD END);
	END Test.

positive: procedure type with parameters of variable anonymous record type

	MODULE Test;
	TYPE Procedure = PROCEDURE (VAR a, b, c: RECORD END);
	END Test.

positive: procedure type with a parameter of constant anonymous record type

	MODULE Test;
	TYPE Procedure = PROCEDURE (CONST parameter: RECORD END);
	END Test.

positive: procedure type with parameters of constant anonymous record type

	MODULE Test;
	TYPE Procedure = PROCEDURE (CONST a, b, c: RECORD END);
	END Test.

positive: procedure type with intermixed parameters of anonymous record type

	MODULE Test;
	TYPE Procedure = PROCEDURE (a: RECORD END; VAR b: RECORD END; CONST c: RECORD END);
	END Test.

positive: procedure type with a parameter of array type

	MODULE Test;
	TYPE Array = ARRAY 10 OF RECORD END;
	TYPE Procedure = PROCEDURE (parameter: Array);
	END Test.

positive: procedure type with parameters of array type

	MODULE Test;
	TYPE Array = ARRAY 10 OF RECORD END;
	TYPE Procedure = PROCEDURE (a, b, c: Array);
	END Test.

positive: procedure type with a parameter of variable array type

	MODULE Test;
	TYPE Array = ARRAY 10 OF RECORD END;
	TYPE Procedure = PROCEDURE (VAR parameter: Array);
	END Test.

positive: procedure type with parameters of variable array type

	MODULE Test;
	TYPE Array = ARRAY 10 OF RECORD END;
	TYPE Procedure = PROCEDURE (VAR a, b, c: Array);
	END Test.

positive: procedure type with a parameter of constant array type

	MODULE Test;
	TYPE Array = ARRAY 10 OF RECORD END;
	TYPE Procedure = PROCEDURE (CONST parameter: Array);
	END Test.

positive: procedure type with parameters of constant array type

	MODULE Test;
	TYPE Array = ARRAY 10 OF RECORD END;
	TYPE Procedure = PROCEDURE (CONST a, b, c: Array);
	END Test.

positive: procedure type with intermixed parameters of array type

	MODULE Test;
	TYPE Array = ARRAY 10 OF RECORD END;
	TYPE Procedure = PROCEDURE (a: Array; VAR b: Array; CONST c: Array);
	END Test.

positive: procedure type with a parameter of anonymous array type

	MODULE Test;
	TYPE Procedure = PROCEDURE (parameter: ARRAY 10 OF RECORD END);
	END Test.

positive: procedure type with parameters of anonymous array type

	MODULE Test;
	TYPE Procedure = PROCEDURE (a, b, c: ARRAY 10 OF RECORD END);
	END Test.

positive: procedure type with a parameter of variable anonymous array type

	MODULE Test;
	TYPE Procedure = PROCEDURE (VAR parameter: ARRAY 10 OF RECORD END);
	END Test.

positive: procedure type with parameters of variable anonymous array type

	MODULE Test;
	TYPE Procedure = PROCEDURE (VAR a, b, c: ARRAY 10 OF RECORD END);
	END Test.

positive: procedure type with a parameter of constant anonymous array type

	MODULE Test;
	TYPE Procedure = PROCEDURE (CONST parameter: ARRAY 10 OF RECORD END);
	END Test.

positive: procedure type with parameters of constant anonymous array type

	MODULE Test;
	TYPE Procedure = PROCEDURE (CONST a, b, c: ARRAY 10 OF RECORD END);
	END Test.

positive: procedure type with intermixed parameters of anonymous array type

	MODULE Test;
	TYPE Procedure = PROCEDURE (a: ARRAY 10 OF RECORD END; VAR b: ARRAY 10 OF RECORD END; CONST c: ARRAY 10 OF RECORD END);
	END Test.

positive: procedure type with a parameter of open array type

	MODULE Test;
	TYPE Array = ARRAY OF RECORD END;
	TYPE Procedure = PROCEDURE (parameter: Array);
	END Test.

positive: procedure type with parameters of open array type

	MODULE Test;
	TYPE Array = ARRAY OF RECORD END;
	TYPE Procedure = PROCEDURE (a, b, c: Array);
	END Test.

positive: procedure type with a parameter of variable open array type

	MODULE Test;
	TYPE Array = ARRAY OF RECORD END;
	TYPE Procedure = PROCEDURE (VAR parameter: Array);
	END Test.

positive: procedure type with parameters of variable open array type

	MODULE Test;
	TYPE Array = ARRAY OF RECORD END;
	TYPE Procedure = PROCEDURE (VAR a, b, c: Array);
	END Test.

positive: procedure type with a parameter of constant open array type

	MODULE Test;
	TYPE Array = ARRAY OF RECORD END;
	TYPE Procedure = PROCEDURE (CONST parameter: Array);
	END Test.

positive: procedure type with parameters of constant open array type

	MODULE Test;
	TYPE Array = ARRAY OF RECORD END;
	TYPE Procedure = PROCEDURE (CONST a, b, c: Array);
	END Test.

positive: procedure type with intermixed parameters of open array type

	MODULE Test;
	TYPE Array = ARRAY OF RECORD END;
	TYPE Procedure = PROCEDURE (a: Array; VAR b: Array; CONST c: Array);
	END Test.

positive: procedure type with a parameter of anonymous open array type

	MODULE Test;
	TYPE Procedure = PROCEDURE (parameter: ARRAY OF RECORD END);
	END Test.

positive: procedure type with parameters of anonymous open array type

	MODULE Test;
	TYPE Procedure = PROCEDURE (a, b, c: ARRAY OF RECORD END);
	END Test.

positive: procedure type with a parameter of variable anonymous open array type

	MODULE Test;
	TYPE Procedure = PROCEDURE (VAR parameter: ARRAY OF RECORD END);
	END Test.

positive: procedure type with parameters of variable anonymous open array type

	MODULE Test;
	TYPE Procedure = PROCEDURE (VAR a, b, c: ARRAY OF RECORD END);
	END Test.

positive: procedure type with a parameter of constant anonymous open array type

	MODULE Test;
	TYPE Procedure = PROCEDURE (CONST parameter: ARRAY OF RECORD END);
	END Test.

positive: procedure type with parameters of constant anonymous open array type

	MODULE Test;
	TYPE Procedure = PROCEDURE (CONST a, b, c: ARRAY OF RECORD END);
	END Test.

positive: procedure type with intermixed parameters of anonymous open array type

	MODULE Test;
	TYPE Procedure = PROCEDURE (a: ARRAY OF RECORD END; VAR b: ARRAY OF RECORD END; CONST c: ARRAY OF RECORD END);
	END Test.

positive: procedure type with a parameter of object type

	MODULE Test;
	TYPE Object = OBJECT END Object;
	TYPE Procedure = PROCEDURE (parameter: Object);
	END Test.

positive: procedure type with parameters of object type

	MODULE Test;
	TYPE Object = OBJECT END Object;
	TYPE Procedure = PROCEDURE (a, b, c: Object);
	END Test.

positive: procedure type with a parameter of variable object type

	MODULE Test;
	TYPE Object = OBJECT END Object;
	TYPE Procedure = PROCEDURE (VAR parameter: Object);
	END Test.

positive: procedure type with parameters of variable object type

	MODULE Test;
	TYPE Object = OBJECT END Object;
	TYPE Procedure = PROCEDURE (VAR a, b, c: Object);
	END Test.

positive: procedure type with a parameter of constant object type

	MODULE Test;
	TYPE Object = OBJECT END Object;
	TYPE Procedure = PROCEDURE (CONST parameter: Object);
	END Test.

positive: procedure type with parameters of constant object type

	MODULE Test;
	TYPE Object = OBJECT END Object;
	TYPE Procedure = PROCEDURE (CONST a, b, c: Object);
	END Test.

positive: procedure type with intermixed parameters of object type

	MODULE Test;
	TYPE Object = OBJECT END Object;
	TYPE Procedure = PROCEDURE (a: Object; VAR b: Object; CONST c: Object);
	END Test.

positive: procedure type with a parameter of anonymous object type

	MODULE Test;
	TYPE Procedure = PROCEDURE (parameter: OBJECT END);
	END Test.

positive: procedure type with parameters of anonymous object type

	MODULE Test;
	TYPE Procedure = PROCEDURE (a, b, c: OBJECT END);
	END Test.

positive: procedure type with a parameter of variable anonymous object type

	MODULE Test;
	TYPE Procedure = PROCEDURE (VAR parameter: OBJECT END);
	END Test.

positive: procedure type with parameters of variable anonymous object type

	MODULE Test;
	TYPE Procedure = PROCEDURE (VAR a, b, c: OBJECT END);
	END Test.

positive: procedure type with a parameter of constant anonymous object type

	MODULE Test;
	TYPE Procedure = PROCEDURE (CONST parameter: OBJECT END);
	END Test.

positive: procedure type with parameters of constant anonymous object type

	MODULE Test;
	TYPE Procedure = PROCEDURE (CONST a, b, c: OBJECT END);
	END Test.

positive: procedure type with intermixed parameters of anonymous object type

	MODULE Test;
	TYPE Procedure = PROCEDURE (a: OBJECT END; VAR b: OBJECT END; CONST c: OBJECT END);
	END Test.

positive: procedure type with a parameter of pointer type

	MODULE Test;
	TYPE Pointer = POINTER TO RECORD END;
	TYPE Procedure = PROCEDURE (parameter: Pointer);
	END Test.

positive: procedure type with parameters of pointer type

	MODULE Test;
	TYPE Pointer = POINTER TO RECORD END;
	TYPE Procedure = PROCEDURE (a, b, c: Pointer);
	END Test.

positive: procedure type with a parameter of variable pointer type

	MODULE Test;
	TYPE Pointer = POINTER TO RECORD END;
	TYPE Procedure = PROCEDURE (VAR parameter: Pointer);
	END Test.

positive: procedure type with parameters of variable pointer type

	MODULE Test;
	TYPE Pointer = POINTER TO RECORD END;
	TYPE Procedure = PROCEDURE (VAR a, b, c: Pointer);
	END Test.

positive: procedure type with a parameter of constant pointer type

	MODULE Test;
	TYPE Pointer = POINTER TO RECORD END;
	TYPE Procedure = PROCEDURE (CONST parameter: Pointer);
	END Test.

positive: procedure type with parameters of constant pointer type

	MODULE Test;
	TYPE Pointer = POINTER TO RECORD END;
	TYPE Procedure = PROCEDURE (CONST a, b, c: Pointer);
	END Test.

positive: procedure type with intermixed parameters of pointer type

	MODULE Test;
	TYPE Pointer = POINTER TO RECORD END;
	TYPE Procedure = PROCEDURE (a: Pointer; VAR b: Pointer; CONST c: Pointer);
	END Test.

positive: procedure type with a parameter of anonymous pointer type

	MODULE Test;
	TYPE Procedure = PROCEDURE (parameter: POINTER TO RECORD END);
	END Test.

positive: procedure type with parameters of anonymous pointer type

	MODULE Test;
	TYPE Procedure = PROCEDURE (a, b, c: POINTER TO RECORD END);
	END Test.

positive: procedure type with a parameter of variable anonymous pointer type

	MODULE Test;
	TYPE Procedure = PROCEDURE (VAR parameter: POINTER TO RECORD END);
	END Test.

positive: procedure type with parameters of variable anonymous pointer type

	MODULE Test;
	TYPE Procedure = PROCEDURE (VAR a, b, c: POINTER TO RECORD END);
	END Test.

positive: procedure type with a parameter of constant anonymous pointer type

	MODULE Test;
	TYPE Procedure = PROCEDURE (CONST parameter: OBJECT END);
	END Test.

positive: procedure type with parameters of constant anonymous pointer type

	MODULE Test;
	TYPE Procedure = PROCEDURE (CONST a, b, c: POINTER TO RECORD END);
	END Test.

positive: procedure type with intermixed parameters of anonymous pointer type

	MODULE Test;
	TYPE Procedure = PROCEDURE (a: POINTER TO RECORD END; VAR b: POINTER TO RECORD END; CONST c: POINTER TO RECORD END);
	END Test.

positive: procedure type with a parameter of procedure type

	MODULE Test;
	TYPE ProcedureType = PROCEDURE;
	TYPE Procedure = PROCEDURE (parameter: ProcedureType);
	END Test.

positive: procedure type with parameters of procedure type

	MODULE Test;
	TYPE ProcedureType = PROCEDURE;
	TYPE Procedure = PROCEDURE (a, b, c: ProcedureType);
	END Test.

positive: procedure type with a parameter of variable procedure type

	MODULE Test;
	TYPE ProcedureType = PROCEDURE;
	TYPE Procedure = PROCEDURE (VAR parameter: ProcedureType);
	END Test.

positive: procedure type with parameters of variable procedure type

	MODULE Test;
	TYPE ProcedureType = PROCEDURE;
	TYPE Procedure = PROCEDURE (VAR a, b, c: ProcedureType);
	END Test.

positive: procedure type with a parameter of constant procedure type

	MODULE Test;
	TYPE ProcedureType = PROCEDURE;
	TYPE Procedure = PROCEDURE (CONST parameter: ProcedureType);
	END Test.

positive: procedure type with parameters of constant procedure type

	MODULE Test;
	TYPE ProcedureType = PROCEDURE;
	TYPE Procedure = PROCEDURE (CONST a, b, c: ProcedureType);
	END Test.

positive: procedure type with intermixed parameters of procedure type

	MODULE Test;
	TYPE ProcedureType = PROCEDURE;
	TYPE Procedure = PROCEDURE (a: ProcedureType; VAR b: ProcedureType; CONST c: ProcedureType);
	END Test.

positive: procedure type with a parameter of anonymous procedure type

	MODULE Test;
	TYPE Procedure = PROCEDURE (parameter: PROCEDURE);
	END Test.

positive: procedure type with parameters of anonymous procedure type

	MODULE Test;
	TYPE Procedure = PROCEDURE (a, b, c: PROCEDURE);
	END Test.

positive: procedure type with a parameter of variable anonymous procedure type

	MODULE Test;
	TYPE Procedure = PROCEDURE (VAR parameter: PROCEDURE);
	END Test.

positive: procedure type with parameters of variable anonymous procedure type

	MODULE Test;
	TYPE Procedure = PROCEDURE (VAR a, b, c: PROCEDURE);
	END Test.

positive: procedure type with a parameter of constant anonymous procedure type

	MODULE Test;
	TYPE Procedure = PROCEDURE (CONST parameter: PROCEDURE);
	END Test.

positive: procedure type with parameters of constant anonymous procedure type

	MODULE Test;
	TYPE Procedure = PROCEDURE (CONST a, b, c: PROCEDURE);
	END Test.

positive: procedure type with intermixed parameters of anonymous procedure type

	MODULE Test;
	TYPE Procedure = PROCEDURE (a: PROCEDURE; VAR b: PROCEDURE; CONST c: PROCEDURE);
	END Test.

# enumerations

positive: simple enumeration

	MODULE Test;
	TYPE Color=ENUM red, green, blue END;
	VAR color: Color;
	BEGIN color := Color.red END Test.

positive: enumeration type extension

	MODULE Test;
	TYPE Color=ENUM red, green, blue END;
		FineColor=ENUM (Color) black, white END;
	VAR color: FineColor;
	BEGIN color := Color.red; color := FineColor.white END Test.

positive: enumeration assignment compatibility

	MODULE Test;
	TYPE Color=ENUM red, green, blue END;
		FineColor=ENUM(Color) black, white END;
	VAR color,color2: Color; fineColor,fineColor2: FineColor;
	BEGIN color := Color.blue; fineColor := Color.red; fineColor := FineColor.black;
		color2 := color; fineColor2 := fineColor;
		fineColor := color;
	END Test.

negative: wrong enumeration assignment

	MODULE Test;
	TYPE Color=ENUM red, green, blue END;
		FineColor=ENUM(Color) black, white END;
	VAR color,color2: Color; fineColor,fineColor2: FineColor;
	BEGIN color := fineColor
	END Test.

positive: enumeration comparison compatibility

	MODULE Test;
	TYPE Color=ENUM red, green, blue END;
		FineColor=ENUM(Color) black, white END;
	VAR color,color2: Color; fineColor,fineColor2: FineColor; b: BOOLEAN;
	BEGIN
		b := color = color2;
		b := color # color2;
		b := fineColor = fineColor2;
		b := fineColor # fineColor2;
		b := color = fineColor;
		b := fineColor = color;
	END Test.

positive: enumeration comparison with impossible value (extension)

	MODULE Test;
	TYPE Color=ENUM red, green, blue END;
		FineColor=ENUM(Color) black, white END;
	VAR color,color2: Color; fineColor,fineColor2: FineColor; b: BOOLEAN;
	BEGIN
		b := color = FineColor.white;
	END Test.

positive: passing enumeration as parameter

	MODULE Test;
	TYPE Color=ENUM red, green, blue END;
		FineColor=ENUM(Color) black, white END;
	VAR color,color2: Color; fineColor,fineColor2: FineColor; b: BOOLEAN;

		PROCEDURE P1(color: Color);
		BEGIN END P1;
		PROCEDURE P2(color: FineColor);
		BEGIN END P2;
		PROCEDURE P1V(VAR color: Color);
		BEGIN END P1V;
		PROCEDURE P2V(VAR color: FineColor);
		BEGIN END P2V;

	BEGIN
		P1(color);
		P2(fineColor);
		P2(color);
		P1V(color);
		P2V(fineColor);
	END Test.

negative: passing enumeration extension on base type

	MODULE Test;
	TYPE Color=ENUM red, green, blue END;
		FineColor=ENUM(Color) black, white END;
	VAR color,color2: Color; fineColor,fineColor2: FineColor; b: BOOLEAN;

		PROCEDURE P1(color: Color);
		BEGIN END P1;

	BEGIN
		P1(fineColor);
	END Test.

negative: passing enumeration extension on extended type as var parameter

	MODULE Test;
	TYPE Color=ENUM red, green, blue END;
		FineColor=ENUM(Color) black, white END;
	VAR color,color2: Color; fineColor,fineColor2: FineColor; b: BOOLEAN;

		PROCEDURE P1(VAR color: Color);
		BEGIN END P1;

	BEGIN
		P1(fineColor);
	END Test.

positive: returning enumeration type

	MODULE Test;

	TYPE
	Enumeration = ENUM
		red, green, blue
	END;

	PROCEDURE Test(): Enumeration;
	BEGIN
		RETURN Enumeration.green;
	END Test;

	BEGIN
		ASSERT(Test() = Enumeration.green);
	END Test.

# variables

positive: unmarked variable

	MODULE Test;
	VAR variable: RECORD END;
	END Test.

positive: initializing unmarked variable

	MODULE Test;
	VAR variable: SIGNED16;
	BEGIN variable := 0
	END Test.

positive: unmarked variable within procedure

	MODULE Test;
	PROCEDURE Procedure;
		VAR variable: RECORD END;
	END Procedure;
	END Test.

positive: initializing unmarked variable within procedure

	MODULE Test;
	PROCEDURE Procedure;
		VAR variable: SIGNED16;
		BEGIN variable := 0
	END Procedure;
	END Test.

positive: unmarked variable within nested procedure

	MODULE Test;
	PROCEDURE Procedure;
		PROCEDURE Procedure;
			VAR variable: RECORD END;
		END Procedure;
	END Procedure;
	END Test.

positive: initializing unmarked variable within nested procedure

	MODULE Test;
	PROCEDURE Procedure;
		PROCEDURE Procedure;
			VAR variable: SIGNED16;
			BEGIN variable := 0
		END Procedure;
	END Procedure;
	END Test.

positive: unmarked variable within record

	MODULE Test;
	TYPE Record = RECORD
		variable: RECORD END;
	END;
	END Test.

positive: initializing unmarked variable within record

	MODULE Test;
	TYPE Record = RECORD
		variable: SIGNED16;
	END;
	VAR record: Record;
	BEGIN record.variable := 0
	END Test.

positive: unmarked variable within object

	MODULE Test;
	TYPE Object = OBJECT
		VAR variable: RECORD END;
	END Object;
	END Test.

positive: initializing unmarked variable within object

	MODULE Test;
	TYPE Object = OBJECT
		VAR variable: SIGNED16;
		BEGIN variable := 0
	END Object;
	END Test.

positive: unmarked variable within record in procedure

	MODULE Test;
	PROCEDURE Procedure;
		TYPE Record = RECORD
			variable: RECORD END;
		END;
	END Procedure;
	END Test.

positive: initializing unmarked variable within record in procedure

	MODULE Test;
	PROCEDURE Procedure;
		TYPE Record = RECORD
			variable: SIGNED16;
		END;
		VAR record: Record;
		BEGIN record.variable := 0
	END Procedure;
	END Test.

positive: unmarked variable within object in procedure

	MODULE Test;
	PROCEDURE Procedure;
		TYPE Object = OBJECT
			VAR variable: RECORD END;
		END Object;
	END Procedure;
	END Test.

positive: initializing unmarked variable within object in procedure

	MODULE Test;
	PROCEDURE Procedure;
		TYPE Object = OBJECT
			VAR variable: SIGNED16;
			BEGIN variable := 0
		END Object;
	END Procedure;
	END Test.

positive: unmarked variable within procedure in object

	MODULE Test;
	TYPE Object = OBJECT
		PROCEDURE Procedure;
			VAR variable: RECORD END;
		END Procedure;
	END Object;
	END Test.

positive: initializing unmarked variable within procedure in object

	MODULE Test;
	TYPE Object = OBJECT
		PROCEDURE Procedure;
			VAR variable: SIGNED16;
			BEGIN variable := 0
		END Procedure;
	END Object;
	END Test.

positive: variable marked as exported

	MODULE Test;
	VAR variable*: RECORD END;
	END Test.

positive: initializing variable marked as exported

	MODULE Test;
	VAR variable*: SIGNED16;
	BEGIN variable := 0
	END Test.

negative: variable marked as exported within procedure

	MODULE Test;
	PROCEDURE Procedure;
		VAR variable*: RECORD END;
	END Procedure;
	END Test.

negative: variable marked as exported within nested procedure

	MODULE Test;
	PROCEDURE Procedure;
		PROCEDURE Procedure;
			VAR variable*: RECORD END;
		END Procedure;
	END Procedure;
	END Test.

positive: variable marked as exported within record

	MODULE Test;
	TYPE Record = RECORD
		variable*: RECORD END;
	END;
	END Test.

positive: initializing variable marked as exported within record

	MODULE Test;
	TYPE Record = RECORD
		variable*: SIGNED16;
	END;
	VAR record: Record;
	BEGIN record.variable := 0
	END Test.

positive: variable marked as exported within object

	MODULE Test;
	TYPE Object = OBJECT
		VAR variable*: RECORD END;
	END Object;
	END Test.

positive: initializing variable marked as exported within object

	MODULE Test;
	TYPE Object = OBJECT
		VAR variable*: SIGNED16;
		BEGIN variable := 0
	END Object;
	END Test.

negative: variable marked as exported within record in procedure

	MODULE Test;
	PROCEDURE Procedure;
		TYPE Record = RECORD
			variable*: RECORD END;
		END;
	END Procedure;
	END Test.

negative: variable marked as exported within object in procedure

	MODULE Test;
	PROCEDURE Procedure;
		TYPE Object = OBJECT
			VAR variable*: RECORD END;
		END Object;
	END Procedure;
	END Test.

negative: variable marked as exported within procedure in object

	MODULE Test;
	TYPE Object = OBJECT
		PROCEDURE Procedure;
			VAR variable*: RECORD END;
		END Procedure;
	END Object;
	END Test.

positive: variable marked as read-only

	MODULE Test;
	VAR variable-: RECORD END;
	END Test.

positive: initializing variable marked as read-only

	MODULE Test;
	VAR variable-: SIGNED16;
	BEGIN variable := 0
	END Test.

negative: variable marked as read-only within procedure

	MODULE Test;
	PROCEDURE Procedure;
		VAR variable-: RECORD END;
	END Procedure;
	END Test.

negative: variable marked as read-only within nested procedure

	MODULE Test;
	PROCEDURE Procedure;
		PROCEDURE Procedure;
			VAR variable-: RECORD END;
		END Procedure;
	END Procedure;
	END Test.

positive: variable marked as read-only within record

	MODULE Test;
	TYPE Record = RECORD
		variable-: RECORD END;
	END;
	END Test.

positive: initializing variable marked as read-only within record

	MODULE Test;
	TYPE Record = RECORD
		variable-: SIGNED16;
	END;
	VAR record: Record;
	BEGIN record.variable := 0
	END Test.

positive: variable marked as read-only within object

	MODULE Test;
	TYPE Object = OBJECT
		VAR variable-: RECORD END;
	END Object;
	END Test.

positive: initializing variable marked as read-only within object

	MODULE Test;
	TYPE Object = OBJECT
		VAR variable-: SIGNED16;
		BEGIN variable := 0
	END Object;
	END Test.

negative: variable marked as read-only within record in procedure

	MODULE Test;
	PROCEDURE Procedure;
		TYPE Record = RECORD
			variable-: RECORD END;
		END;
	END Procedure;
	END Test.

negative: variable marked as read-only within object in procedure

	MODULE Test;
	PROCEDURE Procedure;
		TYPE Object = OBJECT
			VAR variable-: RECORD END;
		END Object;
	END Procedure;
	END Test.

negative: variable marked as read-only within procedure in object

	MODULE Test;
	TYPE Object = OBJECT
		PROCEDURE Procedure;
			VAR variable-: RECORD END;
		END Procedure;
	END Object;
	END Test.

negative: duplicated variable

	MODULE Test;
	VAR variable: SIGNED32;
	VAR variable: RECORD END;
	END Test.

negative: duplicated variable within procedure

	MODULE Test;
	PROCEDURE Procedure;
		VAR variable: SIGNED32;
		VAR variable: RECORD END;
	END Procedure;
	END Test.

negative: duplicated variable within nested procedure

	MODULE Test;
	PROCEDURE Procedure;
		PROCEDURE Procedure;
			VAR variable: SIGNED32;
			VAR variable: RECORD END;
		END Procedure;
	END Procedure;
	END Test.

negative: duplicated variable within record

	MODULE Test;
	TYPE Record = RECORD
		variable: SIGNED32;
		variable: RECORD END;
	END;
	END Test.

negative: duplicated variable within object

	MODULE Test;
	TYPE Object = OBJECT
		VAR variable: SIGNED32;
		VAR variable: RECORD END;
	END Object;
	END Test.

negative: duplicated variable within record in procedure

	MODULE Test;
	PROCEDURE Procedure;
		TYPE Record = RECORD
			variable: SIGNED32;
			variable: RECORD END;
		END;
	END Procedure;
	END Test.

negative: duplicated variable within object in procedure

	MODULE Test;
	PROCEDURE Procedure;
		TYPE Object = OBJECT
			VAR variable: SIGNED32;
			VAR variable: RECORD END;
		END Object;
	END Procedure;
	END Test.

negative: duplicated variable within procedure in object

	MODULE Test;
	TYPE Object = OBJECT
		PROCEDURE Procedure;
			VAR variable: SIGNED32;
			VAR variable: RECORD END;
		END Procedure;
	END Object;
	END Test.

negative: duplicated variable in same declaration

	MODULE Test;
	VAR variable, variable: SIGNED32;
	END Test.

negative: duplicated variable in same declaration within procedure

	MODULE Test;
	PROCEDURE Procedure;
		VAR variable, variable: SIGNED32;
	END Procedure;
	END Test.

negative: duplicated variable in same declaration within nested procedure

	MODULE Test;
	PROCEDURE Procedure;
		PROCEDURE Procedure;
			VAR variable, variable: SIGNED32;
		END Procedure;
	END Procedure;
	END Test.

negative: duplicated variable in same declaration within record

	MODULE Test;
	TYPE Record = RECORD
		variable, variable: SIGNED32;
	END;
	END Test.

negative: duplicated variable in same declaration within object

	MODULE Test;
	TYPE Object = OBJECT
		VAR variable, variable: SIGNED32;
	END Object;
	END Test.

negative: duplicated variable in same declaration within record in procedure

	MODULE Test;
	PROCEDURE Procedure;
		TYPE Record = RECORD
			variable, variable: SIGNED32;
		END;
	END Procedure;
	END Test.

negative: duplicated variable in same declaration within object in procedure

	MODULE Test;
	PROCEDURE Procedure;
		TYPE Object = OBJECT
			VAR variable, variable: SIGNED32;
		END Object;
	END Procedure;
	END Test.

negative: duplicated variable in same declaration within procedure in object

	MODULE Test;
	TYPE Object = OBJECT
		PROCEDURE Procedure;
			VAR variable, variable: SIGNED32;
		END Procedure;
	END Object;
	END Test.

negative: import as variable

	MODULE Test;
	IMPORT Import := Dummy;
	VAR variable: Import;
	END Test.

negative: constant as variable

	MODULE Test;
	CONST Constant = 0;
	VAR variable: Constant;
	END Test.

positive: type as variable

	MODULE Test;
	TYPE Type = SIGNED16;
	VAR variable: Type;
	END Test.

negative: procedure as variable

	MODULE Test;
	VAR variable: Procedure;
	PROCEDURE Procedure; END Procedure;
	END Test.

negative: parameter as variable

	MODULE Test;
	PROCEDURE Procedure (parameter: SIGNED16);
	VAR variable: parameter;
	END Procedure;
	END Test.

positive: variable of basic character type

	MODULE Test;
	VAR variable: CHAR;
	END Test.

positive: variable of basic boolean type

	MODULE Test;
	VAR variable: BOOLEAN;
	END Test.

positive: variable of basic short integer type

	MODULE Test;
	VAR variable: SIGNED8;
	END Test.

positive: variable of basic integer type

	MODULE Test;
	VAR variable: SIGNED16;
	END Test.

positive: variable of basic long integer type

	MODULE Test;
	VAR variable: SIGNED32;
	END Test.

positive: variable of basic huge integer type

	MODULE Test;
	VAR variable: SIGNED64;
	END Test.

positive: variable of basic real type

	MODULE Test;
	VAR variable: FLOAT32;
	END Test.

positive: variable of basic long real type

	MODULE Test;
	VAR variable: FLOAT64;
	END Test.

positive: variable of basic set type

	MODULE Test;
	VAR variable: SET;
	END Test.

positive: variable of record type

	MODULE Test;
	TYPE Record = RECORD c: CHAR END;
	VAR variable: Record;
	END Test.

positive: variables of record type

	MODULE Test;
	TYPE Record = RECORD c: CHAR END;
	VAR a, b, c: Record;
	END Test.

positive: variable of anonymous record type

	MODULE Test;
	VAR variable: RECORD c: CHAR END;
	END Test.

positive: variables of anonymous record type

	MODULE Test;
	VAR a, b, c: RECORD c: CHAR END;
	END Test.

positive: variable of array type

	MODULE Test;
	TYPE Array = ARRAY 10 OF RECORD END;
	VAR variable: Array;
	END Test.

positive: variables of array type

	MODULE Test;
	TYPE Array = ARRAY 10 OF RECORD END;
	VAR a, b, c: Array;
	END Test.

positive: variable of anonymous array type

	MODULE Test;
	VAR variable: ARRAY 10 OF RECORD END;
	END Test.

positive: variables of anonymous array type

	MODULE Test;
	VAR a, b, c: ARRAY 10 OF RECORD END;
	END Test.

negative: variable of open array type

	MODULE Test;
	TYPE Array = ARRAY OF RECORD END;
	VAR variable: Array;
	END Test.

negative: variables of open array type

	MODULE Test;
	TYPE Array = ARRAY OF RECORD END;
	VAR a, v, c: Array;
	END Test.

negative: variable of anonymous open array type

	MODULE Test;
	VAR variable: ARRAY OF RECORD END;
	END Test.

negative: variables of anonymous open array type

	MODULE Test;
	VAR a, b, c: ARRAY OF RECORD END;
	END Test.

positive: variable of object type

	MODULE Test;
	TYPE Object = OBJECT VAR c: CHAR END Object;
	VAR variable: Object;
	END Test.

positive: variables of object type

	MODULE Test;
	TYPE Object = OBJECT VAR c: CHAR END Object;
	VAR a, b, c: Object;
	END Test.

positive: variable of anonymous object type

	MODULE Test;
	VAR variable: OBJECT VAR c: CHAR END;
	END Test.

positive: variables of anonymous object type

	MODULE Test;
	VAR a, b, c: OBJECT VAR c: CHAR END;
	END Test.

positive: variable of pointer type

	MODULE Test;
	TYPE Pointer = POINTER TO RECORD c: CHAR END;
	VAR variable: Pointer;
	END Test.

positive: variables of pointer type

	MODULE Test;
	TYPE Pointer = POINTER TO RECORD c: CHAR END;
	VAR a, b, c: Pointer;
	END Test.

positive: variable of anonymous pointer type

	MODULE Test;
	VAR variable: POINTER TO RECORD c: CHAR END;
	END Test.

positive: variables of anonymous pointer type

	MODULE Test;
	VAR a, b, c: POINTER TO RECORD c: CHAR END;
	END Test.

positive: variable of procedure type

	MODULE Test;
	TYPE Procedure = PROCEDURE;
	VAR variable: Procedure;
	END Test.

positive: variables of procedure type

	MODULE Test;
	TYPE Procedure = PROCEDURE;
	VAR a, b, c: Procedure;
	END Test.

positive: variable of anonymous procedure type

	MODULE Test;
	VAR variable: PROCEDURE;
	END Test.

positive: variables of anonymous procedure type

	MODULE Test;
	VAR a, b, c: PROCEDURE;
	END Test.

negative: definition of self in module

	MODULE Test;
	VAR SELF: OBJECT;
	END Test.

negative: definition of self in procedure

	MODULE Test;
	PROCEDURE Procedure;
	VAR SELF: OBJECT;
	END Procedure;
	END Test.

negative: definition of self in object

	MODULE Test;
	TYPE Object = OBJECT
		VAR SELF: OBJECT;
	END Object;
	END Test.

negative: definition of self in procedure in object

	MODULE Test;
	TYPE Object = OBJECT
		PROCEDURE Procedure;
		VAR SELF: OBJECT;
		END Procedure;
	END Object;
	END Test.

negative: definition of self in nested procedure in object

	MODULE Test;
	TYPE Object = OBJECT
		PROCEDURE Procedure;
			PROCEDURE Procedure;
			VAR SELF: OBJECT;
			END Procedure;
		END Procedure;
	END Object;
	END Test.

negative: modification of self in module

	MODULE Test;
	BEGIN SELF := NIL;
	END Test.

negative: modification of self in procedure

	MODULE Test;
	PROCEDURE Procedure;
	BEGIN SELF := NIL;
	END Procedure;
	END Test.

negative: modification of self in object

	MODULE Test;
	TYPE Object = OBJECT
		BEGIN SELF := NIL;
	END Object;
	END Test.

negative: modification of self in procedure in object

	MODULE Test;
	TYPE Object = OBJECT
		PROCEDURE Procedure;
		BEGIN SELF := NIL;
		END Procedure;
	END Object;
	END Test.

negative: modification of self in nested procedure in object

	MODULE Test;
	TYPE Object = OBJECT
		PROCEDURE Procedure;
			PROCEDURE Procedure;
			BEGIN SELF := NIL;
			END Procedure;
		END Procedure;
	END Object;
	END Test.

negative: reading self in module

	MODULE Test;
	VAR a: SIGNED16;
	BEGIN a := SELF.a;
	END Test.

negative: reading self in procedure

	MODULE Test;
	VAR a: SIGNED16;
	PROCEDURE Procedure;
	BEGIN a := SELF.a;
	END Procedure;
	END Test.

positive: reading self in object

	MODULE Test;
	TYPE Object = OBJECT
		VAR a: SIGNED16;
		BEGIN a := SELF.a;
	END Object;
	END Test.

positive: reading self in procedure in object

	MODULE Test;
	TYPE Object = OBJECT
		VAR a: SIGNED16;
		PROCEDURE Procedure;
		BEGIN a := SELF.a;
		END Procedure;
	END Object;
	END Test.

positive: reading self in nested procedure in object

	MODULE Test;
	TYPE Object = OBJECT
		VAR a: SIGNED16;
		PROCEDURE Procedure;
			PROCEDURE Procedure;
			BEGIN a := SELF.a;
			END Procedure;
		END Procedure;
	END Object;
	END Test.

negative: writing self in module

	MODULE Test;
	VAR a: SIGNED16;
	BEGIN SELF.a := a;
	END Test.

negative: writing self in procedure

	MODULE Test;
	VAR a: SIGNED16;
	PROCEDURE Procedure;
	BEGIN SELF.a := a;
	END Procedure;
	END Test.

positive: writing self in object

	MODULE Test;
	TYPE Object = OBJECT
		VAR a: SIGNED16;
		BEGIN SELF.a := a;
	END Object;
	END Test.

positive: writing self in procedure in object

	MODULE Test;
	TYPE Object = OBJECT
		VAR a: SIGNED16;
		PROCEDURE Procedure;
		BEGIN SELF.a := a;
		END Procedure;
	END Object;
	END Test.

positive: writing self in nested procedure in object

	MODULE Test;
	TYPE Object = OBJECT
		VAR a: SIGNED16;
		PROCEDURE Procedure;
			PROCEDURE Procedure;
			BEGIN SELF.a := a;
			END Procedure;
		END Procedure;
	END Object;
	END Test.

positive: usage of self in object

	MODULE Test;
	TYPE Object = OBJECT
		VAR object: Object;
		BEGIN object := SELF;
	END Object;
	END Test.

positive: usage of self in procedure in object

	MODULE Test;
	TYPE Object = OBJECT
		VAR object: Object;
		PROCEDURE Procedure;
		BEGIN object := SELF;
		END Procedure;
	END Object;
	END Test.

positive: usage of self in nested procedure in object

	MODULE Test;
	TYPE Object = OBJECT
		VAR object: Object;
		PROCEDURE Procedure;
			PROCEDURE Procedure;
			BEGIN object := SELF;
			END Procedure;
		END Procedure;
	END Object;
	END Test.

positive: usage of self as base object in object

	MODULE Test;
	TYPE Object = OBJECT
		VAR object: OBJECT;
		BEGIN object := SELF;
	END Object;
	END Test.

positive: usage of self as base object in procedure in object

	MODULE Test;
	TYPE Object = OBJECT
		VAR object: OBJECT;
		PROCEDURE Procedure;
		BEGIN object := SELF;
		END Procedure;
	END Object;
	END Test.

positive: usage of self as base object in nested procedure in object

	MODULE Test;
	TYPE Object = OBJECT
		VAR object: OBJECT;
		PROCEDURE Procedure;
			PROCEDURE Procedure;
			BEGIN object := SELF;
			END Procedure;
		END Procedure;
	END Object;
	END Test.

positive: dummy module exporting variables

	MODULE Dummy;
	VAR exported*, readonly-, private: SIGNED16;
	END Dummy.

positive: importing exported variable

	MODULE Test;
	IMPORT Dummy;
	VAR result: SIGNED16;
	BEGIN result := Dummy.exported;
	END Test.

positive: changing imported exported variable

	MODULE Test;
	IMPORT Dummy;
	BEGIN Dummy.exported := 0;
	END Test.

positive: importing read-only variable

	MODULE Test;
	IMPORT Dummy;
	VAR result: SIGNED16;
	BEGIN result := Dummy.readonly;
	END Test.

negative: changing imported read-only variable

	MODULE Test;
	IMPORT Dummy;
	BEGIN Dummy.readonly := 0;
	END Test.

negative: importing private variable

	MODULE Test;
	IMPORT Dummy;
	VAR result: SIGNED16;
	BEGIN result := Dummy.private;
	END Test.

negative: changing imported private variable

	MODULE Test;
	IMPORT Dummy;
	BEGIN Dummy.private := 0;
	END Test.

negative: importing invalid variable

	MODULE Test;
	IMPORT Dummy;
	VAR result: SIGNED16;
	BEGIN result := Dummy.invalid;
	END Test.


# procedures

positive: unmarked procedure

	MODULE Test;
	PROCEDURE Procedure;
	END Procedure;
	END Test.

positive: unmarked procedure within procedure

	MODULE Test;
	PROCEDURE Procedure;
		PROCEDURE Procedure;
		END Procedure;
	END Procedure;
	END Test.

positive: unmarked procedure within nested procedure

	MODULE Test;
	PROCEDURE Procedure;
		PROCEDURE Procedure;
			PROCEDURE Procedure;
			END Procedure;
		END Procedure;
	END Procedure;
	END Test.

positive: unmarked procedure within object

	MODULE Test;
	TYPE Object = OBJECT
		PROCEDURE Procedure;
		END Procedure;
	END Object;
	END Test.

positive: unmarked procedure within object in procedure

	MODULE Test;
	PROCEDURE Procedure;
		TYPE Object = OBJECT
			PROCEDURE Procedure;
			END Procedure;
		END Object;
	END Procedure;
	END Test.

positive: unmarked procedure within procedure in object

	MODULE Test;
	TYPE Object = OBJECT
		PROCEDURE Procedure;
			PROCEDURE Procedure;
			END Procedure;
		END Procedure;
	END Object;
	END Test.

positive: procedure marked as exported

	MODULE Test;
	PROCEDURE Procedure*;
	END Procedure;
	END Test.

negative: procedure marked as exported within procedure

	MODULE Test;
	PROCEDURE Procedure;
		PROCEDURE Procedure*;
		END Procedure;
	END Procedure;
	END Test.

negative: procedure marked as exported within nested procedure

	MODULE Test;
	PROCEDURE Procedure;
		PROCEDURE Procedure;
			PROCEDURE Procedure*;
			END Procedure;
		END Procedure;
	END Procedure;
	END Test.

positive: procedure marked as exported within object

	MODULE Test;
	TYPE Object = OBJECT
		PROCEDURE Procedure*;
		END Procedure;
	END Object;
	END Test.

negative: procedure marked as exported within object in procedure

	MODULE Test;
	PROCEDURE Procedure;
		TYPE Object = OBJECT
			PROCEDURE Procedure*;
			END Procedure;
		END Object;
	END Procedure;
	END Test.

negative: procedure marked as exported within procedure in object

	MODULE Test;
	TYPE Object = OBJECT
		PROCEDURE Procedure;
			PROCEDURE Procedure*;
			END Procedure;
		END Procedure;
	END Object;
	END Test.

positive: procedure marked as read-only

	MODULE Test;
	PROCEDURE Procedure-;
	END Procedure;
	END Test.

negative: procedure marked as read-only within procedure

	MODULE Test;
	PROCEDURE Procedure;
		PROCEDURE Procedure-;
		END Procedure;
	END Procedure;
	END Test.

negative: procedure marked as read-only within nested procedure

	MODULE Test;
	PROCEDURE Procedure;
		PROCEDURE Procedure;
			PROCEDURE Procedure-;
			END Procedure;
		END Procedure;
	END Procedure;
	END Test.

positive: procedure marked as read-only within object

	MODULE Test;
	TYPE Object = OBJECT
		PROCEDURE Procedure-;
		END Procedure;
	END Object;
	END Test.

negative: procedure marked as read-only within object in procedure

	MODULE Test;
	PROCEDURE Procedure;
		TYPE Object = OBJECT
			PROCEDURE Procedure-;
			END Procedure;
		END Object;
	END Procedure;
	END Test.

negative: procedure marked as read-only within procedure in object

	MODULE Test;
	TYPE Object = OBJECT
		PROCEDURE Procedure;
			PROCEDURE Procedure-;
			END Procedure;
		END Procedure;
	END Object;
	END Test.

negative: duplicated procedure

	MODULE Test;
	PROCEDURE Procedure; END Procedure;
	PROCEDURE Procedure; END Procedure;
	END Test.

negative: duplicated procedure within procedure

	MODULE Test;
	PROCEDURE Procedure;
		PROCEDURE Procedure; END Procedure;
		PROCEDURE Procedure; END Procedure;
	END Procedure;
	END Test.

negative: duplicated procedure within nested procedure

	MODULE Test;
	PROCEDURE Procedure;
		PROCEDURE Procedure;
			PROCEDURE Procedure; END Procedure;
			PROCEDURE Procedure; END Procedure;
		END Procedure;
	END Procedure;
	END Test.

negative: duplicated procedure within object

	MODULE Test;
	TYPE Object = OBJECT
		PROCEDURE Procedure; END Procedure;
		PROCEDURE Procedure; END Procedure;
	END Object;
	END Test.

negative: duplicated procedure within object in procedure

	MODULE Test;
	PROCEDURE Procedure;
		TYPE Object = OBJECT
			PROCEDURE Procedure; END Procedure;
			PROCEDURE Procedure; END Procedure;
		END Object;
	END Procedure;
	END Test.

negative: duplicated procedure within procedure in object

	MODULE Test;
	TYPE Object = OBJECT
		PROCEDURE Procedure;
			PROCEDURE Procedure; END Procedure;
			PROCEDURE Procedure; END Procedure;
		END Procedure;
	END Object;
	END Test.

positive: calling procedure in module

	MODULE Test;
	PROCEDURE Procedure; END Procedure;
	BEGIN Procedure
	END Test.

positive: calling procedure in module with parentheses

	MODULE Test;
	PROCEDURE Procedure; END Procedure;
	BEGIN Procedure ()
	END Test.

positive: calling procedure recursively

	MODULE Test;
	PROCEDURE Procedure;
	BEGIN Procedure
	END Procedure;
	END Test.

positive: calling procedure recursively with parentheses

	MODULE Test;
	PROCEDURE Procedure;
	BEGIN Procedure
	END Procedure;
	END Test.

positive: calling nested procedure in procedure

	MODULE Test;
	PROCEDURE Procedure;
		PROCEDURE Nested; END Nested;
	BEGIN Nested
	END Procedure;
	END Test.

positive: calling nested procedure in procedure with parentheses

	MODULE Test;
	PROCEDURE Procedure;
		PROCEDURE Nested; END Nested;
	BEGIN Nested ()
	END Procedure;
	END Test.

positive: calling nested procedure in procedure recursively

	MODULE Test;
	PROCEDURE Procedure;
		PROCEDURE Nested;
		BEGIN Nested
		END Nested;
	END Procedure;
	END Test.

positive: calling nested procedure in procedure recursively with parentheses

	MODULE Test;
	PROCEDURE Procedure;
		PROCEDURE Nested;
		BEGIN Nested ()
		END Nested;
	END Procedure;
	END Test.

positive: calling method in object

	MODULE Test;
	TYPE Object = OBJECT
		PROCEDURE Procedure; END Procedure;
		BEGIN Procedure
	END Object;
	END Test.

positive: calling method in object with parentheses

	MODULE Test;
	TYPE Object = OBJECT
		PROCEDURE Procedure; END Procedure;
		BEGIN Procedure
	END Object;
	END Test.

positive: calling method recursively

	MODULE Test;
	TYPE Object = OBJECT
		PROCEDURE Procedure;
		BEGIN Procedure
		END Procedure;
	END Object;
	END Test.

positive: calling method recursively with parentheses

	MODULE Test;
	TYPE Object = OBJECT
		PROCEDURE Procedure;
		BEGIN Procedure ()
		END Procedure;
	END Object;
	END Test.

positive: calling nested procedure in method

	MODULE Test;
	TYPE Object = OBJECT
		PROCEDURE Procedure;
			PROCEDURE Nested; END Nested;
		BEGIN Nested
		END Procedure;
	END Object;
	END Test.

positive: calling nested procedure in method with parentheses

	MODULE Test;
	TYPE Object = OBJECT
		PROCEDURE Procedure;
			PROCEDURE Nested; END Nested;
		BEGIN Nested ()
		END Procedure;
	END Object;
	END Test.

positive: calling nested procedure in method recursively

	MODULE Test;
	TYPE Object = OBJECT
		PROCEDURE Procedure;
			PROCEDURE Nested;
			BEGIN Nested
			END Nested;
		END Procedure;
	END Object;
	END Test.

positive: calling nested procedure in method recursively with parentheses

	MODULE Test;
	TYPE Object = OBJECT
		PROCEDURE Procedure;
			PROCEDURE Nested;
			BEGIN Nested ()
			END Nested;
		END Procedure;
	END Object;
	END Test.

positive: calling procedure variable in module

	MODULE Test;
	VAR procedure: PROCEDURE;
	BEGIN procedure
	END Test.

positive: calling procedure variable in module with parentheses

	MODULE Test;
	VAR procedure: PROCEDURE;
	BEGIN procedure ()
	END Test.

positive: calling procedure variable in procedure

	MODULE Test;
	VAR procedure: PROCEDURE;
	PROCEDURE Procedure;
	BEGIN procedure
	END Procedure;
	END Test.

positive: calling procedure variable in procedure with parentheses

	MODULE Test;
	VAR procedure: PROCEDURE;
	PROCEDURE Procedure;
	BEGIN procedure ()
	END Procedure;
	END Test.

positive: calling procedure variable in object

	MODULE Test;
	TYPE Object = OBJECT
		VAR procedure: PROCEDURE;
		BEGIN procedure
	END Object;
	END Test.

	VAR procedure: PROCEDURE;
	BEGIN procedure

positive: calling procedure variable in object with parentheses

	MODULE Test;
	TYPE Object = OBJECT
		VAR procedure: PROCEDURE;
		BEGIN procedure ()
	END Object;
	END Test.

	VAR procedure: PROCEDURE;
	BEGIN procedure

positive: calling procedure variable in method

	MODULE Test;
	TYPE Object = OBJECT
		VAR procedure: PROCEDURE;
		PROCEDURE Procedure;
		BEGIN procedure
		END Procedure;
	END Object;
	END Test.

positive: calling procedure variable in method with parentheses

	MODULE Test;
	TYPE Object = OBJECT
		VAR procedure: PROCEDURE;
		PROCEDURE Procedure;
		BEGIN procedure ()
		END Procedure;
	END Object;
	END Test.

positive: calling procedure with no parameters with no arguments

	MODULE Test;
	PROCEDURE Procedure; END Procedure;
	BEGIN Procedure
	END Test.

negative: calling procedure with one parameter with no arguments

	MODULE Test;
	PROCEDURE Procedure (one: SIGNED16); END Procedure;
	BEGIN Procedure
	END Test.

negative: calling procedure with two parameter with no arguments

	MODULE Test;
	PROCEDURE Procedure (one, two: SIGNED16); END Procedure;
	BEGIN Procedure
	END Test.

negative: calling procedure with no parameters with one argument

	MODULE Test;
	PROCEDURE Procedure; END Procedure;
	BEGIN Procedure (0)
	END Test.

positive: calling procedure with one parameter with one argument

	MODULE Test;
	PROCEDURE Procedure (one: SIGNED16); END Procedure;
	BEGIN Procedure (0)
	END Test.

negative: calling procedure with two parameter with one argument

	MODULE Test;
	PROCEDURE Procedure (one, two: SIGNED16); END Procedure;
	BEGIN Procedure (0)
	END Test.

negative: calling procedure with no parameters with two arguments

	MODULE Test;
	PROCEDURE Procedure; END Procedure;
	BEGIN Procedure (1, 2)
	END Test.

negative: calling procedure with one parameter with two arguments

	MODULE Test;
	PROCEDURE Procedure (one: SIGNED16); END Procedure;
	BEGIN Procedure (1, 2)
	END Test.

positive: calling procedure with two parameter with two arguments

	MODULE Test;
	PROCEDURE Procedure (one, two: SIGNED16); END Procedure;
	BEGIN Procedure (1, 2)
	END Test.

positive: calling procedure variable with no parameters with no arguments

	MODULE Test;
	VAR procedure: PROCEDURE;
	BEGIN procedure
	END Test.

negative: calling procedure variable with one parameter with no arguments

	MODULE Test;
	VAR procedure: PROCEDURE (one: SIGNED16);
	BEGIN procedure
	END Test.

negative: calling procedure variable with two parameter with no arguments

	MODULE Test;
	VAR procedure: PROCEDURE (one, two: SIGNED16);
	BEGIN procedure
	END Test.

negative: calling procedure variable with no parameters with one argument

	MODULE Test;
	VAR procedure: PROCEDURE;
	BEGIN procedure (0)
	END Test.

positive: calling procedure variable with one parameter with one argument

	MODULE Test;
	VAR procedure: PROCEDURE (one: SIGNED16);
	BEGIN procedure (0)
	END Test.

negative: calling procedure variable with two parameter with one argument

	MODULE Test;
	VAR procedure: PROCEDURE (one, two: SIGNED16);
	BEGIN procedure (0)
	END Test.

negative: calling procedure variable with no parameters with two arguments

	MODULE Test;
	VAR procedure: PROCEDURE;
	BEGIN procedure (1, 2)
	END Test.

negative: calling procedure variable with one parameter with two arguments

	MODULE Test;
	VAR procedure: PROCEDURE (one: SIGNED16);
	BEGIN procedure (1, 2)
	END Test.

positive: calling procedure variable with two parameter with two arguments

	MODULE Test;
	VAR procedure: PROCEDURE (one, two: SIGNED16);
	BEGIN procedure (1, 2)
	END Test.


# procedure return types

positive: procedure returning basic character type

	MODULE Test;
	PROCEDURE Procedure (): CHAR;
	END Procedure;
	END Test.

positive: procedure returning basic boolean type

	MODULE Test;
	PROCEDURE Procedure (): BOOLEAN;
	END Procedure;
	END Test.

positive: procedure returning basic short integer type

	MODULE Test;
	PROCEDURE Procedure (): SIGNED8;
	END Procedure;
	END Test.

positive: procedure returning basic integer type

	MODULE Test;
	PROCEDURE Procedure (): SIGNED16;
	END Procedure;
	END Test.

positive: procedure returning basic long integer type

	MODULE Test;
	PROCEDURE Procedure (): SIGNED32;
	END Procedure;
	END Test.

positive: procedure returning basic huge integer type

	MODULE Test;
	PROCEDURE Procedure (): SIGNED64;
	END Procedure;
	END Test.

positive: procedure returning basic real type

	MODULE Test;
	PROCEDURE Procedure (): FLOAT32;
	END Procedure;
	END Test.

positive: procedure returning basic long real type

	MODULE Test;
	PROCEDURE Procedure (): FLOAT64;
	END Procedure;
	END Test.

positive: procedure returning basic set type

	MODULE Test;
	PROCEDURE Procedure (): SET;
	END Procedure;
	END Test.

positive: procedure returning record type

	MODULE Test;
	TYPE Record = RECORD END;
	PROCEDURE Procedure (): Record;
	END Procedure;
	END Test.

positive: procedure returning anonymous record type

	MODULE Test;
	PROCEDURE Procedure (): RECORD END;
	END Procedure;
	END Test.

positive: procedure returning array type

	MODULE Test;
	TYPE Array = ARRAY 10 OF RECORD END;
	PROCEDURE Procedure (): Array;
	END Procedure;
	END Test.

positive: procedure returning anonymous array type

	MODULE Test;
	PROCEDURE Procedure (): ARRAY 10 OF RECORD END;
	END Procedure;
	END Test.

negative: procedure returning open array type

	MODULE Test;
	TYPE Array = ARRAY OF RECORD END;
	PROCEDURE Procedure (): Array;
	END Procedure;
	END Test.

negative: procedure returning anonymous open array type

	MODULE Test;
	PROCEDURE Procedure (): ARRAY OF RECORD END;
	END Procedure;
	END Test.

positive: procedure returning object type

	MODULE Test;
	TYPE Object = OBJECT;
	PROCEDURE Procedure (): Object;
	END Procedure;
	END Test.

positive: procedure returning anonymous object type

	MODULE Test;
	PROCEDURE Procedure (): OBJECT;
	END Procedure;
	END Test.

positive: procedure returning pointer type

	MODULE Test;
	TYPE Pointer = POINTER TO RECORD END;
	PROCEDURE Procedure (): Pointer;
	END Procedure;
	END Test.

positive: procedure returning anonymous pointer type

	MODULE Test;
	PROCEDURE Procedure (): POINTER TO RECORD END;
	END Procedure;
	END Test.

positive: procedure returning procedure type

	MODULE Test;
	TYPE Proc = PROCEDURE;
	PROCEDURE Procedure (): Proc;
	END Procedure;
	END Test.

positive: procedure returning anonymous procedure type

	MODULE Test;
	PROCEDURE Procedure (): PROCEDURE;
	END Procedure;
	END Test.

positive: procedure returning anonymous procedure returning anonymous procedure

	MODULE Test;
	PROCEDURE Procedure (): PROCEDURE (): PROCEDURE;
	END Procedure;
	END Test.

negative: procedure returning itself

	MODULE Test;
	PROCEDURE Procedure (): Procedure;
	END Procedure;
	END Test.

negative: procedure with returning local type

	MODULE Test;
	PROCEDURE Procedure (): Type;
	TYPE Type = RECORD END;
	END Procedure;
	END Test.


# procedure parameters

negative: parameter marked as exported

	MODULE Test;
	PROCEDURE Procedure (parameter*: OBJECT);
	END Procedure;
	END Test.

negative: parameter marked as read-only

	MODULE Test;
	PROCEDURE Procedure (parameter*: OBJECT);
	END Procedure;
	END Test.

negative: duplicated parameters

	MODULE Test;
	PROCEDURE Procedure (parameter: SIGNED32; parameter: SIGNED32);
	END Procedure;
	END Test.

negative: duplicated parameters in same declaration

	MODULE Test;
	PROCEDURE Procedure (parameter, parameter: SIGNED32);
	END Procedure;
	END Test.

positive: procedure with parameter of same type

	MODULE Test;
	TYPE Proc = PROCEDURE;
	PROCEDURE Procedure (procedure: Proc);
	END Procedure;
	END Test.

negative: procedure with multiple variable parameter

	MODULE Test;
	PROCEDURE Procedure (VAR VAR parameter: SET);
	END Procedure;
	END Test.

negative: procedure with multiple constant parameter

	MODULE Test;
	PROCEDURE Procedure (CONST CONST parameter: SET);
	END Procedure;
	END Test.

negative: procedure with variable and constant parameter

	MODULE Test;
	PROCEDURE Procedure (VAR CONST parameter: SET);
	END Procedure;
	END Test.

negative: procedure with constant and variable parameter

	MODULE Test;
	PROCEDURE Procedure (VAR CONST parameter: SET);
	END Procedure;
	END Test.

negative: procedure with parameter marked as exported

	MODULE Test;
	PROCEDURE Procedure (parameter*: CHAR);
	END Procedure;
	END Test.

negative: procedure with parameter marked as read-only

	MODULE Test;
	PROCEDURE Procedure (parameter-: CHAR);
	END Procedure;
	END Test.

positive: procedure with a parameter of basic character type

	MODULE Test;
	PROCEDURE Procedure (parameter: CHAR);
	END Procedure;
	END Test.

positive: procedure with parameters of basic character type

	MODULE Test;
	PROCEDURE Procedure (a, b, c: CHAR);
	END Procedure;
	END Test.

positive: procedure with a parameter of variable character type

	MODULE Test;
	PROCEDURE Procedure (VAR parameter: CHAR);
	END Procedure;
	END Test.

positive: procedure with parameters of variable character type

	MODULE Test;
	PROCEDURE Procedure (VAR a, b, c: CHAR);
	END Procedure;
	END Test.

positive: procedure with a parameter of constant character type

	MODULE Test;
	PROCEDURE Procedure (CONST parameter: CHAR);
	END Procedure;
	END Test.

positive: procedure with parameters of constant character type

	MODULE Test;
	PROCEDURE Procedure (CONST a, b, c: CHAR);
	END Procedure;
	END Test.

positive: procedure with intermixed parameters of character type

	MODULE Test;
	PROCEDURE Procedure (a: CHAR; VAR b: CHAR; CONST c: CHAR);
	END Procedure;
	END Test.

positive: procedure with a parameter of basic boolean type

	MODULE Test;
	PROCEDURE Procedure (parameter: BOOLEAN);
	END Procedure;
	END Test.

positive: procedure with parameters of basic boolean type

	MODULE Test;
	PROCEDURE Procedure (a, b, c: BOOLEAN);
	END Procedure;
	END Test.

positive: procedure with a parameter of variable boolean type

	MODULE Test;
	PROCEDURE Procedure (VAR parameter: BOOLEAN);
	END Procedure;
	END Test.

positive: procedure with parameters of variable boolean type

	MODULE Test;
	PROCEDURE Procedure (VAR a, b, c: BOOLEAN);
	END Procedure;
	END Test.

positive: procedure with a parameter of constant boolean type

	MODULE Test;
	PROCEDURE Procedure (CONST parameter: BOOLEAN);
	END Procedure;
	END Test.

positive: procedure with parameters of constant boolean type

	MODULE Test;
	PROCEDURE Procedure (CONST a, b, c: BOOLEAN);
	END Procedure;
	END Test.

positive: procedure with intermixed parameters of boolean type

	MODULE Test;
	PROCEDURE Procedure (a: BOOLEAN; VAR b: BOOLEAN; CONST c: BOOLEAN);
	END Procedure;
	END Test.

positive: procedure with a parameter of basic short integer type

	MODULE Test;
	PROCEDURE Procedure (parameter: SIGNED8);
	END Procedure;
	END Test.

positive: procedure with parameters of basic short integer type

	MODULE Test;
	PROCEDURE Procedure (a, b, c: SIGNED8);
	END Procedure;
	END Test.

positive: procedure with a parameter of variable short integer type

	MODULE Test;
	PROCEDURE Procedure (VAR parameter: SIGNED8);
	END Procedure;
	END Test.

positive: procedure with parameters of variable short integer type

	MODULE Test;
	PROCEDURE Procedure (VAR a, b, c: SIGNED8);
	END Procedure;
	END Test.

positive: procedure with a parameter of constant short integer type

	MODULE Test;
	PROCEDURE Procedure (CONST parameter: SIGNED8);
	END Procedure;
	END Test.

positive: procedure with parameters of constant short integer type

	MODULE Test;
	PROCEDURE Procedure (CONST a, b, c: SIGNED8);
	END Procedure;
	END Test.

positive: procedure with intermixed parameters of short integer type

	MODULE Test;
	PROCEDURE Procedure (a: SIGNED8; VAR b: SIGNED8; CONST c: SIGNED8);
	END Procedure;
	END Test.

positive: procedure with a parameter of basic integer type

	MODULE Test;
	PROCEDURE Procedure (parameter: SIGNED16);
	END Procedure;
	END Test.

positive: procedure with parameters of basic integer type

	MODULE Test;
	PROCEDURE Procedure (a, b, c: SIGNED16);
	END Procedure;
	END Test.

positive: procedure with a parameter of variable integer type

	MODULE Test;
	PROCEDURE Procedure (VAR parameter: SIGNED16);
	END Procedure;
	END Test.

positive: procedure with parameters of variable integer type

	MODULE Test;
	PROCEDURE Procedure (VAR a, b, c: SIGNED16);
	END Procedure;
	END Test.

positive: procedure with a parameter of constant integer type

	MODULE Test;
	PROCEDURE Procedure (CONST parameter: SIGNED16);
	END Procedure;
	END Test.

positive: procedure with parameters of constant integer type

	MODULE Test;
	PROCEDURE Procedure (CONST a, b, c: SIGNED16);
	END Procedure;
	END Test.

positive: procedure with intermixed parameters of integer type

	MODULE Test;
	PROCEDURE Procedure (a: SIGNED16; VAR b: SIGNED16; CONST c: SIGNED16);
	END Procedure;
	END Test.

positive: procedure with a parameter of basic long integer type

	MODULE Test;
	PROCEDURE Procedure (parameter: SIGNED32);
	END Procedure;
	END Test.

positive: procedure with parameters of basic long integer type

	MODULE Test;
	PROCEDURE Procedure (a, b, c: SIGNED32);
	END Procedure;
	END Test.

positive: procedure with a parameter of variable long integer type

	MODULE Test;
	PROCEDURE Procedure (VAR parameter: SIGNED32);
	END Procedure;
	END Test.

positive: procedure with parameters of variable long integer type

	MODULE Test;
	PROCEDURE Procedure (VAR a, b, c: SIGNED32);
	END Procedure;
	END Test.

positive: procedure with a parameter of constant long integer type

	MODULE Test;
	PROCEDURE Procedure (CONST parameter: SIGNED32);
	END Procedure;
	END Test.

positive: procedure with parameters of constant long integer type

	MODULE Test;
	PROCEDURE Procedure (CONST a, b, c: SIGNED32);
	END Procedure;
	END Test.

positive: procedure with intermixed parameters of long integer type

	MODULE Test;
	PROCEDURE Procedure (a: SIGNED32; VAR b: SIGNED32; CONST c: SIGNED32);
	END Procedure;
	END Test.

positive: procedure with a parameter of basic huge integer type

	MODULE Test;
	PROCEDURE Procedure (parameter: SIGNED64);
	END Procedure;
	END Test.

positive: procedure with parameters of basic huge integer type

	MODULE Test;
	PROCEDURE Procedure (a, b, c: SIGNED64);
	END Procedure;
	END Test.

positive: procedure with a parameter of variable huge integer type

	MODULE Test;
	PROCEDURE Procedure (VAR parameter: SIGNED64);
	END Procedure;
	END Test.

positive: procedure with parameters of variable huge integer type

	MODULE Test;
	PROCEDURE Procedure (VAR a, b, c: SIGNED64);
	END Procedure;
	END Test.

positive: procedure with a parameter of constant huge integer type

	MODULE Test;
	PROCEDURE Procedure (CONST parameter: SIGNED64);
	END Procedure;
	END Test.

positive: procedure with parameters of constant huge integer type

	MODULE Test;
	PROCEDURE Procedure (CONST a, b, c: SIGNED64);
	END Procedure;
	END Test.

positive: procedure with intermixed parameters of huge integer type

	MODULE Test;
	PROCEDURE Procedure (a: SIGNED64; VAR b: SIGNED64; CONST c: SIGNED64);
	END Procedure;
	END Test.

positive: procedure with a parameter of basic real type

	MODULE Test;
	PROCEDURE Procedure (parameter: FLOAT32);
	END Procedure;
	END Test.

positive: procedure with parameters of basic real type

	MODULE Test;
	PROCEDURE Procedure (a, b, c: FLOAT32);
	END Procedure;
	END Test.

positive: procedure with a parameter of variable real type

	MODULE Test;
	PROCEDURE Procedure (VAR parameter: FLOAT32);
	END Procedure;
	END Test.

positive: procedure with parameters of variable real type

	MODULE Test;
	PROCEDURE Procedure (VAR a, b, c: FLOAT32);
	END Procedure;
	END Test.

positive: procedure with a parameter of constant real type

	MODULE Test;
	PROCEDURE Procedure (CONST parameter: FLOAT32);
	END Procedure;
	END Test.

positive: procedure with parameters of constant real type

	MODULE Test;
	PROCEDURE Procedure (CONST a, b, c: FLOAT32);
	END Procedure;
	END Test.

positive: procedure with intermixed parameters of real type

	MODULE Test;
	PROCEDURE Procedure (a: FLOAT32; VAR b: FLOAT32; CONST c: FLOAT32);
	END Procedure;
	END Test.

positive: procedure with a parameter of basic long real type

	MODULE Test;
	PROCEDURE Procedure (parameter: FLOAT64);
	END Procedure;
	END Test.

positive: procedure with parameters of basic long real type

	MODULE Test;
	PROCEDURE Procedure (a, b, c: FLOAT64);
	END Procedure;
	END Test.

positive: procedure with a parameter of variable long real type

	MODULE Test;
	PROCEDURE Procedure (VAR parameter: FLOAT64);
	END Procedure;
	END Test.

positive: procedure with parameters of variable long real type

	MODULE Test;
	PROCEDURE Procedure (VAR a, b, c: FLOAT64);
	END Procedure;
	END Test.

positive: procedure with a parameter of constant long real type

	MODULE Test;
	PROCEDURE Procedure (CONST parameter: FLOAT64);
	END Procedure;
	END Test.

positive: procedure with parameters of constant long real type

	MODULE Test;
	PROCEDURE Procedure (CONST a, b, c: FLOAT64);
	END Procedure;
	END Test.

positive: procedure with intermixed parameters of long real type

	MODULE Test;
	PROCEDURE Procedure (a: FLOAT64; VAR b: FLOAT64; CONST c: FLOAT64);
	END Procedure;
	END Test.

positive: procedure with a parameter of basic set type

	MODULE Test;
	PROCEDURE Procedure (parameter: SET);
	END Procedure;
	END Test.

positive: procedure with parameters of basic set type

	MODULE Test;
	PROCEDURE Procedure (a, b, c: SET);
	END Procedure;
	END Test.

positive: procedure with a parameter of variable set type

	MODULE Test;
	PROCEDURE Procedure (VAR parameter: SET);
	END Procedure;
	END Test.

positive: procedure with parameters of variable set type

	MODULE Test;
	PROCEDURE Procedure (VAR a, b, c: SET);
	END Procedure;
	END Test.

positive: procedure with a parameter of constant set type

	MODULE Test;
	PROCEDURE Procedure (CONST parameter: SET);
	END Procedure;
	END Test.

positive: procedure with parameters of constant set type

	MODULE Test;
	PROCEDURE Procedure (CONST a, b, c: SET);
	END Procedure;
	END Test.

positive: procedure with intermixed parameters of set type

	MODULE Test;
	PROCEDURE Procedure (a: SET; VAR b: SET; CONST c: SET);
	END Procedure;
	END Test.

positive: procedure with a parameter of record type

	MODULE Test;
	TYPE Record = RECORD END;
	PROCEDURE Procedure (parameter: Record);
	END Procedure;
	END Test.

positive: procedure with parameters of record type

	MODULE Test;
	TYPE Record = RECORD END;
	PROCEDURE Procedure (a, b, c: Record);
	END Procedure;
	END Test.

positive: procedure with a parameter of variable record type

	MODULE Test;
	TYPE Record = RECORD END;
	PROCEDURE Procedure (VAR parameter: Record);
	END Procedure;
	END Test.

positive: procedure with parameters of variable record type

	MODULE Test;
	TYPE Record = RECORD END;
	PROCEDURE Procedure (VAR a, b, c: Record);
	END Procedure;
	END Test.

positive: procedure with a parameter of constant record type

	MODULE Test;
	TYPE Record = RECORD END;
	PROCEDURE Procedure (CONST parameter: Record);
	END Procedure;
	END Test.

positive: procedure with parameters of constant record type

	MODULE Test;
	TYPE Record = RECORD END;
	PROCEDURE Procedure (CONST a, b, c: Record);
	END Procedure;
	END Test.

positive: procedure with intermixed parameters of record type

	MODULE Test;
	TYPE Record = RECORD END;
	PROCEDURE Procedure (a: Record; VAR b: Record; CONST c: Record);
	END Procedure;
	END Test.

positive: procedure with a parameter of anonymous record type

	MODULE Test;
	TYPE Record = RECORD END;
	PROCEDURE Procedure (parameter: RECORD END);
	END Procedure;
	END Test.

positive: procedure with parameters of anonymous record type

	MODULE Test;
	PROCEDURE Procedure (a, b, c: RECORD END);
	END Procedure;
	END Test.

positive: procedure with a parameter of variable anonymous record type

	MODULE Test;
	PROCEDURE Procedure (VAR parameter: RECORD END);
	END Procedure;
	END Test.

positive: procedure with parameters of variable anonymous record type

	MODULE Test;
	PROCEDURE Procedure (VAR a, b, c: RECORD END);
	END Procedure;
	END Test.

positive: procedure with a parameter of constant anonymous record type

	MODULE Test;
	PROCEDURE Procedure (CONST parameter: RECORD END);
	END Procedure;
	END Test.

positive: procedure with parameters of constant anonymous record type

	MODULE Test;
	PROCEDURE Procedure (CONST a, b, c: RECORD END);
	END Procedure;
	END Test.

positive: procedure with intermixed parameters of anonymous record type

	MODULE Test;
	PROCEDURE Procedure (a: RECORD END; VAR b: RECORD END; CONST c: RECORD END);
	END Procedure;
	END Test.

positive: procedure with a parameter of array type

	MODULE Test;
	TYPE Array = ARRAY 10 OF RECORD END;
	PROCEDURE Procedure (parameter: Array);
	END Procedure;
	END Test.

positive: procedure with parameters of array type

	MODULE Test;
	TYPE Array = ARRAY 10 OF RECORD END;
	PROCEDURE Procedure (a, b, c: Array);
	END Procedure;
	END Test.

positive: procedure with a parameter of variable array type

	MODULE Test;
	TYPE Array = ARRAY 10 OF RECORD END;
	PROCEDURE Procedure (VAR parameter: Array);
	END Procedure;
	END Test.

positive: procedure with parameters of variable array type

	MODULE Test;
	TYPE Array = ARRAY 10 OF RECORD END;
	PROCEDURE Procedure (VAR a, b, c: Array);
	END Procedure;
	END Test.

positive: procedure with a parameter of constant array type

	MODULE Test;
	TYPE Array = ARRAY 10 OF RECORD END;
	PROCEDURE Procedure (CONST parameter: Array);
	END Procedure;
	END Test.

positive: procedure with parameters of constant array type

	MODULE Test;
	TYPE Array = ARRAY 10 OF RECORD END;
	PROCEDURE Procedure (CONST a, b, c: Array);
	END Procedure;
	END Test.

positive: procedure with intermixed parameters of array type

	MODULE Test;
	TYPE Array = ARRAY 10 OF RECORD END;
	PROCEDURE Procedure (a: Array; VAR b: Array; CONST c: Array);
	END Procedure;
	END Test.

positive: procedure with a parameter of anonymous array type

	MODULE Test;
	PROCEDURE Procedure (parameter: ARRAY 10 OF RECORD END);
	END Procedure;
	END Test.

positive: procedure with parameters of anonymous array type

	MODULE Test;
	PROCEDURE Procedure (a, b, c: ARRAY 10 OF RECORD END);
	END Procedure;
	END Test.

positive: procedure with a parameter of variable anonymous array type

	MODULE Test;
	PROCEDURE Procedure (VAR parameter: ARRAY 10 OF RECORD END);
	END Procedure;
	END Test.

positive: procedure with parameters of variable anonymous array type

	MODULE Test;
	PROCEDURE Procedure (VAR a, b, c: ARRAY 10 OF RECORD END);
	END Procedure;
	END Test.

positive: procedure with a parameter of constant anonymous array type

	MODULE Test;
	PROCEDURE Procedure (CONST parameter: ARRAY 10 OF RECORD END);
	END Procedure;
	END Test.

positive: procedure with parameters of constant anonymous array type

	MODULE Test;
	PROCEDURE Procedure (CONST a, b, c: ARRAY 10 OF RECORD END);
	END Procedure;
	END Test.

positive: procedure with intermixed parameters of anonymous array type

	MODULE Test;
	PROCEDURE Procedure (a: ARRAY 10 OF RECORD END; VAR b: ARRAY 10 OF RECORD END; CONST c: ARRAY 10 OF RECORD END);
	END Procedure;
	END Test.

positive: procedure with a parameter of open array type

	MODULE Test;
	TYPE Array = ARRAY OF RECORD END;
	PROCEDURE Procedure (parameter: Array);
	END Procedure;
	END Test.

positive: procedure with parameters of open array type

	MODULE Test;
	TYPE Array = ARRAY OF RECORD END;
	PROCEDURE Procedure (a, b, c: Array);
	END Procedure;
	END Test.

positive: procedure with a parameter of variable open array type

	MODULE Test;
	TYPE Array = ARRAY OF RECORD END;
	PROCEDURE Procedure (VAR parameter: Array);
	END Procedure;
	END Test.

positive: procedure with parameters of variable open array type

	MODULE Test;
	TYPE Array = ARRAY OF RECORD END;
	PROCEDURE Procedure (VAR a, b, c: Array);
	END Procedure;
	END Test.

positive: procedure with a parameter of constant open array type

	MODULE Test;
	TYPE Array = ARRAY OF RECORD END;
	PROCEDURE Procedure (CONST parameter: Array);
	END Procedure;
	END Test.

positive: procedure with parameters of constant open array type

	MODULE Test;
	TYPE Array = ARRAY OF RECORD END;
	PROCEDURE Procedure (CONST a, b, c: Array);
	END Procedure;
	END Test.

positive: procedure with intermixed parameters of open array type

	MODULE Test;
	TYPE Array = ARRAY OF RECORD END;
	PROCEDURE Procedure (a: Array; VAR b: Array; CONST c: Array);
	END Procedure;
	END Test.

positive: procedure with a parameter of anonymous open array type

	MODULE Test;
	PROCEDURE Procedure (parameter: ARRAY OF RECORD END);
	END Procedure;
	END Test.

positive: procedure with parameters of anonymous open array type

	MODULE Test;
	PROCEDURE Procedure (a, b, c: ARRAY OF RECORD END);
	END Procedure;
	END Test.

positive: procedure with a parameter of variable anonymous open array type

	MODULE Test;
	PROCEDURE Procedure (VAR parameter: ARRAY OF RECORD END);
	END Procedure;
	END Test.

positive: procedure with parameters of variable anonymous open array type

	MODULE Test;
	PROCEDURE Procedure (VAR a, b, c: ARRAY OF RECORD END);
	END Procedure;
	END Test.

positive: procedure with a parameter of constant anonymous open array type

	MODULE Test;
	PROCEDURE Procedure (CONST parameter: ARRAY OF RECORD END);
	END Procedure;
	END Test.

positive: procedure with parameters of constant anonymous open array type

	MODULE Test;
	PROCEDURE Procedure (CONST a, b, c: ARRAY OF RECORD END);
	END Procedure;
	END Test.

positive: procedure with intermixed parameters of anonymous open array type

	MODULE Test;
	PROCEDURE Procedure (a: ARRAY OF RECORD END; VAR b: ARRAY OF RECORD END; CONST c: ARRAY OF RECORD END);
	END Procedure;
	END Test.

positive: procedure with a parameter of object type

	MODULE Test;
	TYPE Object = OBJECT END Object;
	PROCEDURE Procedure (parameter: Object);
	END Procedure;
	END Test.

positive: procedure with a parameter of plain object type

	MODULE Test;
	TYPE Object = OBJECT;
	PROCEDURE Procedure (parameter: Object);
	END Procedure;
	END Test.

positive: procedure with parameters of object type

	MODULE Test;
	TYPE Object = OBJECT END Object;
	PROCEDURE Procedure (a, b, c: Object);
	END Procedure;
	END Test.

positive: procedure with a parameter of variable object type

	MODULE Test;
	TYPE Object = OBJECT END Object;
	PROCEDURE Procedure (VAR parameter: Object);
	END Procedure;
	END Test.

positive: procedure with parameters of variable object type

	MODULE Test;
	TYPE Object = OBJECT END Object;
	PROCEDURE Procedure (VAR a, b, c: Object);
	END Procedure;
	END Test.

positive: procedure with a parameter of constant object type

	MODULE Test;
	TYPE Object = OBJECT END Object;
	PROCEDURE Procedure (CONST parameter: Object);
	END Procedure;
	END Test.

positive: procedure with parameters of constant object type

	MODULE Test;
	TYPE Object = OBJECT END Object;
	PROCEDURE Procedure (CONST a, b, c: Object);
	END Procedure;
	END Test.

positive: procedure with intermixed parameters of object type

	MODULE Test;
	TYPE Object = OBJECT END Object;
	PROCEDURE Procedure (a: Object; VAR b: Object; CONST c: Object);
	END Procedure;
	END Test.

positive: procedure with intermixed parameters of plain object type

	MODULE Test;
	TYPE Object = OBJECT;
	PROCEDURE Procedure (a: Object; VAR b: Object; CONST c: Object);
	END Procedure;
	END Test.

positive: procedure with a parameter of anonymous object type

	MODULE Test;
	PROCEDURE Procedure (parameter: OBJECT END);
	END Procedure;
	END Test.

positive: procedure with a parameter of anonymous plain object type

	MODULE Test;
	PROCEDURE Procedure (parameter: OBJECT);
	END Procedure;
	END Test.

positive: procedure with parameters of anonymous object type

	MODULE Test;
	PROCEDURE Procedure (a, b, c: OBJECT END);
	END Procedure;
	END Test.

positive: procedure with a parameter of variable anonymous object type

	MODULE Test;
	PROCEDURE Procedure (VAR parameter: OBJECT END);
	END Procedure;
	END Test.

positive: procedure with parameters of variable anonymous object type

	MODULE Test;
	PROCEDURE Procedure (VAR a, b, c: OBJECT END);
	END Procedure;
	END Test.

positive: procedure with a parameter of constant anonymous object type

	MODULE Test;
	PROCEDURE Procedure (CONST parameter: OBJECT END);
	END Procedure;
	END Test.

positive: procedure with parameters of constant anonymous object type

	MODULE Test;
	PROCEDURE Procedure (CONST a, b, c: OBJECT END);
	END Procedure;
	END Test.

positive: procedure with intermixed parameters of anonymous object type

	MODULE Test;
	PROCEDURE Procedure (a: OBJECT END; VAR b: OBJECT END; CONST c: OBJECT END);
	END Procedure;
	END Test.

positive: procedure with intermixed parameters of anonymous plain object type

	MODULE Test;
	PROCEDURE Procedure (a: OBJECT; VAR b: OBJECT; CONST c: OBJECT);
	END Procedure;
	END Test.

positive: procedure with a parameter of pointer type

	MODULE Test;
	TYPE Pointer = POINTER TO RECORD END;
	PROCEDURE Procedure (parameter: Pointer);
	END Procedure;
	END Test.

positive: procedure with parameters of pointer type

	MODULE Test;
	TYPE Pointer = POINTER TO RECORD END;
	PROCEDURE Procedure (a, b, c: Pointer);
	END Procedure;
	END Test.

positive: procedure with a parameter of variable pointer type

	MODULE Test;
	TYPE Pointer = POINTER TO RECORD END;
	PROCEDURE Procedure (VAR parameter: Pointer);
	END Procedure;
	END Test.

positive: procedure with parameters of variable pointer type

	MODULE Test;
	TYPE Pointer = POINTER TO RECORD END;
	PROCEDURE Procedure (VAR a, b, c: Pointer);
	END Procedure;
	END Test.

positive: procedure with a parameter of constant pointer type

	MODULE Test;
	TYPE Pointer = POINTER TO RECORD END;
	PROCEDURE Procedure (CONST parameter: Pointer);
	END Procedure;
	END Test.

positive: procedure with parameters of constant pointer type

	MODULE Test;
	TYPE Pointer = POINTER TO RECORD END;
	PROCEDURE Procedure (CONST a, b, c: Pointer);
	END Procedure;
	END Test.

positive: procedure with intermixed parameters of pointer type

	MODULE Test;
	TYPE Pointer = POINTER TO RECORD END;
	PROCEDURE Procedure (a: Pointer; VAR b: Pointer; CONST c: Pointer);
	END Procedure;
	END Test.

positive: procedure with a parameter of anonymous pointer type

	MODULE Test;
	PROCEDURE Procedure (parameter: POINTER TO RECORD END);
	END Procedure;
	END Test.

positive: procedure with parameters of anonymous pointer type

	MODULE Test;
	PROCEDURE Procedure (a, b, c: POINTER TO RECORD END);
	END Procedure;
	END Test.

positive: procedure with a parameter of variable anonymous pointer type

	MODULE Test;
	PROCEDURE Procedure (VAR parameter: POINTER TO RECORD END);
	END Procedure;
	END Test.

positive: procedure with parameters of variable anonymous pointer type

	MODULE Test;
	PROCEDURE Procedure (VAR a, b, c: POINTER TO RECORD END);
	END Procedure;
	END Test.

positive: procedure with a parameter of constant anonymous pointer type

	MODULE Test;
	PROCEDURE Procedure (CONST parameter: OBJECT END);
	END Procedure;
	END Test.

positive: procedure with parameters of constant anonymous pointer type

	MODULE Test;
	PROCEDURE Procedure (CONST a, b, c: POINTER TO RECORD END);
	END Procedure;
	END Test.

positive: procedure with intermixed parameters of anonymous pointer type

	MODULE Test;
	PROCEDURE Procedure (a: POINTER TO RECORD END; VAR b: POINTER TO RECORD END; CONST c: POINTER TO RECORD END);
	END Procedure;
	END Test.

positive: procedure with a parameter of procedure type

	MODULE Test;
	TYPE Proc = PROCEDURE;
	PROCEDURE Procedure (parameter: Proc);
	END Procedure;
	END Test.

positive: procedure with parameters of procedure type

	MODULE Test;
	TYPE Proc = PROCEDURE;
	PROCEDURE Procedure (a, b, c: Proc);
	END Procedure;
	END Test.

positive: procedure with a parameter of variable procedure type

	MODULE Test;
	TYPE Proc = PROCEDURE;
	PROCEDURE Procedure (VAR parameter: Proc);
	END Procedure;
	END Test.

positive: procedure with parameters of variable procedure type

	MODULE Test;
	TYPE Proc = PROCEDURE;
	PROCEDURE Procedure (VAR a, b, c: Proc);
	END Procedure;
	END Test.

positive: procedure with a parameter of constant procedure type

	MODULE Test;
	TYPE Proc = PROCEDURE;
	PROCEDURE Procedure (CONST parameter: Proc);
	END Procedure;
	END Test.

positive: procedure with parameters of constant procedure type

	MODULE Test;
	TYPE Proc = PROCEDURE;
	PROCEDURE Procedure (CONST a, b, c: Proc);
	END Procedure;
	END Test.

positive: procedure with intermixed parameters of procedure type

	MODULE Test;
	TYPE Proc = PROCEDURE;
	PROCEDURE Procedure (a: Proc; VAR b: Proc; CONST c: Proc);
	END Procedure;
	END Test.

positive: procedure with a parameter of anonymous procedure type

	MODULE Test;
	PROCEDURE Procedure (parameter: PROCEDURE);
	END Procedure;
	END Test.

positive: procedure with parameters of anonymous procedure type

	MODULE Test;
	PROCEDURE Procedure (a, b, c: PROCEDURE);
	END Procedure;
	END Test.

positive: procedure with a parameter of variable anonymous procedure type

	MODULE Test;
	PROCEDURE Procedure (VAR parameter: PROCEDURE);
	END Procedure;
	END Test.

positive: procedure with parameters of variable anonymous procedure type

	MODULE Test;
	PROCEDURE Procedure (VAR a, b, c: PROCEDURE);
	END Procedure;
	END Test.

positive: procedure with a parameter of constant anonymous procedure type

	MODULE Test;
	PROCEDURE Procedure (CONST parameter: PROCEDURE);
	END Procedure;
	END Test.

positive: procedure with parameters of constant anonymous procedure type

	MODULE Test;
	PROCEDURE Procedure (CONST a, b, c: PROCEDURE);
	END Procedure;
	END Test.

positive: procedure with intermixed parameters of anonymous procedure type

	MODULE Test;
	PROCEDURE Procedure (a: PROCEDURE; VAR b: PROCEDURE; CONST c: PROCEDURE);
	END Procedure;
	END Test.

negative: procedure with parameters of local type

	MODULE Test;
	PROCEDURE Procedure (parameter: Type);
	TYPE Type = RECORD END;
	END Procedure;
	END Test.

negative: procedure with parameter and local constant with same name

	MODULE Test;
	PROCEDURE Procedure (parameter: SET);
	CONST parameter = 10;
	END Procedure;
	END Test.

negative: procedure with parameter and local type with same name

	MODULE Test;
	PROCEDURE Procedure (parameter: SET);
	TYPE parameter = RECORD END;
	END Procedure;
	END Test.

negative: procedure with parameter and local variable with same name

	MODULE Test;
	PROCEDURE Procedure (parameter: SET);
	VAR parameter: SIGNED32;
	END Procedure;
	END Test.

negative: procedure with parameter and nested procedure with same name

	MODULE Test;
	PROCEDURE Procedure (parameter: SET);
		PROCEDURE parameter; END parameter;
	END Procedure;
	END Test.

positive: boolean parameter assignment

	MODULE Test;
	PROCEDURE Procedure (value: BOOLEAN); BEGIN value := value; END Procedure;
	END Test.

positive: char parameter assignment

	MODULE Test;
	PROCEDURE Procedure (value: CHAR); BEGIN value := value; END Procedure;
	END Test.

positive: short integer parameter assignment

	MODULE Test;
	PROCEDURE Procedure (value: SIGNED8); BEGIN value := value; END Procedure;
	END Test.

positive: integer parameter assignment

	MODULE Test;
	PROCEDURE Procedure (VAR value: SIGNED16); BEGIN value := value; END Procedure;
	END Test.

positive: long integer parameter assignment

	MODULE Test;
	PROCEDURE Procedure (value: SIGNED32); BEGIN value := value; END Procedure;
	END Test.

positive: huge integer parameter assignment

	MODULE Test;
	PROCEDURE Procedure (value: SIGNED64); BEGIN value := value; END Procedure;
	END Test.

positive: real parameter assignment

	MODULE Test;
	PROCEDURE Procedure (value: FLOAT32); BEGIN value := value; END Procedure;
	END Test.

positive: long real parameter assignment

	MODULE Test;
	PROCEDURE Procedure (value: FLOAT64); BEGIN value := value; END Procedure;
	END Test.

positive: set parameter assignment

	MODULE Test;
	PROCEDURE Procedure (value: SET); BEGIN value := value; END Procedure;
	END Test.

positive: array parameter assignment

	MODULE Test;
	PROCEDURE Procedure (value: ARRAY 10 OF CHAR); BEGIN value := value; END Procedure;
	END Test.

positive: array parameter element assignment

	MODULE Test;
	PROCEDURE Procedure (value: ARRAY 10 OF CHAR); BEGIN value[0] := value[0]; END Procedure;
	END Test.

negative: open array parameter assignment

	MODULE Test;
	PROCEDURE Procedure (value: ARRAY OF CHAR); BEGIN value := value; END Procedure;
	END Test.

positive: open array parameter element assignment

	MODULE Test;
	PROCEDURE Procedure (value: ARRAY OF CHAR); BEGIN value[0] := value[0]; END Procedure;
	END Test.

positive: record parameter assignment

	MODULE Test;
	PROCEDURE Procedure (value: RECORD END); BEGIN value := value; END Procedure;
	END Test.

positive: record parameter member assignment

	MODULE Test;
	PROCEDURE Procedure (value: RECORD member: SIGNED16 END); BEGIN value.member := value.member; END Procedure;
	END Test.

positive: object parameter assignment

	MODULE Test;
	PROCEDURE Procedure (value: OBJECT END); BEGIN value := value; END Procedure;
	END Test.

positive: object parameter member assignment

	MODULE Test;
	PROCEDURE Procedure (value: OBJECT VAR member: SIGNED16 END); BEGIN value.member := value.member; END Procedure;
	END Test.

positive: base object parameter assignment

	MODULE Test;
	PROCEDURE Procedure (value: OBJECT); BEGIN value := value; END Procedure;
	END Test.

positive: pointer to array parameter assignment

	MODULE Test;
	PROCEDURE Procedure (value: POINTER TO ARRAY 10 OF CHAR); BEGIN value := value; END Procedure;
	END Test.

positive: pointer to array parameter element assignment

	MODULE Test;
	PROCEDURE Procedure (value: POINTER TO ARRAY 10 OF CHAR); BEGIN value[0] := value[0]; END Procedure;
	END Test.

positive: pointer to open array parameter assignment

	MODULE Test;
	PROCEDURE Procedure (value: POINTER TO ARRAY OF CHAR); BEGIN value := value; END Procedure;
	END Test.

positive: pointer to open array parameter element assignment

	MODULE Test;
	PROCEDURE Procedure (value: POINTER TO ARRAY OF CHAR); BEGIN value[0] := value[0]; END Procedure;
	END Test.

positive: pointer to record parameter assignment

	MODULE Test;
	PROCEDURE Procedure (value: POINTER TO RECORD END); BEGIN value := value; END Procedure;
	END Test.

positive: pointer to record parameter member assignment

	MODULE Test;
	PROCEDURE Procedure (value: POINTER TO RECORD member: SIGNED16 END); BEGIN value.member := value.member; END Procedure;
	END Test.

positive: procedure parameter assignment

	MODULE Test;
	PROCEDURE Procedure (value: PROCEDURE); BEGIN value := value; END Procedure;
	END Test.

positive: variable boolean parameter assignment

	MODULE Test;
	PROCEDURE Procedure (VAR value: BOOLEAN); BEGIN value := value; END Procedure;
	END Test.

positive: variable char parameter assignment

	MODULE Test;
	PROCEDURE Procedure (VAR value: CHAR); BEGIN value := value; END Procedure;
	END Test.

positive: variable short integer parameter assignment

	MODULE Test;
	PROCEDURE Procedure (VAR value: SIGNED8); BEGIN value := value; END Procedure;
	END Test.

positive: variable integer parameter assignment

	MODULE Test;
	PROCEDURE Procedure (VAR value: SIGNED16); BEGIN value := value; END Procedure;
	END Test.

positive: variable long integer parameter assignment

	MODULE Test;
	PROCEDURE Procedure (VAR value: SIGNED32); BEGIN value := value; END Procedure;
	END Test.

positive: variable huge integer parameter assignment

	MODULE Test;
	PROCEDURE Procedure (VAR value: SIGNED64); BEGIN value := value; END Procedure;
	END Test.

positive: variable real parameter assignment

	MODULE Test;
	PROCEDURE Procedure (VAR value: FLOAT32); BEGIN value := value; END Procedure;
	END Test.

positive: variable long real parameter assignment

	MODULE Test;
	PROCEDURE Procedure (VAR value: FLOAT64); BEGIN value := value; END Procedure;
	END Test.

positive: variable set parameter assignment

	MODULE Test;
	PROCEDURE Procedure (VAR value: SET); BEGIN value := value; END Procedure;
	END Test.

positive: variable array parameter assignment

	MODULE Test;
	PROCEDURE Procedure (VAR value: ARRAY 10 OF CHAR); BEGIN value := value; END Procedure;
	END Test.

positive: variable array parameter element assignment

	MODULE Test;
	PROCEDURE Procedure (VAR value: ARRAY 10 OF CHAR); BEGIN value[0] := value[0]; END Procedure;
	END Test.

negative: variable open array parameter assignment

	MODULE Test;
	PROCEDURE Procedure (VAR value: ARRAY OF CHAR); BEGIN value := value; END Procedure;
	END Test.

positive: variable open array parameter element assignment

	MODULE Test;
	PROCEDURE Procedure (VAR value: ARRAY OF CHAR); BEGIN value[0] := value[0]; END Procedure;
	END Test.

positive: variable record parameter assignment

	MODULE Test;
	PROCEDURE Procedure (VAR value: RECORD END); BEGIN value := value; END Procedure;
	END Test.

positive: variable record parameter member assignment

	MODULE Test;
	PROCEDURE Procedure (VAR value: RECORD member: SIGNED16 END); BEGIN value.member := value.member; END Procedure;
	END Test.

positive: variable object parameter assignment

	MODULE Test;
	PROCEDURE Procedure (VAR value: OBJECT END); BEGIN value := value; END Procedure;
	END Test.

positive: variable object parameter member assignment

	MODULE Test;
	PROCEDURE Procedure (VAR value: OBJECT VAR member: SIGNED16 END); BEGIN value.member := value.member; END Procedure;
	END Test.

positive: variable base object parameter assignment

	MODULE Test;
	PROCEDURE Procedure (VAR value: OBJECT); BEGIN value := value; END Procedure;
	END Test.

positive: variable pointer to array parameter assignment

	MODULE Test;
	PROCEDURE Procedure (VAR value: POINTER TO ARRAY 10 OF CHAR); BEGIN value := value; END Procedure;
	END Test.

positive: variable pointer to array parameter element assignment

	MODULE Test;
	PROCEDURE Procedure (VAR value: POINTER TO ARRAY 10 OF CHAR); BEGIN value[0] := value[0]; END Procedure;
	END Test.

positive: variable pointer to open array parameter assignment

	MODULE Test;
	PROCEDURE Procedure (VAR value: POINTER TO ARRAY OF CHAR); BEGIN value := value; END Procedure;
	END Test.

positive: variable pointer to open array parameter element assignment

	MODULE Test;
	PROCEDURE Procedure (VAR value: POINTER TO ARRAY OF CHAR); BEGIN value[0] := value[0]; END Procedure;
	END Test.

positive: variable pointer to record parameter assignment

	MODULE Test;
	PROCEDURE Procedure (VAR value: POINTER TO RECORD END); BEGIN value := value; END Procedure;
	END Test.

positive: variable pointer to record parameter member assignment

	MODULE Test;
	PROCEDURE Procedure (VAR value: POINTER TO RECORD member: SIGNED16 END); BEGIN value.member := value.member; END Procedure;
	END Test.

positive: variable procedure parameter assignment

	MODULE Test;
	PROCEDURE Procedure (VAR value: PROCEDURE); BEGIN value := value; END Procedure;
	END Test.

negative: constant boolean parameter assignment

	MODULE Test;
	PROCEDURE Procedure (CONST value: BOOLEAN); BEGIN value := value; END Procedure;
	END Test.

negative: constant char parameter assignment

	MODULE Test;
	PROCEDURE Procedure (CONST value: CHAR); BEGIN value := value; END Procedure;
	END Test.

negative: constant short integer parameter assignment

	MODULE Test;
	PROCEDURE Procedure (CONST value: SIGNED8); BEGIN value := value; END Procedure;
	END Test.

negative: constant integer parameter assignment

	MODULE Test;
	PROCEDURE Procedure (CONST value: SIGNED16); BEGIN value := value; END Procedure;
	END Test.

negative: constant long integer parameter assignment

	MODULE Test;
	PROCEDURE Procedure (CONST value: SIGNED32); BEGIN value := value; END Procedure;
	END Test.

negative: constant huge integer parameter assignment

	MODULE Test;
	PROCEDURE Procedure (CONST value: SIGNED64); BEGIN value := value; END Procedure;
	END Test.

negative: constant real parameter assignment

	MODULE Test;
	PROCEDURE Procedure (CONST value: FLOAT32); BEGIN value := value; END Procedure;
	END Test.

negative: constant long real parameter assignment

	MODULE Test;
	PROCEDURE Procedure (CONST value: FLOAT64); BEGIN value := value; END Procedure;
	END Test.

negative: constant set parameter assignment

	MODULE Test;
	PROCEDURE Procedure (CONST value: SET); BEGIN value := value; END Procedure;
	END Test.

negative: constant array parameter assignment

	MODULE Test;
	PROCEDURE Procedure (CONST value: ARRAY 10 OF CHAR); BEGIN value := value; END Procedure;
	END Test.

negative: constant array parameter element assignment

	MODULE Test;
	PROCEDURE Procedure (CONST value: ARRAY 10 OF CHAR); BEGIN value[0] := value[0]; END Procedure;
	END Test.

negative: constant open array parameter assignment

	MODULE Test;
	PROCEDURE Procedure (CONST value: ARRAY OF CHAR); BEGIN value := value; END Procedure;
	END Test.

negative: constant open array parameter element assignment

	MODULE Test;
	PROCEDURE Procedure (CONST value: ARRAY OF CHAR); BEGIN value[0] := value[0]; END Procedure;
	END Test.

negative: constant record parameter assignment

	MODULE Test;
	PROCEDURE Procedure (CONST value: RECORD END); BEGIN value := value; END Procedure;
	END Test.

negative: constant record parameter member assignment

	MODULE Test;
	PROCEDURE Procedure (CONST value: RECORD member: SIGNED16 END); BEGIN value.member := value.member; END Procedure;
	END Test.

negative: constant object parameter assignment

	MODULE Test;
	PROCEDURE Procedure (CONST value: OBJECT END); BEGIN value := value; END Procedure;
	END Test.

positive: constant object parameter member assignment

	MODULE Test;
	PROCEDURE Procedure (CONST value: OBJECT VAR member: SIGNED16 END); BEGIN value.member := value.member; END Procedure;
	END Test.

negative: constant base object parameter assignment

	MODULE Test;
	PROCEDURE Procedure (CONST value: OBJECT); BEGIN value := value; END Procedure;
	END Test.

negative: constant pointer to array parameter assignment

	MODULE Test;
	PROCEDURE Procedure (CONST value: POINTER TO ARRAY 10 OF CHAR); BEGIN value := value; END Procedure;
	END Test.

positive: constant pointer to array parameter element assignment

	MODULE Test;
	PROCEDURE Procedure (CONST value: POINTER TO ARRAY 10 OF CHAR); BEGIN value[0] := value[0]; END Procedure;
	END Test.

negative: constant pointer to open array parameter assignment

	MODULE Test;
	PROCEDURE Procedure (CONST value: POINTER TO ARRAY OF CHAR); BEGIN value := value; END Procedure;
	END Test.

positive: constant pointer to open array parameter element assignment

	MODULE Test;
	PROCEDURE Procedure (CONST value: POINTER TO ARRAY OF CHAR); BEGIN value[0] := value[0]; END Procedure;
	END Test.

negative: constant pointer to record parameter assignment

	MODULE Test;
	PROCEDURE Procedure (CONST value: POINTER TO RECORD END); BEGIN value := value; END Procedure;
	END Test.

positive: constant pointer to record parameter member assignment

	MODULE Test;
	PROCEDURE Procedure (CONST value: POINTER TO RECORD member: SIGNED16 END); BEGIN value.member := value.member; END Procedure;
	END Test.

negative: constant procedure parameter assignment

	MODULE Test;
	PROCEDURE Procedure (CONST value: PROCEDURE); BEGIN value := value; END Procedure;
	END Test.

positive: calling procedure with boolean parameter with boolean argument

	MODULE Test;
	VAR argument: BOOLEAN;
	PROCEDURE Procedure (value: BOOLEAN); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with boolean parameter with character argument

	MODULE Test;
	VAR argument: CHAR;
	PROCEDURE Procedure (value: BOOLEAN); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with boolean parameter with short integer argument

	MODULE Test;
	VAR argument: SIGNED8;
	PROCEDURE Procedure (value: BOOLEAN); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with boolean parameter with integer argument

	MODULE Test;
	VAR argument: SIGNED16;
	PROCEDURE Procedure (value: BOOLEAN); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with boolean parameter with long integer argument

	MODULE Test;
	VAR argument: SIGNED32;
	PROCEDURE Procedure (value: BOOLEAN); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with boolean parameter with huge integer argument

	MODULE Test;
	VAR argument: SIGNED64;
	PROCEDURE Procedure (value: BOOLEAN); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with boolean parameter with real argument

	MODULE Test;
	VAR argument: FLOAT32;
	PROCEDURE Procedure (value: BOOLEAN); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with boolean parameter with long real argument

	MODULE Test;
	VAR argument: FLOAT64;
	PROCEDURE Procedure (value: BOOLEAN); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with boolean parameter with set argument

	MODULE Test;
	VAR argument: SET;
	PROCEDURE Procedure (value: BOOLEAN); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with boolean parameter with array argument

	MODULE Test;
	VAR argument: ARRAY 10 OF CHAR;
	PROCEDURE Procedure (value: BOOLEAN); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with boolean parameter with record argument

	MODULE Test;
	VAR argument: RECORD END;
	PROCEDURE Procedure (value: BOOLEAN); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with boolean parameter with object argument

	MODULE Test;
	VAR argument: OBJECT END;
	PROCEDURE Procedure (value: BOOLEAN); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with boolean parameter with base object argument

	MODULE Test;
	VAR argument: OBJECT;
	PROCEDURE Procedure (value: BOOLEAN); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with boolean parameter with pointer to array argument

	MODULE Test;
	VAR argument: POINTER TO ARRAY 10 OF CHAR;
	PROCEDURE Procedure (value: BOOLEAN); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with boolean parameter with pointer to record argument

	MODULE Test;
	VAR argument: POINTER TO RECORD END;
	PROCEDURE Procedure (value: BOOLEAN); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with boolean parameter with procedure argument

	MODULE Test;
	VAR argument: PROCEDURE;
	PROCEDURE Procedure (value: BOOLEAN); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with character parameter with boolean argument

	MODULE Test;
	VAR argument: BOOLEAN;
	PROCEDURE Procedure (value: CHAR); END Procedure;
	BEGIN Procedure (argument);
	END Test.

positive: calling procedure with character parameter with character argument

	MODULE Test;
	VAR argument: CHAR;
	PROCEDURE Procedure (value: CHAR); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with character parameter with short integer argument

	MODULE Test;
	VAR argument: SIGNED8;
	PROCEDURE Procedure (value: CHAR); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with character parameter with integer argument

	MODULE Test;
	VAR argument: SIGNED16;
	PROCEDURE Procedure (value: CHAR); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with character parameter with long integer argument

	MODULE Test;
	VAR argument: SIGNED32;
	PROCEDURE Procedure (value: CHAR); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with character parameter with huge integer argument

	MODULE Test;
	VAR argument: SIGNED64;
	PROCEDURE Procedure (value: CHAR); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with character parameter with real argument

	MODULE Test;
	VAR argument: FLOAT32;
	PROCEDURE Procedure (value: CHAR); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with character parameter with long real argument

	MODULE Test;
	VAR argument: FLOAT64;
	PROCEDURE Procedure (value: CHAR); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with character parameter with set argument

	MODULE Test;
	VAR argument: SET;
	PROCEDURE Procedure (value: CHAR); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with character parameter with array argument

	MODULE Test;
	VAR argument: ARRAY 10 OF CHAR;
	PROCEDURE Procedure (value: CHAR); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with character parameter with record argument

	MODULE Test;
	VAR argument: RECORD END;
	PROCEDURE Procedure (value: CHAR); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with character parameter with object argument

	MODULE Test;
	VAR argument: OBJECT END;
	PROCEDURE Procedure (value: CHAR); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with character parameter with base object argument

	MODULE Test;
	VAR argument: OBJECT;
	PROCEDURE Procedure (value: CHAR); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with character parameter with pointer to array argument

	MODULE Test;
	VAR argument: POINTER TO ARRAY 10 OF CHAR;
	PROCEDURE Procedure (value: CHAR); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with character parameter with pointer to record argument

	MODULE Test;
	VAR argument: POINTER TO RECORD END;
	PROCEDURE Procedure (value: CHAR); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with character parameter with procedure argument

	MODULE Test;
	VAR argument: PROCEDURE;
	PROCEDURE Procedure (value: CHAR); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with short integer parameter with boolean argument

	MODULE Test;
	VAR argument: BOOLEAN;
	PROCEDURE Procedure (value: SIGNED8); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with short integer parameter with character argument

	MODULE Test;
	VAR argument: CHAR;
	PROCEDURE Procedure (value: SIGNED8); END Procedure;
	BEGIN Procedure (argument);
	END Test.

positive: calling procedure with short integer parameter with short integer argument

	MODULE Test;
	VAR argument: SIGNED8;
	PROCEDURE Procedure (value: SIGNED8); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with short integer parameter with integer argument

	MODULE Test;
	VAR argument: SIGNED16;
	PROCEDURE Procedure (value: SIGNED8); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with short integer parameter with long integer argument

	MODULE Test;
	VAR argument: SIGNED32;
	PROCEDURE Procedure (value: SIGNED8); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with short integer parameter with huge integer argument

	MODULE Test;
	VAR argument: SIGNED64;
	PROCEDURE Procedure (value: SIGNED8); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with short integer parameter with real argument

	MODULE Test;
	VAR argument: FLOAT32;
	PROCEDURE Procedure (value: SIGNED8); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with short integer parameter with long real argument

	MODULE Test;
	VAR argument: FLOAT64;
	PROCEDURE Procedure (value: SIGNED8); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with short integer parameter with set argument

	MODULE Test;
	VAR argument: SET;
	PROCEDURE Procedure (value: SIGNED8); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with short integer parameter with array argument

	MODULE Test;
	VAR argument: ARRAY 10 OF CHAR;
	PROCEDURE Procedure (value: SIGNED8); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with short integer parameter with record argument

	MODULE Test;
	VAR argument: RECORD END;
	PROCEDURE Procedure (value: SIGNED8); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with short integer parameter with object argument

	MODULE Test;
	VAR argument: OBJECT END;
	PROCEDURE Procedure (value: SIGNED8); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with short integer parameter with base object argument

	MODULE Test;
	VAR argument: OBJECT;
	PROCEDURE Procedure (value: SIGNED8); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with short integer parameter with pointer to array argument

	MODULE Test;
	VAR argument: POINTER TO ARRAY 10 OF CHAR;
	PROCEDURE Procedure (value: SIGNED8); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with short integer parameter with pointer to record argument

	MODULE Test;
	VAR argument: POINTER TO RECORD END;
	PROCEDURE Procedure (value: SIGNED8); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with short integer parameter with procedure argument

	MODULE Test;
	VAR argument: PROCEDURE;
	PROCEDURE Procedure (value: SIGNED8); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with integer parameter with boolean argument

	MODULE Test;
	VAR argument: BOOLEAN;
	PROCEDURE Procedure (value: SIGNED16); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with integer parameter with character argument

	MODULE Test;
	VAR argument: CHAR;
	PROCEDURE Procedure (value: SIGNED16); END Procedure;
	BEGIN Procedure (argument);
	END Test.

positive: calling procedure with integer parameter with short integer argument

	MODULE Test;
	VAR argument: SIGNED8;
	PROCEDURE Procedure (value: SIGNED16); END Procedure;
	BEGIN Procedure (argument);
	END Test.

positive: calling procedure with integer parameter with integer argument

	MODULE Test;
	VAR argument: SIGNED16;
	PROCEDURE Procedure (value: SIGNED16); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with integer parameter with long integer argument

	MODULE Test;
	VAR argument: SIGNED32;
	PROCEDURE Procedure (value: SIGNED16); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with integer parameter with huge integer argument

	MODULE Test;
	VAR argument: SIGNED64;
	PROCEDURE Procedure (value: SIGNED16); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with integer parameter with real argument

	MODULE Test;
	VAR argument: FLOAT32;
	PROCEDURE Procedure (value: SIGNED16); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with integer parameter with long real argument

	MODULE Test;
	VAR argument: FLOAT64;
	PROCEDURE Procedure (value: SIGNED16); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with integer parameter with set argument

	MODULE Test;
	VAR argument: SET;
	PROCEDURE Procedure (value: SIGNED16); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with integer parameter with array argument

	MODULE Test;
	VAR argument: ARRAY 10 OF CHAR;
	PROCEDURE Procedure (value: SIGNED16); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with integer parameter with record argument

	MODULE Test;
	VAR argument: RECORD END;
	PROCEDURE Procedure (value: SIGNED16); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with integer parameter with object argument

	MODULE Test;
	VAR argument: OBJECT END;
	PROCEDURE Procedure (value: SIGNED16); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with integer parameter with base object argument

	MODULE Test;
	VAR argument: OBJECT;
	PROCEDURE Procedure (value: SIGNED16); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with integer parameter with pointer to array argument

	MODULE Test;
	VAR argument: POINTER TO ARRAY 10 OF CHAR;
	PROCEDURE Procedure (value: SIGNED16); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with integer parameter with pointer to record argument

	MODULE Test;
	VAR argument: POINTER TO RECORD END;
	PROCEDURE Procedure (value: SIGNED16); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with integer parameter with procedure argument

	MODULE Test;
	VAR argument: PROCEDURE;
	PROCEDURE Procedure (value: SIGNED16); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with long integer parameter with boolean argument

	MODULE Test;
	VAR argument: BOOLEAN;
	PROCEDURE Procedure (value: SIGNED32); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with long integer parameter with character argument

	MODULE Test;
	VAR argument: CHAR;
	PROCEDURE Procedure (value: SIGNED32); END Procedure;
	BEGIN Procedure (argument);
	END Test.

positive: calling procedure with long integer parameter with short integer argument

	MODULE Test;
	VAR argument: SIGNED8;
	PROCEDURE Procedure (value: SIGNED32); END Procedure;
	BEGIN Procedure (argument);
	END Test.

positive: calling procedure with long integer parameter with integer argument

	MODULE Test;
	VAR argument: SIGNED16;
	PROCEDURE Procedure (value: SIGNED32); END Procedure;
	BEGIN Procedure (argument);
	END Test.

positive: calling procedure with long integer parameter with long integer argument

	MODULE Test;
	VAR argument: SIGNED32;
	PROCEDURE Procedure (value: SIGNED32); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with long integer parameter with huge integer argument

	MODULE Test;
	VAR argument: SIGNED64;
	PROCEDURE Procedure (value: SIGNED32); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with long integer parameter with real argument

	MODULE Test;
	VAR argument: FLOAT32;
	PROCEDURE Procedure (value: SIGNED32); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with long integer parameter with long real argument

	MODULE Test;
	VAR argument: FLOAT64;
	PROCEDURE Procedure (value: SIGNED32); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with long integer parameter with set argument

	MODULE Test;
	VAR argument: SET;
	PROCEDURE Procedure (value: SIGNED32); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with long integer parameter with array argument

	MODULE Test;
	VAR argument: ARRAY 10 OF CHAR;
	PROCEDURE Procedure (value: SIGNED32); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with long integer parameter with record argument

	MODULE Test;
	VAR argument: RECORD END;
	PROCEDURE Procedure (value: SIGNED32); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with long integer parameter with object argument

	MODULE Test;
	VAR argument: OBJECT END;
	PROCEDURE Procedure (value: SIGNED32); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with long integer parameter with base object argument

	MODULE Test;
	VAR argument: OBJECT;
	PROCEDURE Procedure (value: SIGNED32); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with long integer parameter with pointer to array argument

	MODULE Test;
	VAR argument: POINTER TO ARRAY 10 OF CHAR;
	PROCEDURE Procedure (value: SIGNED32); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with long integer parameter with pointer to record argument

	MODULE Test;
	VAR argument: POINTER TO RECORD END;
	PROCEDURE Procedure (value: SIGNED32); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with long integer parameter with procedure argument

	MODULE Test;
	VAR argument: PROCEDURE;
	PROCEDURE Procedure (value: SIGNED32); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with huge integer parameter with boolean argument

	MODULE Test;
	VAR argument: BOOLEAN;
	PROCEDURE Procedure (value: SIGNED64); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with huge integer parameter with character argument

	MODULE Test;
	VAR argument: CHAR;
	PROCEDURE Procedure (value: SIGNED64); END Procedure;
	BEGIN Procedure (argument);
	END Test.

positive: calling procedure with huge integer parameter with short integer argument

	MODULE Test;
	VAR argument: SIGNED8;
	PROCEDURE Procedure (value: SIGNED64); END Procedure;
	BEGIN Procedure (argument);
	END Test.

positive: calling procedure with huge integer parameter with integer argument

	MODULE Test;
	VAR argument: SIGNED16;
	PROCEDURE Procedure (value: SIGNED64); END Procedure;
	BEGIN Procedure (argument);
	END Test.

positive: calling procedure with huge integer parameter with long integer argument

	MODULE Test;
	VAR argument: SIGNED32;
	PROCEDURE Procedure (value: SIGNED64); END Procedure;
	BEGIN Procedure (argument);
	END Test.

positive: calling procedure with huge integer parameter with huge integer argument

	MODULE Test;
	VAR argument: SIGNED64;
	PROCEDURE Procedure (value: SIGNED64); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with huge integer parameter with real argument

	MODULE Test;
	VAR argument: FLOAT32;
	PROCEDURE Procedure (value: SIGNED64); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with huge integer parameter with long real argument

	MODULE Test;
	VAR argument: FLOAT64;
	PROCEDURE Procedure (value: SIGNED64); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with huge integer parameter with set argument

	MODULE Test;
	VAR argument: SET;
	PROCEDURE Procedure (value: SIGNED64); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with huge integer parameter with array argument

	MODULE Test;
	VAR argument: ARRAY 10 OF CHAR;
	PROCEDURE Procedure (value: SIGNED64); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with huge integer parameter with record argument

	MODULE Test;
	VAR argument: RECORD END;
	PROCEDURE Procedure (value: SIGNED64); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with huge integer parameter with object argument

	MODULE Test;
	VAR argument: OBJECT END;
	PROCEDURE Procedure (value: SIGNED64); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with huge integer parameter with base object argument

	MODULE Test;
	VAR argument: OBJECT;
	PROCEDURE Procedure (value: SIGNED64); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with huge integer parameter with pointer to array argument

	MODULE Test;
	VAR argument: POINTER TO ARRAY 10 OF CHAR;
	PROCEDURE Procedure (value: SIGNED64); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with huge integer parameter with pointer to record argument

	MODULE Test;
	VAR argument: POINTER TO RECORD END;
	PROCEDURE Procedure (value: SIGNED64); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with huge integer parameter with procedure argument

	MODULE Test;
	VAR argument: PROCEDURE;
	PROCEDURE Procedure (value: SIGNED64); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with real parameter with boolean argument

	MODULE Test;
	VAR argument: BOOLEAN;
	PROCEDURE Procedure (value: FLOAT32); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with real parameter with character argument

	MODULE Test;
	VAR argument: CHAR;
	PROCEDURE Procedure (value: FLOAT32); END Procedure;
	BEGIN Procedure (argument);
	END Test.

positive: calling procedure with real parameter with short integer argument

	MODULE Test;
	VAR argument: SIGNED8;
	PROCEDURE Procedure (value: FLOAT32); END Procedure;
	BEGIN Procedure (argument);
	END Test.

positive: calling procedure with real parameter with integer argument

	MODULE Test;
	VAR argument: SIGNED16;
	PROCEDURE Procedure (value: FLOAT32); END Procedure;
	BEGIN Procedure (argument);
	END Test.

positive: calling procedure with real parameter with long integer argument

	MODULE Test;
	VAR argument: SIGNED32;
	PROCEDURE Procedure (value: FLOAT32); END Procedure;
	BEGIN Procedure (argument);
	END Test.

positive: calling procedure with real parameter with huge integer argument

	MODULE Test;
	VAR argument: SIGNED64;
	PROCEDURE Procedure (value: FLOAT32); END Procedure;
	BEGIN Procedure (argument);
	END Test.

positive: calling procedure with real parameter with real argument

	MODULE Test;
	VAR argument: FLOAT32;
	PROCEDURE Procedure (value: FLOAT32); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with real parameter with long real argument

	MODULE Test;
	VAR argument: FLOAT64;
	PROCEDURE Procedure (value: FLOAT32); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with real parameter with set argument

	MODULE Test;
	VAR argument: SET;
	PROCEDURE Procedure (value: FLOAT32); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with real parameter with array argument

	MODULE Test;
	VAR argument: ARRAY 10 OF CHAR;
	PROCEDURE Procedure (value: FLOAT32); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with real parameter with record argument

	MODULE Test;
	VAR argument: RECORD END;
	PROCEDURE Procedure (value: FLOAT32); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with real parameter with object argument

	MODULE Test;
	VAR argument: OBJECT END;
	PROCEDURE Procedure (value: FLOAT32); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with real parameter with base object argument

	MODULE Test;
	VAR argument: OBJECT;
	PROCEDURE Procedure (value: FLOAT32); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with real parameter with pointer to array argument

	MODULE Test;
	VAR argument: POINTER TO ARRAY 10 OF CHAR;
	PROCEDURE Procedure (value: FLOAT32); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with real parameter with pointer to record argument

	MODULE Test;
	VAR argument: POINTER TO RECORD END;
	PROCEDURE Procedure (value: FLOAT32); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with real parameter with procedure argument

	MODULE Test;
	VAR argument: PROCEDURE;
	PROCEDURE Procedure (value: FLOAT32); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with long real parameter with boolean argument

	MODULE Test;
	VAR argument: BOOLEAN;
	PROCEDURE Procedure (value: FLOAT64); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with long real parameter with character argument

	MODULE Test;
	VAR argument: CHAR;
	PROCEDURE Procedure (value: FLOAT64); END Procedure;
	BEGIN Procedure (argument);
	END Test.

positive: calling procedure with long real parameter with short integer argument

	MODULE Test;
	VAR argument: SIGNED8;
	PROCEDURE Procedure (value: FLOAT64); END Procedure;
	BEGIN Procedure (argument);
	END Test.

positive: calling procedure with long real parameter with integer argument

	MODULE Test;
	VAR argument: SIGNED16;
	PROCEDURE Procedure (value: FLOAT64); END Procedure;
	BEGIN Procedure (argument);
	END Test.

positive: calling procedure with long real parameter with long integer argument

	MODULE Test;
	VAR argument: SIGNED32;
	PROCEDURE Procedure (value: FLOAT64); END Procedure;
	BEGIN Procedure (argument);
	END Test.

positive: calling procedure with long real parameter with huge integer argument

	MODULE Test;
	VAR argument: SIGNED64;
	PROCEDURE Procedure (value: FLOAT64); END Procedure;
	BEGIN Procedure (argument);
	END Test.

positive: calling procedure with long real parameter with real argument

	MODULE Test;
	VAR argument: FLOAT32;
	PROCEDURE Procedure (value: FLOAT64); END Procedure;
	BEGIN Procedure (argument);
	END Test.

positive: calling procedure with long real parameter with long real argument

	MODULE Test;
	VAR argument: FLOAT64;
	PROCEDURE Procedure (value: FLOAT64); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with long real parameter with set argument

	MODULE Test;
	VAR argument: SET;
	PROCEDURE Procedure (value: FLOAT64); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with long real parameter with array argument

	MODULE Test;
	VAR argument: ARRAY 10 OF CHAR;
	PROCEDURE Procedure (value: FLOAT64); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with long real parameter with record argument

	MODULE Test;
	VAR argument: RECORD END;
	PROCEDURE Procedure (value: FLOAT64); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with long real parameter with object argument

	MODULE Test;
	VAR argument: OBJECT END;
	PROCEDURE Procedure (value: FLOAT64); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with long real parameter with base object argument

	MODULE Test;
	VAR argument: OBJECT;
	PROCEDURE Procedure (value: FLOAT64); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with long real parameter with pointer to array argument

	MODULE Test;
	VAR argument: POINTER TO ARRAY 10 OF CHAR;
	PROCEDURE Procedure (value: FLOAT64); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with long real parameter with pointer to record argument

	MODULE Test;
	VAR argument: POINTER TO RECORD END;
	PROCEDURE Procedure (value: FLOAT64); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with long real parameter with procedure argument

	MODULE Test;
	VAR argument: PROCEDURE;
	PROCEDURE Procedure (value: FLOAT64); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with set parameter with boolean argument

	MODULE Test;
	VAR argument: BOOLEAN;
	PROCEDURE Procedure (value: SET); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with set parameter with character argument

	MODULE Test;
	VAR argument: CHAR;
	PROCEDURE Procedure (value: SET); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with set parameter with short integer argument

	MODULE Test;
	VAR argument: SIGNED8;
	PROCEDURE Procedure (value: SET); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with set parameter with integer argument

	MODULE Test;
	VAR argument: SIGNED16;
	PROCEDURE Procedure (value: SET); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with set parameter with long integer argument

	MODULE Test;
	VAR argument: SIGNED32;
	PROCEDURE Procedure (value: SET); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with set parameter with huge integer argument

	MODULE Test;
	VAR argument: SIGNED64;
	PROCEDURE Procedure (value: SET); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with set parameter with real argument

	MODULE Test;
	VAR argument: FLOAT32;
	PROCEDURE Procedure (value: SET); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with set parameter with long real argument

	MODULE Test;
	VAR argument: FLOAT64;
	PROCEDURE Procedure (value: SET); END Procedure;
	BEGIN Procedure (argument);
	END Test.

positive: calling procedure with set parameter with set argument

	MODULE Test;
	VAR argument: SET;
	PROCEDURE Procedure (value: SET); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with set parameter with array argument

	MODULE Test;
	VAR argument: ARRAY 10 OF CHAR;
	PROCEDURE Procedure (value: SET); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with set parameter with record argument

	MODULE Test;
	VAR argument: RECORD END;
	PROCEDURE Procedure (value: SET); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with set parameter with object argument

	MODULE Test;
	VAR argument: OBJECT END;
	PROCEDURE Procedure (value: SET); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with set parameter with base object argument

	MODULE Test;
	VAR argument: OBJECT;
	PROCEDURE Procedure (value: SET); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with set parameter with pointer to array argument

	MODULE Test;
	VAR argument: POINTER TO ARRAY 10 OF CHAR;
	PROCEDURE Procedure (value: SET); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with set parameter with pointer to record argument

	MODULE Test;
	VAR argument: POINTER TO RECORD END;
	PROCEDURE Procedure (value: SET); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with set parameter with procedure argument

	MODULE Test;
	VAR argument: PROCEDURE;
	PROCEDURE Procedure (value: SET); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with array parameter with boolean argument

	MODULE Test;
	VAR argument: BOOLEAN;
	PROCEDURE Procedure (value: ARRAY 10 OF CHAR); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with array parameter with character argument

	MODULE Test;
	VAR argument: CHAR;
	PROCEDURE Procedure (value: ARRAY 10 OF CHAR); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with array parameter with short integer argument

	MODULE Test;
	VAR argument: SIGNED8;
	PROCEDURE Procedure (value: ARRAY 10 OF CHAR); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with array parameter with integer argument

	MODULE Test;
	VAR argument: SIGNED16;
	PROCEDURE Procedure (value: ARRAY 10 OF CHAR); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with array parameter with long integer argument

	MODULE Test;
	VAR argument: SIGNED32;
	PROCEDURE Procedure (value: ARRAY 10 OF CHAR); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with array parameter with huge integer argument

	MODULE Test;
	VAR argument: SIGNED64;
	PROCEDURE Procedure (value: ARRAY 10 OF CHAR); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with array parameter with real argument

	MODULE Test;
	VAR argument: FLOAT32;
	PROCEDURE Procedure (value: ARRAY 10 OF CHAR); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with array parameter with long real argument

	MODULE Test;
	VAR argument: FLOAT64;
	PROCEDURE Procedure (value: ARRAY 10 OF CHAR); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with array parameter with set argument

	MODULE Test;
	VAR argument: SET;
	PROCEDURE Procedure (value: ARRAY 10 OF CHAR); END Procedure;
	BEGIN Procedure (argument);
	END Test.

positive: calling procedure with array parameter with array argument

	MODULE Test;
	VAR argument: ARRAY 10 OF CHAR;
	PROCEDURE Procedure (value: ARRAY 10 OF CHAR); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with array parameter with longer array argument

	MODULE Test;
	VAR argument: ARRAY 20 OF CHAR;
	PROCEDURE Procedure (value: ARRAY 10 OF CHAR); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with array parameter with shorter array argument

	MODULE Test;
	VAR argument: ARRAY 10 OF CHAR;
	PROCEDURE Procedure (value: ARRAY 20 OF CHAR); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with array parameter with open array argument

	MODULE Test;
	PROCEDURE Procedure (value: ARRAY 10 OF CHAR); END Procedure;
	PROCEDURE Test (argument: ARRAY OF CHAR); BEGIN Procedure (argument); END Test;
	END Test.

negative: calling procedure with array parameter with record argument

	MODULE Test;
	VAR argument: RECORD END;
	PROCEDURE Procedure (value: ARRAY 10 OF CHAR); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with array parameter with object argument

	MODULE Test;
	VAR argument: OBJECT END;
	PROCEDURE Procedure (value: ARRAY 10 OF CHAR); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with array parameter with base object argument

	MODULE Test;
	VAR argument: OBJECT;
	PROCEDURE Procedure (value: ARRAY 10 OF CHAR); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with array parameter with pointer to array argument

	MODULE Test;
	VAR argument: POINTER TO ARRAY 10 OF CHAR;
	PROCEDURE Procedure (value: ARRAY 10 OF CHAR); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with array parameter with pointer to record argument

	MODULE Test;
	VAR argument: POINTER TO RECORD END;
	PROCEDURE Procedure (value: ARRAY 10 OF CHAR); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with array parameter with procedure argument

	MODULE Test;
	VAR argument: PROCEDURE;
	PROCEDURE Procedure (value: ARRAY 10 OF CHAR); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with open array parameter with boolean argument

	MODULE Test;
	VAR argument: BOOLEAN;
	PROCEDURE Procedure (value: ARRAY OF CHAR); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with open array parameter with character argument

	MODULE Test;
	VAR argument: CHAR;
	PROCEDURE Procedure (value: ARRAY OF CHAR); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with open array parameter with short integer argument

	MODULE Test;
	VAR argument: SIGNED8;
	PROCEDURE Procedure (value: ARRAY OF CHAR); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with open array parameter with integer argument

	MODULE Test;
	VAR argument: SIGNED16;
	PROCEDURE Procedure (value: ARRAY OF CHAR); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with open array parameter with long integer argument

	MODULE Test;
	VAR argument: SIGNED32;
	PROCEDURE Procedure (value: ARRAY OF CHAR); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with open array parameter with huge integer argument

	MODULE Test;
	VAR argument: SIGNED64;
	PROCEDURE Procedure (value: ARRAY OF CHAR); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with open array parameter with real argument

	MODULE Test;
	VAR argument: FLOAT32;
	PROCEDURE Procedure (value: ARRAY OF CHAR); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with open array parameter with long real argument

	MODULE Test;
	VAR argument: FLOAT64;
	PROCEDURE Procedure (value: ARRAY OF CHAR); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with open array parameter with set argument

	MODULE Test;
	VAR argument: SET;
	PROCEDURE Procedure (value: ARRAY OF CHAR); END Procedure;
	BEGIN Procedure (argument);
	END Test.

positive: calling procedure with open array parameter with array argument

	MODULE Test;
	VAR argument: ARRAY 10 OF CHAR;
	PROCEDURE Procedure (value: ARRAY OF CHAR); END Procedure;
	BEGIN Procedure (argument);
	END Test.

positive: calling procedure with open array parameter with open array argument

	MODULE Test;
	PROCEDURE Procedure (value: ARRAY OF CHAR); END Procedure;
	PROCEDURE Test (argument: ARRAY OF CHAR); BEGIN Procedure (argument); END Test;
	END Test.

negative: calling procedure with open array parameter with record argument

	MODULE Test;
	VAR argument: RECORD END;
	PROCEDURE Procedure (value: ARRAY OF CHAR); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with open array parameter with object argument

	MODULE Test;
	VAR argument: OBJECT END;
	PROCEDURE Procedure (value: ARRAY OF CHAR); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with open array parameter with base object argument

	MODULE Test;
	VAR argument: OBJECT;
	PROCEDURE Procedure (value: ARRAY OF CHAR); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with open array parameter with pointer to array argument

	MODULE Test;
	VAR argument: POINTER TO ARRAY 10 OF CHAR;
	PROCEDURE Procedure (value: ARRAY OF CHAR); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with open array parameter with pointer to record argument

	MODULE Test;
	VAR argument: POINTER TO RECORD END;
	PROCEDURE Procedure (value: ARRAY OF CHAR); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with open array parameter with procedure argument

	MODULE Test;
	VAR argument: PROCEDURE;
	PROCEDURE Procedure (value: ARRAY OF CHAR); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with record parameter with boolean argument

	MODULE Test;
	VAR argument: BOOLEAN;
	PROCEDURE Procedure (value: RECORD END); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with record parameter with character argument

	MODULE Test;
	VAR argument: CHAR;
	PROCEDURE Procedure (value: RECORD END); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with record parameter with short integer argument

	MODULE Test;
	VAR argument: SIGNED8;
	PROCEDURE Procedure (value: RECORD END); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with record parameter with integer argument

	MODULE Test;
	VAR argument: SIGNED16;
	PROCEDURE Procedure (value: RECORD END); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with record parameter with long integer argument

	MODULE Test;
	VAR argument: SIGNED32;
	PROCEDURE Procedure (value: RECORD END); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with record parameter with huge integer argument

	MODULE Test;
	VAR argument: SIGNED64;
	PROCEDURE Procedure (value: RECORD END); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with record parameter with real argument

	MODULE Test;
	VAR argument: FLOAT32;
	PROCEDURE Procedure (value: RECORD END); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with record parameter with long real argument

	MODULE Test;
	VAR argument: FLOAT64;
	PROCEDURE Procedure (value: RECORD END); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with record parameter with set argument

	MODULE Test;
	VAR argument: SET;
	PROCEDURE Procedure (value: RECORD END); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with record parameter with array argument

	MODULE Test;
	VAR argument: ARRAY 10 OF CHAR;
	PROCEDURE Procedure (value: RECORD END); END Procedure;
	BEGIN Procedure (argument);
	END Test.

positive: calling procedure with record parameter with record argument

	MODULE Test;
	TYPE Record = RECORD END;
	VAR argument: Record;
	PROCEDURE Procedure (value: Record); END Procedure;
	BEGIN Procedure (argument);
	END Test.

positive: calling procedure with record parameter with compatible record argument

	MODULE Test;
	TYPE Record = RECORD END;
	VAR argument: RECORD (Record) END;
	PROCEDURE Procedure (value: Record); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with record parameter with incompatible record argument

	MODULE Test;
	TYPE Record = RECORD END;
	VAR argument: Record;
	PROCEDURE Procedure (value: RECORD (Record) END); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with record parameter with object argument

	MODULE Test;
	VAR argument: OBJECT END;
	PROCEDURE Procedure (value: RECORD END); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with record parameter with base object argument

	MODULE Test;
	VAR argument: OBJECT;
	PROCEDURE Procedure (value: RECORD END); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with record parameter with pointer to array argument

	MODULE Test;
	VAR argument: POINTER TO ARRAY 10 OF CHAR;
	PROCEDURE Procedure (value: RECORD END); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with record parameter with pointer to record argument

	MODULE Test;
	VAR argument: POINTER TO RECORD END;
	PROCEDURE Procedure (value: RECORD END); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with record parameter with procedure argument

	MODULE Test;
	VAR argument: PROCEDURE;
	PROCEDURE Procedure (value: RECORD END); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with object parameter with boolean argument

	MODULE Test;
	VAR argument: BOOLEAN;
	PROCEDURE Procedure (value: OBJECT END); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with object parameter with character argument

	MODULE Test;
	VAR argument: CHAR;
	PROCEDURE Procedure (value: OBJECT END); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with object parameter with short integer argument

	MODULE Test;
	VAR argument: SIGNED8;
	PROCEDURE Procedure (value: OBJECT END); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with object parameter with integer argument

	MODULE Test;
	VAR argument: SIGNED16;
	PROCEDURE Procedure (value: OBJECT END); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with object parameter with long integer argument

	MODULE Test;
	VAR argument: SIGNED32;
	PROCEDURE Procedure (value: OBJECT END); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with object parameter with huge integer argument

	MODULE Test;
	VAR argument: SIGNED64;
	PROCEDURE Procedure (value: OBJECT END); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with object parameter with real argument

	MODULE Test;
	VAR argument: FLOAT32;
	PROCEDURE Procedure (value: OBJECT END); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with object parameter with long real argument

	MODULE Test;
	VAR argument: FLOAT64;
	PROCEDURE Procedure (value: OBJECT END); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with object parameter with set argument

	MODULE Test;
	VAR argument: SET;
	PROCEDURE Procedure (value: OBJECT END); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with object parameter with array argument

	MODULE Test;
	VAR argument: ARRAY 10 OF CHAR;
	PROCEDURE Procedure (value: OBJECT END); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with object parameter with record argument

	MODULE Test;
	VAR argument: RECORD END;
	PROCEDURE Procedure (value: OBJECT END); END Procedure;
	BEGIN Procedure (argument);
	END Test.

positive: calling procedure with object parameter with object argument

	MODULE Test;
	TYPE Object = OBJECT END Object;
	VAR argument: Object;
	PROCEDURE Procedure (value: Object); END Procedure;
	BEGIN Procedure (argument);
	END Test.

positive: calling procedure with object parameter with compatible object argument

	MODULE Test;
	TYPE Object = OBJECT END Object;
	VAR argument: OBJECT (Object) END;
	PROCEDURE Procedure (value: Object); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with object parameter with incompatible object argument

	MODULE Test;
	TYPE Object = OBJECT END Object;
	VAR argument: Object;
	PROCEDURE Procedure (value: OBJECT (Object) END); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with object parameter with base object argument

	MODULE Test;
	VAR argument: OBJECT;
	PROCEDURE Procedure (value: OBJECT END); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with object parameter with pointer to array argument

	MODULE Test;
	VAR argument: POINTER TO ARRAY 10 OF CHAR;
	PROCEDURE Procedure (value: OBJECT END); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with object parameter with pointer to record argument

	MODULE Test;
	VAR argument: POINTER TO RECORD END;
	PROCEDURE Procedure (value: OBJECT END); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with object parameter with procedure argument

	MODULE Test;
	VAR argument: PROCEDURE;
	PROCEDURE Procedure (value: OBJECT END); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with base object parameter with boolean argument

	MODULE Test;
	VAR argument: BOOLEAN;
	PROCEDURE Procedure (value: OBJECT); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with base object parameter with character argument

	MODULE Test;
	VAR argument: CHAR;
	PROCEDURE Procedure (value: OBJECT); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with base object parameter with short integer argument

	MODULE Test;
	VAR argument: SIGNED8;
	PROCEDURE Procedure (value: OBJECT); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with base object parameter with integer argument

	MODULE Test;
	VAR argument: SIGNED16;
	PROCEDURE Procedure (value: OBJECT); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with base object parameter with long integer argument

	MODULE Test;
	VAR argument: SIGNED32;
	PROCEDURE Procedure (value: OBJECT); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with base object parameter with huge integer argument

	MODULE Test;
	VAR argument: SIGNED64;
	PROCEDURE Procedure (value: OBJECT); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with base object parameter with real argument

	MODULE Test;
	VAR argument: FLOAT32;
	PROCEDURE Procedure (value: OBJECT); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with base object parameter with long real argument

	MODULE Test;
	VAR argument: FLOAT64;
	PROCEDURE Procedure (value: OBJECT); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with base object parameter with set argument

	MODULE Test;
	VAR argument: SET;
	PROCEDURE Procedure (value: OBJECT); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with base object parameter with array argument

	MODULE Test;
	VAR argument: ARRAY 10 OF CHAR;
	PROCEDURE Procedure (value: OBJECT); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with base object parameter with record argument

	MODULE Test;
	VAR argument: RECORD END;
	PROCEDURE Procedure (value: OBJECT); END Procedure;
	BEGIN Procedure (argument);
	END Test.

positive: calling procedure with base object parameter with object argument

	MODULE Test;
	VAR argument: OBJECT END;
	PROCEDURE Procedure (value: OBJECT); END Procedure;
	BEGIN Procedure (argument);
	END Test.

positive: calling procedure with base object parameter with base object argument

	MODULE Test;
	VAR argument: OBJECT;
	PROCEDURE Procedure (value: OBJECT); END Procedure;
	BEGIN Procedure (argument);
	END Test.

positive: calling procedure with base object parameter with pointer to record argument

	MODULE Test;
	VAR argument: POINTER TO RECORD END;
	PROCEDURE Procedure (value: OBJECT); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with base object parameter with pointer to array argument

	MODULE Test;
	VAR argument: POINTER TO ARRAY 10 OF CHAR;
	PROCEDURE Procedure (value: OBJECT); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with base object parameter with procedure argument

	MODULE Test;
	VAR argument: PROCEDURE;
	PROCEDURE Procedure (value: OBJECT); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with pointer to array parameter with boolean argument

	MODULE Test;
	VAR argument: BOOLEAN;
	PROCEDURE Procedure (value: POINTER TO ARRAY 10 OF CHAR); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with pointer to array parameter with character argument

	MODULE Test;
	VAR argument: CHAR;
	PROCEDURE Procedure (value: POINTER TO ARRAY 10 OF CHAR); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with pointer to array parameter with short integer argument

	MODULE Test;
	VAR argument: SIGNED8;
	PROCEDURE Procedure (value: POINTER TO ARRAY 10 OF CHAR); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with pointer to array parameter with integer argument

	MODULE Test;
	VAR argument: SIGNED16;
	PROCEDURE Procedure (value: POINTER TO ARRAY 10 OF CHAR); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with pointer to array parameter with long integer argument

	MODULE Test;
	VAR argument: SIGNED32;
	PROCEDURE Procedure (value: POINTER TO ARRAY 10 OF CHAR); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with pointer to array parameter with huge integer argument

	MODULE Test;
	VAR argument: SIGNED64;
	PROCEDURE Procedure (value: POINTER TO ARRAY 10 OF CHAR); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with pointer to array parameter with real argument

	MODULE Test;
	VAR argument: FLOAT32;
	PROCEDURE Procedure (value: POINTER TO ARRAY 10 OF CHAR); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with pointer to array parameter with long real argument

	MODULE Test;
	VAR argument: FLOAT64;
	PROCEDURE Procedure (value: POINTER TO ARRAY 10 OF CHAR); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with pointer to array parameter with set argument

	MODULE Test;
	VAR argument: SET;
	PROCEDURE Procedure (value: POINTER TO ARRAY 10 OF CHAR); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with pointer to array parameter with array argument

	MODULE Test;
	VAR argument: ARRAY 10 OF CHAR;
	PROCEDURE Procedure (value: POINTER TO ARRAY 10 OF CHAR); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with pointer to array parameter with record argument

	MODULE Test;
	VAR argument: RECORD END;
	PROCEDURE Procedure (value: POINTER TO ARRAY 10 OF CHAR); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with pointer to array parameter with object argument

	MODULE Test;
	VAR argument: OBJECT END;
	PROCEDURE Procedure (value: POINTER TO ARRAY 10 OF CHAR); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with pointer to array parameter with base object argument

	MODULE Test;
	VAR argument: OBJECT;
	PROCEDURE Procedure (value: POINTER TO ARRAY 10 OF CHAR); END Procedure;
	BEGIN Procedure (argument);
	END Test.

positive: calling procedure with pointer to array parameter with pointer to array argument

	MODULE Test;
	VAR argument: POINTER TO ARRAY 10 OF CHAR;
	PROCEDURE Procedure (value: POINTER TO ARRAY 10 OF CHAR); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with pointer to array parameter with pointer to record argument

	MODULE Test;
	VAR argument: POINTER TO RECORD END;
	PROCEDURE Procedure (value: POINTER TO ARRAY 10 OF CHAR); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with pointer to array parameter with procedure argument

	MODULE Test;
	VAR argument: PROCEDURE;
	PROCEDURE Procedure (value: POINTER TO ARRAY 10 OF CHAR); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with pointer to record parameter with boolean argument

	MODULE Test;
	VAR argument: BOOLEAN;
	PROCEDURE Procedure (value: POINTER TO RECORD END); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with pointer to record parameter with character argument

	MODULE Test;
	VAR argument: CHAR;
	PROCEDURE Procedure (value: POINTER TO RECORD END); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with pointer to record parameter with short integer argument

	MODULE Test;
	VAR argument: SIGNED8;
	PROCEDURE Procedure (value: POINTER TO RECORD END); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with pointer to record parameter with integer argument

	MODULE Test;
	VAR argument: SIGNED16;
	PROCEDURE Procedure (value: POINTER TO RECORD END); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with pointer to record parameter with long integer argument

	MODULE Test;
	VAR argument: SIGNED32;
	PROCEDURE Procedure (value: POINTER TO RECORD END); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with pointer to record parameter with huge integer argument

	MODULE Test;
	VAR argument: SIGNED64;
	PROCEDURE Procedure (value: POINTER TO RECORD END); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with pointer to record parameter with real argument

	MODULE Test;
	VAR argument: FLOAT32;
	PROCEDURE Procedure (value: POINTER TO RECORD END); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with pointer to record parameter with long real argument

	MODULE Test;
	VAR argument: FLOAT64;
	PROCEDURE Procedure (value: POINTER TO RECORD END); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with pointer to record parameter with set argument

	MODULE Test;
	VAR argument: SET;
	PROCEDURE Procedure (value: POINTER TO RECORD END); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with pointer to record parameter with array argument

	MODULE Test;
	VAR argument: ARRAY 10 OF CHAR;
	PROCEDURE Procedure (value: POINTER TO RECORD END); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with pointer to record parameter with record argument

	MODULE Test;
	VAR argument: RECORD END;
	PROCEDURE Procedure (value: POINTER TO RECORD END); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with pointer to record parameter with object argument

	MODULE Test;
	VAR argument: OBJECT END;
	PROCEDURE Procedure (value: POINTER TO RECORD END); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with pointer to record parameter with base object argument

	MODULE Test;
	VAR argument: OBJECT;
	PROCEDURE Procedure (value: POINTER TO RECORD END); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with pointer to record parameter with pointer to array argument

	MODULE Test;
	VAR argument: POINTER TO ARRAY 10 OF CHAR;
	PROCEDURE Procedure (value: POINTER TO RECORD END); END Procedure;
	BEGIN Procedure (argument);
	END Test.

positive: calling procedure with pointer to record parameter with pointer to record argument

	MODULE Test;
	TYPE Record = RECORD END;
	VAR argument: POINTER TO Record;
	PROCEDURE Procedure (value: POINTER TO Record); END Procedure;
	BEGIN Procedure (argument);
	END Test.

positive: calling procedure with pointer to record parameter with compatible pointer to record argument

	MODULE Test;
	TYPE Record = RECORD END;
	VAR argument: POINTER TO RECORD (Record) END;
	PROCEDURE Procedure (value: POINTER TO Record); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with pointer to record parameter with incompatible pointer to record argument

	MODULE Test;
	TYPE Record = RECORD END;
	VAR argument: POINTER TO Record;
	PROCEDURE Procedure (value: POINTER TO RECORD (Record) END); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with pointer to record parameter with procedure argument

	MODULE Test;
	VAR argument: PROCEDURE;
	PROCEDURE Procedure (value: POINTER TO RECORD END); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with procedure parameter with boolean argument

	MODULE Test;
	VAR argument: BOOLEAN;
	PROCEDURE Procedure (value: PROCEDURE); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with procedure parameter with character argument

	MODULE Test;
	VAR argument: CHAR;
	PROCEDURE Procedure (value: PROCEDURE); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with procedure parameter with short integer argument

	MODULE Test;
	VAR argument: SIGNED8;
	PROCEDURE Procedure (value: PROCEDURE); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with procedure parameter with integer argument

	MODULE Test;
	VAR argument: SIGNED16;
	PROCEDURE Procedure (value: PROCEDURE); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with procedure parameter with long integer argument

	MODULE Test;
	VAR argument: SIGNED32;
	PROCEDURE Procedure (value: PROCEDURE); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with procedure parameter with huge integer argument

	MODULE Test;
	VAR argument: SIGNED64;
	PROCEDURE Procedure (value: PROCEDURE); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with procedure parameter with real argument

	MODULE Test;
	VAR argument: FLOAT32;
	PROCEDURE Procedure (value: PROCEDURE); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with procedure parameter with long real argument

	MODULE Test;
	VAR argument: FLOAT64;
	PROCEDURE Procedure (value: PROCEDURE); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with procedure parameter with set argument

	MODULE Test;
	VAR argument: SET;
	PROCEDURE Procedure (value: PROCEDURE); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with procedure parameter with array argument

	MODULE Test;
	VAR argument: ARRAY 10 OF CHAR;
	PROCEDURE Procedure (value: PROCEDURE); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with procedure parameter with record argument

	MODULE Test;
	VAR argument: RECORD END;
	PROCEDURE Procedure (value: PROCEDURE); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with procedure parameter with object argument

	MODULE Test;
	VAR argument: OBJECT END;
	PROCEDURE Procedure (value: PROCEDURE); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with procedure parameter with base object argument

	MODULE Test;
	VAR argument: OBJECT;
	PROCEDURE Procedure (value: PROCEDURE); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with procedure parameter with pointer to array argument

	MODULE Test;
	VAR argument: POINTER TO ARRAY 10 OF CHAR;
	PROCEDURE Procedure (value: PROCEDURE); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with procedure parameter with pointer to record argument

	MODULE Test;
	VAR argument: POINTER TO RECORD END;
	PROCEDURE Procedure (value: PROCEDURE); END Procedure;
	BEGIN Procedure (argument);
	END Test.

positive: calling procedure with procedure parameter with procedure argument

	MODULE Test;
	VAR argument: PROCEDURE;
	PROCEDURE Procedure (value: PROCEDURE); END Procedure;
	BEGIN Procedure (argument);
	END Test.

positive: calling procedure with boolean variable parameter with boolean argument

	MODULE Test;
	VAR argument: BOOLEAN;
	PROCEDURE Procedure (VAR value: BOOLEAN); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with boolean variable parameter with character argument

	MODULE Test;
	VAR argument: CHAR;
	PROCEDURE Procedure (VAR value: BOOLEAN); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with boolean variable parameter with short integer argument

	MODULE Test;
	VAR argument: SIGNED8;
	PROCEDURE Procedure (VAR value: BOOLEAN); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with boolean variable parameter with integer argument

	MODULE Test;
	VAR argument: SIGNED16;
	PROCEDURE Procedure (VAR value: BOOLEAN); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with boolean variable parameter with long integer argument

	MODULE Test;
	VAR argument: SIGNED32;
	PROCEDURE Procedure (VAR value: BOOLEAN); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with boolean variable parameter with huge integer argument

	MODULE Test;
	VAR argument: SIGNED64;
	PROCEDURE Procedure (VAR value: BOOLEAN); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with boolean variable parameter with real argument

	MODULE Test;
	VAR argument: FLOAT32;
	PROCEDURE Procedure (VAR value: BOOLEAN); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with boolean variable parameter with long real argument

	MODULE Test;
	VAR argument: FLOAT64;
	PROCEDURE Procedure (VAR value: BOOLEAN); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with boolean variable parameter with set argument

	MODULE Test;
	VAR argument: SET;
	PROCEDURE Procedure (VAR value: BOOLEAN); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with boolean variable parameter with array argument

	MODULE Test;
	VAR argument: ARRAY 10 OF CHAR;
	PROCEDURE Procedure (VAR value: BOOLEAN); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with boolean variable parameter with record argument

	MODULE Test;
	VAR argument: RECORD END;
	PROCEDURE Procedure (VAR value: BOOLEAN); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with boolean variable parameter with object argument

	MODULE Test;
	VAR argument: OBJECT END;
	PROCEDURE Procedure (VAR value: BOOLEAN); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with boolean variable parameter with base object argument

	MODULE Test;
	VAR argument: OBJECT;
	PROCEDURE Procedure (VAR value: BOOLEAN); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with boolean variable parameter with pointer to array argument

	MODULE Test;
	VAR argument: POINTER TO ARRAY 10 OF CHAR;
	PROCEDURE Procedure (VAR value: BOOLEAN); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with boolean variable parameter with pointer to record argument

	MODULE Test;
	VAR argument: POINTER TO RECORD END;
	PROCEDURE Procedure (VAR value: BOOLEAN); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with boolean variable parameter with procedure argument

	MODULE Test;
	VAR argument: PROCEDURE;
	PROCEDURE Procedure (VAR value: BOOLEAN); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with character variable parameter with boolean argument

	MODULE Test;
	VAR argument: BOOLEAN;
	PROCEDURE Procedure (VAR value: CHAR); END Procedure;
	BEGIN Procedure (argument);
	END Test.

positive: calling procedure with character variable parameter with character argument

	MODULE Test;
	VAR argument: CHAR;
	PROCEDURE Procedure (VAR value: CHAR); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with character variable parameter with short integer argument

	MODULE Test;
	VAR argument: SIGNED8;
	PROCEDURE Procedure (VAR value: CHAR); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with character variable parameter with integer argument

	MODULE Test;
	VAR argument: SIGNED16;
	PROCEDURE Procedure (VAR value: CHAR); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with character variable parameter with long integer argument

	MODULE Test;
	VAR argument: SIGNED32;
	PROCEDURE Procedure (VAR value: CHAR); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with character variable parameter with huge integer argument

	MODULE Test;
	VAR argument: SIGNED64;
	PROCEDURE Procedure (VAR value: CHAR); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with character variable parameter with real argument

	MODULE Test;
	VAR argument: FLOAT32;
	PROCEDURE Procedure (VAR value: CHAR); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with character variable parameter with long real argument

	MODULE Test;
	VAR argument: FLOAT64;
	PROCEDURE Procedure (VAR value: CHAR); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with character variable parameter with set argument

	MODULE Test;
	VAR argument: SET;
	PROCEDURE Procedure (VAR value: CHAR); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with character variable parameter with array argument

	MODULE Test;
	VAR argument: ARRAY 10 OF CHAR;
	PROCEDURE Procedure (VAR value: CHAR); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with character variable parameter with record argument

	MODULE Test;
	VAR argument: RECORD END;
	PROCEDURE Procedure (VAR value: CHAR); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with character variable parameter with object argument

	MODULE Test;
	VAR argument: OBJECT END;
	PROCEDURE Procedure (VAR value: CHAR); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with character variable parameter with base object argument

	MODULE Test;
	VAR argument: OBJECT;
	PROCEDURE Procedure (VAR value: CHAR); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with character variable parameter with pointer to array argument

	MODULE Test;
	VAR argument: POINTER TO ARRAY 10 OF CHAR;
	PROCEDURE Procedure (VAR value: CHAR); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with character variable parameter with pointer to record argument

	MODULE Test;
	VAR argument: POINTER TO RECORD END;
	PROCEDURE Procedure (VAR value: CHAR); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with character variable parameter with procedure argument

	MODULE Test;
	VAR argument: PROCEDURE;
	PROCEDURE Procedure (VAR value: CHAR); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with short integer variable parameter with boolean argument

	MODULE Test;
	VAR argument: BOOLEAN;
	PROCEDURE Procedure (VAR value: SIGNED8); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with short integer variable parameter with character argument

	MODULE Test;
	VAR argument: CHAR;
	PROCEDURE Procedure (VAR value: SIGNED8); END Procedure;
	BEGIN Procedure (argument);
	END Test.

positive: calling procedure with short integer variable parameter with short integer argument

	MODULE Test;
	VAR argument: SIGNED8;
	PROCEDURE Procedure (VAR value: SIGNED8); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with short integer variable parameter with integer argument

	MODULE Test;
	VAR argument: SIGNED16;
	PROCEDURE Procedure (VAR value: SIGNED8); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with short integer variable parameter with long integer argument

	MODULE Test;
	VAR argument: SIGNED32;
	PROCEDURE Procedure (VAR value: SIGNED8); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with short integer variable parameter with huge integer argument

	MODULE Test;
	VAR argument: SIGNED64;
	PROCEDURE Procedure (VAR value: SIGNED8); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with short integer variable parameter with real argument

	MODULE Test;
	VAR argument: FLOAT32;
	PROCEDURE Procedure (VAR value: SIGNED8); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with short integer variable parameter with long real argument

	MODULE Test;
	VAR argument: FLOAT64;
	PROCEDURE Procedure (VAR value: SIGNED8); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with short integer variable parameter with set argument

	MODULE Test;
	VAR argument: SET;
	PROCEDURE Procedure (VAR value: SIGNED8); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with short integer variable parameter with array argument

	MODULE Test;
	VAR argument: ARRAY 10 OF CHAR;
	PROCEDURE Procedure (VAR value: SIGNED8); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with short integer variable parameter with record argument

	MODULE Test;
	VAR argument: RECORD END;
	PROCEDURE Procedure (VAR value: SIGNED8); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with short integer variable parameter with object argument

	MODULE Test;
	VAR argument: OBJECT END;
	PROCEDURE Procedure (VAR value: SIGNED8); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with short integer variable parameter with base object argument

	MODULE Test;
	VAR argument: OBJECT;
	PROCEDURE Procedure (VAR value: SIGNED8); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with short integer variable parameter with pointer to array argument

	MODULE Test;
	VAR argument: POINTER TO ARRAY 10 OF CHAR;
	PROCEDURE Procedure (VAR value: SIGNED8); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with short integer variable parameter with pointer to record argument

	MODULE Test;
	VAR argument: POINTER TO RECORD END;
	PROCEDURE Procedure (VAR value: SIGNED8); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with short integer variable parameter with procedure argument

	MODULE Test;
	VAR argument: PROCEDURE;
	PROCEDURE Procedure (VAR value: SIGNED8); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with integer variable parameter with boolean argument

	MODULE Test;
	VAR argument: BOOLEAN;
	PROCEDURE Procedure (VAR value: SIGNED16); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with integer variable parameter with character argument

	MODULE Test;
	VAR argument: CHAR;
	PROCEDURE Procedure (VAR value: SIGNED16); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with integer variable parameter with short integer argument

	MODULE Test;
	VAR argument: SIGNED8;
	PROCEDURE Procedure (VAR value: SIGNED16); END Procedure;
	BEGIN Procedure (argument);
	END Test.

positive: calling procedure with integer variable parameter with integer argument

	MODULE Test;
	VAR argument: SIGNED16;
	PROCEDURE Procedure (VAR value: SIGNED16); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with integer variable parameter with long integer argument

	MODULE Test;
	VAR argument: SIGNED32;
	PROCEDURE Procedure (VAR value: SIGNED16); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with integer variable parameter with huge integer argument

	MODULE Test;
	VAR argument: SIGNED64;
	PROCEDURE Procedure (VAR value: SIGNED16); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with integer variable parameter with real argument

	MODULE Test;
	VAR argument: FLOAT32;
	PROCEDURE Procedure (VAR value: SIGNED16); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with integer variable parameter with long real argument

	MODULE Test;
	VAR argument: FLOAT64;
	PROCEDURE Procedure (VAR value: SIGNED16); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with integer variable parameter with set argument

	MODULE Test;
	VAR argument: SET;
	PROCEDURE Procedure (VAR value: SIGNED16); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with integer variable parameter with array argument

	MODULE Test;
	VAR argument: ARRAY 10 OF CHAR;
	PROCEDURE Procedure (VAR value: SIGNED16); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with integer variable parameter with record argument

	MODULE Test;
	VAR argument: RECORD END;
	PROCEDURE Procedure (VAR value: SIGNED16); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with integer variable parameter with object argument

	MODULE Test;
	VAR argument: OBJECT END;
	PROCEDURE Procedure (VAR value: SIGNED16); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with integer variable parameter with base object argument

	MODULE Test;
	VAR argument: OBJECT;
	PROCEDURE Procedure (VAR value: SIGNED16); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with integer variable parameter with pointer to array argument

	MODULE Test;
	VAR argument: POINTER TO ARRAY 10 OF CHAR;
	PROCEDURE Procedure (VAR value: SIGNED16); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with integer variable parameter with pointer to record argument

	MODULE Test;
	VAR argument: POINTER TO RECORD END;
	PROCEDURE Procedure (VAR value: SIGNED16); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with integer variable parameter with procedure argument

	MODULE Test;
	VAR argument: PROCEDURE;
	PROCEDURE Procedure (VAR value: SIGNED16); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with long integer variable parameter with boolean argument

	MODULE Test;
	VAR argument: BOOLEAN;
	PROCEDURE Procedure (VAR value: SIGNED32); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with long integer variable parameter with character argument

	MODULE Test;
	VAR argument: CHAR;
	PROCEDURE Procedure (VAR value: SIGNED32); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with long integer variable parameter with short integer argument

	MODULE Test;
	VAR argument: SIGNED8;
	PROCEDURE Procedure (VAR value: SIGNED32); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with long integer variable parameter with integer argument

	MODULE Test;
	VAR argument: SIGNED16;
	PROCEDURE Procedure (VAR value: SIGNED32); END Procedure;
	BEGIN Procedure (argument);
	END Test.

positive: calling procedure with long integer variable parameter with long integer argument

	MODULE Test;
	VAR argument: SIGNED32;
	PROCEDURE Procedure (VAR value: SIGNED32); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with long integer variable parameter with huge integer argument

	MODULE Test;
	VAR argument: SIGNED64;
	PROCEDURE Procedure (VAR value: SIGNED32); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with long integer variable parameter with real argument

	MODULE Test;
	VAR argument: FLOAT32;
	PROCEDURE Procedure (VAR value: SIGNED32); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with long integer variable parameter with long real argument

	MODULE Test;
	VAR argument: FLOAT64;
	PROCEDURE Procedure (VAR value: SIGNED32); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with long integer variable parameter with set argument

	MODULE Test;
	VAR argument: SET;
	PROCEDURE Procedure (VAR value: SIGNED32); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with long integer variable parameter with array argument

	MODULE Test;
	VAR argument: ARRAY 10 OF CHAR;
	PROCEDURE Procedure (VAR value: SIGNED32); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with long integer variable parameter with record argument

	MODULE Test;
	VAR argument: RECORD END;
	PROCEDURE Procedure (VAR value: SIGNED32); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with long integer variable parameter with object argument

	MODULE Test;
	VAR argument: OBJECT END;
	PROCEDURE Procedure (VAR value: SIGNED32); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with long integer variable parameter with base object argument

	MODULE Test;
	VAR argument: OBJECT;
	PROCEDURE Procedure (VAR value: SIGNED32); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with long integer variable parameter with pointer to array argument

	MODULE Test;
	VAR argument: POINTER TO ARRAY 10 OF CHAR;
	PROCEDURE Procedure (VAR value: SIGNED32); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with long integer variable parameter with pointer to record argument

	MODULE Test;
	VAR argument: POINTER TO RECORD END;
	PROCEDURE Procedure (VAR value: SIGNED32); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with long integer variable parameter with procedure argument

	MODULE Test;
	VAR argument: PROCEDURE;
	PROCEDURE Procedure (VAR value: SIGNED32); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with huge integer variable parameter with boolean argument

	MODULE Test;
	VAR argument: BOOLEAN;
	PROCEDURE Procedure (VAR value: SIGNED64); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with huge integer variable parameter with character argument

	MODULE Test;
	VAR argument: CHAR;
	PROCEDURE Procedure (VAR value: SIGNED64); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with huge integer variable parameter with short integer argument

	MODULE Test;
	VAR argument: SIGNED8;
	PROCEDURE Procedure (VAR value: SIGNED64); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with huge integer variable parameter with integer argument

	MODULE Test;
	VAR argument: SIGNED16;
	PROCEDURE Procedure (VAR value: SIGNED64); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with huge integer variable parameter with long integer argument

	MODULE Test;
	VAR argument: SIGNED32;
	PROCEDURE Procedure (VAR value: SIGNED64); END Procedure;
	BEGIN Procedure (argument);
	END Test.

positive: calling procedure with huge integer variable parameter with huge integer argument

	MODULE Test;
	VAR argument: SIGNED64;
	PROCEDURE Procedure (VAR value: SIGNED64); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with huge integer variable parameter with real argument

	MODULE Test;
	VAR argument: FLOAT32;
	PROCEDURE Procedure (VAR value: SIGNED64); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with huge integer variable parameter with long real argument

	MODULE Test;
	VAR argument: FLOAT64;
	PROCEDURE Procedure (VAR value: SIGNED64); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with huge integer variable parameter with set argument

	MODULE Test;
	VAR argument: SET;
	PROCEDURE Procedure (VAR value: SIGNED64); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with huge integer variable parameter with array argument

	MODULE Test;
	VAR argument: ARRAY 10 OF CHAR;
	PROCEDURE Procedure (VAR value: SIGNED64); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with huge integer variable parameter with record argument

	MODULE Test;
	VAR argument: RECORD END;
	PROCEDURE Procedure (VAR value: SIGNED64); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with huge integer variable parameter with object argument

	MODULE Test;
	VAR argument: OBJECT END;
	PROCEDURE Procedure (VAR value: SIGNED64); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with huge integer variable parameter with base object argument

	MODULE Test;
	VAR argument: OBJECT;
	PROCEDURE Procedure (VAR value: SIGNED64); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with huge integer variable parameter with pointer to array argument

	MODULE Test;
	VAR argument: POINTER TO ARRAY 10 OF CHAR;
	PROCEDURE Procedure (VAR value: SIGNED64); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with huge integer variable parameter with pointer to record argument

	MODULE Test;
	VAR argument: POINTER TO RECORD END;
	PROCEDURE Procedure (VAR value: SIGNED64); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with huge integer variable parameter with procedure argument

	MODULE Test;
	VAR argument: PROCEDURE;
	PROCEDURE Procedure (VAR value: SIGNED64); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with real variable parameter with boolean argument

	MODULE Test;
	VAR argument: BOOLEAN;
	PROCEDURE Procedure (VAR value: FLOAT32); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with real variable parameter with character argument

	MODULE Test;
	VAR argument: CHAR;
	PROCEDURE Procedure (VAR value: FLOAT32); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with real variable parameter with short integer argument

	MODULE Test;
	VAR argument: SIGNED8;
	PROCEDURE Procedure (VAR value: FLOAT32); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with real variable parameter with integer argument

	MODULE Test;
	VAR argument: SIGNED16;
	PROCEDURE Procedure (VAR value: FLOAT32); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with real variable parameter with long integer argument

	MODULE Test;
	VAR argument: SIGNED32;
	PROCEDURE Procedure (VAR value: FLOAT32); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with real variable parameter with huge integer argument

	MODULE Test;
	VAR argument: SIGNED64;
	PROCEDURE Procedure (VAR value: FLOAT32); END Procedure;
	BEGIN Procedure (argument);
	END Test.

positive: calling procedure with real variable parameter with real argument

	MODULE Test;
	VAR argument: FLOAT32;
	PROCEDURE Procedure (VAR value: FLOAT32); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with real variable parameter with long real argument

	MODULE Test;
	VAR argument: FLOAT64;
	PROCEDURE Procedure (VAR value: FLOAT32); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with real variable parameter with set argument

	MODULE Test;
	VAR argument: SET;
	PROCEDURE Procedure (VAR value: FLOAT32); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with real variable parameter with array argument

	MODULE Test;
	VAR argument: ARRAY 10 OF CHAR;
	PROCEDURE Procedure (VAR value: FLOAT32); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with real variable parameter with record argument

	MODULE Test;
	VAR argument: RECORD END;
	PROCEDURE Procedure (VAR value: FLOAT32); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with real variable parameter with object argument

	MODULE Test;
	VAR argument: OBJECT END;
	PROCEDURE Procedure (VAR value: FLOAT32); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with real variable parameter with base object argument

	MODULE Test;
	VAR argument: OBJECT;
	PROCEDURE Procedure (VAR value: FLOAT32); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with real variable parameter with pointer to array argument

	MODULE Test;
	VAR argument: POINTER TO ARRAY 10 OF CHAR;
	PROCEDURE Procedure (VAR value: FLOAT32); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with real variable parameter with pointer to record argument

	MODULE Test;
	VAR argument: POINTER TO RECORD END;
	PROCEDURE Procedure (VAR value: FLOAT32); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with real variable parameter with procedure argument

	MODULE Test;
	VAR argument: PROCEDURE;
	PROCEDURE Procedure (VAR value: FLOAT32); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with long real variable parameter with boolean argument

	MODULE Test;
	VAR argument: BOOLEAN;
	PROCEDURE Procedure (VAR value: FLOAT64); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with long real variable parameter with character argument

	MODULE Test;
	VAR argument: CHAR;
	PROCEDURE Procedure (VAR value: FLOAT64); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with long real variable parameter with short integer argument

	MODULE Test;
	VAR argument: SIGNED8;
	PROCEDURE Procedure (VAR value: FLOAT64); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with long real variable parameter with integer argument

	MODULE Test;
	VAR argument: SIGNED16;
	PROCEDURE Procedure (VAR value: FLOAT64); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with long real variable parameter with long integer argument

	MODULE Test;
	VAR argument: SIGNED32;
	PROCEDURE Procedure (VAR value: FLOAT64); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with long real variable parameter with huge integer argument

	MODULE Test;
	VAR argument: SIGNED64;
	PROCEDURE Procedure (VAR value: FLOAT64); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with long real variable parameter with real argument

	MODULE Test;
	VAR argument: FLOAT32;
	PROCEDURE Procedure (VAR value: FLOAT64); END Procedure;
	BEGIN Procedure (argument);
	END Test.

positive: calling procedure with long real variable parameter with long real argument

	MODULE Test;
	VAR argument: FLOAT64;
	PROCEDURE Procedure (VAR value: FLOAT64); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with long real variable parameter with set argument

	MODULE Test;
	VAR argument: SET;
	PROCEDURE Procedure (VAR value: FLOAT64); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with long real variable parameter with array argument

	MODULE Test;
	VAR argument: ARRAY 10 OF CHAR;
	PROCEDURE Procedure (VAR value: FLOAT64); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with long real variable parameter with record argument

	MODULE Test;
	VAR argument: RECORD END;
	PROCEDURE Procedure (VAR value: FLOAT64); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with long real variable parameter with object argument

	MODULE Test;
	VAR argument: OBJECT END;
	PROCEDURE Procedure (VAR value: FLOAT64); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with long real variable parameter with base object argument

	MODULE Test;
	VAR argument: OBJECT;
	PROCEDURE Procedure (VAR value: FLOAT64); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with long real variable parameter with pointer to array argument

	MODULE Test;
	VAR argument: POINTER TO ARRAY 10 OF CHAR;
	PROCEDURE Procedure (VAR value: FLOAT64); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with long real variable parameter with pointer to record argument

	MODULE Test;
	VAR argument: POINTER TO RECORD END;
	PROCEDURE Procedure (VAR value: FLOAT64); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with long real variable parameter with procedure argument

	MODULE Test;
	VAR argument: PROCEDURE;
	PROCEDURE Procedure (VAR value: FLOAT64); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with set variable parameter with boolean argument

	MODULE Test;
	VAR argument: BOOLEAN;
	PROCEDURE Procedure (VAR value: SET); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with set variable parameter with character argument

	MODULE Test;
	VAR argument: CHAR;
	PROCEDURE Procedure (VAR value: SET); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with set variable parameter with short integer argument

	MODULE Test;
	VAR argument: SIGNED8;
	PROCEDURE Procedure (VAR value: SET); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with set variable parameter with integer argument

	MODULE Test;
	VAR argument: SIGNED16;
	PROCEDURE Procedure (VAR value: SET); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with set variable parameter with long integer argument

	MODULE Test;
	VAR argument: SIGNED32;
	PROCEDURE Procedure (VAR value: SET); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with set variable parameter with huge integer argument

	MODULE Test;
	VAR argument: SIGNED64;
	PROCEDURE Procedure (VAR value: SET); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with set variable parameter with real argument

	MODULE Test;
	VAR argument: FLOAT32;
	PROCEDURE Procedure (VAR value: SET); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with set variable parameter with long real argument

	MODULE Test;
	VAR argument: FLOAT64;
	PROCEDURE Procedure (VAR value: SET); END Procedure;
	BEGIN Procedure (argument);
	END Test.

positive: calling procedure with set variable parameter with set argument

	MODULE Test;
	VAR argument: SET;
	PROCEDURE Procedure (VAR value: SET); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with set variable parameter with array argument

	MODULE Test;
	VAR argument: ARRAY 10 OF CHAR;
	PROCEDURE Procedure (VAR value: SET); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with set variable parameter with record argument

	MODULE Test;
	VAR argument: RECORD END;
	PROCEDURE Procedure (VAR value: SET); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with set variable parameter with object argument

	MODULE Test;
	VAR argument: OBJECT END;
	PROCEDURE Procedure (VAR value: SET); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with set variable parameter with base object argument

	MODULE Test;
	VAR argument: OBJECT;
	PROCEDURE Procedure (VAR value: SET); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with set variable parameter with pointer to array argument

	MODULE Test;
	VAR argument: POINTER TO ARRAY 10 OF CHAR;
	PROCEDURE Procedure (VAR value: SET); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with set variable parameter with pointer to record argument

	MODULE Test;
	VAR argument: POINTER TO RECORD END;
	PROCEDURE Procedure (VAR value: SET); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with set variable parameter with procedure argument

	MODULE Test;
	VAR argument: PROCEDURE;
	PROCEDURE Procedure (VAR value: SET); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with array variable parameter with boolean argument

	MODULE Test;
	VAR argument: BOOLEAN;
	PROCEDURE Procedure (VAR value: ARRAY 10 OF CHAR); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with array variable parameter with character argument

	MODULE Test;
	VAR argument: CHAR;
	PROCEDURE Procedure (VAR value: ARRAY 10 OF CHAR); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with array variable parameter with short integer argument

	MODULE Test;
	VAR argument: SIGNED8;
	PROCEDURE Procedure (VAR value: ARRAY 10 OF CHAR); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with array variable parameter with integer argument

	MODULE Test;
	VAR argument: SIGNED16;
	PROCEDURE Procedure (VAR value: ARRAY 10 OF CHAR); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with array variable parameter with long integer argument

	MODULE Test;
	VAR argument: SIGNED32;
	PROCEDURE Procedure (VAR value: ARRAY 10 OF CHAR); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with array variable parameter with huge integer argument

	MODULE Test;
	VAR argument: SIGNED64;
	PROCEDURE Procedure (VAR value: ARRAY 10 OF CHAR); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with array variable parameter with real argument

	MODULE Test;
	VAR argument: FLOAT32;
	PROCEDURE Procedure (VAR value: ARRAY 10 OF CHAR); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with array variable parameter with long real argument

	MODULE Test;
	VAR argument: FLOAT64;
	PROCEDURE Procedure (VAR value: ARRAY 10 OF CHAR); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with array variable parameter with set argument

	MODULE Test;
	VAR argument: SET;
	PROCEDURE Procedure (VAR value: ARRAY 10 OF CHAR); END Procedure;
	BEGIN Procedure (argument);
	END Test.

positive: calling procedure with array variable parameter with array argument

	MODULE Test;
	VAR argument: ARRAY 10 OF CHAR;
	PROCEDURE Procedure (VAR value: ARRAY 10 OF CHAR); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with array variable parameter with longer array argument

	MODULE Test;
	VAR argument: ARRAY 20 OF CHAR;
	PROCEDURE Procedure (VAR value: ARRAY 10 OF CHAR); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with array variable parameter with record argument

	MODULE Test;
	VAR argument: RECORD END;
	PROCEDURE Procedure (VAR value: ARRAY 10 OF CHAR); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with array variable parameter with object argument

	MODULE Test;
	VAR argument: OBJECT END;
	PROCEDURE Procedure (VAR value: ARRAY 10 OF CHAR); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with array variable parameter with base object argument

	MODULE Test;
	VAR argument: OBJECT;
	PROCEDURE Procedure (VAR value: ARRAY 10 OF CHAR); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with array variable parameter with pointer to array argument

	MODULE Test;
	VAR argument: POINTER TO ARRAY 10 OF CHAR;
	PROCEDURE Procedure (VAR value: ARRAY 10 OF CHAR); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with array variable parameter with pointer to record argument

	MODULE Test;
	VAR argument: POINTER TO RECORD END;
	PROCEDURE Procedure (VAR value: ARRAY 10 OF CHAR); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with array variable parameter with procedure argument

	MODULE Test;
	VAR argument: PROCEDURE;
	PROCEDURE Procedure (VAR value: ARRAY 10 OF CHAR); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with open array variable parameter with boolean argument

	MODULE Test;
	VAR argument: BOOLEAN;
	PROCEDURE Procedure (VAR value: ARRAY OF CHAR); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with open array variable parameter with character argument

	MODULE Test;
	VAR argument: CHAR;
	PROCEDURE Procedure (VAR value: ARRAY OF CHAR); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with open array variable parameter with short integer argument

	MODULE Test;
	VAR argument: SIGNED8;
	PROCEDURE Procedure (VAR value: ARRAY OF CHAR); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with open array variable parameter with integer argument

	MODULE Test;
	VAR argument: SIGNED16;
	PROCEDURE Procedure (VAR value: ARRAY OF CHAR); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with open array variable parameter with long integer argument

	MODULE Test;
	VAR argument: SIGNED32;
	PROCEDURE Procedure (VAR value: ARRAY OF CHAR); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with open array variable parameter with huge integer argument

	MODULE Test;
	VAR argument: SIGNED64;
	PROCEDURE Procedure (VAR value: ARRAY OF CHAR); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with open array variable parameter with real argument

	MODULE Test;
	VAR argument: FLOAT32;
	PROCEDURE Procedure (VAR value: ARRAY OF CHAR); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with open array variable parameter with long real argument

	MODULE Test;
	VAR argument: FLOAT64;
	PROCEDURE Procedure (VAR value: ARRAY OF CHAR); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with open array variable parameter with set argument

	MODULE Test;
	VAR argument: SET;
	PROCEDURE Procedure (VAR value: ARRAY OF CHAR); END Procedure;
	BEGIN Procedure (argument);
	END Test.

positive: calling procedure with open array variable parameter with array argument

	MODULE Test;
	VAR argument: ARRAY 10 OF CHAR;
	PROCEDURE Procedure (VAR value: ARRAY OF CHAR); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with open array variable parameter with record argument

	MODULE Test;
	VAR argument: RECORD END;
	PROCEDURE Procedure (VAR value: ARRAY OF CHAR); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with open array variable parameter with object argument

	MODULE Test;
	VAR argument: OBJECT END;
	PROCEDURE Procedure (VAR value: ARRAY OF CHAR); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with open array variable parameter with base object argument

	MODULE Test;
	VAR argument: OBJECT;
	PROCEDURE Procedure (VAR value: ARRAY OF CHAR); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with open array variable parameter with pointer to array argument

	MODULE Test;
	VAR argument: POINTER TO ARRAY 10 OF CHAR;
	PROCEDURE Procedure (VAR value: ARRAY OF CHAR); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with open array variable parameter with pointer to record argument

	MODULE Test;
	VAR argument: POINTER TO RECORD END;
	PROCEDURE Procedure (VAR value: ARRAY OF CHAR); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with open array variable parameter with procedure argument

	MODULE Test;
	VAR argument: PROCEDURE;
	PROCEDURE Procedure (VAR value: ARRAY OF CHAR); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with record variable parameter with boolean argument

	MODULE Test;
	VAR argument: BOOLEAN;
	PROCEDURE Procedure (VAR value: RECORD END); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with record variable parameter with character argument

	MODULE Test;
	VAR argument: CHAR;
	PROCEDURE Procedure (VAR value: RECORD END); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with record variable parameter with short integer argument

	MODULE Test;
	VAR argument: SIGNED8;
	PROCEDURE Procedure (VAR value: RECORD END); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with record variable parameter with integer argument

	MODULE Test;
	VAR argument: SIGNED16;
	PROCEDURE Procedure (VAR value: RECORD END); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with record variable parameter with long integer argument

	MODULE Test;
	VAR argument: SIGNED32;
	PROCEDURE Procedure (VAR value: RECORD END); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with record variable parameter with huge integer argument

	MODULE Test;
	VAR argument: SIGNED64;
	PROCEDURE Procedure (VAR value: RECORD END); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with record variable parameter with real argument

	MODULE Test;
	VAR argument: FLOAT32;
	PROCEDURE Procedure (VAR value: RECORD END); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with record variable parameter with long real argument

	MODULE Test;
	VAR argument: FLOAT64;
	PROCEDURE Procedure (VAR value: RECORD END); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with record variable parameter with set argument

	MODULE Test;
	VAR argument: SET;
	PROCEDURE Procedure (VAR value: RECORD END); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with record variable parameter with array argument

	MODULE Test;
	VAR argument: ARRAY 10 OF CHAR;
	PROCEDURE Procedure (VAR value: RECORD END); END Procedure;
	BEGIN Procedure (argument);
	END Test.

positive: calling procedure with record variable parameter with record argument

	MODULE Test;
	TYPE Record = RECORD END;
	VAR argument: Record;
	PROCEDURE Procedure (VAR value: Record); END Procedure;
	BEGIN Procedure (argument);
	END Test.

positive: calling procedure with record variable parameter with compatible record argument

	MODULE Test;
	TYPE Record = RECORD END;
	VAR argument: RECORD (Record) END;
	PROCEDURE Procedure (VAR value: Record); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with record variable parameter with incompatible record argument

	MODULE Test;
	TYPE Record = RECORD END;
	VAR argument: Record;
	PROCEDURE Procedure (VAR value: RECORD (Record) END); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with record variable parameter with object argument

	MODULE Test;
	VAR argument: OBJECT END;
	PROCEDURE Procedure (VAR value: RECORD END); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with record variable parameter with base object argument

	MODULE Test;
	VAR argument: OBJECT;
	PROCEDURE Procedure (VAR value: RECORD END); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with record variable parameter with pointer to array argument

	MODULE Test;
	VAR argument: POINTER TO ARRAY 10 OF CHAR;
	PROCEDURE Procedure (VAR value: RECORD END); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with record variable parameter with pointer to record argument

	MODULE Test;
	VAR argument: POINTER TO RECORD END;
	PROCEDURE Procedure (VAR value: RECORD END); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with record variable parameter with procedure argument

	MODULE Test;
	VAR argument: PROCEDURE;
	PROCEDURE Procedure (VAR value: RECORD END); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with object variable parameter with boolean argument

	MODULE Test;
	VAR argument: BOOLEAN;
	PROCEDURE Procedure (VAR value: OBJECT END); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with object variable parameter with character argument

	MODULE Test;
	VAR argument: CHAR;
	PROCEDURE Procedure (VAR value: OBJECT END); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with object variable parameter with short integer argument

	MODULE Test;
	VAR argument: SIGNED8;
	PROCEDURE Procedure (VAR value: OBJECT END); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with object variable parameter with integer argument

	MODULE Test;
	VAR argument: SIGNED16;
	PROCEDURE Procedure (VAR value: OBJECT END); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with object variable parameter with long integer argument

	MODULE Test;
	VAR argument: SIGNED32;
	PROCEDURE Procedure (VAR value: OBJECT END); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with object variable parameter with huge integer argument

	MODULE Test;
	VAR argument: SIGNED64;
	PROCEDURE Procedure (VAR value: OBJECT END); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with object variable parameter with real argument

	MODULE Test;
	VAR argument: FLOAT32;
	PROCEDURE Procedure (VAR value: OBJECT END); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with object variable parameter with long real argument

	MODULE Test;
	VAR argument: FLOAT64;
	PROCEDURE Procedure (VAR value: OBJECT END); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with object variable parameter with set argument

	MODULE Test;
	VAR argument: SET;
	PROCEDURE Procedure (VAR value: OBJECT END); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with object variable parameter with array argument

	MODULE Test;
	VAR argument: ARRAY 10 OF CHAR;
	PROCEDURE Procedure (VAR value: OBJECT END); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with object variable parameter with record argument

	MODULE Test;
	VAR argument: RECORD END;
	PROCEDURE Procedure (VAR value: OBJECT END); END Procedure;
	BEGIN Procedure (argument);
	END Test.

positive: calling procedure with object variable parameter with object argument

	MODULE Test;
	TYPE Object = OBJECT END Object;
	VAR argument: Object;
	PROCEDURE Procedure (VAR value: Object); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with object variable parameter with compatible object argument

	MODULE Test;
	TYPE Object = OBJECT END Object;
	VAR argument: OBJECT (Object) END;
	PROCEDURE Procedure (VAR value: Object); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with object variable parameter with incompatible object argument

	MODULE Test;
	TYPE Object = OBJECT END Object;
	VAR argument: Object;
	PROCEDURE Procedure (VAR value: OBJECT (Object) END); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with object variable parameter with base object argument

	MODULE Test;
	VAR argument: OBJECT;
	PROCEDURE Procedure (VAR value: OBJECT END); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with object variable parameter with pointer to array argument

	MODULE Test;
	VAR argument: POINTER TO ARRAY 10 OF CHAR;
	PROCEDURE Procedure (VAR value: OBJECT END); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with object variable parameter with pointer to record argument

	MODULE Test;
	VAR argument: POINTER TO RECORD END;
	PROCEDURE Procedure (VAR value: OBJECT END); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with object variable parameter with procedure argument

	MODULE Test;
	VAR argument: PROCEDURE;
	PROCEDURE Procedure (VAR value: OBJECT END); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with base object variable parameter with boolean argument

	MODULE Test;
	VAR argument: BOOLEAN;
	PROCEDURE Procedure (VAR value: OBJECT); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with base object variable parameter with character argument

	MODULE Test;
	VAR argument: CHAR;
	PROCEDURE Procedure (VAR value: OBJECT); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with base object variable parameter with short integer argument

	MODULE Test;
	VAR argument: SIGNED8;
	PROCEDURE Procedure (VAR value: OBJECT); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with base object variable parameter with integer argument

	MODULE Test;
	VAR argument: SIGNED16;
	PROCEDURE Procedure (VAR value: OBJECT); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with base object variable parameter with long integer argument

	MODULE Test;
	VAR argument: SIGNED32;
	PROCEDURE Procedure (VAR value: OBJECT); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with base object variable parameter with huge integer argument

	MODULE Test;
	VAR argument: SIGNED64;
	PROCEDURE Procedure (VAR value: OBJECT); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with base object variable parameter with real argument

	MODULE Test;
	VAR argument: FLOAT32;
	PROCEDURE Procedure (VAR value: OBJECT); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with base object variable parameter with long real argument

	MODULE Test;
	VAR argument: FLOAT64;
	PROCEDURE Procedure (VAR value: OBJECT); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with base object variable parameter with set argument

	MODULE Test;
	VAR argument: SET;
	PROCEDURE Procedure (VAR value: OBJECT); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with base object variable parameter with array argument

	MODULE Test;
	VAR argument: ARRAY 10 OF CHAR;
	PROCEDURE Procedure (VAR value: OBJECT); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with base object variable parameter with record argument

	MODULE Test;
	VAR argument: RECORD END;
	PROCEDURE Procedure (VAR value: OBJECT); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with base object variable parameter with object argument

	MODULE Test;
	VAR argument: OBJECT END;
	PROCEDURE Procedure (VAR value: OBJECT); END Procedure;
	BEGIN Procedure (argument);
	END Test.

positive: calling procedure with base object variable parameter with base object argument

	MODULE Test;
	VAR argument: OBJECT;
	PROCEDURE Procedure (VAR value: OBJECT); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with base object variable parameter with pointer to array argument

	MODULE Test;
	VAR argument: POINTER TO ARRAY 10 OF CHAR;
	PROCEDURE Procedure (VAR value: OBJECT); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with base object variable parameter with pointer to record argument

	MODULE Test;
	VAR argument: POINTER TO RECORD END;
	PROCEDURE Procedure (VAR value: OBJECT); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with base object variable parameter with procedure argument

	MODULE Test;
	VAR argument: PROCEDURE;
	PROCEDURE Procedure (VAR value: OBJECT); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with pointer to array variable parameter with boolean argument

	MODULE Test;
	VAR argument: BOOLEAN;
	PROCEDURE Procedure (VAR value: POINTER TO ARRAY 10 OF CHAR); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with pointer to array variable parameter with character argument

	MODULE Test;
	VAR argument: CHAR;
	PROCEDURE Procedure (VAR value: POINTER TO ARRAY 10 OF CHAR); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with pointer to array variable parameter with short integer argument

	MODULE Test;
	VAR argument: SIGNED8;
	PROCEDURE Procedure (VAR value: POINTER TO ARRAY 10 OF CHAR); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with pointer to array variable parameter with integer argument

	MODULE Test;
	VAR argument: SIGNED16;
	PROCEDURE Procedure (VAR value: POINTER TO ARRAY 10 OF CHAR); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with pointer to array variable parameter with long integer argument

	MODULE Test;
	VAR argument: SIGNED32;
	PROCEDURE Procedure (VAR value: POINTER TO ARRAY 10 OF CHAR); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with pointer to array variable parameter with huge integer argument

	MODULE Test;
	VAR argument: SIGNED64;
	PROCEDURE Procedure (VAR value: POINTER TO ARRAY 10 OF CHAR); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with pointer to array variable parameter with real argument

	MODULE Test;
	VAR argument: FLOAT32;
	PROCEDURE Procedure (VAR value: POINTER TO ARRAY 10 OF CHAR); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with pointer to array variable parameter with long real argument

	MODULE Test;
	VAR argument: FLOAT64;
	PROCEDURE Procedure (VAR value: POINTER TO ARRAY 10 OF CHAR); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with pointer to array variable parameter with set argument

	MODULE Test;
	VAR argument: SET;
	PROCEDURE Procedure (VAR value: POINTER TO ARRAY 10 OF CHAR); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with pointer to array variable parameter with array argument

	MODULE Test;
	VAR argument: ARRAY 10 OF CHAR;
	PROCEDURE Procedure (VAR value: POINTER TO ARRAY 10 OF CHAR); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with pointer to array variable parameter with record argument

	MODULE Test;
	VAR argument: RECORD END;
	PROCEDURE Procedure (VAR value: POINTER TO ARRAY 10 OF CHAR); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with pointer to array variable parameter with object argument

	MODULE Test;
	VAR argument: OBJECT END;
	PROCEDURE Procedure (VAR value: POINTER TO ARRAY 10 OF CHAR); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with pointer to array variable parameter with base object argument

	MODULE Test;
	VAR argument: OBJECT;
	PROCEDURE Procedure (VAR value: POINTER TO ARRAY 10 OF CHAR); END Procedure;
	BEGIN Procedure (argument);
	END Test.

positive: calling procedure with pointer to array variable parameter with pointer to array argument

	MODULE Test;
	VAR argument: POINTER TO ARRAY 10 OF CHAR;
	PROCEDURE Procedure (VAR value: POINTER TO ARRAY 10 OF CHAR); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with pointer to array variable parameter with pointer to record argument

	MODULE Test;
	VAR argument: POINTER TO RECORD END;
	PROCEDURE Procedure (VAR value: POINTER TO ARRAY 10 OF CHAR); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with pointer to array variable parameter with procedure argument

	MODULE Test;
	VAR argument: PROCEDURE;
	PROCEDURE Procedure (VAR value: POINTER TO ARRAY 10 OF CHAR); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with pointer to record variable parameter with boolean argument

	MODULE Test;
	VAR argument: BOOLEAN;
	PROCEDURE Procedure (VAR value: POINTER TO RECORD END); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with pointer to record variable parameter with character argument

	MODULE Test;
	VAR argument: CHAR;
	PROCEDURE Procedure (VAR value: POINTER TO RECORD END); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with pointer to record variable parameter with short integer argument

	MODULE Test;
	VAR argument: SIGNED8;
	PROCEDURE Procedure (VAR value: POINTER TO RECORD END); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with pointer to record variable parameter with integer argument

	MODULE Test;
	VAR argument: SIGNED16;
	PROCEDURE Procedure (VAR value: POINTER TO RECORD END); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with pointer to record variable parameter with long integer argument

	MODULE Test;
	VAR argument: SIGNED32;
	PROCEDURE Procedure (VAR value: POINTER TO RECORD END); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with pointer to record variable parameter with huge integer argument

	MODULE Test;
	VAR argument: SIGNED64;
	PROCEDURE Procedure (VAR value: POINTER TO RECORD END); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with pointer to record variable parameter with real argument

	MODULE Test;
	VAR argument: FLOAT32;
	PROCEDURE Procedure (VAR value: POINTER TO RECORD END); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with pointer to record variable parameter with long real argument

	MODULE Test;
	VAR argument: FLOAT64;
	PROCEDURE Procedure (VAR value: POINTER TO RECORD END); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with pointer to record variable parameter with set argument

	MODULE Test;
	VAR argument: SET;
	PROCEDURE Procedure (VAR value: POINTER TO RECORD END); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with pointer to record variable parameter with array argument

	MODULE Test;
	VAR argument: ARRAY 10 OF CHAR;
	PROCEDURE Procedure (VAR value: POINTER TO RECORD END); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with pointer to record variable parameter with record argument

	MODULE Test;
	VAR argument: RECORD END;
	PROCEDURE Procedure (VAR value: POINTER TO RECORD END); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with pointer to record variable parameter with object argument

	MODULE Test;
	VAR argument: OBJECT END;
	PROCEDURE Procedure (VAR value: POINTER TO RECORD END); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with pointer to record variable parameter with base object argument

	MODULE Test;
	VAR argument: OBJECT;
	PROCEDURE Procedure (VAR value: POINTER TO RECORD END); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with pointer to record variable parameter with pointer to array argument

	MODULE Test;
	VAR argument: POINTER TO ARRAY 10 OF CHAR;
	PROCEDURE Procedure (VAR value: POINTER TO RECORD END); END Procedure;
	BEGIN Procedure (argument);
	END Test.

positive: calling procedure with pointer to record variable parameter with pointer to record argument

	MODULE Test;
	TYPE Record = RECORD END;
	VAR argument: POINTER TO Record;
	PROCEDURE Procedure (VAR value: POINTER TO Record); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with pointer to record variable parameter with compatible pointer to record argument

	MODULE Test;
	TYPE Record = RECORD END;
	VAR argument: POINTER TO RECORD (Record) END;
	PROCEDURE Procedure (VAR value: POINTER TO Record); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with pointer to record variable parameter with incompatible pointer to record argument

	MODULE Test;
	TYPE Record = RECORD END;
	VAR argument: POINTER TO Record;
	PROCEDURE Procedure (VAR value: POINTER TO RECORD (Record) END); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with pointer to record variable parameter with procedure argument

	MODULE Test;
	VAR argument: PROCEDURE;
	PROCEDURE Procedure (VAR value: POINTER TO RECORD END); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with procedure variable parameter with boolean argument

	MODULE Test;
	VAR argument: BOOLEAN;
	PROCEDURE Procedure (VAR value: PROCEDURE); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with procedure variable parameter with character argument

	MODULE Test;
	VAR argument: CHAR;
	PROCEDURE Procedure (VAR value: PROCEDURE); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with procedure variable parameter with short integer argument

	MODULE Test;
	VAR argument: SIGNED8;
	PROCEDURE Procedure (VAR value: PROCEDURE); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with procedure variable parameter with integer argument

	MODULE Test;
	VAR argument: SIGNED16;
	PROCEDURE Procedure (VAR value: PROCEDURE); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with procedure variable parameter with long integer argument

	MODULE Test;
	VAR argument: SIGNED32;
	PROCEDURE Procedure (VAR value: PROCEDURE); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with procedure variable parameter with huge integer argument

	MODULE Test;
	VAR argument: SIGNED64;
	PROCEDURE Procedure (VAR value: PROCEDURE); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with procedure variable parameter with real argument

	MODULE Test;
	VAR argument: FLOAT32;
	PROCEDURE Procedure (VAR value: PROCEDURE); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with procedure variable parameter with long real argument

	MODULE Test;
	VAR argument: FLOAT64;
	PROCEDURE Procedure (VAR value: PROCEDURE); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with procedure variable parameter with set argument

	MODULE Test;
	VAR argument: SET;
	PROCEDURE Procedure (VAR value: PROCEDURE); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with procedure variable parameter with array argument

	MODULE Test;
	VAR argument: ARRAY 10 OF CHAR;
	PROCEDURE Procedure (VAR value: PROCEDURE); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with procedure variable parameter with record argument

	MODULE Test;
	VAR argument: RECORD END;
	PROCEDURE Procedure (VAR value: PROCEDURE); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with procedure variable parameter with object argument

	MODULE Test;
	VAR argument: OBJECT END;
	PROCEDURE Procedure (VAR value: PROCEDURE); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with procedure variable parameter with base object argument

	MODULE Test;
	VAR argument: OBJECT;
	PROCEDURE Procedure (VAR value: PROCEDURE); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with procedure variable parameter with pointer to array argument

	MODULE Test;
	VAR argument: POINTER TO ARRAY 10 OF CHAR;
	PROCEDURE Procedure (VAR value: PROCEDURE); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure with procedure variable parameter with pointer to record argument

	MODULE Test;
	VAR argument: POINTER TO RECORD END;
	PROCEDURE Procedure (VAR value: PROCEDURE); END Procedure;
	BEGIN Procedure (argument);
	END Test.

positive: calling procedure with procedure variable parameter with procedure argument

	MODULE Test;
	VAR argument: PROCEDURE;
	PROCEDURE Procedure (VAR value: PROCEDURE); END Procedure;
	BEGIN Procedure (argument);
	END Test.

negative: calling procedure returning boolean

	MODULE Test;
	PROCEDURE Procedure (): BOOLEAN; END Procedure;
	BEGIN Procedure ()
	END Test.

positive: ignoring procedure call returning boolean

	MODULE Test;
	PROCEDURE Procedure (): BOOLEAN; END Procedure;
	BEGIN IGNORE Procedure ()
	END Test.

negative: calling procedure returning character

	MODULE Test;
	PROCEDURE Procedure (): CHAR; END Procedure;
	BEGIN Procedure ()
	END Test.

positive: ignoring procedure call returning character

	MODULE Test;
	PROCEDURE Procedure (): CHAR; END Procedure;
	BEGIN IGNORE Procedure ()
	END Test.

negative: calling procedure returning integer

	MODULE Test;
	PROCEDURE Procedure (): SIGNED16; END Procedure;
	BEGIN Procedure ()
	END Test.

positive: ignoring procedure call returning integer

	MODULE Test;
	PROCEDURE Procedure (): SIGNED16; END Procedure;
	BEGIN IGNORE Procedure ()
	END Test.

negative: calling procedure returning real

	MODULE Test;
	PROCEDURE Procedure (): FLOAT32; END Procedure;
	BEGIN Procedure ()
	END Test.

positive: ignoring procedure call returning real

	MODULE Test;
	PROCEDURE Procedure (): FLOAT32; END Procedure;
	BEGIN IGNORE Procedure ()
	END Test.

negative: calling procedure returning set

	MODULE Test;
	PROCEDURE Procedure (): SET; END Procedure;
	BEGIN Procedure ()
	END Test.

positive: ignoring procedure call returning set

	MODULE Test;
	PROCEDURE Procedure (): SET; END Procedure;
	BEGIN IGNORE Procedure ()
	END Test.

negative: calling procedure returning array

	MODULE Test;
	PROCEDURE Procedure (): ARRAY 10 OF CHAR; END Procedure;
	BEGIN Procedure ()
	END Test.

positive: ignoring procedure call returning array

	MODULE Test;
	PROCEDURE Procedure (): ARRAY 10 OF CHAR; END Procedure;
	BEGIN IGNORE Procedure ()
	END Test.

negative: calling procedure returning record

	MODULE Test;
	PROCEDURE Procedure (): RECORD END; END Procedure;
	BEGIN Procedure ()
	END Test.

positive: ignoring procedure call returning record

	MODULE Test;
	PROCEDURE Procedure (): RECORD END; END Procedure;
	BEGIN IGNORE Procedure ()
	END Test.

negative: calling procedure returning object

	MODULE Test;
	PROCEDURE Procedure (): OBJECT END; END Procedure;
	BEGIN Procedure ()
	END Test.

positive: ignoring procedure call returning object

	MODULE Test;
	PROCEDURE Procedure (): OBJECT END; END Procedure;
	BEGIN IGNORE Procedure ()
	END Test.

negative: calling procedure returning base object

	MODULE Test;
	PROCEDURE Procedure (): OBJECT; END Procedure;
	BEGIN Procedure ()
	END Test.

positive: ignoring procedure call returning base object

	MODULE Test;
	PROCEDURE Procedure (): OBJECT; END Procedure;
	BEGIN IGNORE Procedure ()
	END Test.

negative: calling procedure returning pointer to array

	MODULE Test;
	PROCEDURE Procedure (): POINTER TO ARRAY 10 OF CHAR; END Procedure;
	BEGIN Procedure ()
	END Test.

positive: ignoring procedure call returning pointer to array

	MODULE Test;
	PROCEDURE Procedure (): POINTER TO ARRAY 10 OF CHAR; END Procedure;
	BEGIN IGNORE Procedure ()
	END Test.

negative: calling procedure returning pointer to record

	MODULE Test;
	PROCEDURE Procedure (): POINTER TO ARRAY 10 OF RECORD END; END Procedure;
	BEGIN Procedure ()
	END Test.

positive: ignoring procedure call returning pointer to record

	MODULE Test;
	PROCEDURE Procedure (): POINTER TO ARRAY 10 OF RECORD END; END Procedure;
	BEGIN IGNORE Procedure ()
	END Test.

negative: calling procedure returning procedure

	MODULE Test;
	PROCEDURE Procedure (): PROCEDURE; END Procedure;
	BEGIN Procedure ()
	END Test.

positive: ignoring procedure call returning procedure

	MODULE Test;
	PROCEDURE Procedure (): PROCEDURE; END Procedure;
	BEGIN IGNORE Procedure ()
	END Test.

positive: calling procedure returning nothing

	MODULE Test;
	PROCEDURE Procedure (); END Procedure;
	BEGIN Procedure; Procedure ()
	END Test.

negative: ignoring procedure call returning nothing

	MODULE Test;
	PROCEDURE Procedure (); END Procedure;
	BEGIN IGNORE Procedure ()
	END Test.


# initializers

negative: initializer within module

	MODULE Test;
	PROCEDURE &Initializer; END Initializer;
	END Test.

negative: initializer within procedure

	MODULE Test;
	PROCEDURE Procedure;
		PROCEDURE &Initializer; END Initializer;
	END Procedure;
	END Test.

negative: initializer within nested procedure

	MODULE Test;
	PROCEDURE Procedure;
		PROCEDURE Procedure;
			PROCEDURE &Initializer; END Initializer;
		END Procedure;
	END Procedure;
	END Test.

positive: initializer within object

	MODULE Test;
	TYPE Object = OBJECT
		PROCEDURE &Initializer; END Initializer;
	END Object;
	END Test.

positive: initializer within object in procedure

	MODULE Test;
	PROCEDURE Procedure;
		TYPE Object = OBJECT
			PROCEDURE &Initializer; END Initializer;
		END Object;
	END Procedure;
	END Test.

negative: initializer within procedure in object

	MODULE Test;
	TYPE Object = OBJECT
		PROCEDURE Procedure;
			PROCEDURE &Initializer; END Initializer;
		END Procedure;
	END Object;
	END Test.

negative: initializer within nested procedure in object

	MODULE Test;
	TYPE Object = OBJECT
		PROCEDURE Procedure;
			PROCEDURE Procedure;
				PROCEDURE &Initializer; END Initializer;
			END Procedure;
		END Procedure;
	END Object;
	END Test.

negative: two initializers in object

	MODULE Test;
	TYPE Object = OBJECT
		PROCEDURE &Initializer1; END Initializer1;
		PROCEDURE &Initializer2; END Initializer2;
	END Object;
	END Test.

negative: two initializers in object with same name

	MODULE Test;
	TYPE Object = OBJECT
		PROCEDURE &Initializer; END Initializer;
		PROCEDURE &Initializer; END Initializer;
	END Object;
	END Test.

positive: initializer without return type

	MODULE Test;
	TYPE Object = OBJECT
		PROCEDURE &Initializer; END Initializer;
	END Object;
	END Test.

negative: initializer with return type

	MODULE Test;
	TYPE Object = OBJECT
		PROCEDURE &Initializer (): Object; END Initializer;
	END Object;
	END Test.

positive: initializer with parameter

	MODULE Test;
	TYPE Object = OBJECT
		PROCEDURE &Initializer (object: Object); END Initializer;
	END Object;
	END Test.

positive: initializer with parameters

	MODULE Test;
	TYPE Object = OBJECT
		PROCEDURE &Initializer (a, b: Object); END Initializer;
	END Object;
	END Test.


# statement blocks

negative: invalid block modifier notag

	MODULE Test;
	BEGIN {NOTAG};
	END Test.

negative: invalid block modifier delegate

	MODULE Test;
	BEGIN {DELEGATE};
	END Test.

negative: repeated exclusive block modifier

	MODULE Test;
	BEGIN {EXCLUSIVE, EXCLUSIVE};
	END Test.

negative: repeated active block modifier

	MODULE Test;
	TYPE Object = OBJECT
	BEGIN {ACTIVE,ACTIVE}
	END Object;
	END Test.

positive: exclusive module body

	MODULE Test;
	BEGIN {EXCLUSIVE}
	END Test.

positive: nested exclusive module body

	MODULE Test;
	BEGIN BEGIN {EXCLUSIVE} END
	END Test.

negative: exclusive block in exclusive module body

	MODULE Test;
	BEGIN {EXCLUSIVE} BEGIN {EXCLUSIVE} END
	END Test.

negative: exclusive block in active module body

	MODULE Test;
	BEGIN {ACTIVE} BEGIN {EXCLUSIVE} END
	END Test.

positive: exclusive object body

	MODULE Test;
	TYPE Object = OBJECT
	BEGIN {EXCLUSIVE}
	END Object;
	END Test.

positive: nested exclusive object body

	MODULE Test;
	TYPE Object = OBJECT
	BEGIN BEGIN {EXCLUSIVE} END
	END Object;
	END Test.

negative: exclusive block in exclusive object body

	MODULE Test;
	TYPE Object = OBJECT
	BEGIN {EXCLUSIVE} BEGIN {EXCLUSIVE} END
	END Object;
	END Test.

positive: exclusive block in active object body

	MODULE Test;
	TYPE Object = OBJECT
	BEGIN {ACTIVE} BEGIN {EXCLUSIVE} END
	END Object;
	END Test.

positive: exclusive procedure body within module

	MODULE Test;
	PROCEDURE Procedure;
	BEGIN {EXCLUSIVE}
	END Procedure;
	END Test.

positive: nested exclusive procedure body within module

	MODULE Test;
	PROCEDURE Procedure;
	BEGIN BEGIN {EXCLUSIVE} END
	END Procedure;
	END Test.

negative: exclusive block in exclusive procedure body within module

	MODULE Test;
	PROCEDURE Procedure;
	BEGIN {EXCLUSIVE} BEGIN {EXCLUSIVE} END
	END Procedure;
	END Test.

negative: exclusive block in active procedure body within module

	MODULE Test;
	PROCEDURE Procedure;
	BEGIN {ACTIVE} BEGIN {EXCLUSIVE} END
	END Procedure;
	END Test.

positive: exclusive procedure body within object

	MODULE Test;
	TYPE Object = OBJECT
		PROCEDURE Procedure;
		BEGIN {EXCLUSIVE}
		END Procedure;
	END Object;
	END Test.

positive: exclusive nested procedure body within object

	MODULE Test;
	TYPE Object = OBJECT
		PROCEDURE Procedure;
		BEGIN BEGIN {EXCLUSIVE} END
		END Procedure;
	END Object;
	END Test.

negative: exclusive block in exclusive procedure body within object

	MODULE Test;
	TYPE Object = OBJECT
		PROCEDURE Procedure;
		BEGIN {EXCLUSIVE} BEGIN {EXCLUSIVE} END
		END Procedure;
	END Object;
	END Test.

negative: exclusive block in active procedure body within object

	MODULE Test;
	TYPE Object = OBJECT
		PROCEDURE Procedure;
		BEGIN {ACTIVE} BEGIN {EXCLUSIVE} END
		END Procedure;
	END Object;
	END Test.

negative: active module body

	MODULE Test;
	BEGIN {ACTIVE}
	END Test.

negative: nested active module body

	MODULE Test;
	BEGIN BEGIN {ACTIVE} END
	END Test.

negative: active block in active module body

	MODULE Test;
	BEGIN {ACTIVE} BEGIN {ACTIVE} END
	END Test.

negative: active block in exclusive module body

	MODULE Test;
	BEGIN {EXCLUSIVE} BEGIN {ACTIVE} END
	END Test.

positive: active object body

	MODULE Test;
	TYPE Object = OBJECT
	BEGIN {ACTIVE}
	END Object;
	END Test.

negative: nested active object body

	MODULE Test;
	TYPE Object = OBJECT
	BEGIN BEGIN {ACTIVE} END
	END Object;
	END Test.

negative: active block in active object body

	MODULE Test;
	TYPE Object = OBJECT
	BEGIN {ACTIVE} BEGIN {ACTIVE} END
	END Object;
	END Test.

negative: active block in exclusive object body

	MODULE Test;
	TYPE Object = OBJECT
	BEGIN {EXCLUSIVE} BEGIN {ACTIVE} END
	END Object;
	END Test.

negative: active procedure body within module

	MODULE Test;
	PROCEDURE Procedure;
	BEGIN {ACTIVE}
	END Procedure;
	END Test.

negative: nested active procedure body within module

	MODULE Test;
	PROCEDURE Procedure;
	BEGIN BEGIN {ACTIVE} END
	END Procedure;
	END Test.

negative: active block in active procedure body within module

	MODULE Test;
	PROCEDURE Procedure;
	BEGIN {ACTIVE} BEGIN {ACTIVE} END
	END Procedure;
	END Test.

negative: active block in exclusive procedure body within module

	MODULE Test;
	PROCEDURE Procedure;
	BEGIN {EXCLUSIVE} BEGIN {ACTIVE} END
	END Procedure;
	END Test.

negative: active procedure body within object

	MODULE Test;
	TYPE Object = OBJECT
		PROCEDURE Procedure;
		BEGIN {ACTIVE}
		END Procedure;
	END Object;
	END Test.

negative: active nested procedure body within object

	MODULE Test;
	TYPE Object = OBJECT
		PROCEDURE Procedure;
		BEGIN BEGIN {ACTIVE} END
		END Procedure;
	END Object;
	END Test.

negative: active block in active procedure body within object

	MODULE Test;
	TYPE Object = OBJECT
		PROCEDURE Procedure;
		BEGIN {ACTIVE} BEGIN {ACTIVE} END
		END Procedure;
	END Object;
	END Test.

negative: active block in exclusive procedure body within object

	MODULE Test;
	TYPE Object = OBJECT
		PROCEDURE Procedure;
		BEGIN {EXCLUSIVE} BEGIN {ACTIVE} END
		END Procedure;
	END Object;
	END Test.

negative: exclusive and active module body

	MODULE Test;
	BEGIN {EXCLUSIVE, ACTIVE}
	END Test.

negative: nested exclusive and active module body

	MODULE Test;
	BEGIN BEGIN {EXCLUSIVE, ACTIVE} END
	END Test.

negative: exclusive and active block in exclusive and active module body

	MODULE Test;
	BEGIN {EXCLUSIVE, ACTIVE} BEGIN {EXCLUSIVE, ACTIVE} END
	END Test.

positive: exclusive and active object body

	MODULE Test;
	TYPE Object = OBJECT
	BEGIN {EXCLUSIVE, ACTIVE}
	END Object;
	END Test.

negative: nested exclusive and active object body

	MODULE Test;
	TYPE Object = OBJECT
	BEGIN BEGIN {EXCLUSIVE, ACTIVE} END
	END Object;
	END Test.

negative: exclusive and active block in exclusive and active object body

	MODULE Test;
	TYPE Object = OBJECT
	BEGIN {EXCLUSIVE, ACTIVE} BEGIN {EXCLUSIVE, ACTIVE} END
	END Object;
	END Test.

negative: exclusive and active procedure body within module

	MODULE Test;
	PROCEDURE Procedure;
	BEGIN {EXCLUSIVE, ACTIVE}
	END Procedure;
	END Test.

negative: nested exclusive and active procedure body within module

	MODULE Test;
	PROCEDURE Procedure;
	BEGIN BEGIN {EXCLUSIVE, ACTIVE} END
	END Procedure;
	END Test.

negative: exclusive and active block in exclusive and active procedure body within module

	MODULE Test;
	PROCEDURE Procedure;
	BEGIN {EXCLUSIVE, ACTIVE} BEGIN {EXCLUSIVE, ACTIVE} END
	END Procedure;
	END Test.

negative: exclusive and active procedure body within object

	MODULE Test;
	TYPE Object = OBJECT
		PROCEDURE Procedure;
		BEGIN {EXCLUSIVE, ACTIVE}
		END Procedure;
	END Object;
	END Test.

negative: exclusive and active nested procedure body within object

	MODULE Test;
	TYPE Object = OBJECT
		PROCEDURE Procedure;
		BEGIN BEGIN {EXCLUSIVE, ACTIVE} END
		END Procedure;
	END Object;
	END Test.

negative: exclusive and active block in exclusive and active procedure body within object

	MODULE Test;
	TYPE Object = OBJECT
		PROCEDURE Procedure;
		BEGIN {EXCLUSIVE, ACTIVE} BEGIN {EXCLUSIVE, ACTIVE} END
		END Procedure;
	END Object;
	END Test.


# while statement

positive: while statement with constant true condition

	MODULE Test;
	BEGIN WHILE TRUE DO END;
	END Test.

positive: while statement with constant false condition

	MODULE Test;
	BEGIN WHILE FALSE DO END;
	END Test.

negative: while statement with constant condition of type character

	MODULE Test;
	BEGIN WHILE 'a' DO END;
	END Test.

negative: while statement with constant condition of type integer

	MODULE Test;
	BEGIN WHILE 5 DO END;
	END Test.

negative: while statement with constant condition of type real

	MODULE Test;
	BEGIN WHILE 4.5 DO END;
	END Test.

negative: while statement with constant condition of type set

	MODULE Test;
	BEGIN WHILE {5} DO END;
	END Test.

negative: while statement with constant condition of type string

	MODULE Test;
	BEGIN WHILE "condition" DO END;
	END Test.

negative: while statement with constant condition of type nil pointer

	MODULE Test;
	BEGIN WHILE NIL DO END;
	END Test.

positive: while statement with condition of type boolean

	MODULE Test;
	VAR condition: BOOLEAN;
	BEGIN WHILE condition DO END;
	END Test.

negative: while statement with condition of type character

	MODULE Test;
	VAR condition: CHAR;
	BEGIN WHILE condition DO END;
	END Test.

negative: while statement with condition of type short integer

	MODULE Test;
	VAR condition: SIGNED8;
	BEGIN WHILE condition DO END;
	END Test.

negative: while statement with condition of type integer

	MODULE Test;
	VAR condition: SIGNED16;
	BEGIN WHILE condition DO END;
	END Test.

negative: while statement with condition of type long integer

	MODULE Test;
	VAR condition: SIGNED32;
	BEGIN WHILE condition DO END;
	END Test.

negative: while statement with condition of type huge integer

	MODULE Test;
	VAR condition: SIGNED64;
	BEGIN WHILE condition DO END;
	END Test.

negative: while statement with condition of type real

	MODULE Test;
	VAR condition: FLOAT32;
	BEGIN WHILE condition DO END;
	END Test.

negative: while statement with condition of type long real

	MODULE Test;
	VAR condition: FLOAT64;
	BEGIN WHILE condition DO END;
	END Test.

negative: while statement with condition of type set

	MODULE Test;
	VAR condition: SET;
	BEGIN WHILE condition DO END;
	END Test.

negative: while statement with condition of type array

	MODULE Test;
	VAR condition: ARRAY 10 OF CHAR;
	BEGIN WHILE condition DO END;
	END Test.

negative: while statement with condition of type record

	MODULE Test;
	VAR condition: RECORD END;
	BEGIN WHILE condition DO END;
	END Test.

negative: while statement with condition of type object

	MODULE Test;
	VAR condition: OBJECT;
	BEGIN WHILE condition DO END;
	END Test.

negative: while statement with condition of type pointer

	MODULE Test;
	VAR condition: POINTER TO RECORD END;
	BEGIN WHILE condition DO END;
	END Test.

negative: while statement with condition of type procedure

	MODULE Test;
	VAR condition: PROCEDURE;
	BEGIN WHILE condition DO END;
	END Test.

negative: while statement with import as condition

	MODULE Test;
	IMPORT condition := Dummy;
	BEGIN WHILE condition DO END;
	END Test.

negative: while statement with type as condition

	MODULE Test;
	TYPE condition = BOOLEAN;
	BEGIN WHILE condition DO END;
	END Test.


# repeat statement

positive: repeat statement with constant true condition

	MODULE Test;
	BEGIN REPEAT UNTIL TRUE;
	END Test.

positive: repeat statement with constant false condition

	MODULE Test;
	BEGIN REPEAT UNTIL FALSE;
	END Test.

negative: repeat statement with constant condition of type character

	MODULE Test;
	BEGIN REPEAT UNTIL 'a';
	END Test.

negative: repeat statement with constant condition of type integer

	MODULE Test;
	BEGIN REPEAT UNTIL 5;
	END Test.

negative: repeat statement with constant condition of type real

	MODULE Test;
	BEGIN REPEAT UNTIL 4.5;
	END Test.

negative: repeat statement with constant condition of type set

	MODULE Test;
	BEGIN REPEAT UNTIL {5};
	END Test.

negative: repeat statement with constant condition of type string

	MODULE Test;
	BEGIN REPEAT UNTIL "condition";
	END Test.

negative: repeat statement with constant condition of type nil pointer

	MODULE Test;
	BEGIN REPEAT UNTIL NIL;
	END Test.

positive: repeat statement with condition of type boolean

	MODULE Test;
	VAR condition: BOOLEAN;
	BEGIN REPEAT UNTIL condition;
	END Test.

negative: repeat statement with condition of type character

	MODULE Test;
	VAR condition: CHAR;
	BEGIN REPEAT UNTIL condition;
	END Test.

negative: repeat statement with condition of type short integer

	MODULE Test;
	VAR condition: SIGNED8;
	BEGIN REPEAT UNTIL condition;
	END Test.

negative: repeat statement with condition of type integer

	MODULE Test;
	VAR condition: SIGNED16;
	BEGIN REPEAT UNTIL condition;
	END Test.

negative: repeat statement with condition of type long integer

	MODULE Test;
	VAR condition: SIGNED32;
	BEGIN REPEAT UNTIL condition;
	END Test.

negative: repeat statement with condition of type huge integer

	MODULE Test;
	VAR condition: SIGNED64;
	BEGIN REPEAT UNTIL condition;
	END Test.

negative: repeat statement with condition of type real

	MODULE Test;
	VAR condition: FLOAT32;
	BEGIN REPEAT UNTIL condition;
	END Test.

negative: repeat statement with condition of type long real

	MODULE Test;
	VAR condition: FLOAT64;
	BEGIN REPEAT UNTIL condition;
	END Test.

negative: repeat statement with condition of type set

	MODULE Test;
	VAR condition: SET;
	BEGIN REPEAT UNTIL condition;
	END Test.

negative: repeat statement with condition of type array

	MODULE Test;
	VAR condition: ARRAY 10 OF CHAR;
	BEGIN REPEAT UNTIL condition;
	END Test.

negative: repeat statement with condition of type record

	MODULE Test;
	VAR condition: RECORD END;
	BEGIN REPEAT UNTIL condition;
	END Test.

negative: repeat statement with condition of type object

	MODULE Test;
	VAR condition: OBJECT;
	BEGIN REPEAT UNTIL condition;
	END Test.

negative: repeat statement with condition of type pointer

	MODULE Test;
	VAR condition: POINTER TO RECORD END;
	BEGIN REPEAT UNTIL condition;
	END Test.

negative: repeat statement with condition of type procedure

	MODULE Test;
	VAR condition: PROCEDURE;
	BEGIN REPEAT UNTIL condition;
	END Test.

negative: repeat statement with import as condition

	MODULE Test;
	IMPORT condition := Dummy;
	BEGIN REPEAT UNTIL condition;
	END Test.

negative: repeat statement with type as condition

	MODULE Test;
	TYPE condition = BOOLEAN;
	BEGIN REPEAT UNTIL condition;
	END Test.


# await statement

positive: await statement in non-exclusive block

	MODULE Test;
	VAR condition: BOOLEAN;
	BEGIN AWAIT (condition);
	END Test.

positive: await statement in nested non-exclusive block

	MODULE Test;
	VAR condition: BOOLEAN;
	BEGIN BEGIN AWAIT (condition) END;
	END Test.

positive: await statement in exclusive block

	MODULE Test;
	VAR condition: BOOLEAN;
	BEGIN {EXCLUSIVE} AWAIT (condition);
	END Test.

positive: await statement in nested exclusive block

	MODULE Test;
	VAR condition: BOOLEAN;
	BEGIN BEGIN {EXCLUSIVE} AWAIT (condition) END;
	END Test.

positive: await statement within nested exclusive block

	MODULE Test;
	VAR condition: BOOLEAN;
	BEGIN {EXCLUSIVE} BEGIN AWAIT (condition) END;
	END Test.

negative: await statement with constant true condition

	MODULE Test;
	BEGIN {EXCLUSIVE} AWAIT (TRUE);
	END Test.

negative: await statement with constant false condition

	MODULE Test;
	BEGIN {EXCLUSIVE} AWAIT (FALSE);
	END Test.

negative: await statement with constant condition of type character

	MODULE Test;
	BEGIN {EXCLUSIVE} AWAIT ('a');
	END Test.

negative: await statement with constant condition of type integer

	MODULE Test;
	BEGIN {EXCLUSIVE} AWAIT (5);
	END Test.

negative: await statement with constant condition of type real

	MODULE Test;
	BEGIN {EXCLUSIVE} AWAIT (4.5);
	END Test.

negative: await statement with constant condition of type set

	MODULE Test;
	BEGIN {EXCLUSIVE} AWAIT ({5});
	END Test.

negative: await statement with constant condition of type string

	MODULE Test;
	BEGIN {EXCLUSIVE} AWAIT ("condition");
	END Test.

negative: await statement with constant condition of type nil pointer

	MODULE Test;
	BEGIN {EXCLUSIVE} AWAIT (NIL);
	END Test.

positive: await statement with condition of type boolean

	MODULE Test;
	VAR condition: BOOLEAN;
	BEGIN {EXCLUSIVE} AWAIT (condition);
	END Test.

negative: await statement with condition of type character

	MODULE Test;
	VAR condition: CHAR;
	BEGIN {EXCLUSIVE} AWAIT (condition);
	END Test.

negative: await statement with condition of type short integer

	MODULE Test;
	VAR condition: SIGNED8;
	BEGIN {EXCLUSIVE} AWAIT (condition);
	END Test.

negative: await statement with condition of type integer

	MODULE Test;
	VAR condition: SIGNED16;
	BEGIN {EXCLUSIVE} AWAIT (condition);
	END Test.

negative: await statement with condition of type long integer

	MODULE Test;
	VAR condition: SIGNED32;
	BEGIN {EXCLUSIVE} AWAIT (condition);
	END Test.

negative: await statement with condition of type huge integer

	MODULE Test;
	VAR condition: SIGNED64;
	BEGIN {EXCLUSIVE} AWAIT (condition);
	END Test.

negative: await statement with condition of type real

	MODULE Test;
	VAR condition: FLOAT32;
	BEGIN {EXCLUSIVE} AWAIT (condition);
	END Test.

negative: await statement with condition of type long real

	MODULE Test;
	VAR condition: FLOAT64;
	BEGIN {EXCLUSIVE} AWAIT (condition);
	END Test.

negative: await statement with condition of type set

	MODULE Test;
	VAR condition: SET;
	BEGIN {EXCLUSIVE} AWAIT (condition);
	END Test.

negative: await statement with condition of type array

	MODULE Test;
	VAR condition: ARRAY 10 OF CHAR;
	BEGIN {EXCLUSIVE} AWAIT (condition);
	END Test.

negative: await statement with condition of type record

	MODULE Test;
	VAR condition: RECORD END;
	BEGIN {EXCLUSIVE} AWAIT (condition);
	END Test.

negative: await statement with condition of type object

	MODULE Test;
	VAR condition: OBJECT;
	BEGIN {EXCLUSIVE} AWAIT (condition);
	END Test.

negative: await statement with condition of type pointer

	MODULE Test;
	VAR condition: POINTER TO RECORD END;
	BEGIN {EXCLUSIVE} AWAIT (condition);
	END Test.

negative: await statement with condition of type procedure

	MODULE Test;
	VAR condition: PROCEDURE;
	BEGIN {EXCLUSIVE} AWAIT (condition);
	END Test.

negative: await statement with import as condition

	MODULE Test;
	IMPORT condition := Dummy;
	BEGIN {EXCLUSIVE} AWAIT (condition);
	END Test.

negative: await statement with type as condition

	MODULE Test;
	TYPE condition = BOOLEAN;
	BEGIN {EXCLUSIVE} AWAIT (condition);
	END Test.


# assignment statement

positive: constant boolean to variable boolean assignment

	MODULE Test;
	VAR result: BOOLEAN;
	BEGIN result := TRUE;
	END Test.

negative: constant boolean to temporary boolean assignment

	MODULE Test;
	VAR result: PROCEDURE (): BOOLEAN;
	BEGIN result () := TRUE;
	END Test.

negative: constant character to variable boolean assignment

	MODULE Test;
	VAR result: BOOLEAN;
	BEGIN result := 'f';
	END Test.

negative: constant short integer to variable boolean assignment

	MODULE Test;
	VAR result: BOOLEAN;
	BEGIN result := 10H;
	END Test.

negative: constant integer to variable boolean assignment

	MODULE Test;
	VAR result: BOOLEAN;
	BEGIN result := 1000H;
	END Test.

negative: constant long integer to variable boolean assignment

	MODULE Test;
	VAR result: BOOLEAN;
	BEGIN result := 100000H;
	END Test.

negative: constant huge integer to variable boolean assignment

	MODULE Test;
	VAR result: BOOLEAN;
	BEGIN result := 10000000000H;
	END Test.

negative: constant real to variable boolean assignment

	MODULE Test;
	VAR result: BOOLEAN;
	BEGIN result := 5.4;
	END Test.

negative: constant long real to variable boolean assignment

	MODULE Test;
	VAR result: BOOLEAN;
	BEGIN result := 5.4D100;
	END Test.

negative: constant set to variable boolean assignment

	MODULE Test;
	VAR result: BOOLEAN;
	BEGIN result := {5};
	END Test.

negative: string to variable boolean assignment

	MODULE Test;
	VAR result: BOOLEAN;
	BEGIN result := "string";
	END Test.

negative: nil pointer to variable boolean assignment

	MODULE Test;
	VAR result: BOOLEAN;
	BEGIN result := NIL;
	END Test.

negative: procedure to variable boolean assignment

	MODULE Test;
	VAR result: BOOLEAN;
	PROCEDURE Procedure; END Procedure;
	BEGIN result := Procedure;
	END Test.

negative: constant boolean to variable character assignment

	MODULE Test;
	VAR result: CHAR;
	BEGIN result := TRUE;
	END Test.

positive: constant character to variable character assignment

	MODULE Test;
	VAR result: CHAR;
	BEGIN result := 'f';
	END Test.

negative: constant character to temporary character assignment

	MODULE Test;
	VAR result: PROCEDURE (): CHAR;
	BEGIN result () := 'u';
	END Test.

negative: constant short integer to variable character assignment

	MODULE Test;
	VAR result: CHAR;
	BEGIN result := 10H;
	END Test.

negative: constant integer to variable character assignment

	MODULE Test;
	VAR result: CHAR;
	BEGIN result := 1000H;
	END Test.

negative: constant long integer to variable character assignment

	MODULE Test;
	VAR result: CHAR;
	BEGIN result := 100000H;
	END Test.

negative: constant huge integer to variable character assignment

	MODULE Test;
	VAR result: CHAR;
	BEGIN result := 10000000000H;
	END Test.

negative: constant real to variable character assignment

	MODULE Test;
	VAR result: CHAR;
	BEGIN result := 5.4;
	END Test.

negative: constant long real to variable character assignment

	MODULE Test;
	VAR result: CHAR;
	BEGIN result := 5.4D100;
	END Test.

negative: constant set to variable character assignment

	MODULE Test;
	VAR result: CHAR;
	BEGIN result := {5};
	END Test.

negative: string to variable character assignment

	MODULE Test;
	VAR result: CHAR;
	BEGIN result := "string";
	END Test.

negative: nil pointer to variable character assignment

	MODULE Test;
	VAR result: CHAR;
	BEGIN result := NIL;
	END Test.

negative: procedure to variable character assignment

	MODULE Test;
	VAR result: CHAR;
	PROCEDURE Procedure; END Procedure;
	BEGIN result := Procedure;
	END Test.

negative: constant boolean to variable short integer assignment

	MODULE Test;
	VAR result: SIGNED8;
	BEGIN result := TRUE;
	END Test.

negative: constant character to variable short integer assignment

	MODULE Test;
	VAR result: SIGNED8;
	BEGIN result := 'f';
	END Test.

positive: constant short integer to variable short integer assignment

	MODULE Test;
	VAR result: SIGNED8;
	BEGIN result := 10H;
	END Test.

negative: constant short integer to temporary short integer assignment

	MODULE Test;
	VAR result: PROCEDURE (): SIGNED8;
	BEGIN result () := 10H;
	END Test.

negative: constant integer to variable short integer assignment

	MODULE Test;
	VAR result: SIGNED8;
	BEGIN result := 1000H;
	END Test.

negative: constant long integer to variable short integer assignment

	MODULE Test;
	VAR result: SIGNED8;
	BEGIN result := 100000H;
	END Test.

negative: constant huge integer to variable short integer assignment

	MODULE Test;
	VAR result: SIGNED8;
	BEGIN result := 10000000000H;
	END Test.

negative: constant real to variable short integer assignment

	MODULE Test;
	VAR result: SIGNED8;
	BEGIN result := 5.4;
	END Test.

negative: constant long real to variable short integer assignment

	MODULE Test;
	VAR result: SIGNED8;
	BEGIN result := 5.4D100;
	END Test.

negative: constant set to variable short integer assignment

	MODULE Test;
	VAR result: SIGNED8;
	BEGIN result := {5};
	END Test.

negative: string to variable short integer assignment

	MODULE Test;
	VAR result: SIGNED8;
	BEGIN result := "string";
	END Test.

negative: nil pointer to variable short integer assignment

	MODULE Test;
	VAR result: SIGNED8;
	BEGIN result := NIL;
	END Test.

negative: procedure to variable short integer assignment

	MODULE Test;
	VAR result: SIGNED8;
	PROCEDURE Procedure; END Procedure;
	BEGIN result := Procedure;
	END Test.

negative: constant boolean to variable integer assignment

	MODULE Test;
	VAR result: SIGNED16;
	BEGIN result := TRUE;
	END Test.

negative: constant character to variable integer assignment

	MODULE Test;
	VAR result: SIGNED16;
	BEGIN result := 'f';
	END Test.

positive: constant short integer to variable integer assignment

	MODULE Test;
	VAR result: SIGNED16;
	BEGIN result := 10H;
	END Test.

negative: constant short integer to temporary integer assignment

	MODULE Test;
	VAR result: PROCEDURE (): SIGNED16;
	BEGIN result () := 10H;
	END Test.

positive: constant integer to variable integer assignment

	MODULE Test;
	VAR result: SIGNED16;
	BEGIN result := 1000H;
	END Test.

negative: constant integer to temporary integer assignment

	MODULE Test;
	VAR result: PROCEDURE (): SIGNED16;
	BEGIN result () := 1000H;
	END Test.

negative: constant long integer to variable integer assignment

	MODULE Test;
	VAR result: SIGNED16;
	BEGIN result := 100000H;
	END Test.

negative: constant huge integer to variable integer assignment

	MODULE Test;
	VAR result: SIGNED16;
	BEGIN result := 10000000000H;
	END Test.

negative: constant real to variable integer assignment

	MODULE Test;
	VAR result: SIGNED16;
	BEGIN result := 5.4;
	END Test.

negative: constant long real to variable integer assignment

	MODULE Test;
	VAR result: SIGNED16;
	BEGIN result := 5.4D100;
	END Test.

negative: constant set to variable integer assignment

	MODULE Test;
	VAR result: SIGNED16;
	BEGIN result := {5};
	END Test.

negative: string to variable integer assignment

	MODULE Test;
	VAR result: SIGNED16;
	BEGIN result := "string";
	END Test.

negative: nil pointer to variable integer assignment

	MODULE Test;
	VAR result: SIGNED16;
	BEGIN result := NIL;
	END Test.

negative: procedure to variable integer assignment

	MODULE Test;
	VAR result: SIGNED16;
	PROCEDURE Procedure; END Procedure;
	BEGIN result := Procedure;
	END Test.

negative: constant boolean to variable long integer assignment

	MODULE Test;
	VAR result: SIGNED32;
	BEGIN result := TRUE;
	END Test.

negative: constant character to variable long integer assignment

	MODULE Test;
	VAR result: SIGNED32;
	BEGIN result := 'f';
	END Test.

positive: constant short integer to variable long integer assignment

	MODULE Test;
	VAR result: SIGNED32;
	BEGIN result := 10H;
	END Test.

negative: constant short integer to temporary long integer assignment

	MODULE Test;
	VAR result: PROCEDURE (): SIGNED32;
	BEGIN result () := 10H;
	END Test.

positive: constant integer to variable long integer assignment

	MODULE Test;
	VAR result: SIGNED32;
	BEGIN result := 1000H;
	END Test.

negative: constant integer to temporary long integer assignment

	MODULE Test;
	VAR result: PROCEDURE (): SIGNED32;
	BEGIN result () := 1000H;
	END Test.

positive: constant long integer to variable long integer assignment

	MODULE Test;
	VAR result: SIGNED32;
	BEGIN result := 100000H;
	END Test.

negative: constant long integer to temporary long integer assignment

	MODULE Test;
	VAR result: PROCEDURE (): SIGNED32;
	BEGIN result () := 100000H;
	END Test.

negative: constant huge integer to variable long integer assignment

	MODULE Test;
	VAR result: SIGNED32;
	BEGIN result := 10000000000H;
	END Test.

negative: constant real to variable long integer assignment

	MODULE Test;
	VAR result: SIGNED32;
	BEGIN result := 5.4;
	END Test.

negative: constant long real to variable long integer assignment

	MODULE Test;
	VAR result: SIGNED32;
	BEGIN result := 5.4D100;
	END Test.

negative: constant set to variable long integer assignment

	MODULE Test;
	VAR result: SIGNED32;
	BEGIN result := {5};
	END Test.

negative: string to variable long integer assignment

	MODULE Test;
	VAR result: SIGNED32;
	BEGIN result := "string";
	END Test.

negative: nil pointer to variable long integer assignment

	MODULE Test;
	VAR result: SIGNED32;
	BEGIN result := NIL;
	END Test.

negative: procedure to variable long integer assignment

	MODULE Test;
	VAR result: SIGNED32;
	PROCEDURE Procedure; END Procedure;
	BEGIN result := Procedure;
	END Test.

negative: constant boolean to variable huge integer assignment

	MODULE Test;
	VAR result: SIGNED64;
	BEGIN result := TRUE;
	END Test.

negative: constant character to variable huge integer assignment

	MODULE Test;
	VAR result: SIGNED64;
	BEGIN result := 'f';
	END Test.

positive: constant short integer to variable huge integer assignment

	MODULE Test;
	VAR result: SIGNED64;
	BEGIN result := 10H;
	END Test.

negative: constant short integer to temporary huge integer assignment

	MODULE Test;
	VAR result: PROCEDURE (): SIGNED64;
	BEGIN result () := 10H;
	END Test.

positive: constant integer to variable huge integer assignment

	MODULE Test;
	VAR result: SIGNED64;
	BEGIN result := 1000H;
	END Test.

negative: constant integer to temporary huge integer assignment

	MODULE Test;
	VAR result: PROCEDURE (): SIGNED64;
	BEGIN result () := 1000H;
	END Test.

positive: constant long integer to variable huge integer assignment

	MODULE Test;
	VAR result: SIGNED64;
	BEGIN result := 100000H;
	END Test.

negative: constant long integer to temporary huge integer assignment

	MODULE Test;
	VAR result: PROCEDURE (): SIGNED64;
	BEGIN result () := 100000H;
	END Test.

positive: constant huge integer to variable huge integer assignment

	MODULE Test;
	VAR result: SIGNED64;
	BEGIN result := 10000000000H;
	END Test.

negative: constant huge integer to temporary huge integer assignment

	MODULE Test;
	VAR result: PROCEDURE (): SIGNED64;
	BEGIN result () := 10000000000H;
	END Test.

negative: constant real to variable huge integer assignment

	MODULE Test;
	VAR result: SIGNED64;
	BEGIN result := 5.4;
	END Test.

negative: constant long real to variable huge integer assignment

	MODULE Test;
	VAR result: SIGNED64;
	BEGIN result := 5.4D100;
	END Test.

negative: constant set to variable huge integer assignment

	MODULE Test;
	VAR result: SIGNED64;
	BEGIN result := {5};
	END Test.

negative: string to variable huge integer assignment

	MODULE Test;
	VAR result: SIGNED64;
	BEGIN result := "string";
	END Test.

negative: nil pointer to variable huge integer assignment

	MODULE Test;
	VAR result: SIGNED64;
	BEGIN result := NIL;
	END Test.

negative: procedure to variable huge integer assignment

	MODULE Test;
	VAR result: SIGNED64;
	PROCEDURE Procedure; END Procedure;
	BEGIN result := Procedure;
	END Test.

negative: constant boolean to variable real assignment

	MODULE Test;
	VAR result: FLOAT32;
	BEGIN result := TRUE;
	END Test.

negative: constant character to variable real assignment

	MODULE Test;
	VAR result: FLOAT32;
	BEGIN result := 'f';
	END Test.

positive: constant short integer to variable real assignment

	MODULE Test;
	VAR result: FLOAT32;
	BEGIN result := 10H;
	END Test.

negative: constant short integer to temporary real assignment

	MODULE Test;
	VAR result: PROCEDURE (): FLOAT32;
	BEGIN result () := 10H;
	END Test.

positive: constant integer to variable real assignment

	MODULE Test;
	VAR result: FLOAT32;
	BEGIN result := 1000H;
	END Test.

negative: constant integer to temporary real assignment

	MODULE Test;
	VAR result: PROCEDURE (): FLOAT32;
	BEGIN result () := 1000H;
	END Test.

positive: constant long integer to variable real assignment

	MODULE Test;
	VAR result: FLOAT32;
	BEGIN result := 100000H;
	END Test.

negative: constant long integer to temporary real assignment

	MODULE Test;
	VAR result: PROCEDURE (): FLOAT32;
	BEGIN result () := 100000H;
	END Test.

positive: constant huge integer to variable real assignment

	MODULE Test;
	VAR result: FLOAT32;
	BEGIN result := 10000000000H;
	END Test.

negative: constant huge integer to temporary real assignment

	MODULE Test;
	VAR result: PROCEDURE (): FLOAT32;
	BEGIN result () := 10000000000H;
	END Test.

positive: constant real to variable real assignment

	MODULE Test;
	VAR result: FLOAT32;
	BEGIN result := 5.4;
	END Test.

negative: constant real to temporary real assignment

	MODULE Test;
	VAR result: PROCEDURE (): FLOAT32;
	BEGIN result () := 5.4;
	END Test.

negative: constant long real to variable real assignment

	MODULE Test;
	VAR result: FLOAT32;
	BEGIN result := 5.4D100;
	END Test.

negative: constant set to variable real assignment

	MODULE Test;
	VAR result: FLOAT32;
	BEGIN result := {5};
	END Test.

negative: string to variable real assignment

	MODULE Test;
	VAR result: FLOAT32;
	BEGIN result := "string";
	END Test.

negative: nil pointer to variable real assignment

	MODULE Test;
	VAR result: FLOAT32;
	BEGIN result := NIL;
	END Test.

negative: procedure to variable real assignment

	MODULE Test;
	VAR result: FLOAT32;
	PROCEDURE Procedure; END Procedure;
	BEGIN result := Procedure;
	END Test.

negative: constant boolean to variable long real assignment

	MODULE Test;
	VAR result: FLOAT64;
	BEGIN result := TRUE;
	END Test.

negative: constant character to variable long real assignment

	MODULE Test;
	VAR result: FLOAT64;
	BEGIN result := 'f';
	END Test.

positive: constant short integer to variable long real assignment

	MODULE Test;
	VAR result: FLOAT64;
	BEGIN result := 10H;
	END Test.

negative: constant short integer to temporary long real assignment

	MODULE Test;
	VAR result: PROCEDURE (): FLOAT64;
	BEGIN result () := 10H;
	END Test.

positive: constant integer to variable long real assignment

	MODULE Test;
	VAR result: FLOAT64;
	BEGIN result := 1000H;
	END Test.

negative: constant integer to temporary long real assignment

	MODULE Test;
	VAR result: PROCEDURE (): FLOAT64;
	BEGIN result () := 1000H;
	END Test.

positive: constant long integer to variable long real assignment

	MODULE Test;
	VAR result: FLOAT64;
	BEGIN result := 100000H;
	END Test.

negative: constant long integer to temporary long real assignment

	MODULE Test;
	VAR result: PROCEDURE (): FLOAT64;
	BEGIN result () := 100000H;
	END Test.

positive: constant huge integer to variable long real assignment

	MODULE Test;
	VAR result: FLOAT64;
	BEGIN result := 10000000000H;
	END Test.

negative: constant huge integer to temporary long real assignment

	MODULE Test;
	VAR result: PROCEDURE (): FLOAT64;
	BEGIN result () := 10000000000H;
	END Test.

positive: constant real to variable long real assignment

	MODULE Test;
	VAR result: FLOAT64;
	BEGIN result := 5.4;
	END Test.

negative: constant real to temporary long real assignment

	MODULE Test;
	VAR result: PROCEDURE (): FLOAT64;
	BEGIN result () := 5.4;
	END Test.

positive: constant long real to variable long real assignment

	MODULE Test;
	VAR result: FLOAT64;
	BEGIN result := 5.4D100;
	END Test.

negative: constant long real to temporary long real assignment

	MODULE Test;
	VAR result: PROCEDURE (): FLOAT64;
	BEGIN result () := 5.4D100;
	END Test.

negative: constant set to variable long real assignment

	MODULE Test;
	VAR result: FLOAT64;
	BEGIN result := {5};
	END Test.

negative: string to variable long real assignment

	MODULE Test;
	VAR result: FLOAT64;
	BEGIN result := "string";
	END Test.

negative: nil pointer to variable long real assignment

	MODULE Test;
	VAR result: FLOAT64;
	BEGIN result := NIL;
	END Test.

negative: procedure to variable long real assignment

	MODULE Test;
	VAR result: FLOAT64;
	PROCEDURE Procedure; END Procedure;
	BEGIN result := Procedure;
	END Test.

negative: constant boolean to variable set assignment

	MODULE Test;
	VAR result: SET;
	BEGIN result := TRUE;
	END Test.

negative: constant character to variable set assignment

	MODULE Test;
	VAR result: SET;
	BEGIN result := 'f';
	END Test.

negative: constant short integer to variable set assignment

	MODULE Test;
	VAR result: SET;
	BEGIN result := 10H;
	END Test.

negative: constant integer to variable set assignment

	MODULE Test;
	VAR result: SET;
	BEGIN result := 1000H;
	END Test.

negative: constant long integer to variable set assignment

	MODULE Test;
	VAR result: SET;
	BEGIN result := 100000H;
	END Test.

negative: constant huge integer to variable set assignment

	MODULE Test;
	VAR result: SET;
	BEGIN result := 10000000000H;
	END Test.

negative: constant real to variable set assignment

	MODULE Test;
	VAR result: SET;
	BEGIN result := 5.4;
	END Test.

negative: constant long real to variable set assignment

	MODULE Test;
	VAR result: SET;
	BEGIN result := 5.4D100;
	END Test.

positive: constant set to variable set assignment

	MODULE Test;
	VAR result: SET;
	BEGIN result := {5};
	END Test.

negative: constant set to temporary set assignment

	MODULE Test;
	VAR result: PROCEDURE (): SET;
	BEGIN result () := {5};
	END Test.

negative: string to variable set assignment

	MODULE Test;
	VAR result: SET;
	BEGIN result := "string";
	END Test.

negative: nil pointer to variable set assignment

	MODULE Test;
	VAR result: SET;
	BEGIN result := NIL;
	END Test.

negative: procedure to variable set assignment

	MODULE Test;
	VAR result: SET;
	PROCEDURE Procedure; END Procedure;
	BEGIN result := Procedure;
	END Test.

negative: constant boolean to variable array assignment

	MODULE Test;
	VAR result: ARRAY 10 OF CHAR;
	BEGIN result := TRUE;
	END Test.

#temporarily removed
#negative: constant character to variable array assignment
#
#	MODULE Test;
#	VAR result: ARRAY 10 OF CHAR;
#	BEGIN result := 'f';
#	END Test.

negative: constant short integer to variable array assignment

	MODULE Test;
	VAR result: ARRAY 10 OF CHAR;
	BEGIN result := 10H;
	END Test.

negative: constant integer to variable array assignment

	MODULE Test;
	VAR result: ARRAY 10 OF CHAR;
	BEGIN result := 1000H;
	END Test.

negative: constant long integer to variable array assignment

	MODULE Test;
	VAR result: ARRAY 10 OF CHAR;
	BEGIN result := 100000H;
	END Test.

negative: constant huge integer to variable array assignment

	MODULE Test;
	VAR result: ARRAY 10 OF CHAR;
	BEGIN result := 10000000000H;
	END Test.

negative: constant real to variable array assignment

	MODULE Test;
	VAR result: ARRAY 10 OF CHAR;
	BEGIN result := 5.4;
	END Test.

negative: constant long real to variable array assignment

	MODULE Test;
	VAR result: ARRAY 10 OF CHAR;
	BEGIN result := 5.4D100;
	END Test.

negative: constant set to variable array assignment

	MODULE Test;
	VAR result: ARRAY 10 OF CHAR;
	BEGIN result := {5};
	END Test.

negative: string to variable array of boolean assignment

	MODULE Test;
	VAR result: ARRAY 10 OF BOOLEAN;
	BEGIN result := "string";
	END Test.

positive: string to longer variable array of character assignment

	MODULE Test;
	VAR result: ARRAY 10 OF CHAR;
	BEGIN result := "string";
	END Test.

negative: string to longer temporary array of character assignment

	MODULE Test;
	VAR result: PROCEDURE (): ARRAY 10 OF CHAR;
	BEGIN result () := "string";
	END Test.

positive: string to variable array of character of equal size assignment

	MODULE Test;
	VAR result: ARRAY 7 OF CHAR;
	BEGIN result := "string";
	END Test.

negative: string to temporary array of equal size assignment

	MODULE Test;
	VAR result: PROCEDURE (): ARRAY 7 OF CHAR;
	BEGIN result () := "string";
	END Test.

negative: string to shorter variable array of character assignment

	MODULE Test;
	VAR result: ARRAY 6 OF CHAR;
	BEGIN result := "string";
	END Test.

negative: string to variable array of short integer assignment

	MODULE Test;
	VAR result: ARRAY 10 OF SIGNED8;
	BEGIN result := "string";
	END Test.

negative: string to variable array of integer assignment

	MODULE Test;
	VAR result: ARRAY 10 OF SIGNED16;
	BEGIN result := "string";
	END Test.

negative: string to variable array of long integer assignment

	MODULE Test;
	VAR result: ARRAY 10 OF SIGNED32;
	BEGIN result := "string";
	END Test.

negative: string to variable array of huge integer assignment

	MODULE Test;
	VAR result: ARRAY 10 OF SIGNED64;
	BEGIN result := "string";
	END Test.

negative: string to variable array of real assignment

	MODULE Test;
	VAR result: ARRAY 10 OF FLOAT32;
	BEGIN result := "string";
	END Test.

negative: string to variable array of long real assignment

	MODULE Test;
	VAR result: ARRAY 10 OF FLOAT64;
	BEGIN result := "string";
	END Test.

negative: string to variable array of set assignment

	MODULE Test;
	VAR result: ARRAY 10 OF SET;
	BEGIN result := "string";
	END Test.

negative: string to variable array of array assignment

	MODULE Test;
	VAR result: ARRAY 10 OF ARRAY 10 OF CHAR;
	BEGIN result := "string";
	END Test.

negative: string to variable array of record assignment

	MODULE Test;
	VAR result: ARRAY 10 OF RECORD END;
	BEGIN result := "string";
	END Test.

negative: string to variable array of object assignment

	MODULE Test;
	VAR result: ARRAY 10 OF OBJECT END;
	BEGIN result := "string";
	END Test.

negative: string to variable array of pointer assignment

	MODULE Test;
	VAR result: ARRAY 10 OF POINTER TO RECORD END;
	BEGIN result := "string";
	END Test.

negative: string to variable array of procedure assignment

	MODULE Test;
	VAR result: ARRAY 10 OF PROCEDURE;
	BEGIN result := "string";
	END Test.

negative: nil pointer to variable array assignment

	MODULE Test;
	VAR result: ARRAY 10 OF CHAR;
	BEGIN result := NIL;
	END Test.

negative: procedure to variable array assignment

	MODULE Test;
	VAR result: ARRAY 10 OF PROCEDURE;
	PROCEDURE Procedure; END Procedure;
	BEGIN result := Procedure;
	END Test.

negative: constant boolean to record assignment

	MODULE Test;
	VAR result: RECORD END;
	BEGIN result := TRUE;
	END Test.

negative: constant character to record assignment

	MODULE Test;
	VAR result: RECORD END;
	BEGIN result := 'f';
	END Test.

negative: constant short integer to record assignment

	MODULE Test;
	VAR result: RECORD END;
	BEGIN result := 10H;
	END Test.

negative: constant integer to record assignment

	MODULE Test;
	VAR result: RECORD END;
	BEGIN result := 1000H;
	END Test.

negative: constant long integer to record assignment

	MODULE Test;
	VAR result: RECORD END;
	BEGIN result := 100000H;
	END Test.

negative: constant huge integer to record assignment

	MODULE Test;
	VAR result: RECORD END;
	BEGIN result := 10000000000H;
	END Test.

negative: constant real to record assignment

	MODULE Test;
	VAR result: RECORD END;
	BEGIN result := 5.4;
	END Test.

negative: constant long real to record assignment

	MODULE Test;
	VAR result: RECORD END;
	BEGIN result := 5.4D100;
	END Test.

negative: constant set to record assignment

	MODULE Test;
	VAR result: RECORD END;
	BEGIN result := {5};
	END Test.

negative: string to record assignment

	MODULE Test;
	VAR result: RECORD END;
	BEGIN result := "string";
	END Test.

negative: nil pointer to record assignment

	MODULE Test;
	VAR result: RECORD END;
	BEGIN result := NIL;
	END Test.

negative: procedure to record assignment

	MODULE Test;
	VAR result: RECORD END;
	PROCEDURE Procedure; END Procedure;
	BEGIN result := Procedure;
	END Test.

negative: constant boolean to object assignment

	MODULE Test;
	VAR result: OBJECT END;
	BEGIN result := TRUE;
	END Test.

negative: constant character to object assignment

	MODULE Test;
	VAR result: OBJECT END;
	BEGIN result := 'f';
	END Test.

negative: constant short integer to object assignment

	MODULE Test;
	VAR result: OBJECT END;
	BEGIN result := 10H;
	END Test.

negative: constant integer to object assignment

	MODULE Test;
	VAR result: OBJECT END;
	BEGIN result := 1000H;
	END Test.

negative: constant long integer to object assignment

	MODULE Test;
	VAR result: OBJECT END;
	BEGIN result := 100000H;
	END Test.

negative: constant huge integer to object assignment

	MODULE Test;
	VAR result: OBJECT END;
	BEGIN result := 10000000000H;
	END Test.

negative: constant real to object assignment

	MODULE Test;
	VAR result: OBJECT END;
	BEGIN result := 5.4;
	END Test.

negative: constant long real to object assignment

	MODULE Test;
	VAR result: OBJECT END;
	BEGIN result := 5.4D100;
	END Test.

negative: constant set to object assignment

	MODULE Test;
	VAR result: OBJECT END;
	BEGIN result := {5};
	END Test.

negative: string to object assignment

	MODULE Test;
	VAR result: OBJECT END;
	BEGIN result := "string";
	END Test.

positive: nil pointer to object assignment

	MODULE Test;
	VAR result: OBJECT END;
	BEGIN result := NIL;
	END Test.

negative: nil pointer to temporary object assignment

	MODULE Test;
	VAR result: PROCEDURE (): OBJECT END;
	BEGIN result () := NIL;
	END Test.

negative: procedure to object assignment

	MODULE Test;
	VAR result: OBJECT END;
	PROCEDURE Procedure; END Procedure;
	BEGIN result := Procedure;
	END Test.

negative: constant boolean to pointer assignment

	MODULE Test;
	VAR result: POINTER TO RECORD END;
	BEGIN result := TRUE;
	END Test.

negative: constant character to pointer assignment

	MODULE Test;
	VAR result: POINTER TO RECORD END;
	BEGIN result := 'f';
	END Test.

negative: constant short integer to pointer assignment

	MODULE Test;
	VAR result: POINTER TO RECORD END;
	BEGIN result := 10H;
	END Test.

negative: constant integer to pointer assignment

	MODULE Test;
	VAR result: POINTER TO RECORD END;
	BEGIN result := 1000H;
	END Test.

negative: constant long integer to pointer assignment

	MODULE Test;
	VAR result: POINTER TO RECORD END;
	BEGIN result := 100000H;
	END Test.

negative: constant huge integer to pointer assignment

	MODULE Test;
	VAR result: POINTER TO RECORD END;
	BEGIN result := 10000000000H;
	END Test.

negative: constant real to pointer assignment

	MODULE Test;
	VAR result: POINTER TO RECORD END;
	BEGIN result := 5.4;
	END Test.

negative: constant long real to pointer assignment

	MODULE Test;
	VAR result: POINTER TO RECORD END;
	BEGIN result := 5.4D100;
	END Test.

negative: constant set to pointer assignment

	MODULE Test;
	VAR result: POINTER TO RECORD END;
	BEGIN result := {5};
	END Test.

negative: string to pointer assignment

	MODULE Test;
	VAR result: POINTER TO RECORD END;
	BEGIN result := "string";
	END Test.

positive: nil pointer to pointer assignment

	MODULE Test;
	VAR result: POINTER TO RECORD END;
	BEGIN result := NIL;
	END Test.

negative: nil pointer to temporary pointer assignment

	MODULE Test;
	VAR result: PROCEDURE (): POINTER TO RECORD END;
	BEGIN result () := NIL;
	END Test.

negative: procedure to pointer assignment

	MODULE Test;
	VAR result: POINTER TO RECORD END;
	PROCEDURE Procedure; END Procedure;
	BEGIN result := Procedure;
	END Test.

negative: constant boolean to procedure assignment

	MODULE Test;
	VAR result: PROCEDURE;
	BEGIN result := TRUE;
	END Test.

negative: constant character to procedure assignment

	MODULE Test;
	VAR result: PROCEDURE;
	BEGIN result := 'f';
	END Test.

negative: constant short integer to procedure assignment

	MODULE Test;
	VAR result: PROCEDURE;
	BEGIN result := 10H;
	END Test.

negative: constant integer to procedure assignment

	MODULE Test;
	VAR result: PROCEDURE;
	BEGIN result := 1000H;
	END Test.

negative: constant long integer to procedure assignment

	MODULE Test;
	VAR result: PROCEDURE;
	BEGIN result := 100000H;
	END Test.

negative: constant huge integer to procedure assignment

	MODULE Test;
	VAR result: PROCEDURE;
	BEGIN result := 10000000000H;
	END Test.

negative: constant real to procedure assignment

	MODULE Test;
	VAR result: PROCEDURE;
	BEGIN result := 5.4;
	END Test.

negative: constant long real to procedure assignment

	MODULE Test;
	VAR result: PROCEDURE;
	BEGIN result := 5.4D100;
	END Test.

negative: constant set to procedure assignment

	MODULE Test;
	VAR result: PROCEDURE;
	BEGIN result := {5};
	END Test.

negative: string to procedure assignment

	MODULE Test;
	VAR result: PROCEDURE;
	BEGIN result := "string";
	END Test.

positive: nil pointer to procedure assignment

	MODULE Test;
	VAR result: PROCEDURE;
	BEGIN result := NIL;
	END Test.

negative: nil pointer to temporary procedure assignment

	MODULE Test;
	VAR result: PROCEDURE (): PROCEDURE;
	BEGIN result () := NIL;
	END Test.

positive: procedure with one equal parameter to procedure assignment

	MODULE Test;
	VAR result: PROCEDURE (a: SIGNED16);
	PROCEDURE Procedure (b: SIGNED16); END Procedure;
	BEGIN result := Procedure;
	END Test.

negative: procedure with one compatible parameter to procedure assignment

	MODULE Test;
	VAR result: PROCEDURE (a: SIGNED16);
	PROCEDURE Procedure (b: SIGNED32); END Procedure;
	BEGIN result := Procedure;
	END Test.

negative: procedure with one incompatible parameter to procedure assignment

	MODULE Test;
	VAR result: PROCEDURE (a: SET);
	PROCEDURE Procedure (b: SIGNED32); END Procedure;
	BEGIN result := Procedure;
	END Test.

negative: procedure with one equal variable parameter to procedure assignment

	MODULE Test;
	VAR result: PROCEDURE (VAR a: SIGNED16);
	PROCEDURE Procedure (b: SIGNED16); END Procedure;
	BEGIN result := Procedure;
	END Test.

negative: procedure with one equal constant parameter to procedure assignment

	MODULE Test;
	VAR result: PROCEDURE (CONST a: SIGNED16);
	PROCEDURE Procedure (b: SIGNED16); END Procedure;
	BEGIN result := Procedure;
	END Test.

positive: procedure with two equal parameters to procedure assignment

	MODULE Test;
	VAR result: PROCEDURE (a, b: SIGNED16);
	PROCEDURE Procedure (c, d: SIGNED16); END Procedure;
	BEGIN result := Procedure;
	END Test.

negative: procedure with two compatible parameters to procedure assignment

	MODULE Test;
	VAR result: PROCEDURE (a, b: SIGNED16);
	PROCEDURE Procedure (c, d: SIGNED32); END Procedure;
	BEGIN result := Procedure;
	END Test.

negative: procedure with two incompatible parameters to procedure assignment

	MODULE Test;
	VAR result: PROCEDURE (a, b: SET);
	PROCEDURE Procedure (c, d: SIGNED32); END Procedure;
	BEGIN result := Procedure;
	END Test.

negative: procedure with two equal variable parameters to procedure assignment

	MODULE Test;
	VAR result: PROCEDURE (VAR a, b: SIGNED16);
	PROCEDURE Procedure (c, d: SIGNED16); END Procedure;
	BEGIN result := Procedure;
	END Test.

negative: procedure with two equal constant parameters to procedure assignment

	MODULE Test;
	VAR result: PROCEDURE (CONST a, b: SIGNED16);
	PROCEDURE Procedure (c, d: SIGNED16); END Procedure;
	BEGIN result := Procedure;
	END Test.

positive: procedure with several equal parameters to procedure assignment

	MODULE Test;
	VAR result: PROCEDURE (CONST a: SET; VAR i: SIGNED16; o: OBJECT);
	PROCEDURE Procedure (CONST a: SET; VAR i: SIGNED16; o: OBJECT); END Procedure;
	BEGIN result := Procedure;
	END Test.

positive: procedure with equal return type to procedure assignment

	MODULE Test;
	VAR result: PROCEDURE (): SIGNED16;
	PROCEDURE Procedure (): SIGNED16; BEGIN RETURN 0 END Procedure;
	BEGIN result := Procedure;
	END Test.

negative: procedure with compatible return type to procedure assignment

	MODULE Test;
	VAR result: PROCEDURE (): SIGNED32;
	PROCEDURE Procedure (): SIGNED16; BEGIN RETURN 0 END Procedure;
	BEGIN result := Procedure;
	END Test.

negative: procedure with incompatible return type to procedure assignment

	MODULE Test;
	VAR result: PROCEDURE (): SET;
	PROCEDURE Procedure (): SIGNED16; BEGIN RETURN 0 END Procedure;
	BEGIN result := Procedure;
	END Test.

positive: procedure with several equal parameters and equal return type to procedure assignment

	MODULE Test;
	TYPE Record = RECORD END;
	VAR result: PROCEDURE (CONST a: SET; VAR i: SIGNED16; o: OBJECT): POINTER TO Record;
	PROCEDURE Procedure (CONST a: SET; VAR i: SIGNED16; o: OBJECT): POINTER TO Record; END Procedure;
	BEGIN result := Procedure;
	END Test.

positive: dummy module for import assignments

	MODULE Dummy; END Dummy.

negative: constant boolean to import assignment

	MODULE Test;
	IMPORT result := Dummy;
	BEGIN result := TRUE;
	END Test.

negative: constant character to import assignment

	MODULE Test;
	IMPORT result := Dummy;
	BEGIN result := 'f';
	END Test.

negative: constant short integer to import assignment

	MODULE Test;
	IMPORT result := Dummy;
	BEGIN result := 10H;
	END Test.

negative: constant integer to import assignment

	MODULE Test;
	IMPORT result := Dummy;
	BEGIN result := 1000H;
	END Test.

negative: constant long integer to import assignment

	MODULE Test;
	IMPORT result := Dummy;
	BEGIN result := 100000H;
	END Test.

negative: constant huge integer to import assignment

	MODULE Test;
	IMPORT result := Dummy;
	BEGIN result := 10000000000H;
	END Test.

negative: constant real to import assignment

	MODULE Test;
	IMPORT result := Dummy;
	BEGIN result := 5.4;
	END Test.

negative: constant long real to import assignment

	MODULE Test;
	IMPORT result := Dummy;
	BEGIN result := 5.4D100;
	END Test.

negative: constant set to import assignment

	MODULE Test;
	IMPORT result := Dummy;
	BEGIN result := {5};
	END Test.

negative: string to import assignment

	MODULE Test;
	IMPORT result := Dummy;
	BEGIN result := "string";
	END Test.

negative: nil pointer to import assignment

	MODULE Test;
	IMPORT result := Dummy;
	BEGIN result := NIL;
	END Test.

negative: procedure to import assignment

	MODULE Test;
	IMPORT result := Dummy;
	PROCEDURE Procedure; END Procedure;
	BEGIN result := Procedure;
	END Test.

positive: nil pointer to references assignment

	MODULE Test;
	VAR o: OBJECT END; ob: OBJECT; ptr: POINTER TO RECORD END; p: PROCEDURE;
	BEGIN o := NIL; ob := NIL; ptr := NIL; p := NIL;
	END Test.

positive: indirect nil pointer to references assignment

	MODULE Test;
	CONST Nil = NIL;
	VAR o: OBJECT END; ob: OBJECT; ptr: POINTER TO RECORD END; p: PROCEDURE;
	BEGIN o := Nil; ob := Nil; ptr := Nil; p := Nil;
	END Test.

positive: variable boolean to variable boolean assignment

	MODULE Test;
	VAR variable, result: BOOLEAN;
	BEGIN result := variable;
	END Test.

negative: variable boolean to temporary boolean assignment

	MODULE Test;
	VAR variable: BOOLEAN; result: PROCEDURE (): BOOLEAN;
	BEGIN result () := variable;
	END Test.

negative: variable character to variable boolean assignment

	MODULE Test;
	VAR variable: CHAR; result: BOOLEAN;
	BEGIN result := variable;
	END Test.

negative: variable short integer to variable boolean assignment

	MODULE Test;
	VAR variable: SIGNED8; result: BOOLEAN;
	BEGIN result := variable;
	END Test.

negative: variable integer to variable boolean assignment

	MODULE Test;
	VAR variable: SIGNED16; result: BOOLEAN;
	BEGIN result := variable;
	END Test.

negative: variable long integer to variable boolean assignment

	MODULE Test;
	VAR variable: SIGNED32; result: BOOLEAN;
	BEGIN result := variable;
	END Test.

negative: variable huge integer to variable boolean assignment

	MODULE Test;
	VAR variable: SIGNED64; result: BOOLEAN;
	BEGIN result := variable;
	END Test.

negative: variable real to variable boolean assignment

	MODULE Test;
	VAR variable: FLOAT32; result: BOOLEAN;
	BEGIN result := variable;
	END Test.

negative: variable long real to variable boolean assignment

	MODULE Test;
	VAR variable: FLOAT64; result: BOOLEAN;
	BEGIN result := variable;
	END Test.

negative: variable set to variable boolean assignment

	MODULE Test;
	VAR variable: SET; result: BOOLEAN;
	BEGIN result := variable;
	END Test.

negative: array to variable boolean assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF CHAR; result: BOOLEAN;
	BEGIN result := variable;
	END Test.

negative: record to variable boolean assignment

	MODULE Test;
	VAR variable: RECORD END; result: BOOLEAN;
	BEGIN result := variable;
	END Test.

negative: object to variable boolean assignment

	MODULE Test;
	VAR variable: OBJECT; result: BOOLEAN;
	BEGIN result := variable;
	END Test.

negative: pointer to variable boolean assignment

	MODULE Test;
	VAR variable: POINTER TO RECORD END; result: BOOLEAN;
	BEGIN result := variable;
	END Test.

negative: variable procedure to variable boolean assignment

	MODULE Test;
	VAR variable: PROCEDURE; result: BOOLEAN;
	BEGIN result := variable;
	END Test.

negative: import to variable boolean assignment

	MODULE Test;
	IMPORT variable := Dummy; VAR result: BOOLEAN;
	BEGIN result := variable;
	END Test.

negative: type to variable boolean assignment

	MODULE Test;
	TYPE Type = BOOLEAN; VAR result: Type;
	BEGIN result := Type;
	END Test.

negative: variable boolean to variable character assignment

	MODULE Test;
	VAR variable: BOOLEAN; result: CHAR;
	BEGIN result := variable;
	END Test.

positive: variable character to variable character assignment

	MODULE Test;
	VAR variable, result: CHAR;
	BEGIN result := variable;
	END Test.

negative: variable character to temporary character assignment

	MODULE Test;
	VAR variable: CHAR; result: PROCEDURE (): CHAR;
	BEGIN result () := variable;
	END Test.

negative: variable short integer to variable character assignment

	MODULE Test;
	VAR variable: SIGNED8; result: CHAR;
	BEGIN result := variable;
	END Test.

negative: variable integer to variable character assignment

	MODULE Test;
	VAR variable: SIGNED16; result: CHAR;
	BEGIN result := variable;
	END Test.

negative: variable long integer to variable character assignment

	MODULE Test;
	VAR variable: SIGNED32; result: CHAR;
	BEGIN result := variable;
	END Test.

negative: variable huge integer to variable character assignment

	MODULE Test;
	VAR variable: SIGNED64; result: CHAR;
	BEGIN result := variable;
	END Test.

negative: variable real to variable character assignment

	MODULE Test;
	VAR variable: FLOAT32; result: CHAR;
	BEGIN result := variable;
	END Test.

negative: variable long real to variable character assignment

	MODULE Test;
	VAR variable: FLOAT64; result: CHAR;
	BEGIN result := variable;
	END Test.

negative: variable set to variable character assignment

	MODULE Test;
	VAR variable: SET; result: CHAR;
	BEGIN result := variable;
	END Test.

negative: array to variable character assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF CHAR; result: CHAR;
	BEGIN result := variable;
	END Test.

negative: record to variable character assignment

	MODULE Test;
	VAR variable: RECORD END; result: CHAR;
	BEGIN result := variable;
	END Test.

negative: object to variable character assignment

	MODULE Test;
	VAR variable: OBJECT; result: CHAR;
	BEGIN result := variable;
	END Test.

negative: pointer to variable character assignment

	MODULE Test;
	VAR variable: POINTER TO RECORD END; result: CHAR;
	BEGIN result := variable;
	END Test.

negative: variable procedure to variable character assignment

	MODULE Test;
	VAR variable: PROCEDURE; result: CHAR;
	BEGIN result := variable;
	END Test.

negative: import to variable character assignment

	MODULE Test;
	IMPORT variable := Dummy; VAR result: CHAR;
	BEGIN result := variable;
	END Test.

negative: type to variable character assignment

	MODULE Test;
	TYPE Type = CHAR; VAR result: Type;
	BEGIN result := Type;
	END Test.

negative: variable boolean to variable short integer assignment

	MODULE Test;
	VAR variable: BOOLEAN; result: SIGNED8;
	BEGIN result := variable;
	END Test.

negative: variable character to variable short integer assignment

	MODULE Test;
	VAR variable: CHAR; result: SIGNED8;
	BEGIN result := variable;
	END Test.

positive: variable short integer to variable short integer assignment

	MODULE Test;
	VAR variable, result: SIGNED8;
	BEGIN result := variable;
	END Test.

negative: variable short integer to temporary short integer assignment

	MODULE Test;
	VAR variable: SIGNED8; result: PROCEDURE (): SIGNED8;
	BEGIN result () := variable;
	END Test.

negative: variable integer to variable short integer assignment

	MODULE Test;
	VAR variable: SIGNED16; result: SIGNED8;
	BEGIN result := variable;
	END Test.

negative: variable long integer to variable short integer assignment

	MODULE Test;
	VAR variable: SIGNED32; result: SIGNED8;
	BEGIN result := variable;
	END Test.

negative: variable huge integer to variable short integer assignment

	MODULE Test;
	VAR variable: SIGNED64; result: SIGNED8;
	BEGIN result := variable;
	END Test.

negative: variable real to variable short integer assignment

	MODULE Test;
	VAR variable: FLOAT32; result: SIGNED8;
	BEGIN result := variable;
	END Test.

negative: variable long real to variable short integer assignment

	MODULE Test;
	VAR variable: FLOAT64; result: SIGNED8;
	BEGIN result := variable;
	END Test.

negative: variable set to variable short integer assignment

	MODULE Test;
	VAR variable: SET; result: SIGNED8;
	BEGIN result := variable;
	END Test.

negative: array to variable short integer assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF CHAR; result: SIGNED8;
	BEGIN result := variable;
	END Test.

negative: record to variable short integer assignment

	MODULE Test;
	VAR variable: RECORD END; result: SIGNED8;
	BEGIN result := variable;
	END Test.

negative: object to variable short integer assignment

	MODULE Test;
	VAR variable: OBJECT; result: SIGNED8;
	BEGIN result := variable;
	END Test.

negative: pointer to variable short integer assignment

	MODULE Test;
	VAR variable: POINTER TO RECORD END; result: SIGNED8;
	BEGIN result := variable;
	END Test.

negative: variable procedure to variable short integer assignment

	MODULE Test;
	VAR variable: PROCEDURE; result: SIGNED8;
	BEGIN result := variable;
	END Test.

negative: import to variable short integer assignment

	MODULE Test;
	IMPORT variable := Dummy; VAR result: SIGNED8;
	BEGIN result := variable;
	END Test.

negative: type to variable short integer assignment

	MODULE Test;
	TYPE Type = SIGNED8; VAR result: Type;
	BEGIN result := Type;
	END Test.

negative: variable boolean to variable integer assignment

	MODULE Test;
	VAR variable: BOOLEAN; result: SIGNED16;
	BEGIN result := variable;
	END Test.

negative: variable character to variable integer assignment

	MODULE Test;
	VAR variable: CHAR; result: SIGNED16;
	BEGIN result := variable;
	END Test.

positive: variable short integer to variable integer assignment

	MODULE Test;
	VAR variable: SIGNED8; result: SIGNED16;
	BEGIN result := variable;
	END Test.

negative: variable short integer to temporary integer assignment

	MODULE Test;
	VAR variable: SIGNED8; result: PROCEDURE (): SIGNED16;
	BEGIN result () := variable;
	END Test.

positive: variable integer to variable integer assignment

	MODULE Test;
	VAR variable, result: SIGNED16;
	BEGIN result := variable;
	END Test.

negative: variable integer to temporary integer assignment

	MODULE Test;
	VAR variable: SIGNED16; result: PROCEDURE (): SIGNED16;
	BEGIN result () := variable;
	END Test.

negative: variable long integer to variable integer assignment

	MODULE Test;
	VAR variable: SIGNED32; result: SIGNED16;
	BEGIN result := variable;
	END Test.

negative: variable huge integer to variable integer assignment

	MODULE Test;
	VAR variable: SIGNED64; result: SIGNED16;
	BEGIN result := variable;
	END Test.

negative: variable real to variable integer assignment

	MODULE Test;
	VAR variable: FLOAT32; result: SIGNED16;
	BEGIN result := variable;
	END Test.

negative: variable long real to variable integer assignment

	MODULE Test;
	VAR variable: FLOAT64; result: SIGNED16;
	BEGIN result := variable;
	END Test.

negative: variable set to variable integer assignment

	MODULE Test;
	VAR variable: SET; result: SIGNED16;
	BEGIN result := variable;
	END Test.

negative: array to variable integer assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF CHAR; result: SIGNED16;
	BEGIN result := variable;
	END Test.

negative: record to variable integer assignment

	MODULE Test;
	VAR variable: RECORD END; result: SIGNED16;
	BEGIN result := variable;
	END Test.

negative: object to variable integer assignment

	MODULE Test;
	VAR variable: OBJECT; result: SIGNED16;
	BEGIN result := variable;
	END Test.

negative: pointer to variable integer assignment

	MODULE Test;
	VAR variable: POINTER TO RECORD END; result: SIGNED16;
	BEGIN result := variable;
	END Test.

negative: variable eto variable integer assignment

	MODULE Test;
	VAR variable: PROCEDURE; result: SIGNED16;
	BEGIN result := variable;
	END Test.

negative: import to variable integer assignment

	MODULE Test;
	IMPORT variable := Dummy; VAR result: SIGNED16;
	BEGIN result := variable;
	END Test.

negative: type to variable integer assignment

	MODULE Test;
	TYPE Type = SIGNED16; VAR result: Type;
	BEGIN result := Type;
	END Test.

negative: variable boolean to variable long integer assignment

	MODULE Test;
	VAR variable: BOOLEAN; result: SIGNED32;
	BEGIN result := variable;
	END Test.

negative: variable character to variable long integer assignment

	MODULE Test;
	VAR variable: CHAR; result: SIGNED32;
	BEGIN result := variable;
	END Test.

positive: variable short integer to variable long integer assignment

	MODULE Test;
	VAR variable: SIGNED8; result: SIGNED32;
	BEGIN result := variable;
	END Test.

negative: variable short integer to temporary long integer assignment

	MODULE Test;
	VAR variable: SIGNED8; result: PROCEDURE (): SIGNED32;
	BEGIN result () := variable;
	END Test.

positive: variable integer to variable long integer assignment

	MODULE Test;
	VAR variable: SIGNED16; result: SIGNED32;
	BEGIN result := variable;
	END Test.

negative: variable integer to temporary long integer assignment

	MODULE Test;
	VAR variable: SIGNED16; result: PROCEDURE (): SIGNED32;
	BEGIN result () := variable;
	END Test.

positive: variable long integer to variable long integer assignment

	MODULE Test;
	VAR variable, result: SIGNED32;
	BEGIN result := variable;
	END Test.

negative: variable long integer to temporary long integer assignment

	MODULE Test;
	VAR variable: SIGNED32; result: PROCEDURE (): SIGNED32;
	BEGIN result () := variable;
	END Test.

negative: variable huge integer to variable long integer assignment

	MODULE Test;
	VAR variable: SIGNED64; result: SIGNED32;
	BEGIN result := variable;
	END Test.

negative: variable real to variable long integer assignment

	MODULE Test;
	VAR variable: FLOAT32; result: SIGNED32;
	BEGIN result := variable;
	END Test.

negative: variable long real to variable long integer assignment

	MODULE Test;
	VAR variable: FLOAT64; result: SIGNED32;
	BEGIN result := variable;
	END Test.

negative: variable set to variable long integer assignment

	MODULE Test;
	VAR variable: SET; result: SIGNED32;
	BEGIN result := variable;
	END Test.

negative: array to variable long integer assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF CHAR; result: SIGNED32;
	BEGIN result := variable;
	END Test.

negative: record to variable long integer assignment

	MODULE Test;
	VAR variable: RECORD END; result: SIGNED32;
	BEGIN result := variable;
	END Test.

negative: object to variable long integer assignment

	MODULE Test;
	VAR variable: OBJECT; result: SIGNED32;
	BEGIN result := variable;
	END Test.

negative: pointer to variable long integer assignment

	MODULE Test;
	VAR variable: POINTER TO RECORD END; result: SIGNED32;
	BEGIN result := variable;
	END Test.

negative: variable procedure to variable long integer assignment

	MODULE Test;
	VAR variable: PROCEDURE; result: SIGNED32;
	BEGIN result := variable;
	END Test.

negative: import to variable long integer assignment

	MODULE Test;
	IMPORT variable := Dummy; VAR result: SIGNED32;
	BEGIN result := variable;
	END Test.

negative: type to variable long integer assignment

	MODULE Test;
	TYPE Type = SIGNED32; VAR result: Type;
	BEGIN result := Type;
	END Test.

negative: variable boolean to variable huge integer assignment

	MODULE Test;
	VAR variable: BOOLEAN; result: SIGNED64;
	BEGIN result := variable;
	END Test.

negative: variable character to variable huge integer assignment

	MODULE Test;
	VAR variable: CHAR; result: SIGNED64;
	BEGIN result := variable;
	END Test.

positive: variable short integer to variable huge integer assignment

	MODULE Test;
	VAR variable: SIGNED8; result: SIGNED64;
	BEGIN result := variable;
	END Test.

negative: variable short integer to temporary huge integer assignment

	MODULE Test;
	VAR variable: SIGNED8; result: PROCEDURE (): SIGNED64;
	BEGIN result () := variable;
	END Test.

positive: variable integer to variable huge integer assignment

	MODULE Test;
	VAR variable: SIGNED16; result: SIGNED64;
	BEGIN result := variable;
	END Test.

negative: variable integer to temporary huge integer assignment

	MODULE Test;
	VAR variable: SIGNED16; result: PROCEDURE (): SIGNED64;
	BEGIN result () := variable;
	END Test.

positive: variable long integer to variable huge integer assignment

	MODULE Test;
	VAR variable: SIGNED32; result: SIGNED64;
	BEGIN result := variable;
	END Test.

negative: variable long integer to temporary huge integer assignment

	MODULE Test;
	VAR variable: SIGNED32; result: PROCEDURE (): SIGNED64;
	BEGIN result () := variable;
	END Test.

positive: variable huge integer to variable huge integer assignment

	MODULE Test;
	VAR variable, result: SIGNED64;
	BEGIN result := variable;
	END Test.

negative: variable huge integer to temporary huge integer assignment

	MODULE Test;
	VAR variable: SIGNED64; result: PROCEDURE (): SIGNED64;
	BEGIN result () := variable;
	END Test.

negative: variable real to variable huge integer assignment

	MODULE Test;
	VAR variable: FLOAT32; result: SIGNED64;
	BEGIN result := variable;
	END Test.

negative: variable long real to variable huge integer assignment

	MODULE Test;
	VAR variable: FLOAT64; result: SIGNED64;
	BEGIN result := variable;
	END Test.

negative: variable set to variable huge integer assignment

	MODULE Test;
	VAR variable: SET; result: SIGNED64;
	BEGIN result := variable;
	END Test.

negative: array to variable huge integer assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF CHAR; result: SIGNED64;
	BEGIN result := variable;
	END Test.

negative: record to variable huge integer assignment

	MODULE Test;
	VAR variable: RECORD END; result: SIGNED64;
	BEGIN result := variable;
	END Test.

negative: object to variable huge integer assignment

	MODULE Test;
	VAR variable: OBJECT; result: SIGNED64;
	BEGIN result := variable;
	END Test.

negative: pointer to variable huge integer assignment

	MODULE Test;
	VAR variable: POINTER TO RECORD END; result: SIGNED64;
	BEGIN result := variable;
	END Test.

negative: variable procedure to variable huge integer assignment

	MODULE Test;
	VAR variable: PROCEDURE; result: SIGNED64;
	BEGIN result := variable;
	END Test.

negative: import to variable huge integer assignment

	MODULE Test;
	IMPORT variable := Dummy; VAR result: SIGNED64;
	BEGIN result := variable;
	END Test.

negative: type to variable huge integer assignment

	MODULE Test;
	TYPE Type = SIGNED64; VAR result: Type;
	BEGIN result := Type;
	END Test.

negative: variable boolean to variable real assignment

	MODULE Test;
	VAR variable: BOOLEAN; result: FLOAT32;
	BEGIN result := variable;
	END Test.

negative: variable character to variable real assignment

	MODULE Test;
	VAR variable: CHAR; result: FLOAT32;
	BEGIN result := variable;
	END Test.

positive: variable short integer to variable real assignment

	MODULE Test;
	VAR variable: SIGNED8; result: FLOAT32;
	BEGIN result := variable;
	END Test.

negative: variable short integer to temporary real assignment

	MODULE Test;
	VAR variable: SIGNED8; result: PROCEDURE (): FLOAT32;
	BEGIN result () := variable;
	END Test.

positive: variable integer to variable real assignment

	MODULE Test;
	VAR variable: SIGNED16; result: FLOAT32;
	BEGIN result := variable;
	END Test.

negative: variable integer to temporary real assignment

	MODULE Test;
	VAR variable: SIGNED16; result: PROCEDURE (): FLOAT32;
	BEGIN result () := variable;
	END Test.

positive: variable long integer to variable real assignment

	MODULE Test;
	VAR variable: SIGNED32; result: FLOAT32;
	BEGIN result := variable;
	END Test.

negative: variable long integer to temporary real assignment

	MODULE Test;
	VAR variable: SIGNED32; result: PROCEDURE (): FLOAT32;
	BEGIN result () := variable;
	END Test.

positive: variable huge integer to variable real assignment

	MODULE Test;
	VAR variable: SIGNED64; result: FLOAT32;
	BEGIN result := variable;
	END Test.

negative: variable huge integer to temporary real assignment

	MODULE Test;
	VAR variable: SIGNED64; result: PROCEDURE (): FLOAT32;
	BEGIN result () := variable;
	END Test.

positive: variable real to variable real assignment

	MODULE Test;
	VAR variable, result: FLOAT32;
	BEGIN result := variable;
	END Test.

negative: variable real to temporary real assignment

	MODULE Test;
	VAR variable: FLOAT32; result: PROCEDURE (): FLOAT32;
	BEGIN result () := variable;
	END Test.

negative: variable long real to variable real assignment

	MODULE Test;
	VAR variable: FLOAT64; result: FLOAT32;
	BEGIN result := variable;
	END Test.

negative: variable set to variable real assignment

	MODULE Test;
	VAR variable: SET; result: FLOAT32;
	BEGIN result := variable;
	END Test.

negative: array to variable real assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF CHAR; result: FLOAT32;
	BEGIN result := variable;
	END Test.

negative: record to variable real assignment

	MODULE Test;
	VAR variable: RECORD END; result: FLOAT32;
	BEGIN result := variable;
	END Test.

negative: object to variable real assignment

	MODULE Test;
	VAR variable: OBJECT; result: FLOAT32;
	BEGIN result := variable;
	END Test.

negative: pointer to variable real assignment

	MODULE Test;
	VAR variable: POINTER TO RECORD END; result: FLOAT32;
	BEGIN result := variable;
	END Test.

negative: variable procedure to variable real assignment

	MODULE Test;
	VAR variable: PROCEDURE; result: FLOAT32;
	BEGIN result := variable;
	END Test.

negative: import to variable real assignment

	MODULE Test;
	IMPORT variable := Dummy; VAR result: FLOAT32;
	BEGIN result := variable;
	END Test.

negative: type to variable real assignment

	MODULE Test;
	TYPE Type = FLOAT32; VAR result: Type;
	BEGIN result := Type;
	END Test.

negative: variable boolean to variable long real assignment

	MODULE Test;
	VAR variable: BOOLEAN; result: FLOAT64;
	BEGIN result := variable;
	END Test.

negative: variable character to variable long real assignment

	MODULE Test;
	VAR variable: CHAR; result: FLOAT64;
	BEGIN result := variable;
	END Test.

positive: variable short integer to variable long real assignment

	MODULE Test;
	VAR variable: SIGNED8; result: FLOAT64;
	BEGIN result := variable;
	END Test.

negative: variable short integer to temporary long real assignment

	MODULE Test;
	VAR variable: SIGNED8; result: PROCEDURE (): FLOAT64;
	BEGIN result () := variable;
	END Test.

positive: variable integer to variable long real assignment

	MODULE Test;
	VAR variable: SIGNED16; result: FLOAT64;
	BEGIN result := variable;
	END Test.

negative: variable integer to temporary long real assignment

	MODULE Test;
	VAR variable: SIGNED16; result: PROCEDURE (): FLOAT64;
	BEGIN result () := variable;
	END Test.

positive: variable long integer to variable long real assignment

	MODULE Test;
	VAR variable: SIGNED32; result: FLOAT64;
	BEGIN result := variable;
	END Test.

negative: variable long integer to temporary long real assignment

	MODULE Test;
	VAR variable: SIGNED32; result: PROCEDURE (): FLOAT64;
	BEGIN result () := variable;
	END Test.

positive: variable huge integer to variable long real assignment

	MODULE Test;
	VAR variable: SIGNED64; result: FLOAT64;
	BEGIN result := variable;
	END Test.

negative: variable huge integer to temporary long real assignment

	MODULE Test;
	VAR variable: SIGNED64; result: PROCEDURE (): FLOAT64;
	BEGIN result () := variable;
	END Test.

positive: variable real to variable long real assignment

	MODULE Test;
	VAR variable: FLOAT32; result: FLOAT64;
	BEGIN result := variable;
	END Test.

negative: variable real to temporary long real assignment

	MODULE Test;
	VAR variable: FLOAT32; result: PROCEDURE (): FLOAT64;
	BEGIN result () := variable;
	END Test.

positive: variable long real to variable long real assignment

	MODULE Test;
	VAR variable, result: FLOAT64;
	BEGIN result := variable;
	END Test.

negative: variable long real to temporary long real assignment

	MODULE Test;
	VAR variable: FLOAT32; result: PROCEDURE (): FLOAT64;
	BEGIN result () := variable;
	END Test.

negative: variable set to variable long real assignment

	MODULE Test;
	VAR variable: SET; result: FLOAT64;
	BEGIN result := variable;
	END Test.

negative: array to variable long real assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF CHAR; result: FLOAT64;
	BEGIN result := variable;
	END Test.

negative: record to variable long real assignment

	MODULE Test;
	VAR variable: RECORD END; result: FLOAT64;
	BEGIN result := variable;
	END Test.

negative: object to variable long real assignment

	MODULE Test;
	VAR variable: OBJECT; result: FLOAT64;
	BEGIN result := variable;
	END Test.

negative: pointer to variable long real assignment

	MODULE Test;
	VAR variable: POINTER TO RECORD END; result: FLOAT64;
	BEGIN result := variable;
	END Test.

negative: variable procedure to variable long real assignment

	MODULE Test;
	VAR variable: PROCEDURE; result: FLOAT64;
	BEGIN result := variable;
	END Test.

negative: import to variable long real assignment

	MODULE Test;
	IMPORT variable := Dummy; VAR result: FLOAT64;
	BEGIN result := variable;
	END Test.

negative: type to variable long real assignment

	MODULE Test;
	TYPE Type = FLOAT64; VAR result: Type;
	BEGIN result := Type;
	END Test.

negative: variable boolean to variable set assignment

	MODULE Test;
	VAR variable: BOOLEAN; result: SET;
	BEGIN result := variable;
	END Test.

negative: variable character to variable set assignment

	MODULE Test;
	VAR variable: CHAR; result: SET;
	BEGIN result := variable;
	END Test.

negative: variable short integer to variable set assignment

	MODULE Test;
	VAR variable: SIGNED8; result: SET;
	BEGIN result := variable;
	END Test.

negative: variable integer to variable set assignment

	MODULE Test;
	VAR variable: SIGNED16; result: SET;
	BEGIN result := variable;
	END Test.

negative: variable long integer to variable set assignment

	MODULE Test;
	VAR variable: SIGNED32; result: SET;
	BEGIN result := variable;
	END Test.

negative: variable huge integer to variable set assignment

	MODULE Test;
	VAR variable: SIGNED64; result: SET;
	BEGIN result := variable;
	END Test.

negative: variable real to variable set assignment

	MODULE Test;
	VAR variable: FLOAT32; result: SET;
	BEGIN result := variable;
	END Test.

negative: variable long real to variable set assignment

	MODULE Test;
	VAR variable: FLOAT64; result: SET;
	BEGIN result := variable;
	END Test.

positive: variable set to variable set assignment

	MODULE Test;
	VAR variable, result: SET;
	BEGIN result := variable;
	END Test.

negative: variable set to temporary set assignment

	MODULE Test;
	VAR variable: SET; result: PROCEDURE (): SET;
	BEGIN result () := variable;
	END Test.

negative: array to variable set assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF CHAR; result: SET;
	BEGIN result := variable;
	END Test.

negative: record to variable set assignment

	MODULE Test;
	VAR variable: RECORD END; result: SET;
	BEGIN result := variable;
	END Test.

negative: object to variable set assignment

	MODULE Test;
	VAR variable: OBJECT; result: SET;
	BEGIN result := variable;
	END Test.

negative: pointer to variable set assignment

	MODULE Test;
	VAR variable: POINTER TO RECORD END; result: SET;
	BEGIN result := variable;
	END Test.

negative: variable procedure to variable set assignment

	MODULE Test;
	VAR variable: PROCEDURE; result: SET;
	BEGIN result := variable;
	END Test.

negative: import to variable set assignment

	MODULE Test;
	IMPORT variable := Dummy; VAR result: SET;
	BEGIN result := variable;
	END Test.

negative: type to variable set assignment

	MODULE Test;
	TYPE Type = SET; VAR result: Type;
	BEGIN result := Type;
	END Test.

negative: variable boolean to array assignment

	MODULE Test;
	VAR variable: BOOLEAN; result: ARRAY 10 OF CHAR;
	BEGIN result := variable;
	END Test.

negative: variable character to array assignment

	MODULE Test;
	VAR variable: CHAR; result: ARRAY 10 OF CHAR;
	BEGIN result := variable;
	END Test.

negative: variable short integer to array assignment

	MODULE Test;
	VAR variable: SIGNED8; result: ARRAY 10 OF CHAR;
	BEGIN result := variable;
	END Test.

negative: variable integer to array assignment

	MODULE Test;
	VAR variable: SIGNED16; result: ARRAY 10 OF CHAR;
	BEGIN result := variable;
	END Test.

negative: variable long integer to array assignment

	MODULE Test;
	VAR variable: SIGNED32; result: ARRAY 10 OF CHAR;
	BEGIN result := variable;
	END Test.

negative: variable huge integer to array assignment

	MODULE Test;
	VAR variable: SIGNED64; result: ARRAY 10 OF CHAR;
	BEGIN result := variable;
	END Test.

negative: variable real to array assignment

	MODULE Test;
	VAR variable: FLOAT32; result: ARRAY 10 OF CHAR;
	BEGIN result := variable;
	END Test.

negative: variable long real to array assignment

	MODULE Test;
	VAR variable: FLOAT64; result: ARRAY 10 OF CHAR;
	BEGIN result := variable;
	END Test.

negative: variable set to array assignment

	MODULE Test;
	VAR variable: SET; result: ARRAY 10 OF CHAR;
	BEGIN result := variable;
	END Test.

positive: array of boolean to array of boolean assignment

	MODULE Test;
	VAR variable, result: ARRAY 10 OF BOOLEAN;
	BEGIN result := variable;
	END Test.

negative: array of boolean to temporary array of boolean assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF BOOLEAN; result: PROCEDURE (): ARRAY 10 OF BOOLEAN;
	BEGIN result () := variable;
	END Test.

negative: array of boolean to longer array of boolean assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF BOOLEAN; result: ARRAY 20 OF BOOLEAN;
	BEGIN result := variable;
	END Test.

negative: array of boolean to shorter array of boolean assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF BOOLEAN; result: ARRAY 5 OF BOOLEAN;
	BEGIN result := variable;
	END Test.

negative: array of boolean to open array of boolean assignment

	MODULE Test;
	PROCEDURE Procedure (VAR result: ARRAY OF BOOLEAN);
	VAR variable: ARRAY 10 OF BOOLEAN;
	BEGIN result := variable;
	END Procedure;
	END Test.

negative: open array of boolean to array of boolean assignment

	MODULE Test;
	PROCEDURE Procedure (VAR variable: ARRAY OF BOOLEAN);
	VAR result: ARRAY 10 OF BOOLEAN;
	BEGIN result := variable;
	END Procedure;
	END Test.

negative: array of boolean to dereferenced open array of boolean assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF BOOLEAN; result: POINTER TO ARRAY OF BOOLEAN;
	BEGIN result^ := variable;
	END Test.

negative: array of character to array of boolean assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF CHAR; result: ARRAY 10 OF BOOLEAN;
	BEGIN result := variable;
	END Test.

negative: array of short integer to array of boolean assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF SIGNED8; result: ARRAY 10 OF BOOLEAN;
	BEGIN result := variable;
	END Test.

negative: array of integer to array of boolean assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF SIGNED16; result: ARRAY 10 OF BOOLEAN;
	BEGIN result := variable;
	END Test.

negative: array of long integer to array of boolean assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF SIGNED32; result: ARRAY 10 OF BOOLEAN;
	BEGIN result := variable;
	END Test.

negative: array of huge integer to array of boolean assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF SIGNED64; result: ARRAY 10 OF BOOLEAN;
	BEGIN result := variable;
	END Test.

negative: array of real to array of boolean assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF FLOAT32; result: ARRAY 10 OF BOOLEAN;
	BEGIN result := variable;
	END Test.

negative: array of long real to array of boolean assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF FLOAT64; result: ARRAY 10 OF BOOLEAN;
	BEGIN result := variable;
	END Test.

negative: array of set to array of boolean assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF SET; result: ARRAY 10 OF BOOLEAN;
	BEGIN result := variable;
	END Test.

negative: array of array to array of boolean assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF ARRAY 10 OF SET; result: ARRAY 10 OF BOOLEAN;
	BEGIN result := variable;
	END Test.

negative: array of record to array of boolean assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF RECORD END; result: ARRAY 10 OF BOOLEAN;
	BEGIN result := variable;
	END Test.

negative: array of object to array of boolean assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF OBJECT; result: ARRAY 10 OF BOOLEAN;
	BEGIN result := variable;
	END Test.

negative: array of pointer to array of boolean assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF POINTER TO RECORD END; result: ARRAY 10 OF BOOLEAN;
	BEGIN result := variable;
	END Test.

negative: array of procedure to array of boolean assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF PROCEDURE; result: ARRAY 10 OF BOOLEAN;
	BEGIN result := variable;
	END Test.

negative: array of boolean to array of character assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF BOOLEAN; result: ARRAY 10 OF CHAR;
	BEGIN result := variable;
	END Test.

positive: array of character to array of character assignment

	MODULE Test;
	VAR variable, result: ARRAY 10 OF CHAR;
	BEGIN result := variable;
	END Test.

negative: array of character to temporary array of character assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF CHAR; result: PROCEDURE (): ARRAY 10 OF CHAR;
	BEGIN result () := variable;
	END Test.

negative: array of character to longer array of character assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF CHAR; result: ARRAY 20 OF CHAR;
	BEGIN result := variable;
	END Test.

negative: array of character to shorter array of character assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF CHAR; result: ARRAY 5 OF CHAR;
	BEGIN result := variable;
	END Test.

negative: array of character to open array of character assignment

	MODULE Test;
	PROCEDURE Procedure (VAR result: ARRAY OF CHAR);
	VAR variable: ARRAY 10 OF CHAR;
	BEGIN result := variable;
	END Procedure;
	END Test.

positive: string to open array of character assignment

	MODULE Test;
	PROCEDURE Procedure (VAR result: ARRAY OF CHAR);
	BEGIN result := "string";
	END Procedure;
	END Test.

negative: open array of character to array of character assignment

	MODULE Test;
	PROCEDURE Procedure (VAR variable: ARRAY OF CHAR);
	VAR result: ARRAY 10 OF CHAR;
	BEGIN result := variable;
	END Procedure;
	END Test.

negative: array of character to dereferenced open array of character assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF CHAR; result: POINTER TO ARRAY OF CHAR;
	BEGIN result^ := variable;
	END Test.

positive: string to dereferenced open array of character assignment

	MODULE Test;
	VAR result: POINTER TO ARRAY OF CHAR;
	BEGIN result^ := "string";
	END Test.

negative: array of short integer to array of character assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF SIGNED8; result: ARRAY 10 OF CHAR;
	BEGIN result := variable;
	END Test.

negative: array of integer to array of character assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF SIGNED16; result: ARRAY 10 OF CHAR;
	BEGIN result := variable;
	END Test.

negative: array of long integer to array of character assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF SIGNED32; result: ARRAY 10 OF CHAR;
	BEGIN result := variable;
	END Test.

negative: array of huge integer to array of character assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF SIGNED64; result: ARRAY 10 OF CHAR;
	BEGIN result := variable;
	END Test.

negative: array of real to array of character assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF FLOAT32; result: ARRAY 10 OF CHAR;
	BEGIN result := variable;
	END Test.

negative: array of long real to array of character assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF FLOAT64; result: ARRAY 10 OF CHAR;
	BEGIN result := variable;
	END Test.

negative: array of set to array of character assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF SET; result: ARRAY 10 OF CHAR;
	BEGIN result := variable;
	END Test.

negative: array of array to array of character assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF ARRAY 10 OF SET; result: ARRAY 10 OF CHAR;
	BEGIN result := variable;
	END Test.

negative: array of record to array of character assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF RECORD END; result: ARRAY 10 OF CHAR;
	BEGIN result := variable;
	END Test.

negative: array of object to array of character assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF OBJECT; result: ARRAY 10 OF CHAR;
	BEGIN result := variable;
	END Test.

negative: array of pointer to array of character assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF POINTER TO RECORD END; result: ARRAY 10 OF CHAR;
	BEGIN result := variable;
	END Test.

negative: array of procedure to array of character assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF PROCEDURE; result: ARRAY 10 OF CHAR;
	BEGIN result := variable;
	END Test.

negative: array of boolean to array of short integer assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF BOOLEAN; result: ARRAY 10 OF SIGNED8;
	BEGIN result := variable;
	END Test.

negative: array of character to array of short integer assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF CHAR; result: ARRAY 10 OF SIGNED8;
	BEGIN result := variable;
	END Test.

positive: array of short integer to array of short integer assignment

	MODULE Test;
	VAR variable, result: ARRAY 10 OF SIGNED8;
	BEGIN result := variable;
	END Test.

negative: array of short integer to temporary array of short integer assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF SIGNED8; result: PROCEDURE (): ARRAY 10 OF SIGNED8;
	BEGIN result () := variable;
	END Test.

negative: array of short integer to longer array of short integer assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF SIGNED8; result: ARRAY 20 OF SIGNED8;
	BEGIN result := variable;
	END Test.

negative: array of short integer to shorter array of short integer assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF SIGNED8; result: ARRAY 5 OF SIGNED8;
	BEGIN result := variable;
	END Test.

negative: array of short integer to open array of short integer assignment

	MODULE Test;
	PROCEDURE Procedure (VAR result: ARRAY OF SIGNED8);
	VAR variable: ARRAY 10 OF SIGNED8;
	BEGIN result := variable;
	END Procedure;
	END Test.

negative: open array of short integer to array of short integer assignment

	MODULE Test;
	PROCEDURE Procedure (VAR variable: ARRAY OF SIGNED8);
	VAR result: ARRAY 10 OF SIGNED8;
	BEGIN result := variable;
	END Procedure;
	END Test.

negative: array of short integer to dereferenced open array of short integer assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF SIGNED8; result: POINTER TO ARRAY OF SIGNED8;
	BEGIN result^ := variable;
	END Test.

negative: array of integer to array of short integer assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF SIGNED16; result: ARRAY 10 OF SIGNED8;
	BEGIN result := variable;
	END Test.

negative: array of long integer to array of short integer assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF SIGNED32; result: ARRAY 10 OF SIGNED8;
	BEGIN result := variable;
	END Test.

negative: array of huge integer to array of short integer assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF SIGNED64; result: ARRAY 10 OF SIGNED8;
	BEGIN result := variable;
	END Test.

negative: array of real to array of short integer assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF FLOAT32; result: ARRAY 10 OF SIGNED8;
	BEGIN result := variable;
	END Test.

negative: array of long real to array of short integer assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF FLOAT64; result: ARRAY 10 OF SIGNED8;
	BEGIN result := variable;
	END Test.

negative: array of set to array of short integer assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF SET; result: ARRAY 10 OF SIGNED8;
	BEGIN result := variable;
	END Test.

negative: array of array to array of short integer assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF ARRAY 10 OF SET; result: ARRAY 10 OF SIGNED8;
	BEGIN result := variable;
	END Test.

negative: array of record to array of short integer assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF RECORD END; result: ARRAY 10 OF SIGNED8;
	BEGIN result := variable;
	END Test.

negative: array of object to array of short integer assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF OBJECT; result: ARRAY 10 OF SIGNED8;
	BEGIN result := variable;
	END Test.

negative: array of pointer to array of short integer assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF POINTER TO RECORD END; result: ARRAY 10 OF SIGNED8;
	BEGIN result := variable;
	END Test.

negative: array of procedure to array of short integer assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF PROCEDURE; result: ARRAY 10 OF SIGNED8;
	BEGIN result := variable;
	END Test.

negative: array of boolean to array of integer assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF BOOLEAN; result: ARRAY 10 OF SIGNED16;
	BEGIN result := variable;
	END Test.

negative: array of character to array of integer assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF CHAR; result: ARRAY 10 OF SIGNED16;
	BEGIN result := variable;
	END Test.

negative: array of short integer to array of integer assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF SIGNED8; result: ARRAY 10 OF SIGNED16;
	BEGIN result := variable;
	END Test.

positive: array of integer to array of integer assignment

	MODULE Test;
	VAR variable, result: ARRAY 10 OF SIGNED16;
	BEGIN result := variable;
	END Test.

negative: array of integer to temporary array of integer assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF SIGNED16; result: PROCEDURE (): ARRAY 10 OF SIGNED16;
	BEGIN result () := variable;
	END Test.

negative: array of integer to longer array of integer assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF SIGNED16; result: ARRAY 20 OF SIGNED16;
	BEGIN result := variable;
	END Test.

negative: array of integer to shorter array of integer assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF SIGNED16; result: ARRAY 5 OF SIGNED16;
	BEGIN result := variable;
	END Test.

negative: array of integer to open array of integer assignment

	MODULE Test;
	PROCEDURE Procedure (VAR result: ARRAY OF SIGNED16);
	VAR variable: ARRAY 10 OF SIGNED16;
	BEGIN result := variable;
	END Procedure;
	END Test.

negative: open array of integer to array of integer assignment

	MODULE Test;
	PROCEDURE Procedure (VAR variable: ARRAY OF SIGNED16);
	VAR result: ARRAY 10 OF SIGNED16;
	BEGIN result := variable;
	END Procedure;
	END Test.

negative: array of integer to dereferenced open array of integer assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF SIGNED16; result: POINTER TO ARRAY OF SIGNED16;
	BEGIN result^ := variable;
	END Test.

negative: array of long integer to array of integer assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF SIGNED32; result: ARRAY 10 OF SIGNED16;
	BEGIN result := variable;
	END Test.

negative: array of huge integer to array of integer assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF SIGNED64; result: ARRAY 10 OF SIGNED16;
	BEGIN result := variable;
	END Test.

negative: array of real to array of integer assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF FLOAT32; result: ARRAY 10 OF SIGNED16;
	BEGIN result := variable;
	END Test.

negative: array of long real to array of integer assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF FLOAT64; result: ARRAY 10 OF SIGNED16;
	BEGIN result := variable;
	END Test.

negative: array of set to array of integer assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF SET; result: ARRAY 10 OF SIGNED16;
	BEGIN result := variable;
	END Test.

negative: array of array to array of integer assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF ARRAY 10 OF SET; result: ARRAY 10 OF SIGNED16;
	BEGIN result := variable;
	END Test.

negative: array of record to array of integer assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF RECORD END; result: ARRAY 10 OF SIGNED16;
	BEGIN result := variable;
	END Test.

negative: array of object to array of integer assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF OBJECT; result: ARRAY 10 OF SIGNED16;
	BEGIN result := variable;
	END Test.

negative: array of pointer to array of integer assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF POINTER TO RECORD END; result: ARRAY 10 OF SIGNED16;
	BEGIN result := variable;
	END Test.

negative: array of procedure to array of integer assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF PROCEDURE; result: ARRAY 10 OF SIGNED16;
	BEGIN result := variable;
	END Test.

negative: array of boolean to array of long integer assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF BOOLEAN; result: ARRAY 10 OF SIGNED32;
	BEGIN result := variable;
	END Test.

negative: array of character to array of long integer assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF CHAR; result: ARRAY 10 OF SIGNED32;
	BEGIN result := variable;
	END Test.

negative: array of short integer to array of long integer assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF SIGNED8; result: ARRAY 10 OF SIGNED32;
	BEGIN result := variable;
	END Test.

negative: array of integer to array of long integer assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF SIGNED16; result: ARRAY 10 OF SIGNED32;
	BEGIN result := variable;
	END Test.

positive: array of long integer to array of long integer assignment

	MODULE Test;
	VAR variable, result: ARRAY 10 OF SIGNED32;
	BEGIN result := variable;
	END Test.

negative: array of long integer to temporary array of long integer assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF SIGNED32; result: PROCEDURE (): ARRAY 10 OF SIGNED32;
	BEGIN result () := variable;
	END Test.

negative: array of long integer to longer array of long integer assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF SIGNED32; result: ARRAY 20 OF SIGNED32;
	BEGIN result := variable;
	END Test.

negative: array of long integer to shorter array of long integer assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF SIGNED32; result: ARRAY 5 OF SIGNED32;
	BEGIN result := variable;
	END Test.

negative: array of long integer to open array of long integer assignment

	MODULE Test;
	PROCEDURE Procedure (VAR result: ARRAY OF SIGNED32);
	VAR variable: ARRAY 10 OF SIGNED32;
	BEGIN result := variable;
	END Procedure;
	END Test.

negative: open array of long integer to array of long integer assignment

	MODULE Test;
	PROCEDURE Procedure (VAR variable: ARRAY OF SIGNED32);
	VAR result: ARRAY 10 OF SIGNED32;
	BEGIN result := variable;
	END Procedure;
	END Test.

negative: array of long integer to dereferenced open array of long integer assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF SIGNED32; result: POINTER TO ARRAY OF SIGNED32;
	BEGIN result^ := variable;
	END Test.

negative: array of huge integer to array of long integer assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF SIGNED64; result: ARRAY 10 OF SIGNED32;
	BEGIN result := variable;
	END Test.

negative: array of real to array of long integer assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF FLOAT32; result: ARRAY 10 OF SIGNED32;
	BEGIN result := variable;
	END Test.

negative: array of long real to array of long integer assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF FLOAT64; result: ARRAY 10 OF SIGNED32;
	BEGIN result := variable;
	END Test.

negative: array of set to array of long integer assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF SET; result: ARRAY 10 OF SIGNED32;
	BEGIN result := variable;
	END Test.

negative: array of array to array of long integer assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF ARRAY 10 OF SET; result: ARRAY 10 OF SIGNED32;
	BEGIN result := variable;
	END Test.

negative: array of record to array of long integer assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF RECORD END; result: ARRAY 10 OF SIGNED32;
	BEGIN result := variable;
	END Test.

negative: array of object to array of long integer assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF OBJECT; result: ARRAY 10 OF SIGNED32;
	BEGIN result := variable;
	END Test.

negative: array of pointer to array of long integer assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF POINTER TO RECORD END; result: ARRAY 10 OF SIGNED32;
	BEGIN result := variable;
	END Test.

negative: array of procedure to array of long integer assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF PROCEDURE; result: ARRAY 10 OF SIGNED32;
	BEGIN result := variable;
	END Test.

negative: array of boolean to array of huge integer assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF BOOLEAN; result: ARRAY 10 OF SIGNED64;
	BEGIN result := variable;
	END Test.

negative: array of character to array of huge integer assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF CHAR; result: ARRAY 10 OF SIGNED64;
	BEGIN result := variable;
	END Test.

negative: array of short integer to array of huge integer assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF SIGNED8; result: ARRAY 10 OF SIGNED64;
	BEGIN result := variable;
	END Test.

negative: array of integer to array of huge integer assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF SIGNED16; result: ARRAY 10 OF SIGNED64;
	BEGIN result := variable;
	END Test.

negative: array of long integer to array of huge integer assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF SIGNED32; result: ARRAY 10 OF SIGNED64;
	BEGIN result := variable;
	END Test.

positive: array of huge integer to array of huge integer assignment

	MODULE Test;
	VAR variable, result: ARRAY 10 OF SIGNED64;
	BEGIN result := variable;
	END Test.

negative: array of huge integer to temporary array of huge integer assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF SIGNED64; result: PROCEDURE (): ARRAY 10 OF SIGNED64;
	BEGIN result () := variable;
	END Test.

negative: array of huge integer to longer array of huge integer assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF SIGNED64; result: ARRAY 20 OF SIGNED64;
	BEGIN result := variable;
	END Test.

negative: array of huge integer to shorter array of huge integer assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF SIGNED64; result: ARRAY 5 OF SIGNED64;
	BEGIN result := variable;
	END Test.

negative: array of huge integer to open array of huge integer assignment

	MODULE Test;
	PROCEDURE Procedure (VAR result: ARRAY OF SIGNED64);
	VAR variable: ARRAY 10 OF SIGNED64;
	BEGIN result := variable;
	END Procedure;
	END Test.

negative: open array of huge integer to array of huge integer assignment

	MODULE Test;
	PROCEDURE Procedure (VAR variable: ARRAY OF SIGNED64);
	VAR result: ARRAY 10 OF SIGNED64;
	BEGIN result := variable;
	END Procedure;
	END Test.

negative: array of huge integer to dereferenced open array of huge integer assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF SIGNED64; result: POINTER TO ARRAY OF SIGNED64;
	BEGIN result^ := variable;
	END Test.

negative: array of real to array of huge integer assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF FLOAT32; result: ARRAY 10 OF SIGNED64;
	BEGIN result := variable;
	END Test.

negative: array of long real to array of huge integer assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF FLOAT64; result: ARRAY 10 OF SIGNED64;
	BEGIN result := variable;
	END Test.

negative: array of set to array of huge integer assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF SET; result: ARRAY 10 OF SIGNED64;
	BEGIN result := variable;
	END Test.

negative: array of array to array of huge integer assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF ARRAY 10 OF SET; result: ARRAY 10 OF SIGNED64;
	BEGIN result := variable;
	END Test.

negative: array of record to array of huge integer assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF RECORD END; result: ARRAY 10 OF SIGNED64;
	BEGIN result := variable;
	END Test.

negative: array of object to array of huge integer assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF OBJECT; result: ARRAY 10 OF SIGNED64;
	BEGIN result := variable;
	END Test.

negative: array of pointer to array of huge integer assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF POINTER TO RECORD END; result: ARRAY 10 OF SIGNED64;
	BEGIN result := variable;
	END Test.

negative: array of procedure to array of huge integer assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF PROCEDURE; result: ARRAY 10 OF SIGNED64;
	BEGIN result := variable;
	END Test.

negative: array of boolean to array of real assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF BOOLEAN; result: ARRAY 10 OF FLOAT32;
	BEGIN result := variable;
	END Test.

negative: array of character to array of real assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF CHAR; result: ARRAY 10 OF FLOAT32;
	BEGIN result := variable;
	END Test.

negative: array of short integer to array of real assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF SIGNED8; result: ARRAY 10 OF FLOAT32;
	BEGIN result := variable;
	END Test.

negative: array of integer to array of real assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF SIGNED16; result: ARRAY 10 OF FLOAT32;
	BEGIN result := variable;
	END Test.

negative: array of long integer to array of real assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF SIGNED32; result: ARRAY 10 OF FLOAT32;
	BEGIN result := variable;
	END Test.

negative: array of huge integer to array of real assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF SIGNED64; result: ARRAY 10 OF FLOAT32;
	BEGIN result := variable;
	END Test.

positive: array of real to array of real assignment

	MODULE Test;
	VAR variable, result: ARRAY 10 OF FLOAT32;
	BEGIN result := variable;
	END Test.

negative: array of real to temporary array of real assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF SIGNED8; result: PROCEDURE (): ARRAY 10 OF SIGNED8;
	BEGIN result () := variable;
	END Test.

negative: array of real to longer array of real assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF FLOAT32; result: ARRAY 20 OF FLOAT32;
	BEGIN result := variable;
	END Test.

negative: array of real to shorter array of real assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF FLOAT32; result: ARRAY 5 OF FLOAT32;
	BEGIN result := variable;
	END Test.

negative: array of real to open array of real assignment

	MODULE Test;
	PROCEDURE Procedure (VAR result: ARRAY OF FLOAT32);
	VAR variable: ARRAY 10 OF FLOAT32;
	BEGIN result := variable;
	END Procedure;
	END Test.

negative: open array of real to array of real assignment

	MODULE Test;
	PROCEDURE Procedure (VAR variable: ARRAY OF FLOAT32);
	VAR result: ARRAY 10 OF FLOAT32;
	BEGIN result := variable;
	END Procedure;
	END Test.

negative: array of real to dereferenced open array of real assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF FLOAT32; result: POINTER TO ARRAY OF FLOAT32;
	BEGIN result^ := variable;
	END Test.

negative: array of long real to array of real assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF FLOAT64; result: ARRAY 10 OF FLOAT32;
	BEGIN result := variable;
	END Test.

negative: array of set to array of real assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF SET; result: ARRAY 10 OF FLOAT32;
	BEGIN result := variable;
	END Test.

negative: array of array to array of real assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF ARRAY 10 OF SET; result: ARRAY 10 OF FLOAT32;
	BEGIN result := variable;
	END Test.

negative: array of record to array of real assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF RECORD END; result: ARRAY 10 OF FLOAT32;
	BEGIN result := variable;
	END Test.

negative: array of object to array of real assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF OBJECT; result: ARRAY 10 OF FLOAT32;
	BEGIN result := variable;
	END Test.

negative: array of pointer to array of real assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF POINTER TO RECORD END; result: ARRAY 10 OF FLOAT32;
	BEGIN result := variable;
	END Test.

negative: array of procedure to array of real assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF PROCEDURE; result: ARRAY 10 OF FLOAT32;
	BEGIN result := variable;
	END Test.

negative: array of boolean to array of long real assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF BOOLEAN; result: ARRAY 10 OF FLOAT64;
	BEGIN result := variable;
	END Test.

negative: array of character to array of long real assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF CHAR; result: ARRAY 10 OF FLOAT64;
	BEGIN result := variable;
	END Test.

negative: array of short integer to array of long real assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF SIGNED8; result: ARRAY 10 OF FLOAT64;
	BEGIN result := variable;
	END Test.

negative: array of integer to array of long real assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF SIGNED16; result: ARRAY 10 OF FLOAT64;
	BEGIN result := variable;
	END Test.

negative: array of long integer to array of long real assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF SIGNED32; result: ARRAY 10 OF FLOAT64;
	BEGIN result := variable;
	END Test.

negative: array of huge integer to array of long real assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF SIGNED64; result: ARRAY 10 OF FLOAT64;
	BEGIN result := variable;
	END Test.

negative: array of real to array of long real assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF FLOAT32; result: ARRAY 10 OF FLOAT64;
	BEGIN result := variable;
	END Test.

positive: array of long real to array of long real assignment

	MODULE Test;
	VAR variable, result: ARRAY 10 OF FLOAT64;
	BEGIN result := variable;
	END Test.

negative: array of long real to temporary array of long real assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF FLOAT64; result: PROCEDURE (): ARRAY 10 OF FLOAT64;
	BEGIN result () := variable;
	END Test.

negative: array of long real to longer array of long real assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF FLOAT64; result: ARRAY 20 OF FLOAT64;
	BEGIN result := variable;
	END Test.

negative: array of long real to shorter array of long real assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF FLOAT64; result: ARRAY 5 OF FLOAT64;
	BEGIN result := variable;
	END Test.

negative: array of long real to open array of long real assignment

	MODULE Test;
	PROCEDURE Procedure (VAR result: ARRAY OF FLOAT64);
	VAR variable: ARRAY 10 OF FLOAT64;
	BEGIN result := variable;
	END Procedure;
	END Test.

negative: open array of long real to array of long real assignment

	MODULE Test;
	PROCEDURE Procedure (VAR variable: ARRAY OF FLOAT64);
	VAR result: ARRAY 10 OF FLOAT64;
	BEGIN result := variable;
	END Procedure;
	END Test.

negative: array of long real to dereferenced open array of long real assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF FLOAT64; result: POINTER TO ARRAY OF FLOAT64;
	BEGIN result^ := variable;
	END Test.

negative: array of set to array of long real assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF SET; result: ARRAY 10 OF FLOAT64;
	BEGIN result := variable;
	END Test.

negative: array of array to array of long real assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF ARRAY 10 OF SET; result: ARRAY 10 OF FLOAT64;
	BEGIN result := variable;
	END Test.

negative: array of record to array of long real assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF RECORD END; result: ARRAY 10 OF FLOAT64;
	BEGIN result := variable;
	END Test.

negative: array of object to array of long real assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF OBJECT; result: ARRAY 10 OF FLOAT64;
	BEGIN result := variable;
	END Test.

negative: array of pointer to array of long real assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF POINTER TO RECORD END; result: ARRAY 10 OF FLOAT64;
	BEGIN result := variable;
	END Test.

negative: array of procedure to array of long real assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF PROCEDURE; result: ARRAY 10 OF FLOAT64;
	BEGIN result := variable;
	END Test.

negative: array of boolean to array of set assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF BOOLEAN; result: ARRAY 10 OF SET;
	BEGIN result := variable;
	END Test.

negative: array of character to array of set assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF CHAR; result: ARRAY 10 OF SET;
	BEGIN result := variable;
	END Test.

negative: array of short integer to array of set assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF SIGNED8; result: ARRAY 10 OF SET;
	BEGIN result := variable;
	END Test.

negative: array of integer to array of set assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF SIGNED16; result: ARRAY 10 OF SET;
	BEGIN result := variable;
	END Test.

negative: array of long integer to array of set assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF SIGNED32; result: ARRAY 10 OF SET;
	BEGIN result := variable;
	END Test.

negative: array of huge integer to array of set assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF SIGNED64; result: ARRAY 10 OF SET;
	BEGIN result := variable;
	END Test.

negative: array of real to array of set assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF FLOAT32; result: ARRAY 10 OF SET;
	BEGIN result := variable;
	END Test.

negative: array of long real to array of set assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF FLOAT64; result: ARRAY 10 OF SET;
	BEGIN result := variable;
	END Test.

positive: array of set to array of set assignment

	MODULE Test;
	VAR variable, result: ARRAY 10 OF SET;
	BEGIN result := variable;
	END Test.

negative: array of set to longer array of set assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF SET; result: ARRAY 20 OF SET;
	BEGIN result := variable;
	END Test.

negative: array of set to shorter array of set assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF SET; result: ARRAY 5 OF SET;
	BEGIN result := variable;
	END Test.

negative: array of set to open array of set assignment

	MODULE Test;
	PROCEDURE Procedure (VAR result: ARRAY OF SET);
	VAR variable: ARRAY 10 OF SET;
	BEGIN result := variable;
	END Procedure;
	END Test.

negative: open array of set to array of set assignment

	MODULE Test;
	PROCEDURE Procedure (VAR variable: ARRAY OF SET);
	VAR result: ARRAY 10 OF SET;
	BEGIN result := variable;
	END Procedure;
	END Test.

negative: array of set to dereferenced open array of set assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF SET; result: POINTER TO ARRAY OF SET;
	BEGIN result^ := variable;
	END Test.

negative: array of array to array of set assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF ARRAY 10 OF BOOLEAN; result: ARRAY 10 OF SET;
	BEGIN result := variable;
	END Test.

negative: array of record to array of set assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF RECORD END; result: ARRAY 10 OF SET;
	BEGIN result := variable;
	END Test.

negative: array of object to array of set assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF OBJECT; result: ARRAY 10 OF SET;
	BEGIN result := variable;
	END Test.

negative: array of pointer to array of set assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF POINTER TO RECORD END; result: ARRAY 10 OF SET;
	BEGIN result := variable;
	END Test.

negative: array of procedure to array of set assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF PROCEDURE; result: ARRAY 10 OF SET;
	BEGIN result := variable;
	END Test.

negative: array of boolean to array of array assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF BOOLEAN; result: ARRAY 10 OF ARRAY 10 OF SET;
	BEGIN result := variable;
	END Test.

negative: array of character to array of array assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF CHAR; result: ARRAY 10 OF ARRAY 10 OF SET;
	BEGIN result := variable;
	END Test.

negative: array of short integer to array of array assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF SIGNED8; result: ARRAY 10 OF ARRAY 10 OF SET;
	BEGIN result := variable;
	END Test.

negative: array of integer to array of array assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF SIGNED16; result: ARRAY 10 OF ARRAY 10 OF SET;
	BEGIN result := variable;
	END Test.

negative: array of long integer to array of array assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF SIGNED32; result: ARRAY 10 OF ARRAY 10 OF SET;
	BEGIN result := variable;
	END Test.

negative: array of huge integer to array of array assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF SIGNED64; result: ARRAY 10 OF ARRAY 10 OF SET;
	BEGIN result := variable;
	END Test.

negative: array of real to array of array assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF FLOAT32; result: ARRAY 10 OF ARRAY 10 OF SET;
	BEGIN result := variable;
	END Test.

negative: array of long real to array of array assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF FLOAT64; result: ARRAY 10 OF ARRAY 10 OF SET;
	BEGIN result := variable;
	END Test.

negative: array of set of array assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF SET; result: ARRAY 10 OF ARRAY 10 OF SET;
	BEGIN result := variable;
	END Test.

positive: array of array to array of array assignment

	MODULE Test;
	VAR variable, result: ARRAY 10 OF ARRAY 10 OF SET;
	BEGIN result := variable;
	END Test.

negative: array of array to temporary array of array assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF ARRAY 10 OF SET; result: PROCEDURE (): ARRAY 10 OF ARRAY 10 OF SET;
	BEGIN result () := variable;
	END Test.

negative: array of array to longer array of array assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF ARRAY 10 OF SET; result: ARRAY 20 OF ARRAY 10 OF SET;
	BEGIN result := variable;
	END Test.

negative: array of array to shorter array of array assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF ARRAY 10 OF SET; result: ARRAY 5 OF ARRAY 10 OF SET;
	BEGIN result := variable;
	END Test.

negative: array of array to open array of array assignment

	MODULE Test;
	PROCEDURE Procedure (VAR result: ARRAY OF ARRAY 10 OF SET);
	VAR variable: ARRAY 10 OF ARRAY 10 OF SET;
	BEGIN result := variable;
	END Procedure;
	END Test.

negative: open array of array to array of array assignment

	MODULE Test;
	PROCEDURE Procedure (VAR variable: ARRAY OF ARRAY 10 OF SET);
	VAR result: ARRAY 10 OF ARRAY 10 OF SET;
	BEGIN result := variable;
	END Procedure;
	END Test.

negative: array of array to dereferenced open array of array assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF ARRAY 10 OF SET; result: POINTER TO ARRAY OF ARRAY 10 OF SET;
	BEGIN result^ := variable;
	END Test.

negative: array of record to array of array assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF RECORD END; result: ARRAY 10 OF ARRAY 10 OF SET;
	BEGIN result := variable;
	END Test.

negative: array of object to array of array assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF OBJECT; result: ARRAY 10 OF ARRAY 10 OF SET;
	BEGIN result := variable;
	END Test.

negative: array of pointer to array of array assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF POINTER TO RECORD END; result: ARRAY 10 OF ARRAY 10 OF SET;
	BEGIN result := variable;
	END Test.

negative: array of procedure to array of array assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF PROCEDURE; result: ARRAY 10 OF ARRAY 10 OF SET;
	BEGIN result := variable;
	END Test.

negative: array of boolean to array of record assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF BOOLEAN; result: ARRAY 10 OF RECORD END;
	BEGIN result := variable;
	END Test.

negative: array of character to array of record assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF CHAR; result: ARRAY 10 OF RECORD END;
	BEGIN result := variable;
	END Test.

negative: array of short integer to array of record assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF SIGNED8; result: ARRAY 10 OF RECORD END;
	BEGIN result := variable;
	END Test.

negative: array of integer to array of record assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF SIGNED16; result: ARRAY 10 OF RECORD END;
	BEGIN result := variable;
	END Test.

negative: array of long integer to array of record assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF SIGNED32; result: ARRAY 10 OF RECORD END;
	BEGIN result := variable;
	END Test.

negative: array of huge integer to array of record assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF SIGNED64; result: ARRAY 10 OF RECORD END;
	BEGIN result := variable;
	END Test.

negative: array of real to array of record assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF FLOAT32; result: ARRAY 10 OF RECORD END;
	BEGIN result := variable;
	END Test.

negative: array of long real to array of record assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF FLOAT64; result: ARRAY 10 OF RECORD END;
	BEGIN result := variable;
	END Test.

negative: array of set to array of record assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF SET; result: ARRAY 10 OF RECORD END;
	BEGIN result := variable;
	END Test.

negative: array of array to array of record assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF ARRAY 10 OF SET; result: ARRAY 10 OF RECORD END;
	BEGIN result := variable;
	END Test.

positive: array of record to array of record assignment

	MODULE Test;
	VAR variable, result: ARRAY 10 OF RECORD END;
	BEGIN result := variable;
	END Test.

negative: array of record to temporary array of record assignment

	MODULE Test;
	TYPE Record = RECORD END;
	VAR variable: ARRAY 10 OF Record; result: PROCEDURE (): ARRAY 10 OF Record;
	BEGIN result () := variable;
	END Test.

negative: array of record to longer array of record assignment

	MODULE Test;
	TYPE Record = RECORD END;
	VAR variable: ARRAY 10 OF Record; result: ARRAY 20 OF Record;
	BEGIN result := variable;
	END Test.

negative: array of record to shorter array of record assignment

	MODULE Test;
	TYPE Record = RECORD END;
	VAR variable: ARRAY 10 OF Record; result: ARRAY 5 OF Record;
	BEGIN result := variable;
	END Test.

negative: array of record to open array of record assignment

	MODULE Test;
	TYPE Record = RECORD END;
	PROCEDURE Procedure (VAR result: ARRAY OF Record);
	VAR variable: ARRAY 10 OF Record;
	BEGIN result := variable;
	END Procedure;
	END Test.

negative: open array of record to array of record assignment

	MODULE Test;
	TYPE Record = RECORD END;
	PROCEDURE Procedure (VAR variable: ARRAY OF Record);
	VAR result: ARRAY 10 OF Record;
	BEGIN result := variable;
	END Procedure;
	END Test.

negative: array of record to dereferenced open array of record assignment

	MODULE Test;
	TYPE Record = RECORD END;
	VAR variable: ARRAY 10 OF Record; result: POINTER TO ARRAY OF Record;
	BEGIN result^ := variable;
	END Test.

negative: array of object to array of record assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF OBJECT; result: ARRAY 10 OF RECORD END;
	BEGIN result := variable;
	END Test.

negative: array of pointer to array of record assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF POINTER TO RECORD END; result: ARRAY 10 OF RECORD END;
	BEGIN result := variable;
	END Test.

negative: array of procedure to array of record assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF PROCEDURE; result: ARRAY 10 OF RECORD END;
	BEGIN result := variable;
	END Test.

negative: array of boolean to array of object assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF BOOLEAN; result: ARRAY 10 OF OBJECT END;
	BEGIN result := variable;
	END Test.

negative: array of character to array of object assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF CHAR; result: ARRAY 10 OF OBJECT END;
	BEGIN result := variable;
	END Test.

negative: array of short integer to array of object assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF SIGNED8; result: ARRAY 10 OF OBJECT END;
	BEGIN result := variable;
	END Test.

negative: array of integer to array of object assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF SIGNED16; result: ARRAY 10 OF OBJECT END;
	BEGIN result := variable;
	END Test.

negative: array of long integer to array of object assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF SIGNED32; result: ARRAY 10 OF OBJECT END;
	BEGIN result := variable;
	END Test.

negative: array of huge integer to array of object assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF SIGNED64; result: ARRAY 10 OF OBJECT END;
	BEGIN result := variable;
	END Test.

negative: array of real to array of object assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF FLOAT32; result: ARRAY 10 OF OBJECT END;
	BEGIN result := variable;
	END Test.

negative: array of long real to array of object assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF FLOAT64; result: ARRAY 10 OF OBJECT END;
	BEGIN result := variable;
	END Test.

negative: array of set to array of object assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF SET; result: ARRAY 10 OF OBJECT END;
	BEGIN result := variable;
	END Test.

negative: array of array to array of object assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF ARRAY 10 OF SET; result: ARRAY 10 OF OBJECT END;
	BEGIN result := variable;
	END Test.

negative: array of record to array of object assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF RECORD END; result: ARRAY 10 OF OBJECT END;
	BEGIN result := variable;
	END Test.

positive: array of object to array of object assignment

	MODULE Test;
	VAR variable, result: ARRAY 10 OF OBJECT END;
	BEGIN result := variable;
	END Test.

negative: array of object to temporary array of object assignment

	MODULE Test;
	TYPE Object = OBJECT END Object;
	VAR variable: ARRAY 10 OF Object; result: PROCEDURE (): ARRAY 10 OF Object;
	BEGIN result () := variable;
	END Test.

negative: array of object to longer array of object assignment

	MODULE Test;
	TYPE Object = OBJECT END Object;
	VAR variable: ARRAY 10 OF Object; result: ARRAY 20 OF Object;
	BEGIN result := variable;
	END Test.

negative: array of object to shorter array of object assignment

	MODULE Test;
	TYPE Object = OBJECT END Object;
	VAR variable: ARRAY 10 OF Object; result: ARRAY 5 OF Object;
	BEGIN result := variable;
	END Test.

negative: array of object to open array of object assignment

	MODULE Test;
	TYPE Object = OBJECT END Object;
	PROCEDURE Procedure (VAR result: ARRAY OF Object);
	VAR variable: ARRAY 10 OF Object;
	BEGIN result := variable;
	END Procedure;
	END Test.

negative: open array of object to array of object assignment

	MODULE Test;
	TYPE Object = OBJECT END Object;
	PROCEDURE Procedure (VAR variable: ARRAY OF Object);
	VAR result: ARRAY 10 OF Object;
	BEGIN result := variable;
	END Procedure;
	END Test.

negative: array of object to dereferenced open array of object assignment

	MODULE Test;
	TYPE Object = OBJECT END Object;
	VAR variable: ARRAY 10 OF Object; result: POINTER TO ARRAY OF Object;
	BEGIN result^ := variable;
	END Test.

negative: array of pointer to array of object assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF POINTER TO RECORD END; result: ARRAY 10 OF OBJECT END;
	BEGIN result := variable;
	END Test.

negative: array of procedure to array of object assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF PROCEDURE; result: ARRAY 10 OF OBJECT END;
	BEGIN result := variable;
	END Test.

negative: array of boolean to array of pointer assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF BOOLEAN; result: ARRAY 10 OF POINTER TO RECORD END;
	BEGIN result := variable;
	END Test.

negative: array of character to array of pointer assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF CHAR; result: ARRAY 10 OF POINTER TO RECORD END;
	BEGIN result := variable;
	END Test.

negative: array of short integer to array of pointer assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF SIGNED8; result: ARRAY 10 OF POINTER TO RECORD END;
	BEGIN result := variable;
	END Test.

negative: array of integer to array of pointer assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF SIGNED16; result: ARRAY 10 OF POINTER TO RECORD END;
	BEGIN result := variable;
	END Test.

negative: array of long integer to array of pointer assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF SIGNED32; result: ARRAY 10 OF POINTER TO RECORD END;
	BEGIN result := variable;
	END Test.

negative: array of huge integer to array of pointer assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF SIGNED64; result: ARRAY 10 OF POINTER TO RECORD END;
	BEGIN result := variable;
	END Test.

negative: array of real to array of pointer assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF FLOAT32; result: ARRAY 10 OF POINTER TO RECORD END;
	BEGIN result := variable;
	END Test.

negative: array of long real to array of pointer assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF FLOAT64; result: ARRAY 10 OF POINTER TO RECORD END;
	BEGIN result := variable;
	END Test.

negative: array of set to array of pointer assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF SET; result: ARRAY 10 OF POINTER TO RECORD END;
	BEGIN result := variable;
	END Test.

negative: array of array to array of pointer assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF ARRAY 10 OF SET; result: ARRAY 10 OF POINTER TO RECORD END;
	BEGIN result := variable;
	END Test.

negative: array of record to array of pointer assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF RECORD END; result: ARRAY 10 OF POINTER TO RECORD END;
	BEGIN result := variable;
	END Test.

negative: array of object to array of pointer assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF OBJECT END; result: ARRAY 10 OF POINTER TO RECORD END;
	BEGIN result := variable;
	END Test.

positive: array of pointer to array of pointer assignment

	MODULE Test;
	VAR variable, result: ARRAY 10 OF POINTER TO RECORD END;
	BEGIN result := variable;
	END Test.

negative: array of pointer to temporary array of pointer assignment

	MODULE Test;
	TYPE Record = RECORD END;
	VAR variable: ARRAY 10 OF POINTER TO Record; result: PROCEDURE (): ARRAY 10 OF POINTER TO Record;
	BEGIN result () := variable;
	END Test.

negative: array of pointer to longer array of pointer assignment

	MODULE Test;
	TYPE Pointer = POINTER TO RECORD END;
	VAR variable: ARRAY 10 OF Pointer; result: ARRAY 20 OF Pointer;
	BEGIN result := variable;
	END Test.

negative: array of pointer to shorter array of pointer assignment

	MODULE Test;
	TYPE Pointer = POINTER TO RECORD END;
	VAR variable: ARRAY 10 OF Pointer; result: ARRAY 5 OF Pointer;
	BEGIN result := variable;
	END Test.

negative: array of pointer to open array of pointer assignment

	MODULE Test;
	TYPE Pointer = POINTER TO RECORD END;
	PROCEDURE Procedure (VAR result: ARRAY OF Pointer);
	VAR variable: ARRAY 10 OF Pointer;
	BEGIN result := variable;
	END Procedure;
	END Test.

negative: open array of pointer to array of pointer assignment

	MODULE Test;
	TYPE Pointer = POINTER TO RECORD END;
	PROCEDURE Procedure (VAR variable: ARRAY OF Pointer);
	VAR result: ARRAY 10 OF Pointer;
	BEGIN result := variable;
	END Procedure;
	END Test.

negative: array of pointer to dereferenced open array of pointer assignment

	MODULE Test;
	TYPE Pointer = POINTER TO RECORD END;
	VAR variable: ARRAY 10 OF Pointer; result: POINTER TO ARRAY OF Pointer;
	BEGIN result^ := variable;
	END Test.

negative: array of procedure to array of pointer assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF PROCEDURE; result: ARRAY 10 OF POINTER TO RECORD END;
	BEGIN result := variable;
	END Test.

negative: array of boolean to array of procedure assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF BOOLEAN; result: ARRAY 10 OF PROCEDURE;
	BEGIN result := variable;
	END Test.

negative: array of character to array of procedure assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF CHAR; result: ARRAY 10 OF PROCEDURE;
	BEGIN result := variable;
	END Test.

negative: array of short integer to array of procedure assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF SIGNED8; result: ARRAY 10 OF PROCEDURE;
	BEGIN result := variable;
	END Test.

negative: array of integer to array of procedure assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF SIGNED16; result: ARRAY 10 OF PROCEDURE;
	BEGIN result := variable;
	END Test.

negative: array of long integer to array of procedure assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF SIGNED32; result: ARRAY 10 OF PROCEDURE;
	BEGIN result := variable;
	END Test.

negative: array of huge integer to array of procedure assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF SIGNED64; result: ARRAY 10 OF PROCEDURE;
	BEGIN result := variable;
	END Test.

negative: array of real to array of procedure assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF FLOAT32; result: ARRAY 10 OF PROCEDURE;
	BEGIN result := variable;
	END Test.

negative: array of long real to array of procedure assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF FLOAT64; result: ARRAY 10 OF PROCEDURE;
	BEGIN result := variable;
	END Test.

negative: array of set to array of procedure assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF SET; result: ARRAY 10 OF PROCEDURE;
	BEGIN result := variable;
	END Test.

negative: array of array to array of procedure assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF ARRAY 10 OF SET; result: ARRAY 10 OF PROCEDURE;
	BEGIN result := variable;
	END Test.

negative: array of record to array of procedure assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF RECORD END; result: ARRAY 10 OF PROCEDURE;
	BEGIN result := variable;
	END Test.

negative: array of object to array of procedure assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF OBJECT END; result: ARRAY 10 OF PROCEDURE;
	BEGIN result := variable;
	END Test.

negative: array of pointer to array of procedure assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF POINTER TO RECORD END; result: ARRAY 10 OF PROCEDURE;
	BEGIN result := variable;
	END Test.

positive: array of procedure to array of procedure assignment

	MODULE Test;
	VAR variable, result: ARRAY 10 OF PROCEDURE;
	BEGIN result := variable;
	END Test.

negative: array of procedure to temporary array of procedure assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF PROCEDURE; result: PROCEDURE (): ARRAY 10 OF PROCEDURE;
	BEGIN result () := variable;
	END Test.

negative: array of procedure to longer array of procedure assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF PROCEDURE; result: ARRAY 20 OF PROCEDURE;
	BEGIN result := variable;
	END Test.

negative: array of procedure to shorter array of procedure assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF PROCEDURE; result: ARRAY 5 OF PROCEDURE;
	BEGIN result := variable;
	END Test.

negative: array of procedure to open array of procedure assignment

	MODULE Test;
	PROCEDURE Procedure (VAR result: ARRAY OF PROCEDURE);
	VAR variable: ARRAY 10 OF PROCEDURE;
	BEGIN result := variable;
	END Procedure;
	END Test.

negative: open array of procedure to array of procedure assignment

	MODULE Test;
	PROCEDURE Procedure (VAR variable: ARRAY OF PROCEDURE);
	VAR result: ARRAY 10 OF PROCEDURE;
	BEGIN result := variable;
	END Procedure;
	END Test.

negative: array of procedure to dereferenced open array of procedure assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF PROCEDURE; result: POINTER TO ARRAY OF PROCEDURE;
	BEGIN result^ := variable;
	END Test.

negative: record to array assignment

	MODULE Test;
	VAR variable: RECORD END; result: ARRAY 10 OF CHAR;
	BEGIN result := variable;
	END Test.

negative: object to array assignment

	MODULE Test;
	VAR variable: OBJECT; result: ARRAY 10 OF CHAR;
	BEGIN result := variable;
	END Test.

negative: pointer to array assignment

	MODULE Test;
	VAR variable: POINTER TO RECORD END; result: ARRAY 10 OF CHAR;
	BEGIN result := variable;
	END Test.

negative: variable procedure to array assignment

	MODULE Test;
	VAR variable: PROCEDURE; result: ARRAY 10 OF CHAR;
	BEGIN result := variable;
	END Test.

negative: import to array assignment

	MODULE Test;
	IMPORT variable := Dummy; VAR result: ARRAY 10 OF CHAR;
	BEGIN result := variable;
	END Test.

negative: type to variable array assignment

	MODULE Test;
	TYPE Type = ARRAY 10 OF CHAR; VAR result: Type;
	BEGIN result := Type;
	END Test.

negative: variable boolean to record assignment

	MODULE Test;
	VAR variable: BOOLEAN; result: RECORD END;
	BEGIN result := variable;
	END Test.

negative: variable character to record assignment

	MODULE Test;
	VAR variable: CHAR; result: RECORD END;
	BEGIN result := variable;
	END Test.

negative: variable short integer to record assignment

	MODULE Test;
	VAR variable: SIGNED8; result: RECORD END;
	BEGIN result := variable;
	END Test.

negative: variable integer to record assignment

	MODULE Test;
	VAR variable: SIGNED16; result: RECORD END;
	BEGIN result := variable;
	END Test.

negative: variable long integer to record assignment

	MODULE Test;
	VAR variable: SIGNED32; result: RECORD END;
	BEGIN result := variable;
	END Test.

negative: variable huge integer to record assignment

	MODULE Test;
	VAR variable: SIGNED64; result: RECORD END;
	BEGIN result := variable;
	END Test.

negative: variable real to record assignment

	MODULE Test;
	VAR variable: FLOAT32; result: RECORD END;
	BEGIN result := variable;
	END Test.

negative: variable long real to record assignment

	MODULE Test;
	VAR variable: FLOAT64; result: RECORD END;
	BEGIN result := variable;
	END Test.

negative: variable set to record assignment

	MODULE Test;
	VAR variable: FLOAT64; result: RECORD END;
	BEGIN result := variable;
	END Test.

negative: array to record assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF CHAR; result: RECORD END;
	BEGIN result := variable;
	END Test.

positive: record to same record assignment

	MODULE Test;
	VAR variable, result: RECORD END;
	BEGIN result := variable;
	END Test.

negative: record to same temporary record assignment

	MODULE Test;
	TYPE Record = RECORD END;
	VAR variable: Record; result: PROCEDURE (): Record;
	BEGIN result () := variable;
	END Test.

negative: record to different record assignment

	MODULE Test;
	VAR variable: RECORD END; result: RECORD END;
	BEGIN result := variable;
	END Test.

positive: extended record to base record assignment

	MODULE Test;
	TYPE Record = RECORD END;
	VAR variable: RECORD (Record) END; result: Record;
	BEGIN result := variable;
	END Test.

negative: base record to extended record assignment

	MODULE Test;
	TYPE Record = RECORD END;
	VAR variable: Record; result: RECORD (Record) END;
	BEGIN result := variable;
	END Test.

positive: record parameter to same record assignment

	MODULE Test;
	PROCEDURE Procedure (parameter, result: RECORD END);
	BEGIN result := parameter;
	END Procedure;
	END Test.

negative: record parameter to different record assignment

	MODULE Test;
	PROCEDURE Procedure (parameter: RECORD END; result: RECORD END);
	BEGIN result := parameter;
	END Procedure;
	END Test.

positive: extended record parameter to base record assignment

	MODULE Test;
	TYPE Record = RECORD END;
	PROCEDURE Procedure (parameter: RECORD (Record) END; result: Record);
	BEGIN result := parameter;
	END Procedure;
	END Test.

negative: base record parameter to extended record assignment

	MODULE Test;
	TYPE Record = RECORD END;
	PROCEDURE Procedure (parameter: Record; result: RECORD (Record) END);
	BEGIN result := parameter;
	END Procedure;
	END Test.

negative: object to record assignment

	MODULE Test;
	VAR variable: OBJECT; result: RECORD END;
	BEGIN result := variable;
	END Test.

negative: pointer to record assignment

	MODULE Test;
	TYPE Record = RECORD END;
	VAR variable: POINTER TO Record; result: Record;
	BEGIN result := variable;
	END Test.

negative: variable procedure to record assignment

	MODULE Test;
	VAR variable: PROCEDURE; result: RECORD END;
	BEGIN result := variable;
	END Test.

negative: import to record assignment

	MODULE Test;
	IMPORT variable := Dummy; VAR result: RECORD END;
	BEGIN result := variable;
	END Test.

negative: type to variable record assignment

	MODULE Test;
	TYPE Type = RECORD END; VAR result: Type;
	BEGIN result := Type;
	END Test.

negative: variable boolean to object assignment

	MODULE Test;
	VAR variable: BOOLEAN; result: OBJECT END;
	BEGIN result := variable;
	END Test.

negative: variable character to object assignment

	MODULE Test;
	VAR variable: CHAR; result: OBJECT END;
	BEGIN result := variable;
	END Test.

negative: variable short integer to object assignment

	MODULE Test;
	VAR variable: SIGNED8; result: OBJECT END;
	BEGIN result := variable;
	END Test.

negative: variable integer to object assignment

	MODULE Test;
	VAR variable: SIGNED16; result: OBJECT END;
	BEGIN result := variable;
	END Test.

negative: variable long integer to object assignment

	MODULE Test;
	VAR variable: SIGNED32; result: OBJECT END;
	BEGIN result := variable;
	END Test.

negative: variable huge integer to object assignment

	MODULE Test;
	VAR variable: SIGNED64; result: OBJECT END;
	BEGIN result := variable;
	END Test.

negative: variable real to object assignment

	MODULE Test;
	VAR variable: FLOAT32; result: OBJECT END;
	BEGIN result := variable;
	END Test.

negative: variable long real to object assignment

	MODULE Test;
	VAR variable: FLOAT64; result: OBJECT END;
	BEGIN result := variable;
	END Test.

negative: variable set to object assignment

	MODULE Test;
	VAR variable: FLOAT64; result: OBJECT END;
	BEGIN result := variable;
	END Test.

negative: array to object assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF CHAR; result: OBJECT END;
	BEGIN result := variable;
	END Test.

negative: record to object assignment

	MODULE Test;
	VAR variable: RECORD END; result: OBJECT END;
	BEGIN result := variable;
	END Test.

positive: object to same object assignment

	MODULE Test;
	VAR variable, result: OBJECT END;
	BEGIN result := variable;
	END Test.

negative: obbject to same temporary object assignment

	MODULE Test;
	TYPE Object = OBJECT END Object;
	VAR variable: Object; result: PROCEDURE (): Object;
	BEGIN result () := variable;
	END Test.

negative: object to different object assignment

	MODULE Test;
	VAR variable: OBJECT END; result: OBJECT END;
	BEGIN result := variable;
	END Test.

positive: extended object to base object assignment

	MODULE Test;
	TYPE Object = OBJECT END Object;
	VAR variable: OBJECT (Object) END; result: Object;
	BEGIN result := variable;
	END Test.

negative: base object to extended object assignment

	MODULE Test;
	TYPE Object = OBJECT END Object;
	VAR variable: Object; result: OBJECT (Object) END;
	BEGIN result := variable;
	END Test.

positive: object to basic object assignment

	MODULE Test;
	VAR variable: OBJECT END; result: OBJECT;
	BEGIN result := variable;
	END Test.

negative: basic object to object assignment

	MODULE Test;
	VAR variable: OBJECT; result: OBJECT END;
	BEGIN result := variable;
	END Test.

negative: pointer to object assignment

	MODULE Test;
	VAR variable: POINTER TO RECORD END; result: OBJECT END;
	BEGIN result := variable;
	END Test.

negative: variable procedure to object assignment

	MODULE Test;
	VAR variable: PROCEDURE; result: OBJECT END;
	BEGIN result := variable;
	END Test.

negative: import to object assignment

	MODULE Test;
	IMPORT variable := Dummy; VAR result: OBJECT END;
	BEGIN result := variable;
	END Test.

negative: variable boolean to pointer assignment

	MODULE Test;
	VAR variable: BOOLEAN; result: POINTER TO RECORD END;
	BEGIN result := variable;
	END Test.

negative: variable character to pointer assignment

	MODULE Test;
	VAR variable: CHAR; result: POINTER TO RECORD END;
	BEGIN result := variable;
	END Test.

negative: variable short integer to pointer assignment

	MODULE Test;
	VAR variable: SIGNED8; result: POINTER TO RECORD END;
	BEGIN result := variable;
	END Test.

negative: variable integer to pointer assignment

	MODULE Test;
	VAR variable: SIGNED16; result: POINTER TO RECORD END;
	BEGIN result := variable;
	END Test.

negative: variable long integer to pointer assignment

	MODULE Test;
	VAR variable: SIGNED32; result: POINTER TO RECORD END;
	BEGIN result := variable;
	END Test.

negative: variable huge integer to pointer assignment

	MODULE Test;
	VAR variable: SIGNED64; result: POINTER TO RECORD END;
	BEGIN result := variable;
	END Test.

negative: variable real to pointer assignment

	MODULE Test;
	VAR variable: FLOAT32; result: POINTER TO RECORD END;
	BEGIN result := variable;
	END Test.

negative: variable long real to pointer assignment

	MODULE Test;
	VAR variable: FLOAT64; result: POINTER TO RECORD END;
	BEGIN result := variable;
	END Test.

negative: variable set to pointer assignment

	MODULE Test;
	VAR variable: FLOAT64; result: POINTER TO RECORD END;
	BEGIN result := variable;
	END Test.

negative: array to pointer assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF CHAR; result: POINTER TO RECORD END;
	BEGIN result := variable;
	END Test.

negative: record to pointer assignment

	MODULE Test;
	VAR variable: RECORD END; result: POINTER TO RECORD END;
	BEGIN result := variable;
	END Test.

negative: object to pointer assignment

	MODULE Test;
	VAR variable: OBJECT END; result: POINTER TO RECORD END;
	BEGIN result := variable;
	END Test.

positive: pointer to same pointer assignment

	MODULE Test;
	VAR variable, result: POINTER TO RECORD END;
	BEGIN result := variable;
	END Test.

negative: pointer to same temporary pointer assignment

	MODULE Test;
	TYPE Pointer = POINTER TO RECORD END;
	VAR variable: Pointer; result: PROCEDURE (): Pointer;
	BEGIN result () := variable;
	END Test.

positive: pointer to array of same pointer to same pointer assignment

	MODULE Test;
	TYPE Pointer = POINTER TO ARRAY 10 OF Pointer;
	VAR variable, result: Pointer;
	BEGIN result := variable;
	END Test.

positive: pointers to array of same pointer to same pointer assignment

	MODULE Test;
	TYPE A = POINTER TO ARRAY 10 OF B;
	TYPE B = POINTER TO ARRAY 10 OF C;
	TYPE C = POINTER TO ARRAY 10 OF D;
	TYPE D = POINTER TO ARRAY 10 OF A;
	VAR variable: A; result: B;
	BEGIN result := variable;
	END Test.

positive: pointer to open array of same pointer to same pointer assignment

	MODULE Test;
	TYPE Pointer = POINTER TO ARRAY OF Pointer;
	VAR variable, result: Pointer;
	BEGIN result := variable;
	END Test.

positive: pointers to open array of same pointer to same pointer assignment

	MODULE Test;
	TYPE A = POINTER TO ARRAY 10 OF B;
	TYPE B = POINTER TO ARRAY 10 OF C;
	TYPE C = POINTER TO ARRAY 10 OF D;
	TYPE D = POINTER TO ARRAY 10 OF A;
	VAR variable: A; result: B;
	BEGIN result := variable;
	END Test.

positive: pointer to different pointer assignment

	MODULE Test;
	TYPE Record = RECORD END;
	VAR variable: POINTER TO Record; result: POINTER TO Record;
	BEGIN result := variable;
	END Test.

positive: extended pointer to base pointer assignment

	MODULE Test;
	TYPE Record = RECORD END;
	VAR variable: POINTER TO RECORD (Record) END; result: POINTER TO Record;
	BEGIN result := variable;
	END Test.

negative: base pointer to extended pointer assignment

	MODULE Test;
	TYPE Record = RECORD END;
	VAR variable: POINTER TO Record; result: POINTER TO RECORD (Record) END;
	BEGIN result := variable;
	END Test.

negative: pointer to array to pointer to record assignment

	MODULE Test;
	VAR variable: POINTER TO ARRAY 10 OF CHAR; result: POINTER TO RECORD END;
	BEGIN result := variable;
	END Test.

negative: pointer to record to pointer to array assignment

	MODULE Test;
	VAR variable: POINTER TO RECORD END; result: POINTER TO ARRAY 10 OF CHAR;
	BEGIN result := variable;
	END Test.

positive: pointer to array to pointer to array assignment

	MODULE Test;
	VAR variable, result: POINTER TO ARRAY 10 OF CHAR;
	BEGIN result := variable;
	END Test.

negative: pointer to array to temporary pointer to array assignment

	MODULE Test;
	TYPE Pointer = POINTER TO ARRAY 10 OF CHAR;
	VAR variable: Pointer; result: PROCEDURE (): Pointer;
	BEGIN result () := variable;
	END Test.

negative: pointer to array to pointer to longer array assignment

	MODULE Test;
	VAR variable: POINTER TO ARRAY 10 OF CHAR; result: POINTER TO ARRAY 20 OF CHAR;
	BEGIN result := variable;
	END Test.

negative: pointer to array to pointer to shorter array assignment

	MODULE Test;
	VAR variable: POINTER TO ARRAY 10 OF CHAR; result: POINTER TO ARRAY 5 OF CHAR;
	BEGIN result := variable;
	END Test.

negative: variable procedure to pointer assignment

	MODULE Test;
	VAR variable: PROCEDURE; result: POINTER TO RECORD END;
	BEGIN result := variable;
	END Test.

negative: import to pointer assignment

	MODULE Test;
	IMPORT variable := Dummy; VAR result: POINTER TO RECORD END;
	BEGIN result := variable;
	END Test.

negative: type to variable pointer assignment

	MODULE Test;
	TYPE Type = POINTER TO RECORD END; VAR result: Type;
	BEGIN result := Type;
	END Test.

negative: variable boolean to procedure assignment

	MODULE Test;
	VAR variable: BOOLEAN; result: PROCEDURE;
	BEGIN result := variable;
	END Test.

negative: variable character to procedure assignment

	MODULE Test;
	VAR variable: CHAR; result: PROCEDURE;
	BEGIN result := variable;
	END Test.

negative: variable short integer to procedure assignment

	MODULE Test;
	VAR variable: SIGNED8; result: PROCEDURE;
	BEGIN result := variable;
	END Test.

negative: variable integer to procedure assignment

	MODULE Test;
	VAR variable: SIGNED16; result: PROCEDURE;
	BEGIN result := variable;
	END Test.

negative: variable long integer to procedure assignment

	MODULE Test;
	VAR variable: SIGNED32; result: PROCEDURE;
	BEGIN result := variable;
	END Test.

negative: variable huge integer to procedure assignment

	MODULE Test;
	VAR variable: SIGNED64; result: PROCEDURE;
	BEGIN result := variable;
	END Test.

negative: variable real to procedure assignment

	MODULE Test;
	VAR variable: FLOAT32; result: PROCEDURE;
	BEGIN result := variable;
	END Test.

negative: variable long real to procedure assignment

	MODULE Test;
	VAR variable: FLOAT64; result: PROCEDURE;
	BEGIN result := variable;
	END Test.

negative: variable set to procedure assignment

	MODULE Test;
	VAR variable: FLOAT64; result: PROCEDURE;
	BEGIN result := variable;
	END Test.

negative: array to procedure assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF CHAR; result: PROCEDURE;
	BEGIN result := variable;
	END Test.

negative: record to procedure assignment

	MODULE Test;
	VAR variable: RECORD END; result: PROCEDURE;
	BEGIN result := variable;
	END Test.

negative: object to procedure assignment

	MODULE Test;
	VAR variable: OBJECT END; result: PROCEDURE;
	BEGIN result := variable;
	END Test.

negative: pointer to procedure assignment

	MODULE Test;
	VAR variable: POINTER TO RECORD END; result: PROCEDURE;
	BEGIN result := variable;
	END Test.

positive: variable procedure to variable procedure assignment

	MODULE Test;
	VAR variable, result: PROCEDURE;
	BEGIN result := variable;
	END Test.

negative: variable procedure to temporary procedure assignment

	MODULE Test;
	VAR variable: PROCEDURE; result: PROCEDURE (): PROCEDURE;
	BEGIN result () := variable;
	END Test.

positive: procedure to variable procedure assignment

	MODULE Test;
	VAR result: PROCEDURE;
	PROCEDURE variable; END variable;
	BEGIN result := variable;
	END Test.

negative: variable procedure to procedure assignment

	MODULE Test;
	VAR variable: PROCEDURE;
	PROCEDURE result; END result;
	BEGIN result := variable;
	END Test.

negative: procedure to procedure assignment

	MODULE Test;
	PROCEDURE variable; END variable;
	PROCEDURE result; END result;
	BEGIN result := variable;
	END Test.

positive: variable procedure to variable procedure with same parameter assignment

	MODULE Test;
	VAR variable: PROCEDURE (integer: SIGNED16); result: PROCEDURE (integer: SIGNED16);
	BEGIN result := variable;
	END Test.

positive: procedure to variable procedure with same parameter assignment

	MODULE Test;
	VAR result: PROCEDURE (integer: SIGNED16);
	PROCEDURE variable (integer: SIGNED16); END variable;
	BEGIN result := variable;
	END Test.

negative: variable procedure to variable procedure with compatible parameter assignment

	MODULE Test;
	VAR variable: PROCEDURE (object: OBJECT END); result: PROCEDURE (object: OBJECT);
	BEGIN result := variable;
	END Test.

negative: procedure to variable procedure with compatible parameter assignment

	MODULE Test;
	VAR result: PROCEDURE (object: OBJECT);
	PROCEDURE variable (object: OBJECT END); END variable;
	BEGIN result := variable;
	END Test.

negative: variable procedure to variable procedure with incompatible parameter assignment

	MODULE Test;
	VAR variable: PROCEDURE (object: OBJECT END); result: PROCEDURE (object: OBJECT END);
	BEGIN result := variable;
	END Test.

negative: procedure to variable procedure with incompatible parameter assignment

	MODULE Test;
	VAR result: PROCEDURE (object: OBJECT END);
	PROCEDURE variable (object: OBJECT END); END variable;
	BEGIN result := variable;
	END Test.

positive: variable procedure to variable procedure with same return type assignment

	MODULE Test;
	VAR variable: PROCEDURE (): SIGNED16; result: PROCEDURE (): SIGNED16;
	BEGIN result := variable;
	END Test.

positive: procedure to variable procedure with same return type assignment

	MODULE Test;
	VAR result: PROCEDURE (): SIGNED16;
	PROCEDURE variable (): SIGNED16; END variable;
	BEGIN result := variable;
	END Test.

negative: variable procedure to variable procedure with compatible return type assignment

	MODULE Test;
	VAR variable: PROCEDURE (): OBJECT END; result: PROCEDURE (): OBJECT;
	BEGIN result := variable;
	END Test.

negative: procedure to variable procedure with compatible return type assignment

	MODULE Test;
	VAR result: PROCEDURE (): OBJECT;
	PROCEDURE variable (): OBJECT END; END variable;
	BEGIN result := variable;
	END Test.

negative: variable procedure to variable procedure with incompatible return type assignment

	MODULE Test;
	VAR variable: PROCEDURE (): OBJECT END; result: PROCEDURE (): OBJECT END;
	BEGIN result := variable;
	END Test.

negative: procedure to variable procedure with incompatible return type assignment

	MODULE Test;
	VAR result: PROCEDURE (): OBJECT END;
	PROCEDURE variable (): OBJECT END; END variable;
	BEGIN result := variable;
	END Test.

positive: variable procedure to variable procedure with parameter of same procedure type assignment

	MODULE Test;
	TYPE Procedure = PROCEDURE (procedure: Procedure);
	VAR variable: Procedure; result: Procedure;
	BEGIN result := variable;
	END Test.

positive: procedure to variable procedure with parameter of same procedure type assignment

	MODULE Test;
	TYPE Procedure = PROCEDURE (procedure: Procedure);
	VAR result: Procedure;
	PROCEDURE variable (procedure: Procedure); END variable;
	BEGIN result := variable;
	END Test.

positive: variable procedure to variable procedure with parameter of same procedure types assignment

	MODULE Test;
	TYPE A = PROCEDURE (b: B);
	TYPE B = PROCEDURE (c: C);
	TYPE C = PROCEDURE (d: D);
	TYPE D = PROCEDURE (a: A);
	VAR variable: A; result: B;
	BEGIN result := variable;
	END Test.

positive: procedure to variable procedure with parameter of same procedure types assignment

	MODULE Test;
	TYPE A = PROCEDURE (b: B);
	TYPE B = PROCEDURE (c: C);
	TYPE C = PROCEDURE (d: D);
	TYPE D = PROCEDURE (a: A);
	VAR result: A;
	PROCEDURE variable (procedure: A); END variable;
	BEGIN result := variable;
	END Test.

positive: variable procedure to variable procedure with return of same procedure type assignment

	MODULE Test;
	TYPE Procedure = PROCEDURE (): Procedure;
	VAR variable: Procedure; result: Procedure;
	BEGIN result := variable;
	END Test.

positive: procedure to variable procedure with return of same procedure type assignment

	MODULE Test;
	TYPE Procedure = PROCEDURE (): Procedure;
	VAR result: Procedure;
	PROCEDURE variable (): Procedure; END variable;
	BEGIN result := variable;
	END Test.

positive: variable procedure to variable procedure with return of same procedure types assignment

	MODULE Test;
	TYPE A = PROCEDURE (): B;
	TYPE B = PROCEDURE (): C;
	TYPE C = PROCEDURE (): D;
	TYPE D = PROCEDURE (): A;
	VAR variable: A; result: B;
	BEGIN result := variable;
	END Test.

positive: procedure to variable procedure with return of same procedure types assignment

	MODULE Test;
	TYPE A = PROCEDURE (): B;
	TYPE B = PROCEDURE (): C;
	TYPE C = PROCEDURE (): D;
	TYPE D = PROCEDURE (): A;
	VAR result: A;
	PROCEDURE variable (): A; END variable;
	BEGIN result := variable;
	END Test.

positive: global procedure to global variable procedure assignment

	MODULE Test;
	VAR result: PROCEDURE;
	PROCEDURE variable; END variable;
	BEGIN result := variable;
	END Test.

negative: nested procedure to global variable procedure assignment

	MODULE Test;
	VAR result: PROCEDURE;
	PROCEDURE Procedure;
		PROCEDURE variable; END variable;
		BEGIN result := variable;
	END Procedure;
	END Test.

positive: global procedure to nested variable procedure assignment

	MODULE Test;
	PROCEDURE variable; END variable;
	PROCEDURE Procedure;
	VAR result: PROCEDURE;
	BEGIN result := variable;
	END Procedure;
	END Test.

negative: nested procedure to nested variable procedure assignment

	MODULE Test;
	PROCEDURE Procedure;
	VAR result: PROCEDURE;
		PROCEDURE variable; END variable;
		BEGIN result := variable;
	END Procedure;
	END Test.

negative: procedure in object to global variable procedure assignment

	MODULE Test;
	VAR result: PROCEDURE;
	VAR object: OBJECT PROCEDURE variable; END variable; END;
	BEGIN result := object.variable;
	END Test.

negative: nested procedure in object to global variable procedure assignment

	MODULE Test;
	VAR object: OBJECT VAR result: PROCEDURE; PROCEDURE Procedure; PROCEDURE variable; END variable; BEGIN result := variable; END Procedure; END;
	END Test.

negative: procedure in object to nested variable procedure assignment

	MODULE Test;
	VAR result: PROCEDURE;
	VAR object: OBJECT PROCEDURE variable; END variable; END;
	BEGIN result := object.variable;
	END Test.

negative: nested procedure in object to nested variable procedure assignment

	MODULE Test;
	VAR object: OBJECT VAR result: PROCEDURE; PROCEDURE Procedure; PROCEDURE variable; END variable; BEGIN result := variable; END Procedure; END;
	END Test.

negative: import to procedure assignment

	MODULE Test;
	IMPORT variable := Dummy; VAR result: PROCEDURE;
	BEGIN result := variable;
	END Test.

negative: type to variable procedure assignment

	MODULE Test;
	TYPE Type = PROCEDURE; VAR result: Type;
	BEGIN result := Type;
	END Test.

negative: variable boolean to import assignment

	MODULE Test;
	IMPORT result := Dummy;
	VAR variable: BOOLEAN;
	BEGIN result := variable;
	END Test.

negative: variable character to import assignment

	MODULE Test;
	IMPORT result := Dummy;
	VAR variable: CHAR;
	BEGIN result := variable;
	END Test.

negative: variable short integer to import assignment

	MODULE Test;
	IMPORT result := Dummy;
	VAR variable: SIGNED8;
	BEGIN result := variable;
	END Test.

negative: variable integer to import assignment

	MODULE Test;
	IMPORT result := Dummy;
	VAR variable: SIGNED16;
	BEGIN result := variable;
	END Test.

negative: variable long integer to import assignment

	MODULE Test;
	IMPORT result := Dummy;
	VAR variable: SIGNED32;
	BEGIN result := variable;
	END Test.

negative: variable huge integer to import assignment

	MODULE Test;
	IMPORT result := Dummy;
	VAR variable: SIGNED64;
	BEGIN result := variable;
	END Test.

negative: variable real to import assignment

	MODULE Test;
	IMPORT result := Dummy;
	VAR variable: FLOAT32;
	BEGIN result := variable;
	END Test.

negative: variable long real to import assignment

	MODULE Test;
	IMPORT result := Dummy;
	VAR variable: FLOAT64;
	BEGIN result := variable;
	END Test.

negative: variable set to import assignment

	MODULE Test;
	IMPORT result := Dummy;
	VAR variable: FLOAT64;
	BEGIN result := variable;
	END Test.

negative: array to import assignment

	MODULE Test;
	IMPORT result := Dummy;
	VAR variable: ARRAY 10 OF CHAR;
	BEGIN result := variable;
	END Test.

negative: record to import assignment

	MODULE Test;
	IMPORT result := Dummy;
	VAR variable: RECORD END;
	BEGIN result := variable;
	END Test.

negative: object to import assignment

	MODULE Test;
	IMPORT result := Dummy;
	VAR variable: OBJECT END;
	BEGIN result := variable;
	END Test.

negative: pointer to import assignment

	MODULE Test;
	IMPORT result := Dummy;
	VAR variable: POINTER TO RECORD END;
	BEGIN result := variable;
	END Test.

negative: variable procedure to import assignment

	MODULE Test;
	IMPORT result := Dummy;
	VAR variable: PROCEDURE;
	BEGIN result := variable;
	END Test.

negative: import to import assignment

	MODULE Test;
	IMPORT variable := Dummy, result := Dummy;
	BEGIN result := variable;
	END Test.

negative: type to import assignment

	MODULE Test;
	IMPORT result := Dummy; TYPE Type = BOOLEAN;
	BEGIN result := Type;
	END Test.

negative: variable boolean to type assignment

	MODULE Test;
	TYPE result = BOOLEAN; VAR variable: result;
	BEGIN result := variable;
	END Test.

negative: variable character to type assignment

	MODULE Test;
	TYPE result = CHAR; VAR variable: result;
	BEGIN result := variable;
	END Test.

negative: variable short integer to type assignment

	MODULE Test;
	TYPE result = SIGNED8; VAR variable: result;
	BEGIN result := variable;
	END Test.

negative: variable integer to type assignment

	MODULE Test;
	TYPE result = SIGNED16; VAR variable: result;
	BEGIN result := variable;
	END Test.

negative: variable long integer to type assignment

	MODULE Test;
	TYPE result = SIGNED32; VAR variable: result;
	BEGIN result := variable;
	END Test.

negative: variable huge integer to type assignment

	MODULE Test;
	TYPE result = SIGNED64; VAR variable: result;
	BEGIN result := variable;
	END Test.

negative: variable real to type assignment

	MODULE Test;
	TYPE result = FLOAT32; VAR variable: result;
	BEGIN result := variable;
	END Test.

negative: variable long real to type assignment

	MODULE Test;
	TYPE result = FLOAT64; VAR variable: result;
	BEGIN result := variable;
	END Test.

negative: variable set to type assignment

	MODULE Test;
	TYPE result = SET; VAR variable: result;
	BEGIN result := variable;
	END Test.

negative: array to type assignment

	MODULE Test;
	TYPE result = ARRAY 10 OF CHAR; VAR variable: result;
	BEGIN result := variable;
	END Test.

negative: record to type assignment

	MODULE Test;
	TYPE result = RECORD END; VAR variable: result;
	BEGIN result := variable;
	END Test.

negative: object to type assignment

	MODULE Test;
	TYPE result = OBJECT END result; VAR variable: result;
	BEGIN result := variable;
	END Test.

negative: pointer to type assignment

	MODULE Test;
	TYPE result = POINTER TO RECORD END; VAR variable: result;
	BEGIN result := variable;
	END Test.

negative: variable procedure to type assignment

	MODULE Test;
	TYPE result = PROCEDURE; VAR variable: result;
	BEGIN result := variable;
	END Test.

negative: import to type assignment

	MODULE Test;
	IMPORT variable := Dummy; TYPE result = BOOLEAN;
	BEGIN result := variable;
	END Test.


# variable booleans

negative: arithmetic negation on variable boolean

	MODULE Test;
	VAR boolean, result: BOOLEAN;
	BEGIN result := -boolean;
	END Test.

positive: logical negation on variable boolean

	MODULE Test;
	VAR boolean, result: BOOLEAN;
	BEGIN result := ~boolean;
	END Test.

positive: multiple logical negations on variable boolean

	MODULE Test;
	VAR boolean, result: BOOLEAN;
	BEGIN result := ~~~~boolean;
	END Test.

negative: dereferencing variable boolean

	MODULE Test;
	VAR boolean, result: BOOLEAN;
	BEGIN result := boolean^;
	END Test.

negative: addition on variable booleans

	MODULE Test;
	VAR boolean, result: BOOLEAN;
	BEGIN result := boolean + boolean;
	END Test.

negative: subtraction on variable booleans

	MODULE Test;
	VAR boolean, result: BOOLEAN;
	BEGIN result := boolean - boolean
	END Test.

negative: multiplication on variable booleans

	MODULE Test;
	VAR boolean, result: BOOLEAN;
	BEGIN result := boolean * boolean
	END Test.

negative: integer division on variable booleans

	MODULE Test;
	VAR boolean: BOOLEAN; result: SIGNED16;
	BEGIN result := boolean DIV boolean
	END Test.

negative: real division on variable booleans

	MODULE Test;
	VAR boolean: BOOLEAN; result: FLOAT32;
	BEGIN result := boolean / boolean
	END Test.

negative: modulo on variable booleans

	MODULE Test;
	VAR boolean: BOOLEAN; result: SIGNED16;
	BEGIN result := boolean MOD boolean
	END Test.

positive: equal relation on variable booleans

	MODULE Test;
	VAR boolean, result: BOOLEAN;
	BEGIN result := boolean = boolean
	END Test.

positive: unequal relation on variable booleans

	MODULE Test;
	VAR boolean, result: BOOLEAN;
	BEGIN result := boolean # boolean
	END Test.

negative: less relation on variable booleans

	MODULE Test;
	VAR boolean, result: BOOLEAN;
	BEGIN result := boolean < boolean
	END Test.

negative: less or equal relation on variable booleans

	MODULE Test;
	VAR boolean, result: BOOLEAN;
	BEGIN result := boolean <= boolean
	END Test.

negative: greater relation on variable booleans

	MODULE Test;
	VAR boolean, result: BOOLEAN;
	BEGIN result := boolean > boolean
	END Test.

negative: greater or equal relation on variable booleans

	MODULE Test;
	VAR boolean, result: BOOLEAN;
	BEGIN result := boolean >= boolean
	END Test.

negative: set membership on variable booleans

	MODULE Test;
	VAR boolean, result: BOOLEAN;
	BEGIN result := boolean IN boolean
	END Test.

negative: type test on variable booleans

	MODULE Test;
	VAR boolean, result: BOOLEAN;
	BEGIN result := boolean IS boolean
	END Test.

negative: type test on variable boolean

	MODULE Test;
	VAR boolean, result: BOOLEAN;
	BEGIN result := boolean IS BOOLEAN
	END Test.

negative: type test on boolean type

	MODULE Test;
	TYPE Type = BOOLEAN;
	VAR boolean: Type; result: BOOLEAN;
	BEGIN result := boolean IS Type
	END Test.

negative: type guard on variable booleans

	MODULE Test;
	VAR boolean, result: BOOLEAN;
	BEGIN result := boolean(boolean)
	END Test.

negative: type guard on variable boolean

	MODULE Test;
	VAR boolean, result: BOOLEAN;
	BEGIN result := boolean(BOOLEAN)
	END Test.

negative: type guard on boolean type

	MODULE Test;
	TYPE Type = BOOLEAN;
	VAR boolean, result: Type;
	BEGIN result := boolean(Type)
	END Test.

positive: logical and on variable booleans

	MODULE Test;
	VAR boolean, result: BOOLEAN;
	BEGIN result := boolean & boolean
	END Test.

positive: logical or on variable booleans

	MODULE Test;
	VAR boolean, result: BOOLEAN;
	BEGIN result := boolean OR boolean
	END Test.

negative: ordinal value of variable boolean

	MODULE Test;
	VAR boolean: BOOLEAN; result: SIGNED16;
	BEGIN result := ORD (boolean)
	END Test.

negative: character value of variable boolean

	MODULE Test;
	VAR boolean: BOOLEAN; result: CHAR;
	BEGIN result := CHR (boolean)
	END Test.

negative: absolute value of variable boolean

	MODULE Test;
	VAR boolean, result: BOOLEAN;
	BEGIN result := ABS (boolean)
	END Test.

negative: odd test on variable boolean

	MODULE Test;
	VAR boolean, result: BOOLEAN;
	BEGIN result := ODD (boolean)
	END Test.

negative: capital letter of variable boolean

	MODULE Test;
	VAR boolean: BOOLEAN; result: CHAR;
	BEGIN result := CAP (boolean)
	END Test.

negative: arithmetic shift of variable booleans

	MODULE Test;
	VAR boolean, result: BOOLEAN;
	BEGIN result := ASH (boolean, boolean)
	END Test.

negative: short on variable boolean

	MODULE Test;
	VAR boolean, result: BOOLEAN;
	BEGIN result := SHORT (boolean)
	END Test.

negative: long on variable boolean

	MODULE Test;
	VAR boolean, result: BOOLEAN;
	BEGIN result := LONG (boolean)
	END Test.

negative: entier on variable boolean

	MODULE Test;
	VAR boolean, result: BOOLEAN;
	BEGIN result := ENTIER (boolean)
	END Test.

negative: unary length of variable boolean

	MODULE Test;
	VAR boolean: BOOLEAN; result: SIZE;
	BEGIN result := LEN (boolean)
	END Test.

negative: binary length of variable boolean

	MODULE Test;
	VAR boolean: BOOLEAN; result: SIZE;
	BEGIN result := LEN (boolean, 0)
	END Test.

negative: indexing variable boolean

	MODULE Test;
	VAR boolean: BOOLEAN; result: CHAR;
	BEGIN result := boolean[0]
	END Test.

negative: variable boolean as index

	MODULE Test;
	VAR array: ARRAY 10 OF CHAR; result: CHAR; boolean: BOOLEAN;
	BEGIN result := array[boolean]
	END Test.

negative: member selection on variable boolean

	MODULE Test;
	VAR boolean, result: BOOLEAN;
	BEGIN result := boolean.member
	END Test.

negative: calling variable boolean

	MODULE Test;
	VAR boolean: BOOLEAN;
	BEGIN boolean
	END Test.


# variable characters

negative: arithmetic negation on variable character

	MODULE Test;
	VAR character, result: CHAR;
	BEGIN result := -character;
	END Test.

negative: logical negation on variable character

	MODULE Test;
	VAR character: CHAR; result: BOOLEAN;
	BEGIN result := ~character;
	END Test.

negative: dereferencing variable character

	MODULE Test;
	VAR character, result: CHAR;
	BEGIN result := character^;
	END Test.

negative: addition on variable characters

	MODULE Test;
	VAR character, result: CHAR;
	BEGIN result := character + character;
	END Test.

negative: subtraction on variable characters

	MODULE Test;
	VAR character, result: CHAR;
	BEGIN result := character - character
	END Test.

negative: multiplication on variable characters

	MODULE Test;
	VAR character, result: CHAR;
	BEGIN result := character * character
	END Test.

negative: integer division on variable characters

	MODULE Test;
	VAR character: CHAR; result: SIGNED16;
	BEGIN result := character DIV character
	END Test.

negative: real division on variable characters

	MODULE Test;
	VAR character: CHAR; result: FLOAT32;
	BEGIN result := character / character
	END Test.

negative: modulo on variable characters

	MODULE Test;
	VAR character: CHAR; result: SIGNED16;
	BEGIN result := character MOD character
	END Test.

positive: equal relation on variable characters

	MODULE Test;
	VAR character: CHAR; result: BOOLEAN;
	BEGIN result := character = character
	END Test.

positive: unequal relation on variable characters

	MODULE Test;
	VAR character: CHAR; result: BOOLEAN;
	BEGIN result := character # character
	END Test.

positive: less relation on variable characters

	MODULE Test;
	VAR character: CHAR; result: BOOLEAN;
	BEGIN result := character < character
	END Test.

positive: less or equal relation on variable characters

	MODULE Test;
	VAR character: CHAR; result: BOOLEAN;
	BEGIN result := character <= character
	END Test.

positive: greater relation on variable characters

	MODULE Test;
	VAR character: CHAR; result: BOOLEAN;
	BEGIN result := character > character
	END Test.

positive: greater or equal relation on variable characters

	MODULE Test;
	VAR character: CHAR; result: BOOLEAN;
	BEGIN result := character >= character
	END Test.

negative: set membership on variable characters

	MODULE Test;
	VAR character: CHAR; result: BOOLEAN;
	BEGIN result := character IN character
	END Test.

negative: type test on variable characters

	MODULE Test;
	VAR character: CHAR; result: BOOLEAN;
	BEGIN result := character IS character
	END Test.

negative: type test on variable character

	MODULE Test;
	VAR character: CHAR; result: BOOLEAN;
	BEGIN result := character IS CHAR
	END Test.

negative: type test on character type

	MODULE Test;
	TYPE Type = CHAR;
	VAR character: Type; result: BOOLEAN;
	BEGIN result := character IS Type
	END Test.

negative: type guard on variable characters

	MODULE Test;
	VAR character, result: CHAR;
	BEGIN result := character(character)
	END Test.

negative: type guard on variable character

	MODULE Test;
	VAR character, result: CHAR;
	BEGIN result := character(CHAR)
	END Test.

negative: type guard on character type

	MODULE Test;
	TYPE Type = CHAR;
	VAR character, result: Type;
	BEGIN result := character(Type)
	END Test.

negative: logical and on variable characters

	MODULE Test;
	VAR character: CHAR; result: BOOLEAN;
	BEGIN result := character & character
	END Test.

negative: logical or on variable characters

	MODULE Test;
	VAR character: CHAR; result: BOOLEAN;
	BEGIN result := character OR character
	END Test.

positive: ordinal value of variable character

	MODULE Test;
	VAR character: CHAR; result: SIGNED16;
	BEGIN result := ORD (character)
	END Test.

negative: character value of variable character

	MODULE Test;
	VAR character, result: CHAR;
	BEGIN result := CHR (character)
	END Test.

negative: absolute value of variable character

	MODULE Test;
	VAR character, result: CHAR;
	BEGIN result := ABS (character)
	END Test.

negative: odd test on variable character

	MODULE Test;
	VAR character: CHAR; result: BOOLEAN;
	BEGIN result := ODD (character)
	END Test.

positive: capital letter of variable character

	MODULE Test;
	VAR character, result: CHAR;
	BEGIN result := CAP (character)
	END Test.

negative: arithmetic shift of variable characters

	MODULE Test;
	VAR character, result: CHAR;
	BEGIN result := ASH (character, character)
	END Test.

negative: short on variable character

	MODULE Test;
	VAR character, result: CHAR;
	BEGIN result := SHORT (character)
	END Test.

negative: long on variable character

	MODULE Test;
	VAR character, result: CHAR;
	BEGIN result := LONG (character)
	END Test.

negative: entier on variable character

	MODULE Test;
	VAR character, result: CHAR;
	BEGIN result := ENTIER (character)
	END Test.

negative: unary length of variable character

	MODULE Test;
	VAR character: CHAR; result: SIZE;
	BEGIN result := LEN (character)
	END Test.

negative: binary length of variable character

	MODULE Test;
	VAR character: CHAR; result: SIZE;
	BEGIN result := LEN (character, 0)
	END Test.

negative: indexing variable character

	MODULE Test;
	VAR character, result: CHAR;
	BEGIN result := character[0]
	END Test.

negative: variable character as index

	MODULE Test;
	VAR array: ARRAY 10 OF CHAR; result, character: CHAR;
	BEGIN result := array[character]
	END Test.

negative: member selection on variable character

	MODULE Test;
	VAR character, result: CHAR;
	BEGIN result := character.member
	END Test.

negative: calling variable character

	MODULE Test;
	VAR character: CHAR;
	BEGIN character
	END Test.


# variable integers

positive: arithmetic negation on variable integer

	MODULE Test;
	VAR integer, result: SIGNED16;
	BEGIN result := -integer;
	END Test.

positive: multiple arithmetic negations on variable integer

	MODULE Test;
	VAR integer, result: SIGNED16;
	BEGIN result := -(-(-integer));
	END Test.

negative: logical negation on variable integer

	MODULE Test;
	VAR integer: SIGNED16; result: BOOLEAN;
	BEGIN result := ~integer;
	END Test.

negative: dereferencing variable integer

	MODULE Test;
	VAR integer, result: SIGNED16;
	BEGIN result := integer^;
	END Test.

positive: addition on variable integers

	MODULE Test;
	VAR integer, result: SIGNED16;
	BEGIN result := integer + integer;
	END Test.

positive: subtraction on variable integers

	MODULE Test;
	VAR integer, result: SIGNED16;
	BEGIN result := integer - integer
	END Test.

positive: multiplication on variable integers

	MODULE Test;
	VAR integer, result: SIGNED16;
	BEGIN result := integer * integer
	END Test.

positive: integer division on variable integers

	MODULE Test;
	VAR integer, result: SIGNED16;
	BEGIN result := integer DIV integer
	END Test.

positive: real division on variable integers

	MODULE Test;
	VAR integer: SIGNED16; result: FLOAT32;
	BEGIN result := integer / integer
	END Test.

positive: modulo on variable integers

	MODULE Test;
	VAR integer, result: SIGNED16;
	BEGIN result := integer MOD integer
	END Test.

positive: equal relation on variable integers

	MODULE Test;
	VAR integer: SIGNED16; result: BOOLEAN;
	BEGIN result := integer = integer
	END Test.

positive: unequal relation on variable integers

	MODULE Test;
	VAR integer: SIGNED16; result: BOOLEAN;
	BEGIN result := integer # integer
	END Test.

positive: less relation on variable integers

	MODULE Test;
	VAR integer: SIGNED16; result: BOOLEAN;
	BEGIN result := integer < integer
	END Test.

positive: less or equal relation on variable integers

	MODULE Test;
	VAR integer: SIGNED16; result: BOOLEAN;
	BEGIN result := integer <= integer
	END Test.

positive: greater relation on variable integers

	MODULE Test;
	VAR integer: SIGNED16; result: BOOLEAN;
	BEGIN result := integer > integer
	END Test.

positive: greater or equal relation on variable integers

	MODULE Test;
	VAR integer: SIGNED16; result: BOOLEAN;
	BEGIN result := integer >= integer
	END Test.

negative: set membership on variable integers

	MODULE Test;
	VAR integer: SIGNED16; result: BOOLEAN;
	BEGIN result := integer IN integer
	END Test.

negative: type test on variable integers

	MODULE Test;
	VAR integer: SIGNED16; result: BOOLEAN;
	BEGIN result := integer IS integer
	END Test.

positive: type test on variable integer

	MODULE Test;
	VAR integer: SIGNED16; result: BOOLEAN;
	BEGIN result := integer IS SIGNED16
	END Test.

positive: type test on integer type

	MODULE Test;
	TYPE Type = SIGNED16;
	VAR integer: Type; result: BOOLEAN;
	BEGIN result := integer IS Type
	END Test.

negative: type guard on variable integers

	MODULE Test;
	VAR integer, result: SIGNED16;
	BEGIN result := integer(integer)
	END Test.

positive: type guard on variable integer

	MODULE Test;
	VAR integer, result: SIGNED16;
	BEGIN result := integer(SIGNED16)
	END Test.

positive: type guard on integer type

	MODULE Test;
	TYPE Type = SIGNED16;
	VAR integer, result: Type;
	BEGIN result := integer(Type)
	END Test.

negative: logical and on variable integers

	MODULE Test;
	VAR integer: SIGNED16; result: BOOLEAN;
	BEGIN result := integer & integer
	END Test.

negative: logical or on variable integers

	MODULE Test;
	VAR integer: SIGNED16; result: BOOLEAN;
	BEGIN result := integer OR integer
	END Test.

negative: ordinal value of variable integer

	MODULE Test;
	VAR integer, result: SIGNED16;
	BEGIN result := ORD (integer)
	END Test.

positive: character value of variable integer

	MODULE Test;
	VAR integer: SIGNED16; result: CHAR;
	BEGIN result := CHR (integer)
	END Test.

positive: absolute value of variable integer

	MODULE Test;
	VAR integer, result: SIGNED16;
	BEGIN result := ABS (integer)
	END Test.

positive: odd test on variable integer

	MODULE Test;
	VAR integer: SIGNED16; result: BOOLEAN;
	BEGIN result := ODD (integer)
	END Test.

negative: capital letter of variable integer

	MODULE Test;
	VAR integer: SIGNED16; result: CHAR;
	BEGIN result := CAP (integer)
	END Test.

positive: arithmetic shift of variable integers

	MODULE Test;
	VAR integer: SIGNED16; result: SIGNED32;
	BEGIN result := ASH (integer, integer)
	END Test.

negative: short on variable short integer

	MODULE Test;
	VAR shortint, result: SIGNED8;
	BEGIN result := SHORT (shortint)
	END Test.

positive: short on variable integer

	MODULE Test;
	VAR integer, result: SIGNED16;
	BEGIN result := SHORT (integer)
	END Test.

positive: short on variable long integer

	MODULE Test;
	VAR longint, result: SIGNED32;
	BEGIN result := SHORT (longint)
	END Test.

positive: short on variable huge integer

	MODULE Test;
	VAR hugeint, result: SIGNED64;
	BEGIN result := SHORT (hugeint)
	END Test.

positive: long on variable short integer

	MODULE Test;
	VAR shortint, result: SIGNED8;
	BEGIN result := SHORT (LONG (shortint))
	END Test.

positive: long on variable integer

	MODULE Test;
	VAR integer, result: SIGNED16;
	BEGIN result := SHORT (LONG (integer))
	END Test.

positive: long on variable long integer

	MODULE Test;
	VAR longint, result: SIGNED32;
	BEGIN result := SHORT (LONG (longint))
	END Test.

negative: long on variable huge integer

	MODULE Test;
	VAR hugeint, result: SIGNED64;
	BEGIN result := SHORT (LONG (hugeint))
	END Test.

negative: entier on variable integer

	MODULE Test;
	VAR integer, result: SIGNED32;
	BEGIN result := ENTIER (integer)
	END Test.

negative: unary length of variable integer

	MODULE Test;
	VAR integer: SIGNED16; result: SIZE;
	BEGIN result := LEN (integer)
	END Test.

negative: binary length of variable integer

	MODULE Test;
	VAR integer: SIGNED16; result: SIZE;
	BEGIN result := LEN (integer, 0)
	END Test.

negative: indexing variable integer

	MODULE Test;
	VAR integer: SIGNED16; result: CHAR;
	BEGIN result := integer[0]
	END Test.

positive: variable integer as index

	MODULE Test;
	VAR array: ARRAY 10 OF CHAR; result: CHAR; integer: SIGNED16;
	BEGIN result := array[integer]
	END Test.

positive: variable integer as index in two-dimensional array

	MODULE Test;
	VAR array: ARRAY 5, 10 OF CHAR; result: CHAR; integer: SIGNED16;
	BEGIN result := array[integer, integer]
	END Test.

positive: variable integer as index in two-dimensional open array

	MODULE Test;
	PROCEDURE Procedure (CONST array: ARRAY OF ARRAY OF CHAR);
	VAR result: CHAR; integer: SIGNED16;
	BEGIN result := array[integer, integer]; result := array[integer][integer]
	END Procedure;
	END Test.

negative: member selection on variable integer

	MODULE Test;
	VAR integer, result: SIGNED16;
	BEGIN result := integer.member
	END Test.

negative: calling variable integer

	MODULE Test;
	VAR integer: SIGNED16;
	BEGIN integer
	END Test.


# variable reals

positive: arithmetic negation on variable real

	MODULE Test;
	VAR real, result: FLOAT32;
	BEGIN result := -real;
	END Test.

positive: multiple arithmetic negations on variable real

	MODULE Test;
	VAR real, result: FLOAT32;
	BEGIN result := -(-(-real));
	END Test.

negative: logical negation on variable real

	MODULE Test;
	VAR real: FLOAT32; result: BOOLEAN;
	BEGIN result := ~real;
	END Test.

negative: dereferencing variable real

	MODULE Test;
	VAR real, result: FLOAT32;
	BEGIN result := real^;
	END Test.

positive: addition on variable reals

	MODULE Test;
	VAR real, result: FLOAT32;
	BEGIN result := real + real;
	END Test.

positive: subtraction on variable reals

	MODULE Test;
	VAR real, result: FLOAT32;
	BEGIN result := real - real
	END Test.

positive: multiplication on variable reals

	MODULE Test;
	VAR real, result: FLOAT32;
	BEGIN result := real * real
	END Test.

negative: integer division on variable reals

	MODULE Test;
	VAR real: FLOAT32; result: SIGNED16;
	BEGIN result := real DIV real
	END Test.

positive: real division on variable reals

	MODULE Test;
	VAR real, result: FLOAT32;
	BEGIN result := real / real
	END Test.

negative: modulo on variable reals

	MODULE Test;
	VAR real: FLOAT32; result: SIGNED16;
	BEGIN result := real MOD real
	END Test.

positive: equal relation on variable reals

	MODULE Test;
	VAR real: FLOAT32; result: BOOLEAN;
	BEGIN result := real = real
	END Test.

positive: unequal relation on variable reals

	MODULE Test;
	VAR real: FLOAT32; result: BOOLEAN;
	BEGIN result := real # real
	END Test.

positive: less relation on variable reals

	MODULE Test;
	VAR real: FLOAT32; result: BOOLEAN;
	BEGIN result := real < real
	END Test.

positive: less or equal relation on variable reals

	MODULE Test;
	VAR real: FLOAT32; result: BOOLEAN;
	BEGIN result := real <= real
	END Test.

positive: greater relation on variable reals

	MODULE Test;
	VAR real: FLOAT32; result: BOOLEAN;
	BEGIN result := real > real
	END Test.

positive: greater or equal relation on variable reals

	MODULE Test;
	VAR real: FLOAT32; result: BOOLEAN;
	BEGIN result := real >= real
	END Test.

negative: set membership on variable reals

	MODULE Test;
	VAR real: FLOAT32; result: BOOLEAN;
	BEGIN result := real IN real
	END Test.

negative: type test on variable reals

	MODULE Test;
	VAR real: FLOAT32; result: BOOLEAN;
	BEGIN result := real IS real
	END Test.

positive: type test on variable real

	MODULE Test;
	VAR real: FLOAT32; result: BOOLEAN;
	BEGIN result := real IS FLOAT32
	END Test.

positive: type test on real type

	MODULE Test;
	TYPE Type = FLOAT32;
	VAR real: Type; result: BOOLEAN;
	BEGIN result := real IS Type
	END Test.

negative: type guard on variable reals

	MODULE Test;
	VAR real, result: FLOAT32;
	BEGIN result := real(real)
	END Test.

positive: type guard on variable real

	MODULE Test;
	VAR real, result: FLOAT32;
	BEGIN result := real(FLOAT32)
	END Test.

positive: type guard on real type

	MODULE Test;
	TYPE Type = FLOAT32;
	VAR real, result: Type;
	BEGIN result := real(Type)
	END Test.

negative: logical and on variable reals

	MODULE Test;
	VAR real: FLOAT32; result: BOOLEAN;
	BEGIN result := real & real
	END Test.

negative: logical or on variable reals

	MODULE Test;
	VAR real: FLOAT32; result: BOOLEAN;
	BEGIN result := real OR real
	END Test.

negative: ordinal value of variable real

	MODULE Test;
	VAR real: FLOAT32; result: SIGNED16;
	BEGIN result := ORD (real)
	END Test.

negative: character value of variable real

	MODULE Test;
	VAR real: FLOAT32; result: CHAR;
	BEGIN result := CHR (real)
	END Test.

positive: absolute value of variable real

	MODULE Test;
	VAR real, result: FLOAT32;
	BEGIN result := ABS (real)
	END Test.

negative: odd test on variable real

	MODULE Test;
	VAR real: FLOAT32; result: BOOLEAN;
	BEGIN result := ODD (real)
	END Test.

negative: capital letter of variable real

	MODULE Test;
	VAR real: FLOAT32; result: CHAR;
	BEGIN result := CAP (real)
	END Test.

negative: arithmetic shift of variable reals

	MODULE Test;
	VAR real, result: FLOAT32;
	BEGIN result := ASH (real, real)
	END Test.

negative: short on variable real

	MODULE Test;
	VAR real, result: FLOAT32;
	BEGIN result := SHORT (real)
	END Test.

positive: short on variable long real

	MODULE Test;
	VAR longreal, result: FLOAT64;
	BEGIN result := SHORT (longreal)
	END Test.

positive: long on variable real

	MODULE Test;
	VAR real, result: FLOAT32;
	BEGIN result := SHORT (LONG (real))
	END Test.

negative: long on variable long real

	MODULE Test;
	VAR longreal, result: FLOAT64;
	BEGIN result := SHORT (LONG (longreal))
	END Test.

positive: entier on variable real

	MODULE Test;
	VAR real, result: FLOAT32;
	BEGIN result := ENTIER (real)
	END Test.

positive: entier on variable long real

	MODULE Test;
	VAR longreal, result: FLOAT64;
	BEGIN result := ENTIER (longreal)
	END Test.

negative: unary length of variable real

	MODULE Test;
	VAR real: FLOAT32; result: SIZE;
	BEGIN result := LEN (real)
	END Test.

negative: binary length of variable real

	MODULE Test;
	VAR real: FLOAT32; result: SIZE;
	BEGIN result := LEN (real, 0)
	END Test.

negative: indexing variable real

	MODULE Test;
	VAR real: FLOAT32; result: CHAR;
	BEGIN result := real[0]
	END Test.

negative: variable real as index

	MODULE Test;
	VAR array: ARRAY 10 OF CHAR; result: CHAR; real: FLOAT32;
	BEGIN result := array[real]
	END Test.

negative: member selection on variable real

	MODULE Test;
	VAR real, result: FLOAT32;
	BEGIN result := real.member
	END Test.

negative: calling variable real

	MODULE Test;
	VAR real: FLOAT32;
	BEGIN real
	END Test.


# variable set

negative: variable boolean as set element

	MODULE Test;
	VAR boolean: BOOLEAN; result: SET;
	BEGIN result := {boolean};
	END Test.

negative: variable character as set element

	MODULE Test;
	VAR character: CHAR; result: SET;
	BEGIN result := {character};
	END Test.

positive: variable integer variable as set element

	MODULE Test;
	VAR integer: SIGNED16; result: SET;
	BEGIN result := {integer};
	END Test.

negative: variable real as set element

	MODULE Test;
	VAR real: FLOAT32; result: SET;
	BEGIN result := {real};
	END Test.

negative: variable set as set element

	MODULE Test;
	VAR set, result: SET;
	BEGIN result := {set};
	END Test.

positive: several equal variable set elements

	MODULE Test;
	VAR integer: SIGNED16; result: SET;
	BEGIN result := {integer, integer, integer};
	END Test.

positive: several different variable set elements

	MODULE Test;
	VAR integer: SIGNED16; result: SET;
	BEGIN result := {integer, integer, integer};
	END Test.

positive: variable set element range

	MODULE Test;
	VAR integer: SIGNED16; result: SET;
	BEGIN result := {integer..integer};
	END Test.

positive: variable set element range with single element

	MODULE Test;
	VAR integer: SIGNED16; result: SET;
	BEGIN result := {integer..integer};
	END Test.

positive: empty variable set element range

	MODULE Test;
	VAR integer: SIGNED16; result: SET;
	BEGIN result := {integer..integer};
	END Test.

positive: complement on variable set

	MODULE Test;
	VAR set, result: SET;
	BEGIN result := -set;
	END Test.

positive: multiple complements on variable set

	MODULE Test;
	VAR set, result: SET;
	BEGIN result := -(-(-set));
	END Test.

negative: logical negation on variable set

	MODULE Test;
	VAR set: SET; result: BOOLEAN;
	BEGIN result := ~set;
	END Test.

negative: dereferencing variable set

	MODULE Test;
	VAR set, result: SET;
	BEGIN result := set^;
	END Test.

positive: union on variable sets

	MODULE Test;
	VAR set, result: SET;
	BEGIN result := set + set;
	END Test.

positive: difference on variable sets

	MODULE Test;
	VAR set, result: SET;
	BEGIN result := set - set
	END Test.

positive: intersection on variable sets

	MODULE Test;
	VAR set, result: SET;
	BEGIN result := set * set
	END Test.

negative: integer division on variable sets

	MODULE Test;
	VAR set: SET; result: SIGNED16;
	BEGIN result := set DIV set
	END Test.

positive: symmetric difference on variable sets

	MODULE Test;
	VAR set, result: SET;
	BEGIN result := set / set
	END Test.

negative: modulo on variable sets

	MODULE Test;
	VAR set: SET; result: SIGNED16;
	BEGIN result := set MOD set
	END Test.

positive: equal relation on variable sets

	MODULE Test;
	VAR set: SET; result: BOOLEAN;
	BEGIN result := set = set
	END Test.

positive: unequal relation on variable sets

	MODULE Test;
	VAR set: SET; result: BOOLEAN;
	BEGIN result := set # set
	END Test.

positive: less relation on variable sets

	MODULE Test;
	VAR set: SET; result: BOOLEAN;
	BEGIN result := set < set
	END Test.

positive: less or equal relation on variable sets

	MODULE Test;
	VAR set: SET; result: BOOLEAN;
	BEGIN result := set <= set
	END Test.

positive: greater relation on variable sets

	MODULE Test;
	VAR set: SET; result: BOOLEAN;
	BEGIN result := set > set
	END Test.

positive: greater or equal relation on variable sets

	MODULE Test;
	VAR set: SET; result: BOOLEAN;
	BEGIN result := set >= set
	END Test.

negative: set membership on variable sets

	MODULE Test;
	VAR set: SET; result: BOOLEAN;
	BEGIN result := set IN set
	END Test.

positive: set membership on integer and variable set

	MODULE Test;
	VAR integer: SIGNED16; set: SET; result: BOOLEAN;
	BEGIN result := integer IN set
	END Test.

negative: type test on variable sets

	MODULE Test;
	VAR set: SET; result: BOOLEAN;
	BEGIN result := set IS set
	END Test.

negative: type test on variable set

	MODULE Test;
	VAR set: SET; result: BOOLEAN;
	BEGIN result := set IS SET
	END Test.

negative: type test on set type

	MODULE Test;
	TYPE Type = SET;
	VAR set: Type; result: BOOLEAN;
	BEGIN result := set IS Type
	END Test.

negative: type guard on variable sets

	MODULE Test;
	VAR set, result: SET;
	BEGIN result := set(set)
	END Test.

negative: type guard on variable set

	MODULE Test;
	VAR set, result: SET;
	BEGIN result := set(SET)
	END Test.

negative: type guard on set type

	MODULE Test;
	TYPE Type = SET;
	VAR set, result: Type;
	BEGIN result := set(Type)
	END Test.

negative: logical and on variable sets

	MODULE Test;
	VAR set: SET; result: BOOLEAN;
	BEGIN result := set & set
	END Test.

negative: logical or on variable sets

	MODULE Test;
	VAR set: SET; result: BOOLEAN;
	BEGIN result := set OR set
	END Test.

negative: ordinal value of variable set

	MODULE Test;
	VAR set: SET; result: SIGNED16;
	BEGIN result := ORD (set)
	END Test.

negative: character value of variable set

	MODULE Test;
	VAR set: SET; result: CHAR;
	BEGIN result := CHR (set)
	END Test.

negative: absolute value of variable set

	MODULE Test;
	VAR set, result: SET;
	BEGIN result := ABS (set)
	END Test.

negative: odd test on variable set

	MODULE Test;
	VAR set: SET; result: BOOLEAN;
	BEGIN result := ODD (set)
	END Test.

negative: capital letter of variable set

	MODULE Test;
	VAR set: SET; result: CHAR;
	BEGIN result := CAP (set)
	END Test.

negative: arithmetic shift of variable sets

	MODULE Test;
	VAR set, result: SET;
	BEGIN result := ASH (set, set)
	END Test.

negative: short on variable set

	MODULE Test;
	VAR set, result: SET;
	BEGIN result := SHORT (set)
	END Test.

negative: long on variable set

	MODULE Test;
	VAR set, result: SET;
	BEGIN result := LONG (set)
	END Test.

negative: entier on variable set

	MODULE Test;
	VAR set, result: SET;
	BEGIN result := ENTIER (set)
	END Test.

negative: unary length of variable set

	MODULE Test;
	VAR set: SET; result: SIZE;
	BEGIN result := LEN (set)
	END Test.

negative: binary length of variable set

	MODULE Test;
	VAR set: SET; result: SIZE;
	BEGIN result := LEN (set, 0)
	END Test.

negative: indexing variable set

	MODULE Test;
	VAR set: SET; result: CHAR;
	BEGIN result := set[0]
	END Test.

negative: variable set as index

	MODULE Test;
	VAR array: ARRAY 10 OF CHAR; result: CHAR; set: SET;
	BEGIN result := array[set]
	END Test.

negative: member selection on variable set

	MODULE Test;
	VAR set, result: SET;
	BEGIN result := set.member
	END Test.

negative: calling variable set

	MODULE Test;
	VAR set: SET;
	BEGIN set
	END Test.


# variable arrays

negative: arithmetic negation on variable array

	MODULE Test;
	VAR array, result: ARRAY 10 OF SET;
	BEGIN result := -array;
	END Test.

negative: logical negation on variable array

	MODULE Test;
	VAR array: ARRAY 10 OF SET; result: BOOLEAN;
	BEGIN result := ~array;
	END Test.

negative: dereferencing variable array

	MODULE Test;
	VAR array, result: ARRAY 10 OF SET;
	BEGIN result := array^;
	END Test.

negative: addition on variable arrays

	MODULE Test;
	VAR array, result: ARRAY 10 OF SET;
	BEGIN result := array + array;
	END Test.

negative: subtraction on variable arrays

	MODULE Test;
	VAR array, result: ARRAY 10 OF SET;
	BEGIN result := array - array
	END Test.

negative: multiplication on variable arrays

	MODULE Test;
	VAR array, result: ARRAY 10 OF SET;
	BEGIN result := array * array
	END Test.

negative: integer division on variable arrays

	MODULE Test;
	VAR array: ARRAY 10 OF SET; result: SIGNED16;
	BEGIN result := array DIV array
	END Test.

negative: real division on variable arrays

	MODULE Test;
	VAR array: ARRAY 10 OF SET; result: FLOAT32;
	BEGIN result := array / array
	END Test.

negative: modulo on variable arrays

	MODULE Test;
	VAR array: ARRAY 10 OF SET; result: SIGNED16;
	BEGIN result := array MOD array
	END Test.

negative: equal relation on variable arrays

	MODULE Test;
	VAR array: ARRAY 10 OF SET; result: BOOLEAN;
	BEGIN result := array = array
	END Test.

positive: equal relation on variable arrays of character

	MODULE Test;
	VAR array: ARRAY 10 OF CHAR; result: BOOLEAN;
	BEGIN result := array = array
	END Test.

positive: equal relation on variable array of character and string

	MODULE Test;
	VAR array: ARRAY 10 OF CHAR; result: BOOLEAN;
	BEGIN result := array = "string"
	END Test.

negative: unequal relation on variable arrays

	MODULE Test;
	VAR array: ARRAY 10 OF SET; result: BOOLEAN;
	BEGIN result := array # array
	END Test.

positive: unequal relation on variable arrays of character

	MODULE Test;
	VAR array: ARRAY 10 OF CHAR; result: BOOLEAN;
	BEGIN result := array # array
	END Test.

positive: unequal relation on variable array of character and string

	MODULE Test;
	VAR array: ARRAY 10 OF CHAR; result: BOOLEAN;
	BEGIN result := array # "string"
	END Test.

negative: less relation on variable arrays

	MODULE Test;
	VAR array: ARRAY 10 OF SET; result: BOOLEAN;
	BEGIN result := array < array
	END Test.

positive: less relation on variable arrays of character

	MODULE Test;
	VAR array: ARRAY 10 OF CHAR; result: BOOLEAN;
	BEGIN result := array < array
	END Test.

positive: less relation on variable array of character and string

	MODULE Test;
	VAR array: ARRAY 10 OF CHAR; result: BOOLEAN;
	BEGIN result := array < "string"
	END Test.

negative: less or equal relation on variable arrays

	MODULE Test;
	VAR array: ARRAY 10 OF SET; result: BOOLEAN;
	BEGIN result := array <= array
	END Test.

positive: less or equal relation on variable arrays of character

	MODULE Test;
	VAR array: ARRAY 10 OF CHAR; result: BOOLEAN;
	BEGIN result := array <= array
	END Test.

positive: less or equal relation on variable array of character and string

	MODULE Test;
	VAR array: ARRAY 10 OF CHAR; result: BOOLEAN;
	BEGIN result := array <= "string"
	END Test.

negative: greater relation on variable arrays

	MODULE Test;
	VAR array: ARRAY 10 OF SET; result: BOOLEAN;
	BEGIN result := array > array
	END Test.

positive: greater relation on variable arrays of character

	MODULE Test;
	VAR array: ARRAY 10 OF CHAR; result: BOOLEAN;
	BEGIN result := array > array
	END Test.

positive: greater relation on variable array of character and string

	MODULE Test;
	VAR array: ARRAY 10 OF CHAR; result: BOOLEAN;
	BEGIN result := array > "string"
	END Test.

negative: greater or equal relation on variable arrays

	MODULE Test;
	VAR array: ARRAY 10 OF SET; result: BOOLEAN;
	BEGIN result := array >= array
	END Test.

positive: greater or equal relation on variable arrays of character

	MODULE Test;
	VAR array: ARRAY 10 OF CHAR; result: BOOLEAN;
	BEGIN result := array >= array
	END Test.

positive: greater or equal relation on variable array of character and string

	MODULE Test;
	VAR array: ARRAY 10 OF CHAR; result: BOOLEAN;
	BEGIN result := array >= "string"
	END Test.

negative: set membership on variable arrays

	MODULE Test;
	VAR array: ARRAY 10 OF SET; result: BOOLEAN;
	BEGIN result := array IN array
	END Test.

negative: type test on variable arrays

	MODULE Test;
	VAR array: ARRAY 10 OF SET; result: BOOLEAN;
	BEGIN result := array IS array
	END Test.

negative: type test on variable array

	MODULE Test;
	VAR array: ARRAY 10 OF SET; result: BOOLEAN;
	BEGIN result := array IS ARRAY 10 OF SET
	END Test.

negative: type test on array type

	MODULE Test;
	TYPE Type = ARRAY 10 OF SET;
	VAR array: Type; result: BOOLEAN;
	BEGIN result := array IS Type
	END Test.

negative: type guard on variable arrays

	MODULE Test;
	VAR array, result: ARRAY 10 OF SET;
	BEGIN result := array(array)
	END Test.

negative: type guard on variable array

	MODULE Test;
	VAR array, result: ARRAY 10 OF SET;
	BEGIN result := array(ARRAY 10 OF SET)
	END Test.

negative: type guard on array type

	MODULE Test;
	TYPE Type = ARRAY 10 OF SET;
	VAR array, result: Type;
	BEGIN result := array(Type)
	END Test.

negative: logical and on variable arrays

	MODULE Test;
	VAR array, result: ARRAY 10 OF SET;
	BEGIN result := array & array
	END Test.

negative: logical or on variable arrays

	MODULE Test;
	VAR array, result: ARRAY 10 OF SET;
	BEGIN result := array OR array
	END Test.

negative: ordinal value of variable array

	MODULE Test;
	VAR array: ARRAY 10 OF SET; result: SIGNED16;
	BEGIN result := ORD (array)
	END Test.

negative: character value of variable array

	MODULE Test;
	VAR array: ARRAY 10 OF SET; result: CHAR;
	BEGIN result := CHR (array)
	END Test.

negative: absolute value of variable array

	MODULE Test;
	VAR array, result: ARRAY 10 OF SET;
	BEGIN result := ABS (array)
	END Test.

negative: odd test on variable array

	MODULE Test;
	VAR array: ARRAY 10 OF SET; result: BOOLEAN;
	BEGIN result := ODD (array)
	END Test.

negative: capital letter of variable array

	MODULE Test;
	VAR array: ARRAY 10 OF SET; result: CHAR;
	BEGIN result := CAP (array)
	END Test.

negative: arithmetic shift of variable arrays

	MODULE Test;
	VAR array, result: ARRAY 10 OF SET;
	BEGIN result := ASH (array, array)
	END Test.

negative: short on variable array

	MODULE Test;
	VAR array, result: ARRAY 10 OF SET;
	BEGIN result := SHORT (array)
	END Test.

negative: long on variable array

	MODULE Test;
	VAR array, result: ARRAY 10 OF SET;
	BEGIN result := LONG (array)
	END Test.

negative: entier on variable array

	MODULE Test;
	VAR array, result: ARRAY 10 OF SET;
	BEGIN result := ENTIER (array)
	END Test.

positive: unary length of variable array

	MODULE Test;
	VAR array: ARRAY 10 OF CHAR; result: SIZE;
	BEGIN result := LEN (array); ASSERT (LEN (array) = 10);
	END Test.

positive: unary length of variable open array

	MODULE Test;
	PROCEDURE Procedure (array: ARRAY OF CHAR);
	VAR result: SIZE;
	BEGIN result := LEN (array)
	END Procedure
	END Test.

positive: unary length of two-dimensional variable array

	MODULE Test;
	CONST Length = LEN (array);
	VAR array: ARRAY 10, 20 OF CHAR; result: SIZE;
	BEGIN result := LEN (array); ASSERT (Length = 10);
	END Test.

positive: unary length of two-dimensional variable open array

	MODULE Test;
	PROCEDURE Procedure (array: ARRAY OF ARRAY OF CHAR);
	VAR result: SIZE;
	BEGIN result := LEN (array);
	END Procedure;
	END Test.

negative: unary length of array as its size

	MODULE Test;
	VAR a: ARRAY LEN (a) OF CHAR;
	END Test.

negative: indirect unary length of array as its size

	MODULE Test;
	CONST Length = LEN (a)
	VAR a: ARRAY Length OF CHAR;
	END Test.

positive: unary length of array as size of another array

	MODULE Test;
	VAR a: ARRAY 10 OF CHAR; b: ARRAY LEN (a) OF CHAR;
	BEGIN a := b;
	END Test.

positive: indirect unary array as size of another array

	MODULE Test;
	CONST Length = LEN (a)
	VAR a: ARRAY 10 OF CHAR; b: ARRAY Length OF CHAR;
	BEGIN a := b;
	END Test.

positive: binary length of variable array

	MODULE Test;
	VAR array: ARRAY 10 OF CHAR; result: SIZE;
	BEGIN result := LEN (array); ASSERT (LEN (array, 0) = 10); ASSERT (LEN (array, 0) = LEN (array));
	END Test.

negative: binary length of variable array with negative dimension index

	MODULE Test;
	VAR array: ARRAY 10 OF CHAR; result: SIZE;
	BEGIN result := LEN (array, -1);
	END Test.

negative: binary length of variable array with invalid dimension index

	MODULE Test;
	VAR array: ARRAY 10 OF CHAR; result: SIZE;
	BEGIN result := LEN (array, 1);
	END Test.

positive: binary length of variable array with variable dimension index

	MODULE Test;
	VAR array: ARRAY 10 OF CHAR; result: SIZE; dimension: SIGNED16;
	BEGIN result := LEN (array, dimension);
	END Test.

negative: binary length of variable array with boolean as dimension index

	MODULE Test;
	VAR array: ARRAY 10 OF CHAR; result: SIZE; dimension: BOOLEAN;
	BEGIN result := LEN (array, dimension);
	END Test.

negative: binary length of variable array with character as dimension index

	MODULE Test;
	VAR array: ARRAY 10 OF CHAR; result: SIZE; dimension: CHAR;
	BEGIN result := LEN (array, dimension);
	END Test.

positive: binary length of variable array with integer as dimension index

	MODULE Test;
	VAR array: ARRAY 10 OF CHAR; result: SIZE; dimension: SIGNED16;
	BEGIN result := LEN (array, dimension);
	END Test.

negative: binary length of variable array with real as dimension index

	MODULE Test;
	VAR array: ARRAY 10 OF CHAR; result: SIZE; dimension: FLOAT32;
	BEGIN result := LEN (array, dimension);
	END Test.

negative: binary length of variable array with set as dimension index

	MODULE Test;
	VAR array: ARRAY 10 OF CHAR; result: SIZE; dimension: SET;
	BEGIN result := LEN (array, dimension);
	END Test.

negative: binary length of variable array with constant string as dimension index

	MODULE Test;
	VAR array: ARRAY 10 OF CHAR; result: SIZE;
	BEGIN result := LEN (array, "index");
	END Test.

negative: binary length of variable array with nil pointer as dimension index

	MODULE Test;
	VAR array: ARRAY 10 OF CHAR; result: SIZE;
	BEGIN result := LEN (array, NIL);
	END Test.

positive: binary length of two-dimensional variable array

	MODULE Test;
	CONST Length0 = LEN (array, 0); Length1 = LEN (array, 1)
	VAR array: ARRAY 10, 20 OF CHAR; result: SIZE;
	BEGIN result := LEN (array, 0); ASSERT (Length0 = 10); ASSERT (Length1 = 20);
	END Test.

positive: binary length of two-dimensional variable open array

	MODULE Test;
	PROCEDURE Procedure (array: ARRAY OF ARRAY OF CHAR);
	VAR result: SIZE;
	BEGIN result := LEN (array, 0); result := LEN (array, 1);
	END Procedure;
	END Test.

negative: binary length of array as its size

	MODULE Test;
	VAR array: ARRAY LEN (array, 0), LEN (array, 1) OF CHAR;
	END Test.

negative: indirect binary length of array as its size

	MODULE Test;
	CONST Length0 = LEN (array, 0); Length1 = LEN (array, 1)
	VAR array: ARRAY Length0, Length1 OF CHAR;
	END Test.

positive: binary length of array as size of another array

	MODULE Test;
	VAR a: ARRAY 10, 20 OF CHAR; b: ARRAY LEN (a, 0), LEN (a, 1) OF CHAR;
	BEGIN a := b;
	END Test.

positive: indirect binary array as size of another array

	MODULE Test;
	CONST Length0 = LEN (a, 0); Length1 = LEN (a, 1)
	VAR a: ARRAY 10, 20 OF CHAR; b: ARRAY Length0, Length1 OF CHAR;
	BEGIN a := b;
	END Test.

positive: array length constants

	MODULE Test;

	CONST
		ls1=LEN(s1,0);
		ls20=LEN(s2,0);
		ls21=LEN(s2,1);
		lp1=LEN(p1);
		lp20=LEN(p2,0);
		lp21=LEN(p2,1);
		lp31=LEN(p3,1);
		lp32=LEN(p3,2);

	VAR
		s1: ARRAY 2 OF CHAR;
		s2:  ARRAY 2 OF ARRAY 12 OF CHAR;
		p1: POINTER TO ARRAY 2 OF CHAR;
		p2: POINTER TO ARRAY 2 OF ARRAY 12 OF CHAR;
		p3: POINTER TO ARRAY OF ARRAY 2 OF ARRAY 12 OF CHAR;

	BEGIN
		ASSERT(ls1=2);
		ASSERT(ls20=2);
		ASSERT(ls21=12);
		ASSERT(lp1=2);
		ASSERT(lp20=2);
		ASSERT(lp21=12);
		ASSERT(lp31=2);
		ASSERT(lp32=12);
	END Test.

positive: binary length of variable open array

	MODULE Test;
	PROCEDURE Procedure (array: ARRAY OF CHAR);
	VAR result: SIZE;
	BEGIN result := LEN (array, 0);
	END Procedure;
	END Test.

positive: indexing variable boolean array

	MODULE Test;
	VAR array: ARRAY 10 OF BOOLEAN; result: BOOLEAN;
	BEGIN result := array[0]
	END Test.

positive: indexing temporary boolean array

	MODULE Test;
	VAR array: PROCEDURE (): ARRAY 10 OF BOOLEAN; result: BOOLEAN;
	BEGIN result := array()[0]
	END Test.

negative: changing indexed temporary boolean array

	MODULE Test;
	VAR array: PROCEDURE (): ARRAY 10 OF BOOLEAN;
	BEGIN array()[0] := TRUE;
	END Test.

positive: indexing variable character array

	MODULE Test;
	VAR array: ARRAY 10 OF CHAR; result: CHAR;
	BEGIN result := array[0]
	END Test.

positive: indexing temporary character array

	MODULE Test;
	VAR array: PROCEDURE (): ARRAY 10 OF CHAR; result: CHAR;
	BEGIN result := array()[0]
	END Test.

negative: changing indexed temporary character array

	MODULE Test;
	VAR array: PROCEDURE (): ARRAY 10 OF CHAR;
	BEGIN array()[0] := '0';
	END Test.

positive: indexing variable integer array

	MODULE Test;
	VAR array: ARRAY 10 OF SIGNED16; result: SIGNED16;
	BEGIN result := array[0]
	END Test.

positive: indexing temporary integer array

	MODULE Test;
	VAR array: PROCEDURE (): ARRAY 10 OF SIGNED16; result: SIGNED16;
	BEGIN result := array()[0]
	END Test.

negative: changing indexed temporary integer array

	MODULE Test;
	VAR array: PROCEDURE (): ARRAY 10 OF SIGNED16;
	BEGIN array()[0] := 5;
	END Test.

positive: indexing variable real array

	MODULE Test;
	VAR array: ARRAY 10 OF FLOAT32; result: FLOAT32;
	BEGIN result := array[0]
	END Test.

positive: indexing temporary real array

	MODULE Test;
	VAR array: PROCEDURE (): ARRAY 10 OF FLOAT32; result: FLOAT32;
	BEGIN result := array()[0]
	END Test.

negative: changing indexed temporary real array

	MODULE Test;
	VAR array: PROCEDURE (): ARRAY 10 OF FLOAT32;
	BEGIN array()[0] := 5.0;
	END Test.

positive: indexing variable set array

	MODULE Test;
	VAR array: ARRAY 10 OF SET; result: SET;
	BEGIN result := array[0]
	END Test.

positive: indexing temporary set array

	MODULE Test;
	VAR array: PROCEDURE (): ARRAY 10 OF SET; result: SET;
	BEGIN result := array()[0]
	END Test.

negative: changing indexed temporary set array

	MODULE Test;
	VAR array: PROCEDURE (): ARRAY 10 OF SET;
	BEGIN array()[0] := {5};
	END Test.

positive: indexing variable array of array

	MODULE Test;
	VAR array: ARRAY 10 OF ARRAY 10 OF CHAR; result: ARRAY 10 OF CHAR;
	BEGIN result := array[0]
	END Test.

positive: indexing temporary array of array

	MODULE Test;
	VAR array: PROCEDURE (): ARRAY 10 OF ARRAY 10 OF CHAR; result: ARRAY 10 OF CHAR;
	BEGIN result := array()[0]
	END Test.

negative: changing indexed temporary array of array

	MODULE Test;
	VAR array: PROCEDURE (): ARRAY 10 OF ARRAY 10 OF CHAR; value: ARRAY 10 OF CHAR;
	BEGIN array()[0] := value;
	END Test.

positive: indexing variable record array

	MODULE Test;
	TYPE Record = RECORD END;
	VAR array: ARRAY 10 OF Record; result: Record;
	BEGIN result := array[0]
	END Test.

positive: indexing temporary record array

	MODULE Test;
	TYPE Record = RECORD END;
	VAR array: PROCEDURE (): ARRAY 10 OF Record; result: Record;
	BEGIN result := array()[0]
	END Test.

negative: changing indexed temporary record array

	MODULE Test;
	TYPE Record = RECORD END;
	VAR array: PROCEDURE (): ARRAY 10 OF Record; value: Record;
	BEGIN array()[0] := value;
	END Test.

negative: changing member of indexed temporary record array

	MODULE Test;
	TYPE Record = RECORD i: SIGNED16 END;
	VAR array: PROCEDURE (): ARRAY 10 OF Record;
	BEGIN array()[0].i := 5;
	END Test.

positive: indexing variable object array

	MODULE Test;
	TYPE Object = OBJECT END Object;
	VAR array: ARRAY 10 OF Object; result: Object;
	BEGIN result := array[0]
	END Test.

positive: indexing temporary object array

	MODULE Test;
	TYPE Object = OBJECT END Object;
	VAR array: PROCEDURE (): ARRAY 10 OF Object; result: Object;
	BEGIN result := array()[0]
	END Test.

negative: changing indexed temporary object array

	MODULE Test;
	TYPE Object = OBJECT END Object;
	VAR array: PROCEDURE (): ARRAY 10 OF Object; value: Object;
	BEGIN array()[0] := value;
	END Test.

positive: changing member of indexed temporary object array

	MODULE Test;
	TYPE Object = OBJECT VAR i: SIGNED16 END Object;
	VAR array: PROCEDURE (): ARRAY 10 OF Object;
	BEGIN array()[0].i := 5;
	END Test.

positive: indexing variable base object array

	MODULE Test;
	VAR array: ARRAY 10 OF OBJECT; result: OBJECT;
	BEGIN result := array[0]
	END Test.

positive: indexing temporary base object array

	MODULE Test;
	VAR array: PROCEDURE (): ARRAY 10 OF OBJECT; result: OBJECT;
	BEGIN result := array()[0]
	END Test.

negative: changing indexed temporary base object array

	MODULE Test;
	VAR array: PROCEDURE (): ARRAY 10 OF OBJECT; value: OBJECT;
	BEGIN array()[0] := value;
	END Test.

positive: indexing variable pointer to array array

	MODULE Test;
	VAR array: ARRAY 10 OF POINTER TO ARRAY 10 OF CHAR; result: POINTER TO ARRAY 10 OF CHAR;
	BEGIN result := array[0]
	END Test.

positive: indexing temporary pointer to array array

	MODULE Test;
	VAR array: PROCEDURE (): ARRAY 10 OF POINTER TO ARRAY 10 OF CHAR; result: POINTER TO ARRAY 10 OF CHAR;
	BEGIN result := array()[0]
	END Test.

negative: changing indexed temporary pointer to array array

	MODULE Test;
	VAR array: PROCEDURE (): ARRAY 10 OF POINTER TO ARRAY 10 OF CHAR; value: POINTER TO ARRAY 10 OF CHAR;
	BEGIN array()[0] := value;
	END Test.

positive: changing element of indexed temporary pointer to array array

	MODULE Test;
	VAR array: PROCEDURE (): ARRAY 10 OF POINTER TO ARRAY 10 OF CHAR;
	BEGIN array()[0][0] := 'f';
	END Test.

positive: indexing variable array of pointer to record

	MODULE Test;
	TYPE Record = RECORD END;
	VAR array: ARRAY 10 OF POINTER TO Record; result: POINTER TO Record;
	BEGIN result := array[0]
	END Test.

positive: indexing temporary array of pointer to record

	MODULE Test;
	TYPE Record = RECORD END;
	VAR array: PROCEDURE (): ARRAY 10 OF POINTER TO Record; result: POINTER TO Record;
	BEGIN result := array()[0]
	END Test.

negative: changing indexed temporary array of pointer to record

	MODULE Test;
	TYPE Record = RECORD END;
	VAR array: PROCEDURE (): ARRAY 10 OF POINTER TO Record; value: POINTER TO Record;
	BEGIN array()[0] := value;
	END Test.

positive: changing element of indexed temporary array of pointer to record

	MODULE Test;
	VAR array: PROCEDURE (): ARRAY 10 OF POINTER TO RECORD i: SIGNED16 END;
	BEGIN array()[0].i := 5;
	END Test.

positive: indexing variable procedure array

	MODULE Test;
	VAR array: ARRAY 10 OF PROCEDURE; result: PROCEDURE;
	BEGIN result := array[0]
	END Test.

positive: indexing temporary procedure array

	MODULE Test;
	VAR array: PROCEDURE (): ARRAY 10 OF PROCEDURE; result: PROCEDURE;
	BEGIN result := array()[0]
	END Test.

negative: changing indexed temporary procedure array

	MODULE Test;
	VAR array: PROCEDURE (): ARRAY 10 OF PROCEDURE; value: PROCEDURE;
	BEGIN array()[0] := value;
	END Test.

negative: variable array as index

	MODULE Test;
	VAR array: ARRAY 10 OF CHAR; result: CHAR;
	BEGIN result := array[array]
	END Test.

negative: member selection on variable array

	MODULE Test;
	VAR array, result: ARRAY 10 OF CHAR;
	BEGIN result := array.member
	END Test.

negative: calling variable array

	MODULE Test;
	VAR array: ARRAY 10 OF CHAR;
	BEGIN array
	END Test.


# variable records

negative: arithmetic negation on variable record

	MODULE Test;
	VAR record, result: RECORD END;
	BEGIN result := -record;
	END Test.

negative: logical negation on variable record

	MODULE Test;
	VAR record, result: RECORD END;
	BEGIN result := ~record;
	END Test.

negative: dereferencing variable record

	MODULE Test;
	VAR record, result: RECORD END;
	BEGIN result := record^;
	END Test.

negative: addition on variable records

	MODULE Test;
	VAR record, result: RECORD END;
	BEGIN result := record + record;
	END Test.

negative: subtraction on variable records

	MODULE Test;
	VAR record, result: RECORD END;
	BEGIN result := record - record
	END Test.

negative: multiplication on variable records

	MODULE Test;
	VAR record, result: RECORD END;
	BEGIN result := record * record
	END Test.

negative: integer division on variable records

	MODULE Test;
	VAR record: RECORD END; result: SIGNED16;
	BEGIN result := record DIV record
	END Test.

negative: real division on variable records

	MODULE Test;
	VAR record: RECORD END; result: FLOAT32;
	BEGIN result := record / record
	END Test.

negative: modulo on variable records

	MODULE Test;
	VAR record: RECORD END; result: SIGNED16;
	BEGIN result := record MOD record
	END Test.

negative: equal relation on variable records

	MODULE Test;
	VAR record: RECORD END; result: BOOLEAN;
	BEGIN result := record = record
	END Test.

negative: unequal relation on variable records

	MODULE Test;
	VAR record: RECORD END; result: BOOLEAN;
	BEGIN result := record # record
	END Test.

negative: less relation on variable records

	MODULE Test;
	VAR record: RECORD END; result: BOOLEAN;
	BEGIN result := record < record
	END Test.

negative: less or equal relation on variable records

	MODULE Test;
	VAR record: RECORD END; result: BOOLEAN;
	BEGIN result := record <= record
	END Test.

negative: greater relation on variable records

	MODULE Test;
	VAR record: RECORD END; result: BOOLEAN;
	BEGIN result := record > record
	END Test.

negative: greater or equal relation on variable records

	MODULE Test;
	VAR record: RECORD END; result: BOOLEAN;
	BEGIN result := record >= record
	END Test.

negative: set membership on variable records

	MODULE Test;
	VAR record: RECORD END; result: BOOLEAN;
	BEGIN result := record IN record
	END Test.

negative: type test on variable records

	MODULE Test;
	VAR record: RECORD END; result: BOOLEAN;
	BEGIN result := record IS record
	END Test.

negative: type test on variable record

	MODULE Test;
	VAR record: RECORD END; result: BOOLEAN;
	BEGIN result := record IS RECORD END
	END Test.

positive: type test on same record type

	MODULE Test;
	TYPE Type = RECORD END;
	VAR record: Type; result: BOOLEAN;
	BEGIN result := record IS Type
	END Test.

positive: type test on extending record type

	MODULE Test;
	TYPE Record = RECORD END; Type = RECORD (Record) END;
	VAR record: Record; result: BOOLEAN;
	BEGIN result := record IS Type
	END Test.

negative: type test on extended record type

	MODULE Test;
	TYPE Record = RECORD END; Type = Record;
	VAR record: RECORD (Record) END; result: BOOLEAN;
	BEGIN result := record IS Type
	END Test.

negative: type test on incompatible record type

	MODULE Test;
	TYPE Type = RECORD END;
	VAR record: RECORD END; result: BOOLEAN;
	BEGIN result := record IS Type
	END Test.

negative: type guard on variable records

	MODULE Test;
	PROCEDURE Procedure (VAR record, result: RECORD END);
	BEGIN result := record(record)
	END Procedure;
	END Test.

negative: type guard on variable record

	MODULE Test;
	PROCEDURE Procedure (VAR record, result: RECORD END);
	BEGIN result := record(RECORD END)
	END Procedure;
	END Test.

positive: type guard on same record type

	MODULE Test;
	TYPE Type = RECORD END;
	PROCEDURE Procedure (VAR record, result: Type);
	BEGIN result := record(Type)
	END Procedure;
	END Test.

positive: type guard on extending record type

	MODULE Test;
	TYPE Record = RECORD END; Type = RECORD (Record) END;
	PROCEDURE Procedure (VAR record: Record; result: Type);
	BEGIN result := record(Type)
	END Procedure;
	END Test.

negative: type guard on static extending record type

	MODULE Test;
	TYPE Record = RECORD END; Type = RECORD (Record) END;
	VAR record: Record; result: Type;
	BEGIN result := record(Type)
	END Test.

negative: type guard on extended record type

	MODULE Test;
	TYPE Record = RECORD END; Type = Record;
	PROCEDURE Procedure (VAR record: RECORD (Record) END; result: Type);
	BEGIN result := record(Type)
	END Procedure;
	END Test.

negative: type guard on incompatible record type

	MODULE Test;
	TYPE Type = RECORD END;
	PROCEDURE Procedure (VAR record: RECORD END; result: Type);
	BEGIN result := record(Type)
	END Procedure;
	END Test.

negative: logical and on variable records

	MODULE Test;
	VAR record, result: RECORD END;
	BEGIN result := record & record
	END Test.

negative: logical or on variable records

	MODULE Test;
	VAR record, result: RECORD END;
	BEGIN result := record OR record
	END Test.

negative: ordinal value of variable record

	MODULE Test;
	VAR record: RECORD END; result: SIGNED16;
	BEGIN result := ORD (record)
	END Test.

negative: character value of variable record

	MODULE Test;
	VAR record: RECORD END; result: CHAR;
	BEGIN result := CHR (record)
	END Test.

negative: absolute value of variable record

	MODULE Test;
	VAR record, result: RECORD END;
	BEGIN result := ABS (record)
	END Test.

negative: odd test on variable record

	MODULE Test;
	VAR record: RECORD END; result: BOOLEAN;
	BEGIN result := ODD (record)
	END Test.

negative: capital letter of variable record

	MODULE Test;
	VAR record: RECORD END; result: CHAR;
	BEGIN result := CAP (record)
	END Test.

negative: arithmetic shift of variable records

	MODULE Test;
	VAR record, result: RECORD END;
	BEGIN result := ASH (record, record)
	END Test.

negative: short on variable record

	MODULE Test;
	VAR record, result: RECORD END;
	BEGIN result := SHORT (record)
	END Test.

negative: long on variable record

	MODULE Test;
	VAR record, result: RECORD END;
	BEGIN result := LONG (record)
	END Test.

negative: entier on variable record

	MODULE Test;
	VAR record, result: RECORD END;
	BEGIN result := ENTIER (record)
	END Test.

negative: unary length of variable record

	MODULE Test;
	VAR record: RECORD END; result: SIZE;
	BEGIN result := LEN (record)
	END Test.

negative: binary length of variable record

	MODULE Test;
	VAR record: RECORD END; result: SIZE;
	BEGIN result := LEN (record, 0)
	END Test.

negative: indexing variable record

	MODULE Test;
	VAR record: RECORD END; result: CHAR;
	BEGIN result := record[0]
	END Test.

negative: variable record as index

	MODULE Test;
	VAR array: ARRAY 10 OF CHAR; result: CHAR; record: RECORD END;
	BEGIN result := array[record]
	END Test.

positive: member selection on variable record

	MODULE Test;
	VAR record: RECORD member: SET END; result: SET;
	BEGIN result := record.member
	END Test.

positive: member modification on variable record

	MODULE Test;
	VAR record: RECORD member: SET END; value: SET;
	BEGIN record.member := value
	END Test.

positive: member selection on temporary record

	MODULE Test;
	VAR record: PROCEDURE (): RECORD member: SET END; result: SET;
	BEGIN result := record ().member
	END Test.

negative: member modification on temporary record

	MODULE Test;
	VAR record: PROCEDURE (): RECORD member: SET END; value: SET;
	BEGIN record ().member := value
	END Test.

negative: calling variable record

	MODULE Test;
	VAR record: RECORD END;
	BEGIN record
	END Test.


# variable objects

negative: arithmetic negation on variable object

	MODULE Test;
	VAR object, result: OBJECT END;
	BEGIN result := -object;
	END Test.

negative: logical negation on variable object

	MODULE Test;
	VAR object, result: OBJECT END;
	BEGIN result := ~object;
	END Test.

negative: dereferencing variable object

	MODULE Test;
	VAR object, result: OBJECT END;
	BEGIN result := object^;
	END Test.

negative: addition on variable objects

	MODULE Test;
	VAR object, result: OBJECT END;
	BEGIN result := object + object;
	END Test.

negative: subtraction on variable objects

	MODULE Test;
	VAR object, result: OBJECT END;
	BEGIN result := object - object
	END Test.

negative: multiplication on variable objects

	MODULE Test;
	VAR object, result: OBJECT END;
	BEGIN result := object * object
	END Test.

negative: integer division on variable objects

	MODULE Test;
	VAR object: OBJECT END; result: SIGNED16;
	BEGIN result := object DIV object
	END Test.

negative: real division on variable objects

	MODULE Test;
	VAR object: OBJECT END; result: FLOAT32;
	BEGIN result := object / object
	END Test.

negative: modulo on variable objects

	MODULE Test;
	VAR object: OBJECT END; result: SIGNED16;
	BEGIN result := object MOD object
	END Test.

positive: equal relation on variable objects

	MODULE Test;
	VAR object: OBJECT END; result: BOOLEAN;
	BEGIN result := object = object
	END Test.

positive: equal relation on compatible variable objects

	MODULE Test;
	TYPE Object = OBJECT END Object;
	VAR object1: Object; object2: OBJECT (Object) END; result: BOOLEAN;
	BEGIN result := (object1 = object1) OR (object2 = object1)
	END Test.

negative: equal relation on incompatible variable objects

	MODULE Test;
	VAR object1: OBJECT END; object2: OBJECT END; result: BOOLEAN;
	BEGIN result := (object1 = object1) OR (object2 = object1)
	END Test.

positive: unequal relation on variable objects

	MODULE Test;
	VAR object: OBJECT END; result: BOOLEAN;
	BEGIN result := object # object
	END Test.

positive: unequal relation on compatible variable objects

	MODULE Test;
	TYPE Object = OBJECT END Object;
	VAR object1: Object; object2: OBJECT (Object) END; result: BOOLEAN;
	BEGIN result := (object1 # object1) OR (object2 # object1)
	END Test.

negative: unequal relation on incompatible variable objects

	MODULE Test;
	VAR object1: OBJECT END; object2: OBJECT END; result: BOOLEAN;
	BEGIN result := (object1 # object1) OR (object2 # object1)
	END Test.

negative: less relation on variable objects

	MODULE Test;
	VAR object: OBJECT END; result: BOOLEAN;
	BEGIN result := object < object
	END Test.

negative: less or equal relation on variable objects

	MODULE Test;
	VAR object: OBJECT END; result: BOOLEAN;
	BEGIN result := object <= object
	END Test.

negative: greater relation on variable objects

	MODULE Test;
	VAR object: OBJECT END; result: BOOLEAN;
	BEGIN result := object > object
	END Test.

negative: greater or equal relation on variable objects

	MODULE Test;
	VAR object: OBJECT END; result: BOOLEAN;
	BEGIN result := object >= object
	END Test.

negative: set membership on variable objects

	MODULE Test;
	VAR object: OBJECT END; result: BOOLEAN;
	BEGIN result := object IN object
	END Test.

negative: type test on variable objects

	MODULE Test;
	VAR object: OBJECT END; result: BOOLEAN;
	BEGIN result := object IS object
	END Test.

negative: type test on variable object

	MODULE Test;
	VAR object: OBJECT END; result: BOOLEAN;
	BEGIN result := object IS OBJECT;
	END Test.

positive: type test on same object type

	MODULE Test;
	TYPE Type = OBJECT END Type;
	VAR object: Type; result: BOOLEAN;
	BEGIN result := object IS Type
	END Test.

positive: type test on extending object type

	MODULE Test;
	TYPE Object = OBJECT END Object; Type = OBJECT (Object) END Type;
	VAR object: Object; result: BOOLEAN;
	BEGIN result := object IS Type
	END Test.

negative: type test on extended object type

	MODULE Test;
	TYPE Object = OBJECT END Object; Type = Object;
	VAR object: OBJECT (Object) END; result: BOOLEAN;
	BEGIN result := object IS Type
	END Test.

negative: type test on incompatible object type

	MODULE Test;
	TYPE Type = OBJECT END Type;
	VAR object: OBJECT END; result: BOOLEAN;
	BEGIN result := object IS Type
	END Test.

positive: type test on self and same object type

	MODULE Test;
	TYPE Object = OBJECT
		VAR result: BOOLEAN;
		BEGIN result := SELF IS Type
	END Object;
	TYPE Type = Object;
	END Test.

positive: type test on self and extending object type

	MODULE Test;
	TYPE Object = OBJECT
		VAR result: BOOLEAN;
		BEGIN result := SELF IS Type
	END Object;
	TYPE Type = OBJECT (Object) END Type;
	END Test.

negative: type test on self and extended object type

	MODULE Test;
	TYPE Object = OBJECT (Type)
		VAR result: BOOLEAN;
		BEGIN result := SELF IS Type
	END Object;
	TYPE Type = OBJECT END Type;
	END Test.

negative: type guard on variable objects

	MODULE Test;
	VAR object, result: OBJECT END;
	BEGIN result := object(object)
	END Test.

negative: type guard on variable object

	MODULE Test;
	TYPE Type = OBJECT;
	VAR object, result: OBJECT END;
	BEGIN result := object(Type)
	END Test.

positive: type guard on same object type

	MODULE Test;
	TYPE Type = OBJECT END Type;
	VAR object, result: Type;
	BEGIN result := object(Type)
	END Test.

positive: type guard on extending object type

	MODULE Test;
	TYPE Object = OBJECT END Object; Type = OBJECT (Object) END Type;
	VAR object: Object; result: Type;
	BEGIN result := object(Type)
	END Test.

negative: type guard on extended object type

	MODULE Test;
	TYPE Object = OBJECT END Object; Type = Object;
	VAR object: OBJECT (Object) END; result: Type;
	BEGIN result := object(Type)
	END Test.

negative: type guard on incompatible object type

	MODULE Test;
	TYPE Type = OBJECT END Type;
	VAR object: OBJECT END; result: Type;
	BEGIN result := object(Type)
	END Test.

positive: type guard on self and same object type

	MODULE Test;
	TYPE Object = OBJECT
		VAR result: Type;
		BEGIN result := SELF(Type)
	END Object;
	TYPE Type = Object;
	END Test.

positive: type guard on self and extending object type

	MODULE Test;
	TYPE Object = OBJECT
		VAR result: Type;
		BEGIN result := SELF(Type)
	END Object;
	TYPE Type = OBJECT (Object) END Type;
	END Test.

negative: type guard on self and extended object type

	MODULE Test;
	TYPE Object = OBJECT (Type)
		VAR result: Type;
		BEGIN result := SELF(Type)
	END Object;
	TYPE Type = OBJECT END Type;
	END Test.

negative: logical and on variable objects

	MODULE Test;
	VAR object, result: OBJECT END;
	BEGIN result := object & object
	END Test.

negative: logical or on variable objects

	MODULE Test;
	VAR object, result: OBJECT END;
	BEGIN result := object OR object
	END Test.

negative: ordinal value of variable object

	MODULE Test;
	VAR object: OBJECT END; result: SIGNED16;
	BEGIN result := ORD (object)
	END Test.

negative: character value of variable object

	MODULE Test;
	VAR object: OBJECT END; result: CHAR;
	BEGIN result := CHR (object)
	END Test.

negative: absolute value of variable object

	MODULE Test;
	VAR object, result: OBJECT END;
	BEGIN result := ABS (object)
	END Test.

negative: odd test on variable object

	MODULE Test;
	VAR object: OBJECT END; result: BOOLEAN;
	BEGIN result := ODD (object)
	END Test.

negative: capital letter of variable object

	MODULE Test;
	VAR object: OBJECT END; result: CHAR;
	BEGIN result := CAP (object)
	END Test.

negative: arithmetic shift of variable objects

	MODULE Test;
	VAR object, result: OBJECT END;
	BEGIN result := ASH (object, object)
	END Test.

negative: short on variable object

	MODULE Test;
	VAR object, result: OBJECT END;
	BEGIN result := SHORT (object)
	END Test.

negative: long on variable object

	MODULE Test;
	VAR object, result: OBJECT END;
	BEGIN result := LONG (object)
	END Test.

negative: entier on variable object

	MODULE Test;
	VAR object, result: OBJECT END;
	BEGIN result := ENTIER (object)
	END Test.

negative: unary length of variable object

	MODULE Test;
	VAR object: OBJECT END; result: SIZE;
	BEGIN result := LEN (object)
	END Test.

negative: binary length of variable object

	MODULE Test;
	VAR object: OBJECT END; result: SIZE;
	BEGIN result := LEN (object, 0)
	END Test.

negative: indexing variable object

	MODULE Test;
	VAR object: OBJECT END; result: CHAR;
	BEGIN result := object[0]
	END Test.

negative: variable object as index

	MODULE Test;
	VAR array: ARRAY 10 OF CHAR; result: CHAR; object: OBJECT END;
	BEGIN result := array[object]
	END Test.

positive: member selection on variable object

	MODULE Test;
	VAR object: OBJECT VAR member: SET END; result: SET;
	BEGIN result := object.member
	END Test.

positive: member modification on variable object

	MODULE Test;
	VAR object: OBJECT VAR member: SET END; value: SET;
	BEGIN object.member := value
	END Test.

positive: member selection on temporary object

	MODULE Test;
	VAR object: PROCEDURE (): OBJECT VAR member: SET END; result: SET;
	BEGIN result := object ().member
	END Test.

positive: member modification on temporary object

	MODULE Test;
	VAR record: PROCEDURE (): OBJECT VAR member: SET END; value: SET;
	BEGIN record ().member := value
	END Test.

negative: calling variable object

	MODULE Test;
	VAR object: OBJECT END;
	BEGIN object
	END Test.


# variable base objects

negative: arithmetic negation on variable base object

	MODULE Test;
	VAR object, result: OBJECT;
	BEGIN result := -object;
	END Test.

negative: logical negation on variable base object

	MODULE Test;
	VAR object, result: OBJECT;
	BEGIN result := ~object;
	END Test.

negative: dereferencing variable base object

	MODULE Test;
	VAR object, result: OBJECT;
	BEGIN result := object^;
	END Test.

negative: addition on variable base objects

	MODULE Test;
	VAR object, result: OBJECT;
	BEGIN result := object + object;
	END Test.

negative: subtraction on variable base objects

	MODULE Test;
	VAR object, result: OBJECT;
	BEGIN result := object - object
	END Test.

negative: multiplication on variable base objects

	MODULE Test;
	VAR object, result: OBJECT;
	BEGIN result := object * object
	END Test.

negative: integer division on variable base objects

	MODULE Test;
	VAR object: OBJECT; result: SIGNED16;
	BEGIN result := object DIV object
	END Test.

negative: real division on variable base objects

	MODULE Test;
	VAR object: OBJECT; result: FLOAT32;
	BEGIN result := object / object
	END Test.

negative: modulo on variable base objects

	MODULE Test;
	VAR object: OBJECT; result: SIGNED16;
	BEGIN result := object MOD object
	END Test.

positive: equal relation on variable base objects

	MODULE Test;
	VAR object: OBJECT; result: BOOLEAN;
	BEGIN result := object = object
	END Test.

positive: equal relation on compatible variable base objects

	MODULE Test;
	VAR object1: OBJECT; object2: OBJECT END; result: BOOLEAN;
	BEGIN result := (object1 = object1) OR (object2 = object1)
	END Test.

positive: unequal relation on variable base objects

	MODULE Test;
	VAR object: OBJECT; result: BOOLEAN;
	BEGIN result := object # object
	END Test.

positive: unequal relation on compatible variable base objects

	MODULE Test;
	VAR object1: OBJECT; object2: OBJECT END; result: BOOLEAN;
	BEGIN result := (object1 # object1) OR (object2 # object1)
	END Test.

negative: less relation on variable base objects

	MODULE Test;
	VAR object: OBJECT; result: BOOLEAN;
	BEGIN result := object < object
	END Test.

negative: less or equal relation on variable base objects

	MODULE Test;
	VAR object: OBJECT; result: BOOLEAN;
	BEGIN result := object <= object
	END Test.

negative: greater relation on variable base objects

	MODULE Test;
	VAR object: OBJECT; result: BOOLEAN;
	BEGIN result := object > object
	END Test.

negative: greater or equal relation on variable base objects

	MODULE Test;
	VAR object: OBJECT; result: BOOLEAN;
	BEGIN result := object >= object
	END Test.

negative: set membership on variable base objects

	MODULE Test;
	VAR object: OBJECT; result: BOOLEAN;
	BEGIN result := object IN object
	END Test.

negative: type test on variable base objects

	MODULE Test;
	VAR object: OBJECT; result: BOOLEAN;
	BEGIN result := object IS object
	END Test.

negative: type test on variable base object

	MODULE Test;
	VAR object: OBJECT; result: BOOLEAN;
	BEGIN result := object IS OBJECT;
	END Test.

positive: type test on base object type

	MODULE Test;
	TYPE Type = OBJECT;
	VAR object: Type; result: BOOLEAN;
	BEGIN result := object IS Type
	END Test.

positive: type test on extending base object type

	MODULE Test;
	TYPE Type = OBJECT END Type;
	VAR object: OBJECT; result: BOOLEAN;
	BEGIN result := object IS Type
	END Test.

negative: type test on extended base object type

	MODULE Test;
	TYPE Type = OBJECT;
	VAR object: OBJECT END; result: BOOLEAN;
	BEGIN result := object IS Type
	END Test.

negative: type guard on variable base objects

	MODULE Test;
	VAR object, result: OBJECT;
	BEGIN result := object(object)
	END Test.

negative: type guard on variable base object

	MODULE Test;
	VAR object, result: OBJECT;
	BEGIN result := object(OBJECT);
	END Test.

positive: type guard on base object type

	MODULE Test;
	TYPE Type = OBJECT;
	VAR object, result: Type;
	BEGIN result := object(Type)
	END Test.

positive: type guard on extending base object type

	MODULE Test;
	TYPE Type = OBJECT END Type;
	VAR object: OBJECT; result: Type;
	BEGIN result := object(Type)
	END Test.

negative: type guard on extended base object type

	MODULE Test;
	TYPE Type = OBJECT;
	VAR object: OBJECT END; result: Type;
	BEGIN result := object(Type)
	END Test.

negative: logical and on variable base objects

	MODULE Test;
	VAR object, result: OBJECT;
	BEGIN result := object & object
	END Test.

negative: logical or on variable base objects

	MODULE Test;
	VAR object, result: OBJECT;
	BEGIN result := object OR object
	END Test.

negative: ordinal value of variable base object

	MODULE Test;
	VAR object: OBJECT; result: SIGNED16;
	BEGIN result := ORD (object)
	END Test.

negative: character value of variable base object

	MODULE Test;
	VAR object: OBJECT; result: CHAR;
	BEGIN result := CHR (object)
	END Test.

negative: absolute value of variable base object

	MODULE Test;
	VAR object, result: OBJECT;
	BEGIN result := ABS (object)
	END Test.

negative: odd test on variable base object

	MODULE Test;
	VAR object: OBJECT; result: BOOLEAN;
	BEGIN result := ODD (object)
	END Test.

negative: capital letter of variable base object

	MODULE Test;
	VAR object: OBJECT; result: CHAR;
	BEGIN result := CAP (object)
	END Test.

negative: arithmetic shift of variable base objects

	MODULE Test;
	VAR object, result: OBJECT;
	BEGIN result := ASH (object, object)
	END Test.

negative: short on variable base object

	MODULE Test;
	VAR object, result: OBJECT;
	BEGIN result := SHORT (object)
	END Test.

negative: long on variable base object

	MODULE Test;
	VAR object, result: OBJECT;
	BEGIN result := LONG (object)
	END Test.

negative: entier on variable base object

	MODULE Test;
	VAR object, result: OBJECT;
	BEGIN result := ENTIER (object)
	END Test.

negative: unary length of variable base object

	MODULE Test;
	VAR object: OBJECT; result: SIZE;
	BEGIN result := LEN (object)
	END Test.

negative: binary length of variable base object

	MODULE Test;
	VAR object: OBJECT; result: SIZE;
	BEGIN result := LEN (object, 0)
	END Test.

negative: indexing variable base object

	MODULE Test;
	VAR object: OBJECT; result: CHAR;
	BEGIN result := object[0]
	END Test.

negative: variable base object as index

	MODULE Test;
	VAR array: ARRAY 10 OF CHAR; result: CHAR; object: OBJECT;
	BEGIN result := array[object]
	END Test.

negative: member selection on variable base object

	MODULE Test;
	VAR object, result: OBJECT;
	BEGIN result := object.member
	END Test.

negative: calling variable base object

	MODULE Test;
	VAR object: OBJECT;
	BEGIN object
	END Test.


# variable pointers to record

negative: arithmetic negation on variable pointer to record

	MODULE Test;
	VAR pointer, result: POINTER TO RECORD END;
	BEGIN result := -pointer;
	END Test.

negative: logical negation on variable pointer to record

	MODULE Test;
	VAR pointer, result: POINTER TO RECORD END;
	BEGIN result := ~pointer;
	END Test.

positive: dereferencing variable pointer to record

	MODULE Test;
	TYPE Record = RECORD END;
	VAR pointer: POINTER TO Record; result: Record;
	BEGIN result := pointer^;
	END Test.

negative: addition on variable pointers to record

	MODULE Test;
	VAR pointer, result: POINTER TO RECORD END;
	BEGIN result := pointer + pointer;
	END Test.

negative: subtraction on variable pointers to record

	MODULE Test;
	VAR pointer, result: POINTER TO RECORD END;
	BEGIN result := pointer - pointer
	END Test.

negative: multiplication on variable pointers to record

	MODULE Test;
	VAR pointer, result: POINTER TO RECORD END;
	BEGIN result := pointer * pointer
	END Test.

negative: integer division on variable pointers to record

	MODULE Test;
	VAR pointer: POINTER TO RECORD END; result: SIGNED16;
	BEGIN result := pointer DIV pointer
	END Test.

negative: real division on variable pointers to record

	MODULE Test;
	VAR pointer: POINTER TO RECORD END; result: FLOAT32;
	BEGIN result := pointer / pointer
	END Test.

negative: modulo on variable pointers to record

	MODULE Test;
	VAR pointer: POINTER TO RECORD END; result: SIGNED16;
	BEGIN result := pointer MOD pointer
	END Test.

positive: equal relation on variable pointers to record

	MODULE Test;
	VAR pointer: POINTER TO RECORD END; result: BOOLEAN;
	BEGIN result := pointer = pointer
	END Test.

positive: equal relation on compatible variable pointers to record

	MODULE Test;
	TYPE Record = RECORD END;
	VAR pointer1: POINTER TO Record; pointer2: POINTER TO RECORD (Record) END; result: BOOLEAN;
	BEGIN result := (pointer1 = pointer2) OR (pointer2 = pointer1)
	END Test.

negative: equal relation on incompatible variable pointers to record

	MODULE Test;
	VAR pointer1: POINTER TO RECORD END; pointer2: POINTER TO RECORD END; result: BOOLEAN;
	BEGIN result := (pointer1 = pointer2) OR (pointer2 = pointer1)
	END Test.

negative: equal relation on incompatible variable pointers to record and array

	MODULE Test;
	VAR pointer1: POINTER TO RECORD END; pointer2: POINTER TO ARRAY 10 OF CHAR; result: BOOLEAN;
	BEGIN result := (pointer1 = pointer2) OR (pointer2 = pointer1)
	END Test.

positive: unequal relation on variable pointers to record

	MODULE Test;
	VAR pointer: POINTER TO RECORD END; result: BOOLEAN;
	BEGIN result := pointer # pointer
	END Test.

positive: unequal relation on compatible variable pointers to record

	MODULE Test;
	TYPE Record = RECORD END;
	VAR pointer1: POINTER TO Record; pointer2: POINTER TO RECORD (Record) END; result: BOOLEAN;
	BEGIN result := (pointer1 # pointer2) OR (pointer2 # pointer1)
	END Test.

negative: unequal relation on incompatible variable pointers to record

	MODULE Test;
	VAR pointer1: POINTER TO RECORD END; pointer2: POINTER TO RECORD END; result: BOOLEAN;
	BEGIN result := (pointer1 # pointer2) OR (pointer2 # pointer1)
	END Test.

negative: unequal relation on incompatible variable pointers to record and array

	MODULE Test;
	VAR pointer1: POINTER TO RECORD END; pointer2: POINTER TO ARRAY 10 OF CHAR; result: BOOLEAN;
	BEGIN result := (pointer1 # pointer2) OR (pointer2 # pointer1)
	END Test.

negative: less relation on variable pointers to record

	MODULE Test;
	VAR pointer: POINTER TO RECORD END; result: BOOLEAN;
	BEGIN result := pointer < pointer
	END Test.

negative: less or equal relation on variable pointers to record

	MODULE Test;
	VAR pointer: POINTER TO RECORD END; result: BOOLEAN;
	BEGIN result := pointer <= pointer
	END Test.

negative: greater relation on variable pointers to record

	MODULE Test;
	VAR pointer: POINTER TO RECORD END; result: BOOLEAN;
	BEGIN result := pointer > pointer
	END Test.

negative: greater or equal relation on variable pointers to record

	MODULE Test;
	VAR pointer: POINTER TO RECORD END; result: BOOLEAN;
	BEGIN result := pointer >= pointer
	END Test.

negative: set membership on variable pointers to record

	MODULE Test;
	VAR pointer: POINTER TO RECORD END; result: BOOLEAN;
	BEGIN result := pointer IN pointer
	END Test.

negative: type test on variable pointers to record

	MODULE Test;
	VAR pointer: POINTER TO RECORD END; result: BOOLEAN;
	BEGIN result := pointer IS pointer
	END Test.

negative: type test on variable pointer to record

	MODULE Test;
	VAR pointer: POINTER TO RECORD END; result: BOOLEAN;
	BEGIN result := pointer IS POINTER TO RECORD END
	END Test.

positive: type test on same pointer to record type

	MODULE Test;
	TYPE Type = POINTER TO RECORD END;
	VAR pointer: Type; result: BOOLEAN;
	BEGIN result := pointer IS Type
	END Test.

positive: type test on extending pointer to record type

	MODULE Test;
	TYPE Record = RECORD END; Type = POINTER TO RECORD (Record) END;
	VAR pointer: POINTER TO Record; result: BOOLEAN;
	BEGIN result := pointer IS Type
	END Test.

negative: type test on extended pointer to record type

	MODULE Test;
	TYPE Record = RECORD END; Type = POINTER TO Record;
	VAR pointer: POINTER TO RECORD (Record) END; result: BOOLEAN;
	BEGIN result := pointer IS Type
	END Test.

negative: type test on incompatible pointer to record type

	MODULE Test;
	TYPE Type = POINTER TO RECORD END;
	VAR record: POINTER TO RECORD END; result: BOOLEAN;
	BEGIN result := record IS Type
	END Test.

negative: type guard on variable pointers to record

	MODULE Test;
	VAR pointer, result: POINTER TO RECORD END;
	BEGIN result := pointer(pointer)
	END Test.

negative: type guard on variable pointer to record

	MODULE Test;
	VAR pointer, result: POINTER TO RECORD END;
	BEGIN result := pointer(POINTER TO RECORD END)
	END Test.

positive: type guard on same pointer to record type

	MODULE Test;
	TYPE Type = POINTER TO RECORD END;
	VAR pointer, result: Type;
	BEGIN result := pointer(Type)
	END Test.

positive: type guard on extending pointer to record type

	MODULE Test;
	TYPE Record = RECORD END; Type = POINTER TO RECORD (Record) END;
	VAR pointer: POINTER TO Record; result: Type;
	BEGIN result := pointer(Type)
	END Test.

negative: type guard on extended pointer to record type

	MODULE Test;
	TYPE Record = RECORD END; Type = POINTER TO Record;
	VAR pointer: POINTER TO RECORD (Record) END; result: Type;
	BEGIN result := pointer(Type)
	END Test.

negative: type guard on incompatible pointer to record type

	MODULE Test;
	TYPE Type = POINTER TO RECORD END;
	VAR record: POINTER TO RECORD END; result: Type;
	BEGIN result := record(Type)
	END Test.

negative: logical and on variable pointers to record

	MODULE Test;
	VAR pointer, result: POINTER TO RECORD END;
	BEGIN result := pointer & pointer
	END Test.

negative: logical or on variable pointers to record

	MODULE Test;
	VAR pointer, result: POINTER TO RECORD END;
	BEGIN result := pointer OR pointer
	END Test.

negative: ordinal value of variable pointer to record

	MODULE Test;
	VAR pointer: POINTER TO RECORD END; result: SIGNED16;
	BEGIN result := ORD (pointer)
	END Test.

negative: character value of variable pointer to record

	MODULE Test;
	VAR pointer: POINTER TO RECORD END; result: CHAR;
	BEGIN result := CHR (pointer)
	END Test.

negative: absolute value of variable pointer to record

	MODULE Test;
	VAR pointer, result: POINTER TO RECORD END;
	BEGIN result := ABS (pointer)
	END Test.

negative: odd test on variable pointer to record

	MODULE Test;
	VAR pointer: POINTER TO RECORD END; result: BOOLEAN;
	BEGIN result := ODD (pointer)
	END Test.

negative: capital letter of variable pointer to record

	MODULE Test;
	VAR pointer: POINTER TO RECORD END; result: CHAR;
	BEGIN result := CAP (pointer)
	END Test.

negative: arithmetic shift of variable pointers to record

	MODULE Test;
	VAR pointer, result: POINTER TO RECORD END;
	BEGIN result := ASH (pointer, pointer)
	END Test.

negative: short on variable pointer to record

	MODULE Test;
	VAR pointer, result: POINTER TO RECORD END;
	BEGIN result := SHORT (pointer)
	END Test.

negative: long on variable pointer to record

	MODULE Test;
	VAR pointer, result: POINTER TO RECORD END;
	BEGIN result := LONG (pointer)
	END Test.

negative: entier on variable pointer to record

	MODULE Test;
	VAR pointer, result: POINTER TO RECORD END;
	BEGIN result := ENTIER (pointer)
	END Test.

negative: unary length of variable pointer to record

	MODULE Test;
	VAR pointer: POINTER TO RECORD END; result: SIZE;
	BEGIN result := LEN (pointer)
	END Test.

negative: binary length of variable pointer to record

	MODULE Test;
	VAR pointer: POINTER TO RECORD END; result: SIZE;
	BEGIN result := LEN (pointer, 0)
	END Test.

negative: indexing variable pointer to record

	MODULE Test;
	VAR pointer: POINTER TO RECORD END; result: CHAR;
	BEGIN result := pointer[0]
	END Test.

negative: variable pointer to record as index

	MODULE Test;
	VAR array: ARRAY 10 OF CHAR; result: CHAR; pointer: POINTER TO RECORD END;
	BEGIN result := array[pointer]
	END Test.

positive: member selection on variable pointer to record

	MODULE Test;
	VAR pointer: POINTER TO RECORD member: SET END; result: SET;
	BEGIN result := pointer.member
	END Test.

positive: member modification on variable pointer to record

	MODULE Test;
	VAR pointer: POINTER TO RECORD member: SET END; value: SET;
	BEGIN pointer.member := value
	END Test.

positive: member selection on temporary pointer to record

	MODULE Test;
	VAR pointer: PROCEDURE (): POINTER TO RECORD member: SET END; result: SET;
	BEGIN result := pointer ().member
	END Test.

positive: member modification on temporary pointer to record

	MODULE Test;
	VAR pointer: PROCEDURE (): POINTER TO RECORD member: SET END; value: SET;
	BEGIN pointer ().member := value
	END Test.

positive: member selection on dereferenced variable pointer to record

	MODULE Test;
	VAR pointer: POINTER TO RECORD member: SET END; result: SET;
	BEGIN result := pointer^.member
	END Test.

positive: member modification on dereferenced variable pointer to record

	MODULE Test;
	VAR pointer: POINTER TO RECORD member: SET END; value: SET;
	BEGIN pointer^.member := value
	END Test.

positive: member selection on dereferenced temporary pointer to record

	MODULE Test;
	VAR pointer: PROCEDURE (): POINTER TO RECORD member: SET END; result: SET;
	BEGIN result := pointer ()^.member
	END Test.

positive: member modification on dereferenced temporary pointer to record

	MODULE Test;
	VAR pointer: PROCEDURE (): POINTER TO RECORD member: SET END; value: SET;
	BEGIN pointer ()^.member := value
	END Test.

negative: calling variable pointer to record

	MODULE Test;
	VAR pointer: POINTER TO RECORD END;
	BEGIN pointer
	END Test.


# variable pointers to array

negative: arithmetic negation on variable pointer to array

	MODULE Test;
	VAR pointer, result: POINTER TO ARRAY 10 OF CHAR;
	BEGIN result := -pointer;
	END Test.

negative: logical negation on variable pointer to array

	MODULE Test;
	VAR pointer, result: POINTER TO ARRAY 10 OF CHAR;
	BEGIN result := ~pointer;
	END Test.

positive: dereferencing variable pointer to array

	MODULE Test;
	TYPE Array = ARRAY 10 OF CHAR;
	VAR pointer: POINTER TO Array; result: Array;
	BEGIN result := pointer^;
	END Test.

negative: addition on variable pointers to array

	MODULE Test;
	VAR pointer, result: POINTER TO ARRAY 10 OF CHAR;
	BEGIN result := pointer + pointer;
	END Test.

negative: subtraction on variable pointers to array

	MODULE Test;
	VAR pointer, result: POINTER TO ARRAY 10 OF CHAR;
	BEGIN result := pointer - pointer
	END Test.

negative: multiplication on variable pointers to array

	MODULE Test;
	VAR pointer, result: POINTER TO ARRAY 10 OF CHAR;
	BEGIN result := pointer * pointer
	END Test.

negative: integer division on variable pointers to array

	MODULE Test;
	VAR pointer: POINTER TO ARRAY 10 OF CHAR; result: SIGNED16;
	BEGIN result := pointer DIV pointer
	END Test.

negative: real division on variable pointers to array

	MODULE Test;
	VAR pointer: POINTER TO ARRAY 10 OF CHAR; result: FLOAT32;
	BEGIN result := pointer / pointer
	END Test.

negative: modulo on variable pointers to array

	MODULE Test;
	VAR pointer: POINTER TO ARRAY 10 OF CHAR; result: SIGNED16;
	BEGIN result := pointer MOD pointer
	END Test.

positive: equal relation on variable pointers to array

	MODULE Test;
	VAR pointer: POINTER TO ARRAY 10 OF CHAR; result: BOOLEAN;
	BEGIN result := pointer = pointer
	END Test.

positive: equal relation on compatible variable pointers to array

	MODULE Test;
	VAR pointer1: POINTER TO ARRAY 10 OF CHAR; pointer2: POINTER TO ARRAY 10 OF CHAR; result: BOOLEAN;
	BEGIN result := (pointer1 = pointer2) OR (pointer2 = pointer1)
	END Test.

negative: equal relation on incompatible variable pointers to array

	MODULE Test;
	VAR pointer1: POINTER TO ARRAY 10 OF CHAR; pointer2: POINTER TO ARRAY 20 OF CHAR; result: BOOLEAN;
	BEGIN result := (pointer1 = pointer2) OR (pointer2 = pointer1)
	END Test.

negative: equal relation on incompatible variable pointers to array and record

	MODULE Test;
	VAR pointer1: POINTER TO ARRAY 10 OF CHAR; pointer2: RECORD END; result: BOOLEAN;
	BEGIN result := (pointer1 = pointer2) OR (pointer2 = pointer1)
	END Test.

positive: unequal relation on variable pointers to array

	MODULE Test;
	VAR pointer: POINTER TO ARRAY 10 OF CHAR; result: BOOLEAN;
	BEGIN result := pointer # pointer
	END Test.

positive: unequal relation on compatible variable pointers to array

	MODULE Test;
	VAR pointer1: POINTER TO ARRAY 10 OF CHAR; pointer2: POINTER TO ARRAY 10 OF CHAR; result: BOOLEAN;
	BEGIN result := (pointer1 # pointer2) OR (pointer2 # pointer1)
	END Test.

negative: unequal relation on incompatible variable pointers to array

	MODULE Test;
	VAR pointer1: POINTER TO ARRAY 10 OF CHAR; pointer2: POINTER TO ARRAY 20 OF CHAR; result: BOOLEAN;
	BEGIN result := (pointer1 # pointer2) OR (pointer2 # pointer1)
	END Test.

negative: unequal relation on incompatible variable pointers to array and record

	MODULE Test;
	VAR pointer1: POINTER TO ARRAY 10 OF CHAR; pointer2: RECORD END; result: BOOLEAN;
	BEGIN result := (pointer1 # pointer2) OR (pointer2 # pointer1)
	END Test.

negative: less relation on variable pointers to array

	MODULE Test;
	VAR pointer: POINTER TO ARRAY 10 OF CHAR; result: BOOLEAN;
	BEGIN result := pointer < pointer
	END Test.

negative: less or equal relation on variable pointers to array

	MODULE Test;
	VAR pointer: POINTER TO ARRAY 10 OF CHAR; result: BOOLEAN;
	BEGIN result := pointer <= pointer
	END Test.

negative: greater relation on variable pointers to array

	MODULE Test;
	VAR pointer: POINTER TO ARRAY 10 OF CHAR; result: BOOLEAN;
	BEGIN result := pointer > pointer
	END Test.

negative: greater or equal relation on variable pointers to array

	MODULE Test;
	VAR pointer: POINTER TO ARRAY 10 OF CHAR; result: BOOLEAN;
	BEGIN result := pointer >= pointer
	END Test.

negative: set membership on variable pointers to array

	MODULE Test;
	VAR pointer: POINTER TO ARRAY 10 OF CHAR; result: BOOLEAN;
	BEGIN result := pointer IN pointer
	END Test.

negative: type test on variable pointers to array

	MODULE Test;
	VAR pointer: POINTER TO ARRAY 10 OF CHAR; result: BOOLEAN;
	BEGIN result := pointer IS pointer
	END Test.

negative: type test on variable pointer to array

	MODULE Test;
	VAR pointer: POINTER TO ARRAY 10 OF CHAR; result: BOOLEAN;
	BEGIN result := pointer IS POINTER TO ARRAY 10 OF CHAR
	END Test.

negative: type test on pointer to array type

	MODULE Test;
	TYPE Type = POINTER TO ARRAY 10 OF CHAR;
	VAR pointer: Type; result: BOOLEAN;
	BEGIN result := pointer IS Type
	END Test.

negative: type guard on variable pointers to array

	MODULE Test;
	VAR pointer, result: POINTER TO ARRAY 10 OF CHAR;
	BEGIN result := pointer(pointer)
	END Test.

negative: type guard on variable pointer to array

	MODULE Test;
	VAR pointer, result: POINTER TO ARRAY 10 OF CHAR;
	BEGIN result := pointer(POINTER TO ARRAY 10 OF CHAR)
	END Test.

negative: type guard on pointer to array type

	MODULE Test;
	TYPE Type = POINTER TO ARRAY 10 OF CHAR;
	VAR pointer: Type; result: Type;
	BEGIN result := pointer(Type)
	END Test.

negative: logical and on variable pointers to array

	MODULE Test;
	VAR pointer, result: POINTER TO ARRAY 10 OF CHAR;
	BEGIN result := pointer & pointer
	END Test.

negative: logical or on variable pointers to array

	MODULE Test;
	VAR pointer, result: POINTER TO ARRAY 10 OF CHAR;
	BEGIN result := pointer OR pointer
	END Test.

negative: ordinal value of variable pointer to array

	MODULE Test;
	VAR pointer: POINTER TO ARRAY 10 OF CHAR; result: SIGNED16;
	BEGIN result := ORD (pointer)
	END Test.

negative: character value of variable pointer to array

	MODULE Test;
	VAR pointer: POINTER TO ARRAY 10 OF CHAR; result: CHAR;
	BEGIN result := CHR (pointer)
	END Test.

negative: absolute value of variable pointer to array

	MODULE Test;
	VAR pointer, result: POINTER TO ARRAY 10 OF CHAR;
	BEGIN result := ABS (pointer)
	END Test.

negative: odd test on variable pointer to array

	MODULE Test;
	VAR pointer: POINTER TO ARRAY 10 OF CHAR; result: BOOLEAN;
	BEGIN result := ODD (pointer)
	END Test.

negative: capital letter of variable pointer to array

	MODULE Test;
	VAR pointer: POINTER TO ARRAY 10 OF CHAR; result: CHAR;
	BEGIN result := CAP (pointer)
	END Test.

negative: arithmetic shift of variable pointers to array

	MODULE Test;
	VAR pointer, result: POINTER TO ARRAY 10 OF CHAR;
	BEGIN result := ASH (pointer, pointer)
	END Test.

negative: short on variable pointer to array

	MODULE Test;
	VAR pointer, result: POINTER TO ARRAY 10 OF CHAR;
	BEGIN result := SHORT (pointer)
	END Test.

negative: long on variable pointer to array

	MODULE Test;
	VAR pointer, result: POINTER TO ARRAY 10 OF CHAR;
	BEGIN result := LONG (pointer)
	END Test.

negative: entier on variable pointer to array

	MODULE Test;
	VAR pointer, result: POINTER TO ARRAY 10 OF CHAR;
	BEGIN result := ENTIER (pointer)
	END Test.

positive: unary length of variable pointer to array

	MODULE Test;
	VAR pointer: POINTER TO ARRAY 10 OF CHAR; result: SIZE;
	BEGIN result := LEN (pointer)
	END Test.

positive: binary length of variable pointer to array

	MODULE Test;
	VAR pointer: POINTER TO ARRAY 10 OF CHAR; result: SIZE;
	BEGIN result := LEN (pointer, 0)
	END Test.

positive: indexing variable pointer to boolean array

	MODULE Test;
	VAR array: POINTER TO ARRAY 10 OF BOOLEAN; result: BOOLEAN;
	BEGIN result := array[0]
	END Test.

positive: indexing temporary pointer to boolean array

	MODULE Test;
	VAR array: PROCEDURE (): POINTER TO ARRAY 10 OF BOOLEAN; result: BOOLEAN;
	BEGIN result := array()[0]
	END Test.

positive: changing indexed temporary pointer to boolean array

	MODULE Test;
	VAR array: PROCEDURE (): POINTER TO ARRAY 10 OF BOOLEAN;
	BEGIN array()[0] := TRUE;
	END Test.

positive: indexing dereferenced variable pointer to boolean array

	MODULE Test;
	VAR array: POINTER TO ARRAY 10 OF BOOLEAN; result: BOOLEAN;
	BEGIN result := array^[0]
	END Test.

positive: indexing dereferenced temporary pointer to boolean array

	MODULE Test;
	VAR array: PROCEDURE (): POINTER TO ARRAY 10 OF BOOLEAN; result: BOOLEAN;
	BEGIN result := array()^[0]
	END Test.

positive: changing dereferenced indexed temporary pointer to boolean array

	MODULE Test;
	VAR array: PROCEDURE (): POINTER TO ARRAY 10 OF BOOLEAN;
	BEGIN array()^[0] := TRUE;
	END Test.

positive: indexing variable pointer to character array

	MODULE Test;
	VAR array: POINTER TO ARRAY 10 OF CHAR; result: CHAR;
	BEGIN result := array[0]
	END Test.

positive: indexing temporary pointer to character array

	MODULE Test;
	VAR array: PROCEDURE (): POINTER TO ARRAY 10 OF CHAR; result: CHAR;
	BEGIN result := array()[0]
	END Test.

positive: changing indexed temporary pointer to character array

	MODULE Test;
	VAR array: PROCEDURE (): POINTER TO ARRAY 10 OF CHAR;
	BEGIN array()[0] := '0';
	END Test.

positive: indexing dereferenced variable pointer to character array

	MODULE Test;
	VAR array: POINTER TO ARRAY 10 OF CHAR; result: CHAR;
	BEGIN result := array^[0]
	END Test.

positive: indexing dereferenced temporary pointer to character array

	MODULE Test;
	VAR array: PROCEDURE (): POINTER TO ARRAY 10 OF CHAR; result: CHAR;
	BEGIN result := array()^[0]
	END Test.

positive: changing dereferenced indexed temporary pointer to character array

	MODULE Test;
	VAR array: PROCEDURE (): POINTER TO ARRAY 10 OF CHAR;
	BEGIN array()^[0] := '0';
	END Test.

positive: indexing variable pointer to integer array

	MODULE Test;
	VAR array: POINTER TO ARRAY 10 OF SIGNED16; result: SIGNED16;
	BEGIN result := array[0]
	END Test.

positive: indexing temporary pointer to integer array

	MODULE Test;
	VAR array: PROCEDURE (): POINTER TO ARRAY 10 OF SIGNED16; result: SIGNED16;
	BEGIN result := array()[0]
	END Test.

positive: changing indexed temporary pointer to integer array

	MODULE Test;
	VAR array: PROCEDURE (): POINTER TO ARRAY 10 OF SIGNED16;
	BEGIN array()[0] := 5;
	END Test.

positive: indexing dereferenced variable pointer to integer array

	MODULE Test;
	VAR array: POINTER TO ARRAY 10 OF SIGNED16; result: SIGNED16;
	BEGIN result := array^[0]
	END Test.

positive: indexing dereferenced temporary pointer to integer array

	MODULE Test;
	VAR array: PROCEDURE (): POINTER TO ARRAY 10 OF SIGNED16; result: SIGNED16;
	BEGIN result := array()^[0]
	END Test.

positive: changing dereferenced indexed temporary pointer to integer array

	MODULE Test;
	VAR array: PROCEDURE (): POINTER TO ARRAY 10 OF SIGNED16;
	BEGIN array()^[0] := 5;
	END Test.

positive: indexing variable pointer to real array

	MODULE Test;
	VAR array: POINTER TO ARRAY 10 OF FLOAT32; result: FLOAT32;
	BEGIN result := array[0]
	END Test.

positive: indexing temporary pointer to real array

	MODULE Test;
	VAR array: PROCEDURE (): POINTER TO ARRAY 10 OF FLOAT32; result: FLOAT32;
	BEGIN result := array()[0]
	END Test.

positive: changing indexed temporary pointer to real array

	MODULE Test;
	VAR array: PROCEDURE (): POINTER TO ARRAY 10 OF FLOAT32;
	BEGIN array()[0] := 5.0;
	END Test.

positive: indexing dereferenced variable pointer to real array

	MODULE Test;
	VAR array: POINTER TO ARRAY 10 OF FLOAT32; result: FLOAT32;
	BEGIN result := array^[0]
	END Test.

positive: indexing dereferenced temporary pointer to real array

	MODULE Test;
	VAR array: PROCEDURE (): POINTER TO ARRAY 10 OF FLOAT32; result: FLOAT32;
	BEGIN result := array()^[0]
	END Test.

positive: changing dereferenced indexed temporary pointer to real array

	MODULE Test;
	VAR array: PROCEDURE (): POINTER TO ARRAY 10 OF FLOAT32;
	BEGIN array()^[0] := 5.0;
	END Test.

positive: indexing variable pointer to set array

	MODULE Test;
	VAR array: POINTER TO ARRAY 10 OF SET; result: SET;
	BEGIN result := array[0]
	END Test.

positive: indexing temporary pointer to set array

	MODULE Test;
	VAR array: PROCEDURE (): POINTER TO ARRAY 10 OF SET; result: SET;
	BEGIN result := array()[0]
	END Test.

positive: changing indexed temporary pointer to set array

	MODULE Test;
	VAR array: PROCEDURE (): POINTER TO ARRAY 10 OF SET;
	BEGIN array()[0] := {5};
	END Test.

positive: indexing dereferenced variable pointer to set array

	MODULE Test;
	VAR array: POINTER TO ARRAY 10 OF SET; result: SET;
	BEGIN result := array^[0]
	END Test.

positive: indexing dereferenced temporary pointer to set array

	MODULE Test;
	VAR array: PROCEDURE (): POINTER TO ARRAY 10 OF SET; result: SET;
	BEGIN result := array()^[0]
	END Test.

positive: changing dereferenced indexed temporary pointer to set array

	MODULE Test;
	VAR array: PROCEDURE (): POINTER TO ARRAY 10 OF SET;
	BEGIN array()^[0] := {5};
	END Test.

positive: indexing variable pointer to array of array

	MODULE Test;
	VAR array: POINTER TO ARRAY 10 OF ARRAY 10 OF CHAR; result: ARRAY 10 OF CHAR;
	BEGIN result := array[0]
	END Test.

positive: indexing temporary pointer to array of array

	MODULE Test;
	VAR array: PROCEDURE (): POINTER TO ARRAY 10 OF ARRAY 10 OF CHAR; result: ARRAY 10 OF CHAR;
	BEGIN result := array()[0]
	END Test.

positive: changing indexed temporary pointer to array of array

	MODULE Test;
	VAR array: PROCEDURE (): POINTER TO ARRAY 10 OF ARRAY 10 OF CHAR; value: ARRAY 10 OF CHAR;
	BEGIN array()[0] := value;
	END Test.

positive: indexing dereferenced variable pointer to array of array

	MODULE Test;
	VAR array: POINTER TO ARRAY 10 OF ARRAY 10 OF CHAR; result: ARRAY 10 OF CHAR;
	BEGIN result := array^[0]
	END Test.

positive: indexing dereferenced temporary pointer to array of array

	MODULE Test;
	VAR array: PROCEDURE (): POINTER TO ARRAY 10 OF ARRAY 10 OF CHAR; result: ARRAY 10 OF CHAR;
	BEGIN result := array()^[0]
	END Test.

positive: changing dereferenced indexed temporary pointer to array of array

	MODULE Test;
	VAR array: PROCEDURE (): POINTER TO ARRAY 10 OF ARRAY 10 OF CHAR; value: ARRAY 10 OF CHAR;
	BEGIN array()^[0] := value;
	END Test.

positive: indexing variable pointer to record array

	MODULE Test;
	TYPE Record = RECORD END;
	VAR array: POINTER TO ARRAY 10 OF Record; result: Record;
	BEGIN result := array[0]
	END Test.

positive: indexing temporary pointer to record array

	MODULE Test;
	TYPE Record = RECORD END;
	VAR array: PROCEDURE (): POINTER TO ARRAY 10 OF Record; result: Record;
	BEGIN result := array()[0]
	END Test.

positive: changing indexed temporary pointer to record array

	MODULE Test;
	TYPE Record = RECORD END;
	VAR array: PROCEDURE (): POINTER TO ARRAY 10 OF Record; value: Record;
	BEGIN array()[0] := value;
	END Test.

positive: changing member of indexed temporary pointer to record array

	MODULE Test;
	TYPE Record = RECORD i: SIGNED16 END;
	VAR array: PROCEDURE (): POINTER TO ARRAY 10 OF Record;
	BEGIN array()[0].i := 5;
	END Test.

positive: indexing dereferenced variable pointer to array of record

	MODULE Test;
	TYPE Record = RECORD END;
	VAR array: POINTER TO ARRAY 10 OF Record; result: Record;
	BEGIN result := array^[0]
	END Test.

positive: indexing dereferenced temporary pointer to array of record

	MODULE Test;
	TYPE Record = RECORD END;
	VAR array: PROCEDURE (): POINTER TO ARRAY 10 OF Record; result: Record;
	BEGIN result := array()^[0]
	END Test.

positive: changing dereferenced indexed temporary pointer to array of record

	MODULE Test;
	TYPE Record = RECORD END;
	VAR array: PROCEDURE (): POINTER TO ARRAY 10 OF Record; value: Record;
	BEGIN array()^[0] := value;
	END Test.

positive: changing member of dereferenced indexed temporary pointer to array of record

	MODULE Test;
	TYPE Record = RECORD i: SIGNED16 END;
	VAR array: PROCEDURE (): POINTER TO ARRAY 10 OF Record;
	BEGIN array()^[0].i := 5;
	END Test.

positive: indexing variable pointer to object array

	MODULE Test;
	TYPE Object = OBJECT END Object;
	VAR array: POINTER TO ARRAY 10 OF Object; result: Object;
	BEGIN result := array[0]
	END Test.

positive: indexing temporary pointer to object array

	MODULE Test;
	TYPE Object = OBJECT END Object;
	VAR array: PROCEDURE (): POINTER TO ARRAY 10 OF Object; result: Object;
	BEGIN result := array()[0]
	END Test.

positive: changing indexed temporary pointer to object array

	MODULE Test;
	TYPE Object = OBJECT END Object;
	VAR array: PROCEDURE (): POINTER TO ARRAY 10 OF Object; value: Object;
	BEGIN array()[0] := value;
	END Test.

positive: changing member of indexed temporary pointer to object array

	MODULE Test;
	TYPE Object = OBJECT VAR i: SIGNED16 END Object;
	VAR array: PROCEDURE (): POINTER TO ARRAY 10 OF Object;
	BEGIN array()[0].i := 5;
	END Test.

positive: indexing dereferenced variable pointer to object array

	MODULE Test;
	TYPE Object = OBJECT END Object;
	VAR array: POINTER TO ARRAY 10 OF Object; result: Object;
	BEGIN result := array^[0]
	END Test.

positive: indexing dereferenced temporary pointer to object array

	MODULE Test;
	TYPE Object = OBJECT END Object;
	VAR array: PROCEDURE (): POINTER TO ARRAY 10 OF Object; result: Object;
	BEGIN result := array()^[0]
	END Test.

positive: changing dereferenced indexed temporary pointer to object array

	MODULE Test;
	TYPE Object = OBJECT END Object;
	VAR array: PROCEDURE (): POINTER TO ARRAY 10 OF Object; value: Object;
	BEGIN array()^[0] := value;
	END Test.

positive: changing member of dereferenced indexed temporary pointer to object array

	MODULE Test;
	TYPE Object = OBJECT VAR i: SIGNED16 END Object;
	VAR array: PROCEDURE (): POINTER TO ARRAY 10 OF Object;
	BEGIN array()^[0].i := 5;
	END Test.

positive: indexing variable pointer to base object array

	MODULE Test;
	VAR array: POINTER TO ARRAY 10 OF OBJECT; result: OBJECT;
	BEGIN result := array[0]
	END Test.

positive: indexing temporary pointer to base object array

	MODULE Test;
	VAR array: PROCEDURE (): POINTER TO ARRAY 10 OF OBJECT; result: OBJECT;
	BEGIN result := array()[0]
	END Test.

positive: changing indexed temporary pointer to base object array

	MODULE Test;
	VAR array: PROCEDURE (): POINTER TO ARRAY 10 OF OBJECT; value: OBJECT;
	BEGIN array()[0] := value;
	END Test.

positive: indexing dereferenced variable pointer to base object array

	MODULE Test;
	VAR array: POINTER TO ARRAY 10 OF OBJECT; result: OBJECT;
	BEGIN result := array^[0]
	END Test.

positive: indexing dereferenced temporary pointer to base object array

	MODULE Test;
	VAR array: PROCEDURE (): POINTER TO ARRAY 10 OF OBJECT; result: OBJECT;
	BEGIN result := array()^[0]
	END Test.

positive: changing dereferenced indexed temporary pointer to base object array

	MODULE Test;
	VAR array: PROCEDURE (): POINTER TO ARRAY 10 OF OBJECT; value: OBJECT;
	BEGIN array()^[0] := value;
	END Test.

positive: indexing variable pointer to pointer to array array

	MODULE Test;
	VAR array: POINTER TO ARRAY 10 OF POINTER TO ARRAY 10 OF CHAR; result: POINTER TO ARRAY 10 OF CHAR;
	BEGIN result := array[0]
	END Test.

positive: indexing temporary pointer to pointer to array array

	MODULE Test;
	VAR array: PROCEDURE (): POINTER TO ARRAY 10 OF POINTER TO ARRAY 10 OF CHAR; result: POINTER TO ARRAY 10 OF CHAR;
	BEGIN result := array()[0]
	END Test.

positive: changing indexed temporary pointer to pointer to array array

	MODULE Test;
	VAR array: PROCEDURE (): POINTER TO ARRAY 10 OF POINTER TO ARRAY 10 OF CHAR; value: POINTER TO ARRAY 10 OF CHAR;
	BEGIN array()[0] := value;
	END Test.

positive: changing element of indexed temporary pointer to pointer to array array

	MODULE Test;
	VAR array: PROCEDURE (): POINTER TO ARRAY 10 OF POINTER TO ARRAY 10 OF CHAR;
	BEGIN array()[0][0] := 'f';
	END Test.

positive: indexing dereferenced variable pointer to pointer to array array

	MODULE Test;
	VAR array: POINTER TO ARRAY 10 OF POINTER TO ARRAY 10 OF CHAR; result: POINTER TO ARRAY 10 OF CHAR;
	BEGIN result := array^[0]
	END Test.

positive: indexing dereferenced temporary pointer to pointer to array array

	MODULE Test;
	VAR array: PROCEDURE (): POINTER TO ARRAY 10 OF POINTER TO ARRAY 10 OF CHAR; result: POINTER TO ARRAY 10 OF CHAR;
	BEGIN result := array()^[0]
	END Test.

positive: changing dereferenced indexed temporary pointer to pointer to array array

	MODULE Test;
	VAR array: PROCEDURE (): POINTER TO ARRAY 10 OF POINTER TO ARRAY 10 OF CHAR; value: POINTER TO ARRAY 10 OF CHAR;
	BEGIN array()^[0] := value;
	END Test.

positive: changing element of dereferenced indexed temporary pointer to pointer to array array

	MODULE Test;
	VAR array: PROCEDURE (): POINTER TO ARRAY 10 OF POINTER TO ARRAY 10 OF CHAR;
	BEGIN array()^[0][0] := 'f';
	END Test.

positive: indexing variable pointer to pointer to record array

	MODULE Test;
	TYPE Record = RECORD END;
	VAR array: POINTER TO ARRAY 10 OF POINTER TO Record; result: POINTER TO Record;
	BEGIN result := array[0]
	END Test.

positive: indexing temporary pointer to pointer to record array

	MODULE Test;
	TYPE Record = RECORD END;
	VAR array: PROCEDURE (): POINTER TO ARRAY 10 OF POINTER TO Record; result: POINTER TO Record;
	BEGIN result := array()[0]
	END Test.

positive: changing indexed temporary pointer to pointer to record array

	MODULE Test;
	TYPE Record = RECORD END;
	VAR array: PROCEDURE (): POINTER TO ARRAY 10 OF POINTER TO Record; value: POINTER TO Record;
	BEGIN array()[0] := value;
	END Test.

positive: changing element of indexed temporary pointer to pointer to record array

	MODULE Test;
	VAR array: PROCEDURE (): POINTER TO ARRAY 10 OF POINTER TO RECORD i: SIGNED16 END;
	BEGIN array()[0].i := 5;
	END Test.

positive: indexing dereferenced variable pointer to record array

	MODULE Test;
	TYPE Record = RECORD END;
	VAR array: POINTER TO ARRAY 10 OF POINTER TO Record; result: POINTER TO Record;
	BEGIN result := array^[0]
	END Test.

positive: indexing dereferenced temporary pointer to pointer to record array

	MODULE Test;
	TYPE Record = RECORD END;
	VAR array: PROCEDURE (): POINTER TO ARRAY 10 OF POINTER TO Record; result: POINTER TO Record;
	BEGIN result := array()^[0]
	END Test.

positive: changing dereferenced indexed temporary pointer to pointer to record array

	MODULE Test;
	TYPE Record = RECORD END;
	VAR array: PROCEDURE (): POINTER TO ARRAY 10 OF POINTER TO Record; value: POINTER TO Record;
	BEGIN array()^[0] := value;
	END Test.

positive: changing element of dereferenced indexed temporary pointer to pointer to record array

	MODULE Test;
	VAR array: PROCEDURE (): POINTER TO ARRAY 10 OF POINTER TO RECORD i: SIGNED16 END;
	BEGIN array()^[0].i := 5;
	END Test.

positive: indexing variable pointer to procedure array

	MODULE Test;
	VAR array: POINTER TO ARRAY 10 OF PROCEDURE; result: PROCEDURE;
	BEGIN result := array[0]
	END Test.

positive: indexing temporary pointer to procedure array

	MODULE Test;
	VAR array: PROCEDURE (): POINTER TO ARRAY 10 OF PROCEDURE; result: PROCEDURE;
	BEGIN result := array()[0]
	END Test.

positive: changing indexed temporary pointer to procedure array

	MODULE Test;
	VAR array: PROCEDURE (): POINTER TO ARRAY 10 OF PROCEDURE; value: PROCEDURE;
	BEGIN array()[0] := value;
	END Test.

positive: indexing dereferenced variable pointer to procedure array

	MODULE Test;
	VAR array: POINTER TO ARRAY 10 OF PROCEDURE; result: PROCEDURE;
	BEGIN result := array^[0]
	END Test.

positive: indexing dereferenced temporary pointer to procedure array

	MODULE Test;
	VAR array: PROCEDURE (): POINTER TO ARRAY 10 OF PROCEDURE; result: PROCEDURE;
	BEGIN result := array()^[0]
	END Test.

positive: changing dereferenced indexed temporary pointer to procedure array

	MODULE Test;
	VAR array: PROCEDURE (): POINTER TO ARRAY 10 OF PROCEDURE; value: PROCEDURE;
	BEGIN array()^[0] := value;
	END Test.

negative: variable pointer to array as index

	MODULE Test;
	VAR array: ARRAY 10 OF CHAR; result: CHAR; pointer: POINTER TO ARRAY 10 OF CHAR;
	BEGIN result := array[pointer]
	END Test.

negative: member selection on variable pointer to array

	MODULE Test;
	VAR pointer: POINTER TO ARRAY 10 OF CHAR; result: ARRAY 10 OF CHAR;
	BEGIN result := pointer.member
	END Test.

negative: member selection on dereferenced variable pointer to array

	MODULE Test;
	VAR pointer: POINTER TO ARRAY 10 OF CHAR; result: ARRAY 10 OF CHAR;
	BEGIN result := pointer^.member
	END Test.

negative: calling variable pointer to array

	MODULE Test;
	VAR pointer: POINTER TO ARRAY 10 OF CHAR;
	BEGIN pointer
	END Test.


# procedure variables

negative: arithmetic negation on procedure variable

	MODULE Test;
	VAR procedure, result: PROCEDURE;
	BEGIN result := -procedure;
	END Test.

negative: logical negation on procedure variable

	MODULE Test;
	VAR procedure, result: PROCEDURE;
	BEGIN result := ~procedure;
	END Test.

negative: dereferencing variable pointer to procedure

	MODULE Test;
	VAR procedure, result: PROCEDURE;
	BEGIN result := procedure^;
	END Test.

negative: addition on procedure variables

	MODULE Test;
	VAR procedure, result: PROCEDURE;
	BEGIN result := procedure + procedure;
	END Test.

negative: subtraction on procedure variables

	MODULE Test;
	VAR procedure, result: PROCEDURE;
	BEGIN result := procedure - procedure
	END Test.

negative: multiplication on procedure variables

	MODULE Test;
	VAR procedure, result: PROCEDURE;
	BEGIN result := procedure * procedure
	END Test.

negative: integer division on procedure variables

	MODULE Test;
	VAR procedure: PROCEDURE; result: SIGNED16;
	BEGIN result := procedure DIV procedure
	END Test.

negative: real division on procedure variables

	MODULE Test;
	VAR procedure: PROCEDURE; result: FLOAT32;
	BEGIN result := procedure / procedure
	END Test.

negative: modulo on procedure variables

	MODULE Test;
	VAR procedure: PROCEDURE; result: SIGNED16;
	BEGIN result := procedure MOD procedure
	END Test.

positive: equal relation on procedure variables

	MODULE Test;
	VAR procedure: PROCEDURE; result: BOOLEAN;
	BEGIN result := procedure = procedure
	END Test.

positive: equal relation on compatible procedure variables

	MODULE Test;
	VAR procedure1: PROCEDURE; procedure2: PROCEDURE; result: BOOLEAN;
	BEGIN result := (procedure1 = procedure2) OR (procedure2 = procedure1)
	END Test.

negative: equal relation on incompatible procedure variables

	MODULE Test;
	VAR procedure1: PROCEDURE; procedure2: PROCEDURE (p: PROCEDURE); result: BOOLEAN;
	BEGIN result := (procedure1 = procedure2) OR (procedure2 = procedure1)
	END Test.

positive: unequal relation on procedure variables

	MODULE Test;
	VAR procedure: PROCEDURE; result: BOOLEAN;
	BEGIN result := procedure # procedure
	END Test.

positive: unequal relation on compatible procedure variables

	MODULE Test;
	VAR procedure1: PROCEDURE; procedure2: PROCEDURE; result: BOOLEAN;
	BEGIN result := (procedure1 # procedure2) OR (procedure2 # procedure1)
	END Test.

negative: unequal relation on incompatible procedure variables

	MODULE Test;
	VAR procedure1: PROCEDURE; procedure2: PROCEDURE (p: PROCEDURE); result: BOOLEAN;
	BEGIN result := (procedure1 # procedure2) OR (procedure2 # procedure1)
	END Test.

negative: less relation on procedure variables

	MODULE Test;
	VAR procedure: PROCEDURE; result: BOOLEAN;
	BEGIN result := procedure < procedure
	END Test.

negative: less or equal relation on procedure variables

	MODULE Test;
	VAR procedure: PROCEDURE; result: BOOLEAN;
	BEGIN result := procedure <= procedure
	END Test.

negative: greater relation on procedure variables

	MODULE Test;
	VAR procedure: PROCEDURE; result: BOOLEAN;
	BEGIN result := procedure > procedure
	END Test.

negative: greater or equal relation on procedure variables

	MODULE Test;
	VAR procedure: PROCEDURE; result: BOOLEAN;
	BEGIN result := procedure >= procedure
	END Test.

negative: set membership on procedure variables

	MODULE Test;
	VAR procedure: PROCEDURE; result: BOOLEAN;
	BEGIN result := procedure IN procedure
	END Test.

negative: type test on procedure variables

	MODULE Test;
	VAR procedure: PROCEDURE; result: BOOLEAN;
	BEGIN result := procedure IS procedure
	END Test.

negative: type test on procedure variable

	MODULE Test;
	VAR procedure: PROCEDURE; result: BOOLEAN;
	BEGIN result := procedure IS PROCEDURE
	END Test.

negative: type test on pointer to procedure type

	MODULE Test;
	TYPE Type = PROCEDURE;
	VAR procedure: Type; result: BOOLEAN;
	BEGIN result := procedure IS Type
	END Test.

negative: type guard on procedure variables

	MODULE Test;
	VAR procedure, result: PROCEDURE;
	BEGIN result := procedure(procedure)
	END Test.

negative: type guard on procedure variable

	MODULE Test;
	VAR procedure, result: PROCEDURE;
	BEGIN result := procedure(PROCEDURE)
	END Test.

negative: type guard on pointer to procedure type

	MODULE Test;
	TYPE Type = PROCEDURE;
	VAR procedure: Type; result: Type;
	BEGIN result := procedure(Type)
	END Test.

negative: logical and on procedure variables

	MODULE Test;
	VAR procedure, result: PROCEDURE;
	BEGIN result := procedure & procedure
	END Test.

negative: logical or on procedure variables

	MODULE Test;
	VAR procedure, result: PROCEDURE;
	BEGIN result := procedure OR procedure
	END Test.

negative: ordinal value of procedure variable

	MODULE Test;
	VAR procedure: PROCEDURE; result: SIGNED16;
	BEGIN result := ORD (procedure)
	END Test.

negative: character value of procedure variable

	MODULE Test;
	VAR procedure: PROCEDURE; result: CHAR;
	BEGIN result := CHR (procedure)
	END Test.

negative: absolute value of procedure variable

	MODULE Test;
	VAR procedure, result: PROCEDURE;
	BEGIN result := ABS (procedure)
	END Test.

negative: odd test on procedure variable

	MODULE Test;
	VAR procedure: PROCEDURE; result: BOOLEAN;
	BEGIN result := ODD (procedure)
	END Test.

negative: capital letter of procedure variable

	MODULE Test;
	VAR procedure: PROCEDURE; result: CHAR;
	BEGIN result := CAP (procedure)
	END Test.

negative: arithmetic shift of procedure variables

	MODULE Test;
	VAR procedure, result: PROCEDURE;
	BEGIN result := ASH (procedure, procedure)
	END Test.

negative: short on procedure variable

	MODULE Test;
	VAR procedure, result: PROCEDURE;
	BEGIN result := SHORT (procedure)
	END Test.

negative: long on procedure variable

	MODULE Test;
	VAR procedure, result: PROCEDURE;
	BEGIN result := LONG (procedure)
	END Test.

negative: entier on procedure variable

	MODULE Test;
	VAR procedure, result: PROCEDURE;
	BEGIN result := ENTIER (procedure)
	END Test.

negative: unary length of procedure variable

	MODULE Test;
	VAR procedure: PROCEDURE; result: SIZE;
	BEGIN result := LEN (procedure)
	END Test.

negative: binary length of procedure variable

	MODULE Test;
	VAR procedure: PROCEDURE; result: SIZE;
	BEGIN result := LEN (procedure, 0)
	END Test.

negative: indexing procedure variable

	MODULE Test;
	VAR procedure: PROCEDURE; result: CHAR;
	BEGIN result := procedure[0]
	END Test.

negative: procedure variable as index

	MODULE Test;
	VAR array: ARRAY 10 OF CHAR; result: CHAR; procedure: PROCEDURE;
	BEGIN result := array[procedure]
	END Test.

positive: calling procedure variable

	MODULE Test;
	VAR procedure: PROCEDURE;
	BEGIN procedure ()
	END Test.

negative: ignoring procedure variable

	MODULE Test;
	VAR procedure: PROCEDURE;
	BEGIN IGNORE procedure
	END Test.

negative: ignoring procedure variable call

	MODULE Test;
	VAR procedure: PROCEDURE;
	BEGIN IGNORE procedure ()
	END Test.

negative: calling procedure variable returning boolean

	MODULE Test;
	VAR procedure: PROCEDURE (): BOOLEAN;
	BEGIN procedure ()
	END Test.

positive: ignoring procedure variable returning boolean

	MODULE Test;
	VAR procedure: PROCEDURE (): BOOLEAN;
	BEGIN IGNORE procedure ()
	END Test.

negative: calling procedure variable returning character

	MODULE Test;
	VAR procedure: PROCEDURE (): CHAR;
	BEGIN procedure ()
	END Test.

positive: ignoring procedure variable returning character

	MODULE Test;
	VAR procedure: PROCEDURE (): CHAR;
	BEGIN IGNORE procedure ()
	END Test.

negative: calling procedure variable returning integer

	MODULE Test;
	VAR procedure: PROCEDURE (): SIGNED16;
	BEGIN procedure ()
	END Test.

positive: ignoring procedure variable returning integer

	MODULE Test;
	VAR procedure: PROCEDURE (): SIGNED16;
	BEGIN IGNORE procedure ()
	END Test.

negative: calling procedure variable returning real

	MODULE Test;
	VAR procedure: PROCEDURE (): FLOAT32;
	BEGIN procedure ()
	END Test.

positive: ignoring procedure variable returning real

	MODULE Test;
	VAR procedure: PROCEDURE (): FLOAT32;
	BEGIN IGNORE procedure ()
	END Test.

negative: calling procedure variable returning set

	MODULE Test;
	VAR procedure: PROCEDURE (): SET;
	BEGIN procedure ()
	END Test.

positive: ignoring procedure variable returning set

	MODULE Test;
	VAR procedure: PROCEDURE (): SET;
	BEGIN IGNORE procedure ()
	END Test.

negative: calling procedure variable returning array

	MODULE Test;
	VAR procedure: PROCEDURE (): ARRAY 10 OF CHAR;
	BEGIN procedure ()
	END Test.

positive: ignoring procedure variable returning array

	MODULE Test;
	VAR procedure: PROCEDURE (): ARRAY 10 OF CHAR;
	BEGIN IGNORE procedure ()
	END Test.

negative: calling procedure variable returning record

	MODULE Test;
	VAR procedure: PROCEDURE (): RECORD END;
	BEGIN procedure ()
	END Test.

positive: ignoring procedure variable returning record

	MODULE Test;
	VAR procedure: PROCEDURE (): RECORD END;
	BEGIN IGNORE procedure ()
	END Test.

negative: calling procedure variable returning object

	MODULE Test;
	VAR procedure: PROCEDURE (): OBJECT END;
	BEGIN procedure ()
	END Test.

positive: ignoring procedure variable returning object

	MODULE Test;
	VAR procedure: PROCEDURE (): OBJECT END;
	BEGIN IGNORE procedure ()
	END Test.

negative: calling procedure variable returning base object

	MODULE Test;
	VAR procedure: PROCEDURE (): OBJECT;
	BEGIN procedure ()
	END Test.

positive: ignoring procedure variable returning base object

	MODULE Test;
	VAR procedure: PROCEDURE (): OBJECT;
	BEGIN IGNORE procedure ()
	END Test.

negative: calling procedure variable returning pointer to array

	MODULE Test;
	VAR procedure: PROCEDURE (): POINTER TO ARRAY 10 OF CHAR;
	BEGIN procedure ()
	END Test.

positive: ignoring procedure variable returning pointer to array

	MODULE Test;
	VAR procedure: PROCEDURE (): POINTER TO ARRAY 10 OF CHAR;
	BEGIN IGNORE procedure ()
	END Test.

negative: calling procedure variable returning pointer to record

	MODULE Test;
	VAR procedure: PROCEDURE (): POINTER TO ARRAY 10 OF RECORD END;
	BEGIN procedure ()
	END Test.

positive: ignoring procedure variable returning pointer to record

	MODULE Test;
	VAR procedure: PROCEDURE (): POINTER TO ARRAY 10 OF RECORD END;
	BEGIN IGNORE procedure ()
	END Test.

negative: calling procedure variable returning procedure

	MODULE Test;
	VAR procedure: PROCEDURE (): PROCEDURE;
	BEGIN procedure ()
	END Test.

positive: ignoring procedure variable returning procedure

	MODULE Test;
	VAR procedure: PROCEDURE (): PROCEDURE;
	BEGIN IGNORE procedure ()
	END Test.


# implicit variable conversions

positive: implicit variable short to integer conversion

	MODULE Test;
	VAR shortint: SIGNED8; integer, result: SIGNED16;
	BEGIN result := shortint + integer
	END Test.

positive: implicit variable short to long integer conversion

	MODULE Test;
	VAR shortint: SIGNED8; longint, result: SIGNED32;
	BEGIN result := shortint * longint
	END Test.

positive: implicit variable short to huge integer conversion

	MODULE Test;
	VAR shortint: SIGNED8; hugeint, result: SIGNED64;
	BEGIN result := hugeint DIV shortint
	END Test.

positive: implicit variable integer to long integer conversion

	MODULE Test;
	VAR integer: SIGNED16; longint, result: SIGNED32;
	BEGIN result := integer - longint
	END Test.

positive: implicit variable integer to huge integer conversion

	MODULE Test;
	VAR integer: SIGNED16; hugeint, result: SIGNED64;
	BEGIN result := integer * hugeint
	END Test.

positive: implicit variable long to huge integer conversion

	MODULE Test;
	VAR longint: SIGNED16; hugeint, result: SIGNED64;
	BEGIN result := hugeint + longint
	END Test.

positive: implicit variable integer to real conversion

	MODULE Test;
	VAR integer: SIGNED16; real, result: FLOAT32;
	BEGIN result := real + integer
	END Test.

positive: implicit variable integer to long real conversion

	MODULE Test;
	VAR integer: SIGNED16; longreal, result: FLOAT64;
	BEGIN result := integer / longreal
	END Test.

positive: implicit variable real to long real conversion

	MODULE Test;
	VAR real: FLOAT32; longreal, result: FLOAT64;
	BEGIN result := longreal * real
	END Test.

negative: implicit conversion between variable boolean and character

	MODULE Test;
	VAR boolean, result: BOOLEAN; character: CHAR;
	BEGIN result := boolean = character
	END Test.

negative: implicit conversion between variable boolean and integer

	MODULE Test;
	VAR boolean, result: BOOLEAN; integer: SIGNED16;
	BEGIN result := boolean # integer
	END Test.

negative: implicit conversion between variable boolean and real

	MODULE Test;
	VAR boolean, result: BOOLEAN; real: FLOAT32;
	BEGIN result := boolean = real
	END Test.

negative: implicit conversion between variable boolean and set

	MODULE Test;
	VAR boolean, result: BOOLEAN; set: SET;
	BEGIN result := boolean = set
	END Test.

negative: implicit conversion between variable character and integer

	MODULE Test;
	VAR character: CHAR; integer: SIGNED16; result: BOOLEAN;
	BEGIN result := character # integer
	END Test.

negative: implicit conversion between variable character and real

	MODULE Test;
	VAR character: CHAR; real: FLOAT32; result: BOOLEAN;
	BEGIN result := 't' # real
	END Test.

negative: implicit conversion between variable character and set

	MODULE Test;
	VAR character: CHAR; set: SET; result: BOOLEAN;
	BEGIN result := character = set
	END Test.

positive: implicit conversion between variable integer and real

	MODULE Test;
	VAR integer: SIGNED16; real: FLOAT32; result: BOOLEAN;
	BEGIN result := integer # real
	END Test.

negative: implicit conversion between variable integer and set

	MODULE Test;
	VAR integer: SIGNED16; set: SET; result: BOOLEAN;
	BEGIN result := integer = set
	END Test.

negative: implicit conversion between variable real and set

	MODULE Test;
	VAR real: FLOAT32; set: SET; result: BOOLEAN;
	BEGIN result := real = set
	END Test.


# explicit variable conversions

negative: explicit long conversion on variable short integer

	MODULE Test;
	VAR shortint: SIGNED8;
	BEGIN shortint := LONG (shortint);
	END Test.

negative: explicit short conversion on variable short integer

	MODULE Test;
	VAR shortint: SIGNED8;
	BEGIN shortint := SHORT (shortint);
	END Test.

negative: explicit long conversion on variable integer

	MODULE Test;
	VAR integer: SIGNED16;
	BEGIN integer := LONG (integer);
	END Test.

positive: explicit short conversion on variable integer

	MODULE Test;
	VAR integer: SIGNED16;
	BEGIN integer := SHORT (integer);
	END Test.

negative: explicit long conversion on variable long integer

	MODULE Test;
	VAR longint: SIGNED32;
	BEGIN longint := LONG (longint);
	END Test.

positive: explicit short conversion on variable long integer

	MODULE Test;
	VAR longint: SIGNED32;
	BEGIN longint := SHORT (longint);
	END Test.

negative: explicit long conversion on variable huge integer

	MODULE Test;
	VAR hugeint: SIGNED64;
	BEGIN hugeint := LONG (hugeint);
	END Test.

positive: explicit short conversion on variable huge integer

	MODULE Test;
	VAR hugeint: SIGNED64;
	BEGIN hugeint := SHORT (hugeint);
	END Test.

positive: explicit variable short integer to integer conversion

	MODULE Test;
	VAR shortint: SIGNED8; integer: SIGNED16;
	BEGIN integer := LONG (shortint);
	END Test.

positive: explicit variable short to long integer conversion

	MODULE Test;
	VAR shortint: SIGNED8; longint: SIGNED32;
	BEGIN longint := LONG (LONG (shortint));
	END Test.

positive: explicit variable short to huge integer conversion

	MODULE Test;
	VAR shortint: SIGNED8; hugeint: SIGNED64;
	BEGIN hugeint := LONG (LONG (LONG (shortint)));
	END Test.

positive: explicit variable integer to short integer conversion

	MODULE Test;
	VAR integer: SIGNED16; shortint: SIGNED8;
	BEGIN integer := SHORT (integer);
	END Test.

positive: explicit variable integer to long integer conversion

	MODULE Test;
	VAR integer: SIGNED16; longint: SIGNED32;
	BEGIN longint := LONG (integer);
	END Test.

positive: explicit variable integer to huge integer conversion

	MODULE Test;
	VAR integer: SIGNED16; hugeint: SIGNED64;
	BEGIN hugeint := LONG (LONG (integer));
	END Test.

positive: explicit variable long to short integer conversion

	MODULE Test;
	VAR longint: SIGNED32; shortint: SIGNED8;
	BEGIN shortint := SHORT (SHORT (longint));
	END Test.

positive: explicit variable long to integer conversion

	MODULE Test;
	VAR longint: SIGNED32; integer: SIGNED16;
	BEGIN integer := SHORT (longint);
	END Test.

positive: explicit variable long to huge integer conversion

	MODULE Test;
	VAR longint: SIGNED32; hugeint: SIGNED64;
	BEGIN hugeint := LONG (longint);
	END Test.

positive: explicit variable huge to short integer conversion

	MODULE Test;
	VAR hugeint: SIGNED64; shortint: SIGNED8;
	BEGIN shortint := SHORT (SHORT (SHORT (hugeint)));
	END Test.

positive: explicit variable huge to integer conversion

	MODULE Test;
	VAR hugeint: SIGNED64; integer: SIGNED16;
	BEGIN integer := SHORT (SHORT (hugeint));
	END Test.

positive: explicit variable huge to long integer conversion

	MODULE Test;
	VAR hugeint: SIGNED64; longint: SIGNED32;
	BEGIN hugeint := SHORT (hugeint);
	END Test.

negative: explicit variable real to short integer conversion

	MODULE Test;
	VAR real: FLOAT32; shortint: SIGNED8;
	BEGIN shortint := ENTIER (real);
	END Test.

negative: explicit variable real to integer conversion

	MODULE Test;
	VAR real: FLOAT32; integer: SIGNED16;
	BEGIN integer := ENTIER (real);
	END Test.

positive: explicit variable real to long integer conversion

	MODULE Test;
	VAR real: FLOAT32; longint: SIGNED32;
	BEGIN longint := ENTIER (real);
	END Test.

positive: explicit variable real to huge integer conversion

	MODULE Test;
	VAR real: FLOAT32; hugeint: SIGNED64;
	BEGIN hugeint := ENTIER (real);
	END Test.

negative: explicit variable long real to short integer conversion

	MODULE Test;
	VAR longreal: FLOAT64; shortint: SIGNED8;
	BEGIN shortint := ENTIER (longreal);
	END Test.

negative: explicit variable long real to integer conversion

	MODULE Test;
	VAR longreal: FLOAT64; integer: SIGNED16;
	BEGIN integer := ENTIER (longreal);
	END Test.

positive: explicit variable long real to long integer conversion

	MODULE Test;
	VAR longreal: FLOAT64; longint: SIGNED32;
	BEGIN longint := ENTIER (longreal);
	END Test.

positive: explicit variable long real to huge integer conversion

	MODULE Test;
	VAR longreal: FLOAT64; hugeint: SIGNED64;
	BEGIN hugeint := ENTIER (longreal);
	END Test.


# for statement

negative: for statement with unknown counter

	MODULE Test;
	BEGIN FOR i := 0 TO 10 DO END
	END Test.

negative: for statement with constant as counter

	MODULE Test;
	CONST i = 0;
	BEGIN FOR i := 0 TO 10 DO END
	END Test.

negative: for statement with type as counter

	MODULE Test;
	TYPE i = SIGNED32;
	BEGIN FOR i := 0 TO 10 DO END
	END Test.

positive: for statement with variable as counter

	MODULE Test;
	VAR i: SIGNED16;
	BEGIN FOR i := 0 TO 10 DO END
	END Test.

positive: for statement with parameter as counter

	MODULE Test;
	PROCEDURE Procedure (i: SIGNED16);
	BEGIN FOR i := 0 TO 10 DO END
	END Procedure;
	END Test.

negative: for statement with procedure as counter

	MODULE Test;
	PROCEDURE i; END i;
	BEGIN FOR i := 0 TO 10 DO END
	END Test.

negative: for statement with constant counter

	MODULE Test;
	VAR s, e: SIGNED16;
	BEGIN FOR 0 := s TO e DO END
	END Test.

positive: for statement with constant start counter

	MODULE Test;
	VAR i, e: SIGNED16;
	BEGIN FOR i := 0 TO e DO END
	END Test.

positive: for statement with constant end counter

	MODULE Test;
	VAR i, s: SIGNED16;
	BEGIN FOR i := s TO 0 DO END
	END Test.

positive: for statement with variable counter

	MODULE Test;
	VAR i: SIGNED16;
	BEGIN FOR i := 0 TO 10 DO END
	END Test.

positive: for statement with variable start counter

	MODULE Test;
	VAR i, s: SIGNED16;
	BEGIN FOR i := s TO 10 DO END
	END Test.

positive: for statement with variable end counter

	MODULE Test;
	VAR i, e: SIGNED16;
	BEGIN FOR i := 0 TO e DO END
	END Test.

negative: for statement with variable increment

	MODULE Test;
	VAR i, s: SIGNED16;
	BEGIN FOR i := 0 TO 10 BY s DO END
	END Test.

positive: for statement with parameter counter

	MODULE Test;
	PROCEDURE P (i: SIGNED16);
	BEGIN FOR i := 0 TO 10 DO END
	END P;
	END Test.

positive: for statement with variable parameter counter

	MODULE Test;
	PROCEDURE P (VAR i: SIGNED16);
	BEGIN FOR i := 0 TO 10 DO END
	END P;
	END Test.

negative: for statement with constant parameter counter

	MODULE Test;
	PROCEDURE P (CONST i: SIGNED16);
	BEGIN FOR i := 0 TO 10 DO END
	END P;
	END Test.

positive: for statement with parameter start counter

	MODULE Test;
	VAR i: SIGNED16;
	PROCEDURE P (s: SIGNED16);
	BEGIN FOR i := s TO 10 DO END
	END P;
	END Test.

positive: for statement with variable parameter start counter

	MODULE Test;
	VAR i: SIGNED16;
	PROCEDURE P (VAR s: SIGNED16);
	BEGIN FOR i := s TO 10 DO END
	END P;
	END Test.

positive: for statement with constant parameter start counter

	MODULE Test;
	VAR i: SIGNED16;
	PROCEDURE P (CONST s: SIGNED16);
	BEGIN FOR i := s TO 10 DO END
	END P;
	END Test.

positive: for statement with parameter end counter

	MODULE Test;
	VAR i: SIGNED16;
	PROCEDURE P (e: SIGNED16);
	BEGIN FOR i := 0 TO e DO END
	END P;
	END Test.

positive: for statement with variable parameter end counter

	MODULE Test;
	VAR i: SIGNED16;
	PROCEDURE P (VAR e: SIGNED16);
	BEGIN FOR i := 0 TO e DO END
	END P;
	END Test.

positive: for statement with constant parameter end counter

	MODULE Test;
	VAR i: SIGNED16;
	PROCEDURE P (CONST e: SIGNED16);
	BEGIN FOR i := 0 TO e DO END
	END P;
	END Test.

negative: for statement with parameter increment

	MODULE Test;
	VAR i: SIGNED16;
	PROCEDURE P (s: SIGNED16);
	BEGIN FOR i := 0 TO 10 BY s DO END
	END P;
	END Test.

negative: for statement with variable parameter increment

	MODULE Test;
	VAR i: SIGNED16;
	PROCEDURE P (VAR s: SIGNED16);
	BEGIN FOR i := 0 TO 10 BY s DO END
	END P;
	END Test.

negative: for statement with constant parameter increment

	MODULE Test;
	VAR i: SIGNED16;
	PROCEDURE P (CONST s: SIGNED16);
	BEGIN FOR i := 0 TO 10 BY s DO END
	END P;
	END Test.

positive: for statement with positive constant increment

	MODULE Test;
	VAR i: SIGNED16;
	BEGIN FOR i := 0 TO 10 BY 1 DO END
	END Test.

positive: for statement with negative constant increment

	MODULE Test;
	VAR i: SIGNED16;
	BEGIN FOR i := 0 TO 10 BY -1 DO END
	END Test.

negative: for statement with zero increment

	MODULE Test;
	VAR i: SIGNED16;
	BEGIN FOR i := 0 TO 10 BY 0 DO END
	END Test.

negative: for statement with counter of type boolean

	MODULE Test;
	VAR i, s, e: BOOLEAN;
	BEGIN FOR i := s TO e DO END
	END Test.

negative: for statement with counter of type character

	MODULE Test;
	VAR i, s, e: CHAR;
	BEGIN FOR i := s TO e DO END
	END Test.

positive: for statement with counter of type short integer

	MODULE Test;
	VAR i, s, e: SIGNED8;
	BEGIN FOR i := s TO e DO END
	END Test.

positive: for statement with counter of type integer

	MODULE Test;
	VAR i, s, e: SIGNED16;
	BEGIN FOR i := s TO e DO END
	END Test.

positive: for statement with counter of type long integer

	MODULE Test;
	VAR i, s, e: SIGNED32;
	BEGIN FOR i := s TO e DO END
	END Test.

positive: for statement with counter of type huge integer

	MODULE Test;
	VAR i, s, e: SIGNED64;
	BEGIN FOR i := s TO e DO END
	END Test.

negative: for statement with counter of type real

	MODULE Test;
	VAR i, s, e: FLOAT32;
	BEGIN FOR i := s TO e DO END
	END Test.

negative: for statement with counter of type long real

	MODULE Test;
	VAR i, s, e: FLOAT32;
	BEGIN FOR i := s TO e DO END
	END Test.

negative: for statement with counter of type set

	MODULE Test;
	VAR i, s, e: SET;
	BEGIN FOR i := s TO e DO END
	END Test.

negative: for statement with counter of type array

	MODULE Test;
	VAR i, s, e: ARRAY 10 OF CHAR;
	BEGIN FOR i := s TO e DO END
	END Test.

negative: for statement with counter of type record

	MODULE Test;
	VAR i, s, e: RECORD END;
	BEGIN FOR i := s TO e DO END
	END Test.

negative: for statement with counter of type object

	MODULE Test;
	VAR i, s, e: OBJECT END;
	BEGIN FOR i := s TO e DO END
	END Test.

negative: for statement with counter of type pointer

	MODULE Test;
	VAR i, s, e: POINTER TO RECORD;
	BEGIN FOR i := s TO e DO END
	END Test.

negative: for statement with counter of type procedure

	MODULE Test;
	VAR i, s, e: PROCEDURE;
	BEGIN FOR i := s TO e DO END
	END Test.

positive: for statement with short integer counter and short integer start counter

	MODULE Test;
	VAR i, s: SIGNED8;
	BEGIN FOR i := s TO 10 DO END
	END Test.

negative: for statement with short integer counter and integer start counter

	MODULE Test;
	VAR i: SIGNED8; s: SIGNED16;
	BEGIN FOR i := s TO 10 DO END
	END Test.

negative: for statement with short integer counter and long integer start counter

	MODULE Test;
	VAR i: SIGNED8; s: SIGNED32;
	BEGIN FOR i := s TO 10 DO END
	END Test.

negative: for statement with short integer counter and huge integer start counter

	MODULE Test;
	VAR i: SIGNED8; s: SIGNED64;
	BEGIN FOR i := s TO 10 DO END
	END Test.

positive: for statement with integer counter and short integer start counter

	MODULE Test;
	VAR i: SIGNED16; s: SIGNED8;
	BEGIN FOR i := s TO 10 DO END
	END Test.

positive: for statement with integer counter and integer start counter

	MODULE Test;
	VAR i, s: SIGNED16;
	BEGIN FOR i := s TO 10 DO END
	END Test.

negative: for statement with integer counter and long integer start counter

	MODULE Test;
	VAR i: SIGNED16; s: SIGNED32;
	BEGIN FOR i := s TO 10 DO END
	END Test.

negative: for statement with integer counter and huge integer start counter

	MODULE Test;
	VAR i: SIGNED16; s: SIGNED64;
	BEGIN FOR i := s TO 10 DO END
	END Test.

positive: for statement with long integer counter and short integer start counter

	MODULE Test;
	VAR i: SIGNED32; s: SIGNED8;
	BEGIN FOR i := s TO 10 DO END
	END Test.

positive: for statement with long integer counter and integer start counter

	MODULE Test;
	VAR i: SIGNED32; s: SIGNED16;
	BEGIN FOR i := s TO 10 DO END
	END Test.

positive: for statement with long integer counter and long integer start counter

	MODULE Test;
	VAR i, s: SIGNED32;
	BEGIN FOR i := s TO 10 DO END
	END Test.

negative: for statement with long integer counter and huge integer start counter

	MODULE Test;
	VAR i: SIGNED32; s: SIGNED64;
	BEGIN FOR i := s TO 10 DO END
	END Test.

positive: for statement with huge integer counter and short integer start counter

	MODULE Test;
	VAR i: SIGNED64; s: SIGNED8;
	BEGIN FOR i := s TO 10 DO END
	END Test.

positive: for statement with huge integer counter and integer start counter

	MODULE Test;
	VAR i: SIGNED64; s: SIGNED16;
	BEGIN FOR i := s TO 10 DO END
	END Test.

positive: for statement with huge integer counter and long integer start counter

	MODULE Test;
	VAR i: SIGNED64; s: SIGNED32;
	BEGIN FOR i := s TO 10 DO END
	END Test.

positive: for statement with huge integer counter and huge integer start counter

	MODULE Test;
	VAR i, s: SIGNED64;
	BEGIN FOR i := s TO 10 DO END
	END Test.

positive: for statement with short integer counter and short integer end counter

	MODULE Test;
	VAR i, e: SIGNED8;
	BEGIN FOR i := 0 TO e DO END
	END Test.

negative: for statement with short integer counter and integer end counter

	MODULE Test;
	VAR i: SIGNED8; e: SIGNED16;
	BEGIN FOR i := 0 TO e DO END
	END Test.

negative: for statement with short integer counter and long integer end counter

	MODULE Test;
	VAR i: SIGNED8; e: SIGNED32;
	BEGIN FOR i := 0 TO e DO END
	END Test.

negative: for statement with short integer counter and huge integer end counter

	MODULE Test;
	VAR i: SIGNED8; e: SIGNED64;
	BEGIN FOR i := 0 TO e DO END
	END Test.

positive: for statement with integer counter and short integer end counter

	MODULE Test;
	VAR i: SIGNED16; e: SIGNED8;
	BEGIN FOR i := 0 TO e DO END
	END Test.

positive: for statement with integer counter and integer end counter

	MODULE Test;
	VAR i, e: SIGNED16;
	BEGIN FOR i := 0 TO e DO END
	END Test.

negative: for statement with integer counter and long integer end counter

	MODULE Test;
	VAR i: SIGNED16; e: SIGNED32;
	BEGIN FOR i := 0 TO e DO END
	END Test.

negative: for statement with integer counter and huge integer end counter

	MODULE Test;
	VAR i: SIGNED16; e: SIGNED64;
	BEGIN FOR i := 0 TO e DO END
	END Test.

positive: for statement with long integer counter and short integer end counter

	MODULE Test;
	VAR i: SIGNED32; e: SIGNED8;
	BEGIN FOR i := 0 TO e DO END
	END Test.

positive: for statement with long integer counter and integer end counter

	MODULE Test;
	VAR i: SIGNED32; e: SIGNED16;
	BEGIN FOR i := 0 TO e DO END
	END Test.

positive: for statement with long integer counter and long integer end counter

	MODULE Test;
	VAR i, e: SIGNED32;
	BEGIN FOR i := 0 TO e DO END
	END Test.

negative: for statement with long integer counter and huge integer end counter

	MODULE Test;
	VAR i: SIGNED32; e: SIGNED64;
	BEGIN FOR i := 0 TO e DO END
	END Test.

positive: for statement with huge integer counter and short integer end counter

	MODULE Test;
	VAR i: SIGNED64; e: SIGNED8;
	BEGIN FOR i := 0 TO e DO END
	END Test.

positive: for statement with huge integer counter and integer end counter

	MODULE Test;
	VAR i: SIGNED64; e: SIGNED16;
	BEGIN FOR i := 0 TO e DO END
	END Test.

positive: for statement with huge integer counter and long integer end counter

	MODULE Test;
	VAR i: SIGNED64; e: SIGNED32;
	BEGIN FOR i := 0 TO e DO END
	END Test.

positive: for statement with huge integer counter and huge integer end counter

	MODULE Test;
	VAR i, e: SIGNED64;
	BEGIN FOR i := 0 TO e DO END
	END Test.


# return statement

negative: return statement with value in module body

	MODULE Test;
	BEGIN RETURN 0
	END Test.

positive: return statement without value in module body

	MODULE Test;
	BEGIN RETURN
	END Test.

negative: return statement with value in object body

	MODULE Test;
	TYPE Object = OBJECT
	BEGIN RETURN 0
	END Object;
	END Test.

positive: return statement without value in object body

	MODULE Test;
	TYPE Object = OBJECT
	BEGIN RETURN
	END Object;
	END Test.

positive: return statement with value in procedure with return type

	MODULE Test;
	PROCEDURE Procedure (): SIGNED16;
	BEGIN RETURN 0
	END Procedure;
	END Test.

negative: return statement without value in procedure with return type

	MODULE Test;
	PROCEDURE Procedure (): SIGNED16;
	BEGIN RETURN
	END Procedure;
	END Test.

negative: return statement with value in procedure without return type

	MODULE Test;
	PROCEDURE Procedure;
	BEGIN RETURN 0
	END Procedure;
	END Test.

positive: return statement without value in procedure without return type

	MODULE Test;
	PROCEDURE Procedure;
	BEGIN RETURN
	END Procedure;
	END Test.

positive: procedure with boolean as return type returning boolean

	MODULE Test;
	PROCEDURE Procedure (value: BOOLEAN): BOOLEAN; BEGIN RETURN value END Procedure;
	END Test.

negative: procedure with boolean as return type returning character

	MODULE Test;
	PROCEDURE Procedure (value: CHAR): BOOLEAN; BEGIN RETURN value END Procedure;
	END Test.

negative: procedure with boolean as return type returning integer

	MODULE Test;
	PROCEDURE Procedure (value: SIGNED16): BOOLEAN; BEGIN RETURN value END Procedure;
	END Test.

negative: procedure with boolean as return type returning real

	MODULE Test;
	PROCEDURE Procedure (value: FLOAT32): BOOLEAN; BEGIN RETURN value END Procedure;
	END Test.

negative: procedure with boolean as return type returning set

	MODULE Test;
	PROCEDURE Procedure (value: SET): BOOLEAN; BEGIN RETURN value END Procedure;
	END Test.

negative: procedure with boolean as return type returning array

	MODULE Test;
	PROCEDURE Procedure (value: ARRAY 10 OF CHAR): BOOLEAN; BEGIN RETURN value END Procedure;
	END Test.

negative: procedure with boolean as return type returning record

	MODULE Test;
	PROCEDURE Procedure (value: RECORD END): BOOLEAN; BEGIN RETURN value END Procedure;
	END Test.

negative: procedure with boolean as return type returning object

	MODULE Test;
	PROCEDURE Procedure (value: OBJECT END): BOOLEAN; BEGIN RETURN value END Procedure;
	END Test.

negative: procedure with boolean as return type returning base object

	MODULE Test;
	PROCEDURE Procedure (value: OBJECT): BOOLEAN; BEGIN RETURN value END Procedure;
	END Test.

negative: procedure with boolean as return type returning pointer to array

	MODULE Test;
	PROCEDURE Procedure (value: POINTER TO ARRAY 10 OF CHAR): BOOLEAN; BEGIN RETURN value END Procedure;
	END Test.

negative: procedure with boolean as return type returning pointer to record

	MODULE Test;
	PROCEDURE Procedure (value: POINTER TO RECORD END): BOOLEAN; BEGIN RETURN value END Procedure;
	END Test.

negative: procedure with boolean as return type returning procedure

	MODULE Test;
	PROCEDURE Procedure (value: PROCEDURE): BOOLEAN; BEGIN RETURN value END Procedure;
	END Test.

negative: procedure with character as return type returning boolean

	MODULE Test;
	PROCEDURE Procedure (value: BOOLEAN): CHAR; BEGIN RETURN value END Procedure;
	END Test.

positive: procedure with character as return type returning character

	MODULE Test;
	PROCEDURE Procedure (value: CHAR): CHAR; BEGIN RETURN value END Procedure;
	END Test.

negative: procedure with character as return type returning integer

	MODULE Test;
	PROCEDURE Procedure (value: SIGNED16): CHAR; BEGIN RETURN value END Procedure;
	END Test.

negative: procedure with character as return type returning real

	MODULE Test;
	PROCEDURE Procedure (value: FLOAT32): CHAR; BEGIN RETURN value END Procedure;
	END Test.

negative: procedure with character as return type returning set

	MODULE Test;
	PROCEDURE Procedure (value: SET): CHAR; BEGIN RETURN value END Procedure;
	END Test.

negative: procedure with character as return type returning array

	MODULE Test;
	PROCEDURE Procedure (value: ARRAY 10 OF CHAR): CHAR; BEGIN RETURN value END Procedure;
	END Test.

negative: procedure with character as return type returning record

	MODULE Test;
	PROCEDURE Procedure (value: RECORD END): CHAR; BEGIN RETURN value END Procedure;
	END Test.

negative: procedure with character as return type returning object

	MODULE Test;
	PROCEDURE Procedure (value: OBJECT END): CHAR; BEGIN RETURN value END Procedure;
	END Test.

negative: procedure with character as return type returning base object

	MODULE Test;
	PROCEDURE Procedure (value: OBJECT): CHAR; BEGIN RETURN value END Procedure;
	END Test.

negative: procedure with character as return type returning pointer to array

	MODULE Test;
	PROCEDURE Procedure (value: POINTER TO ARRAY 10 OF CHAR): CHAR; BEGIN RETURN value END Procedure;
	END Test.

negative: procedure with character as return type returning pointer to record

	MODULE Test;
	PROCEDURE Procedure (value: POINTER TO RECORD END): CHAR; BEGIN RETURN value END Procedure;
	END Test.

negative: procedure with character as return type returning procedure

	MODULE Test;
	PROCEDURE Procedure (value: PROCEDURE): CHAR; BEGIN RETURN value END Procedure;
	END Test.

negative: procedure with short integer as return type returning boolean

	MODULE Test;
	PROCEDURE Procedure (value: BOOLEAN): SIGNED8; BEGIN RETURN value END Procedure;
	END Test.

negative: procedure with short integer as return type returning character

	MODULE Test;
	PROCEDURE Procedure (value: CHAR): SIGNED8; BEGIN RETURN value END Procedure;
	END Test.

positive: procedure with short integer as return type returning short integer

	MODULE Test;
	PROCEDURE Procedure (value: SIGNED8): SIGNED8; BEGIN RETURN value END Procedure;
	END Test.

negative: procedure with short integer as return type returning integer

	MODULE Test;
	PROCEDURE Procedure (value: SIGNED16): SIGNED8; BEGIN RETURN value END Procedure;
	END Test.

negative: procedure with short integer as return type returning long integer

	MODULE Test;
	PROCEDURE Procedure (value: SIGNED32): SIGNED8; BEGIN RETURN value END Procedure;
	END Test.

negative: procedure with short integer as return type returning huge integer

	MODULE Test;
	PROCEDURE Procedure (value: SIGNED64): SIGNED8; BEGIN RETURN value END Procedure;
	END Test.

negative: procedure with short integer as return type returning real

	MODULE Test;
	PROCEDURE Procedure (value: FLOAT32): SIGNED8; BEGIN RETURN value END Procedure;
	END Test.

negative: procedure with short integer as return type returning set

	MODULE Test;
	PROCEDURE Procedure (value: SET): SIGNED8; BEGIN RETURN value END Procedure;
	END Test.

negative: procedure with short integer as return type returning array

	MODULE Test;
	PROCEDURE Procedure (value: ARRAY 10 OF CHAR): SIGNED8; BEGIN RETURN value END Procedure;
	END Test.

negative: procedure with short integer as return type returning record

	MODULE Test;
	PROCEDURE Procedure (value: RECORD END): SIGNED8; BEGIN RETURN value END Procedure;
	END Test.

negative: procedure with short integer as return type returning object

	MODULE Test;
	PROCEDURE Procedure (value: OBJECT END): SIGNED8; BEGIN RETURN value END Procedure;
	END Test.

negative: procedure with short integer as return type returning base object

	MODULE Test;
	PROCEDURE Procedure (value: OBJECT): SIGNED8; BEGIN RETURN value END Procedure;
	END Test.

negative: procedure with short integer as return type returning pointer to array

	MODULE Test;
	PROCEDURE Procedure (value: POINTER TO ARRAY 10 OF CHAR): SIGNED8; BEGIN RETURN value END Procedure;
	END Test.

negative: procedure with short integer as return type returning pointer to record

	MODULE Test;
	PROCEDURE Procedure (value: POINTER TO RECORD END): SIGNED8; BEGIN RETURN value END Procedure;
	END Test.

negative: procedure with short integer as return type returning procedure

	MODULE Test;
	PROCEDURE Procedure (value: PROCEDURE): SIGNED8; BEGIN RETURN value END Procedure;
	END Test.

negative: procedure with integer as return type returning boolean

	MODULE Test;
	PROCEDURE Procedure (value: BOOLEAN): SIGNED16; BEGIN RETURN value END Procedure;
	END Test.

negative: procedure with integer as return type returning character

	MODULE Test;
	PROCEDURE Procedure (value: CHAR): SIGNED16; BEGIN RETURN value END Procedure;
	END Test.

positive: procedure with integer as return type returning short integer

	MODULE Test;
	PROCEDURE Procedure (value: SIGNED8): SIGNED16; BEGIN RETURN value END Procedure;
	END Test.

positive: procedure with integer as return type returning integer

	MODULE Test;
	PROCEDURE Procedure (value: SIGNED16): SIGNED16; BEGIN RETURN value END Procedure;
	END Test.

negative: procedure with integer as return type returning long integer

	MODULE Test;
	PROCEDURE Procedure (value: SIGNED32): SIGNED16; BEGIN RETURN value END Procedure;
	END Test.

negative: procedure with integer as return type returning huge integer

	MODULE Test;
	PROCEDURE Procedure (value: SIGNED64): SIGNED16; BEGIN RETURN value END Procedure;
	END Test.

negative: procedure with integer as return type returning real

	MODULE Test;
	PROCEDURE Procedure (value: FLOAT32): SIGNED16; BEGIN RETURN value END Procedure;
	END Test.

negative: procedure with integer as return type returning set

	MODULE Test;
	PROCEDURE Procedure (value: SET): SIGNED16; BEGIN RETURN value END Procedure;
	END Test.

negative: procedure with integer as return type returning array

	MODULE Test;
	PROCEDURE Procedure (value: ARRAY 10 OF CHAR): SIGNED16; BEGIN RETURN value END Procedure;
	END Test.

negative: procedure with integer as return type returning record

	MODULE Test;
	PROCEDURE Procedure (value: RECORD END): SIGNED16; BEGIN RETURN value END Procedure;
	END Test.

negative: procedure with integer as return type returning object

	MODULE Test;
	PROCEDURE Procedure (value: OBJECT END): SIGNED16; BEGIN RETURN value END Procedure;
	END Test.

negative: procedure with integer as return type returning base object

	MODULE Test;
	PROCEDURE Procedure (value: OBJECT): SIGNED16; BEGIN RETURN value END Procedure;
	END Test.

negative: procedure with integer as return type returning pointer to array

	MODULE Test;
	PROCEDURE Procedure (value: POINTER TO ARRAY 10 OF CHAR): SIGNED16; BEGIN RETURN value END Procedure;
	END Test.

negative: procedure with integer as return type returning pointer to record

	MODULE Test;
	PROCEDURE Procedure (value: POINTER TO RECORD END): SIGNED16; BEGIN RETURN value END Procedure;
	END Test.

negative: procedure with integer as return type returning procedure

	MODULE Test;
	PROCEDURE Procedure (value: PROCEDURE): SIGNED16; BEGIN RETURN value END Procedure;
	END Test.

negative: procedure with long integer as return type returning boolean

	MODULE Test;
	PROCEDURE Procedure (value: BOOLEAN): SIGNED32; BEGIN RETURN value END Procedure;
	END Test.

negative: procedure with long integer as return type returning character

	MODULE Test;
	PROCEDURE Procedure (value: CHAR): SIGNED32; BEGIN RETURN value END Procedure;
	END Test.

positive: procedure with long integer as return type returning short integer

	MODULE Test;
	PROCEDURE Procedure (value: SIGNED8): SIGNED32; BEGIN RETURN value END Procedure;
	END Test.

positive: procedure with long integer as return type returning integer

	MODULE Test;
	PROCEDURE Procedure (value: SIGNED16): SIGNED32; BEGIN RETURN value END Procedure;
	END Test.

positive: procedure with long integer as return type returning long integer

	MODULE Test;
	PROCEDURE Procedure (value: SIGNED32): SIGNED32; BEGIN RETURN value END Procedure;
	END Test.

negative: procedure with long integer as return type returning huge integer

	MODULE Test;
	PROCEDURE Procedure (value: SIGNED64): SIGNED32; BEGIN RETURN value END Procedure;
	END Test.

negative: procedure with long integer as return type returning real

	MODULE Test;
	PROCEDURE Procedure (value: FLOAT32): SIGNED32; BEGIN RETURN value END Procedure;
	END Test.

negative: procedure with long integer as return type returning set

	MODULE Test;
	PROCEDURE Procedure (value: SET): SIGNED32; BEGIN RETURN value END Procedure;
	END Test.

negative: procedure with long integer as return type returning array

	MODULE Test;
	PROCEDURE Procedure (value: ARRAY 10 OF CHAR): SIGNED32; BEGIN RETURN value END Procedure;
	END Test.

negative: procedure with long integer as return type returning record

	MODULE Test;
	PROCEDURE Procedure (value: RECORD END): SIGNED32; BEGIN RETURN value END Procedure;
	END Test.

negative: procedure with long integer as return type returning object

	MODULE Test;
	PROCEDURE Procedure (value: OBJECT END): SIGNED32; BEGIN RETURN value END Procedure;
	END Test.

negative: procedure with long integer as return type returning base object

	MODULE Test;
	PROCEDURE Procedure (value: OBJECT): SIGNED32; BEGIN RETURN value END Procedure;
	END Test.

negative: procedure with long integer as return type returning pointer to array

	MODULE Test;
	PROCEDURE Procedure (value: POINTER TO ARRAY 10 OF CHAR): SIGNED32; BEGIN RETURN value END Procedure;
	END Test.

negative: procedure with long integer as return type returning pointer to record

	MODULE Test;
	PROCEDURE Procedure (value: POINTER TO RECORD END): SIGNED32; BEGIN RETURN value END Procedure;
	END Test.

negative: procedure with long integer as return type returning procedure

	MODULE Test;
	PROCEDURE Procedure (value: PROCEDURE): SIGNED32; BEGIN RETURN value END Procedure;
	END Test.

negative: procedure with huge integer as return type returning boolean

	MODULE Test;
	PROCEDURE Procedure (value: BOOLEAN): SIGNED64; BEGIN RETURN value END Procedure;
	END Test.

negative: procedure with huge integer as return type returning character

	MODULE Test;
	PROCEDURE Procedure (value: CHAR): SIGNED64; BEGIN RETURN value END Procedure;
	END Test.

positive: procedure with huge integer as return type returning short integer

	MODULE Test;
	PROCEDURE Procedure (value: SIGNED8): SIGNED64; BEGIN RETURN value END Procedure;
	END Test.

positive: procedure with huge integer as return type returning integer

	MODULE Test;
	PROCEDURE Procedure (value: SIGNED16): SIGNED64; BEGIN RETURN value END Procedure;
	END Test.

positive: procedure with huge integer as return type returning long integer

	MODULE Test;
	PROCEDURE Procedure (value: SIGNED32): SIGNED64; BEGIN RETURN value END Procedure;
	END Test.

positive: procedure with huge integer as return type returning huge integer

	MODULE Test;
	PROCEDURE Procedure (value: SIGNED64): SIGNED64; BEGIN RETURN value END Procedure;
	END Test.

negative: procedure with huge integer as return type returning real

	MODULE Test;
	PROCEDURE Procedure (value: FLOAT32): SIGNED64; BEGIN RETURN value END Procedure;
	END Test.

negative: procedure with huge integer as return type returning set

	MODULE Test;
	PROCEDURE Procedure (value: SET): SIGNED64; BEGIN RETURN value END Procedure;
	END Test.

negative: procedure with huge integer as return type returning array

	MODULE Test;
	PROCEDURE Procedure (value: ARRAY 10 OF CHAR): SIGNED64; BEGIN RETURN value END Procedure;
	END Test.

negative: procedure with huge integer as return type returning record

	MODULE Test;
	PROCEDURE Procedure (value: RECORD END): SIGNED64; BEGIN RETURN value END Procedure;
	END Test.

negative: procedure with huge integer as return type returning object

	MODULE Test;
	PROCEDURE Procedure (value: OBJECT END): SIGNED64; BEGIN RETURN value END Procedure;
	END Test.

negative: procedure with huge integer as return type returning base object

	MODULE Test;
	PROCEDURE Procedure (value: OBJECT): SIGNED64; BEGIN RETURN value END Procedure;
	END Test.

negative: procedure with huge integer as return type returning pointer to array

	MODULE Test;
	PROCEDURE Procedure (value: POINTER TO ARRAY 10 OF CHAR): SIGNED64; BEGIN RETURN value END Procedure;
	END Test.

negative: procedure with huge integer as return type returning pointer to record

	MODULE Test;
	PROCEDURE Procedure (value: POINTER TO RECORD END): SIGNED64; BEGIN RETURN value END Procedure;
	END Test.

negative: procedure with huge integer as return type returning procedure

	MODULE Test;
	PROCEDURE Procedure (value: PROCEDURE): SIGNED64; BEGIN RETURN value END Procedure;
	END Test.

negative: procedure with real as return type returning boolean

	MODULE Test;
	PROCEDURE Procedure (value: BOOLEAN): FLOAT32; BEGIN RETURN value END Procedure;
	END Test.

negative: procedure with real as return type returning character

	MODULE Test;
	PROCEDURE Procedure (value: CHAR): FLOAT32; BEGIN RETURN value END Procedure;
	END Test.

positive: procedure with real as return type returning short integer

	MODULE Test;
	PROCEDURE Procedure (value: SIGNED8): FLOAT32; BEGIN RETURN value END Procedure;
	END Test.

positive: procedure with real as return type returning integer

	MODULE Test;
	PROCEDURE Procedure (value: SIGNED16): FLOAT32; BEGIN RETURN value END Procedure;
	END Test.

positive: procedure with real as return type returning long integer

	MODULE Test;
	PROCEDURE Procedure (value: SIGNED32): FLOAT32; BEGIN RETURN value END Procedure;
	END Test.

positive: procedure with real as return type returning huge integer

	MODULE Test;
	PROCEDURE Procedure (value: SIGNED64): FLOAT32; BEGIN RETURN value END Procedure;
	END Test.

positive: procedure with real as return type returning real

	MODULE Test;
	PROCEDURE Procedure (value: FLOAT32): FLOAT32; BEGIN RETURN value END Procedure;
	END Test.

negative: procedure with real as return type returning long real

	MODULE Test;
	PROCEDURE Procedure (value: FLOAT64): FLOAT32; BEGIN RETURN value END Procedure;
	END Test.

negative: procedure with real as return type returning set

	MODULE Test;
	PROCEDURE Procedure (value: SET): FLOAT32; BEGIN RETURN value END Procedure;
	END Test.

negative: procedure with real as return type returning array

	MODULE Test;
	PROCEDURE Procedure (value: ARRAY 10 OF CHAR): FLOAT32; BEGIN RETURN value END Procedure;
	END Test.

negative: procedure with real as return type returning record

	MODULE Test;
	PROCEDURE Procedure (value: RECORD END): FLOAT32; BEGIN RETURN value END Procedure;
	END Test.

negative: procedure with real as return type returning object

	MODULE Test;
	PROCEDURE Procedure (value: OBJECT END): FLOAT32; BEGIN RETURN value END Procedure;
	END Test.

negative: procedure with real as return type returning base object

	MODULE Test;
	PROCEDURE Procedure (value: OBJECT): FLOAT32; BEGIN RETURN value END Procedure;
	END Test.

negative: procedure with real as return type returning pointer to array

	MODULE Test;
	PROCEDURE Procedure (value: POINTER TO ARRAY 10 OF CHAR): FLOAT32; BEGIN RETURN value END Procedure;
	END Test.

negative: procedure with real as return type returning pointer to record

	MODULE Test;
	PROCEDURE Procedure (value: POINTER TO RECORD END): FLOAT32; BEGIN RETURN value END Procedure;
	END Test.

negative: procedure with real as return type returning procedure

	MODULE Test;
	PROCEDURE Procedure (value: PROCEDURE): FLOAT32; BEGIN RETURN value END Procedure;
	END Test.

negative: procedure with long real as return type returning boolean

	MODULE Test;
	PROCEDURE Procedure (value: BOOLEAN): FLOAT64; BEGIN RETURN value END Procedure;
	END Test.

negative: procedure with long real as return type returning character

	MODULE Test;
	PROCEDURE Procedure (value: CHAR): FLOAT64; BEGIN RETURN value END Procedure;
	END Test.

positive: procedure with long real as return type returning short integer

	MODULE Test;
	PROCEDURE Procedure (value: SIGNED8): FLOAT64; BEGIN RETURN value END Procedure;
	END Test.

positive: procedure with long real as return type returning integer

	MODULE Test;
	PROCEDURE Procedure (value: SIGNED16): FLOAT64; BEGIN RETURN value END Procedure;
	END Test.

positive: procedure with long real as return type returning long integer

	MODULE Test;
	PROCEDURE Procedure (value: SIGNED32): FLOAT64; BEGIN RETURN value END Procedure;
	END Test.

positive: procedure with long real as return type returning huge integer

	MODULE Test;
	PROCEDURE Procedure (value: SIGNED64): FLOAT64; BEGIN RETURN value END Procedure;
	END Test.

positive: procedure with long real as return type returning real

	MODULE Test;
	PROCEDURE Procedure (value: FLOAT32): FLOAT64; BEGIN RETURN value END Procedure;
	END Test.

positive: procedure with long real as return type returning long real

	MODULE Test;
	PROCEDURE Procedure (value: FLOAT64): FLOAT64; BEGIN RETURN value END Procedure;
	END Test.

negative: procedure with long real as return type returning set

	MODULE Test;
	PROCEDURE Procedure (value: SET): FLOAT64; BEGIN RETURN value END Procedure;
	END Test.

negative: procedure with long real as return type returning array

	MODULE Test;
	PROCEDURE Procedure (value: ARRAY 10 OF CHAR): FLOAT64; BEGIN RETURN value END Procedure;
	END Test.

negative: procedure with long real as return type returning record

	MODULE Test;
	PROCEDURE Procedure (value: RECORD END): FLOAT64; BEGIN RETURN value END Procedure;
	END Test.

negative: procedure with long real as return type returning object

	MODULE Test;
	PROCEDURE Procedure (value: OBJECT END): FLOAT64; BEGIN RETURN value END Procedure;
	END Test.

negative: procedure with long real as return type returning base object

	MODULE Test;
	PROCEDURE Procedure (value: OBJECT): FLOAT64; BEGIN RETURN value END Procedure;
	END Test.

negative: procedure with long real as return type returning pointer to array

	MODULE Test;
	PROCEDURE Procedure (value: POINTER TO ARRAY 10 OF CHAR): FLOAT64; BEGIN RETURN value END Procedure;
	END Test.

negative: procedure with long real as return type returning pointer to record

	MODULE Test;
	PROCEDURE Procedure (value: POINTER TO RECORD END): FLOAT64; BEGIN RETURN value END Procedure;
	END Test.

negative: procedure with long real as return type returning procedure

	MODULE Test;
	PROCEDURE Procedure (value: PROCEDURE): FLOAT64; BEGIN RETURN value END Procedure;
	END Test.

negative: procedure with set as return type returning boolean

	MODULE Test;
	PROCEDURE Procedure (value: BOOLEAN): SET; BEGIN RETURN value END Procedure;
	END Test.

negative: procedure with set as return type returning character

	MODULE Test;
	PROCEDURE Procedure (value: CHAR): SET; BEGIN RETURN value END Procedure;
	END Test.

negative: procedure with set as return type returning integer

	MODULE Test;
	PROCEDURE Procedure (value: SIGNED16): SET; BEGIN RETURN value END Procedure;
	END Test.

negative: procedure with set as return type returning real

	MODULE Test;
	PROCEDURE Procedure (value: FLOAT32): SET; BEGIN RETURN value END Procedure;
	END Test.

positive: procedure with set as return type returning set

	MODULE Test;
	PROCEDURE Procedure (value: SET): SET; BEGIN RETURN value END Procedure;
	END Test.

negative: procedure with set as return type returning array

	MODULE Test;
	PROCEDURE Procedure (value: ARRAY 10 OF CHAR): SET; BEGIN RETURN value END Procedure;
	END Test.

negative: procedure with set as return type returning record

	MODULE Test;
	PROCEDURE Procedure (value: RECORD END): SET; BEGIN RETURN value END Procedure;
	END Test.

negative: procedure with set as return type returning object

	MODULE Test;
	PROCEDURE Procedure (value: OBJECT END): SET; BEGIN RETURN value END Procedure;
	END Test.

negative: procedure with set as return type returning base object

	MODULE Test;
	PROCEDURE Procedure (value: OBJECT): SET; BEGIN RETURN value END Procedure;
	END Test.

negative: procedure with set as return type returning pointer to array

	MODULE Test;
	PROCEDURE Procedure (value: POINTER TO ARRAY 10 OF CHAR): SET; BEGIN RETURN value END Procedure;
	END Test.

negative: procedure with set as return type returning pointer to record

	MODULE Test;
	PROCEDURE Procedure (value: POINTER TO RECORD END): SET; BEGIN RETURN value END Procedure;
	END Test.

negative: procedure with set as return type returning procedure

	MODULE Test;
	PROCEDURE Procedure (value: PROCEDURE): SET; BEGIN RETURN value END Procedure;
	END Test.

negative: procedure with array as return type returning boolean

	MODULE Test;
	PROCEDURE Procedure (value: BOOLEAN): ARRAY 10 OF CHAR; BEGIN RETURN value END Procedure;
	END Test.

negative: procedure with array as return type returning character

	MODULE Test;
	PROCEDURE Procedure (value: CHAR): ARRAY 10 OF CHAR; BEGIN RETURN value END Procedure;
	END Test.

negative: procedure with array as return type returning integer

	MODULE Test;
	PROCEDURE Procedure (value: SIGNED16): ARRAY 10 OF CHAR; BEGIN RETURN value END Procedure;
	END Test.

negative: procedure with array as return type returning real

	MODULE Test;
	PROCEDURE Procedure (value: FLOAT32): ARRAY 10 OF CHAR; BEGIN RETURN value END Procedure;
	END Test.

negative: procedure with array as return type returning set

	MODULE Test;
	PROCEDURE Procedure (value: SET): ARRAY 10 OF CHAR; BEGIN RETURN value END Procedure;
	END Test.

positive: procedure with array as return type returning compatible array

	MODULE Test;
	PROCEDURE Procedure (value: ARRAY 10 OF CHAR): ARRAY 10 OF CHAR; BEGIN RETURN value END Procedure;
	END Test.

negative: procedure with array as return type returning incompatible array

	MODULE Test;
	PROCEDURE Procedure (value: ARRAY 10 OF SET): ARRAY 10 OF CHAR; BEGIN RETURN value END Procedure;
	END Test.

negative: procedure with array as return type returning open array

	MODULE Test;
	PROCEDURE Procedure (value: ARRAY OF CHAR): ARRAY 10 OF CHAR; BEGIN RETURN value END Procedure;
	END Test.

negative: procedure with array as return type returning record

	MODULE Test;
	PROCEDURE Procedure (value: RECORD END): ARRAY 10 OF CHAR; BEGIN RETURN value END Procedure;
	END Test.

negative: procedure with array as return type returning object

	MODULE Test;
	PROCEDURE Procedure (value: OBJECT END): ARRAY 10 OF CHAR; BEGIN RETURN value END Procedure;
	END Test.

negative: procedure with array as return type returning base object

	MODULE Test;
	PROCEDURE Procedure (value: OBJECT): ARRAY 10 OF CHAR; BEGIN RETURN value END Procedure;
	END Test.

negative: procedure with array as return type returning pointer to array

	MODULE Test;
	PROCEDURE Procedure (value: POINTER TO ARRAY 10 OF CHAR): ARRAY 10 OF CHAR; BEGIN RETURN value END Procedure;
	END Test.

negative: procedure with array as return type returning pointer to record

	MODULE Test;
	PROCEDURE Procedure (value: POINTER TO RECORD END): ARRAY 10 OF CHAR; BEGIN RETURN value END Procedure;
	END Test.

negative: procedure with array as return type returning procedure

	MODULE Test;
	PROCEDURE Procedure (value: PROCEDURE): ARRAY 10 OF CHAR; BEGIN RETURN value END Procedure;
	END Test.

negative: procedure with record as return type returning boolean

	MODULE Test;
	PROCEDURE Procedure (value: BOOLEAN): RECORD END; BEGIN RETURN value END Procedure;
	END Test.

negative: procedure with record as return type returning character

	MODULE Test;
	PROCEDURE Procedure (value: CHAR): RECORD END; BEGIN RETURN value END Procedure;
	END Test.

negative: procedure with record as return type returning integer

	MODULE Test;
	PROCEDURE Procedure (value: SIGNED16): RECORD END; BEGIN RETURN value END Procedure;
	END Test.

negative: procedure with record as return type returning real

	MODULE Test;
	PROCEDURE Procedure (value: FLOAT32): RECORD END; BEGIN RETURN value END Procedure;
	END Test.

negative: procedure with record as return type returning set

	MODULE Test;
	PROCEDURE Procedure (value: SET): RECORD END; BEGIN RETURN value END Procedure;
	END Test.

negative: procedure with record as return type returning array

	MODULE Test;
	PROCEDURE Procedure (value: ARRAY 10 OF CHAR): RECORD END; BEGIN RETURN value END Procedure;
	END Test.

positive: procedure with record as return type returning record

	MODULE Test;
	TYPE Record = RECORD END;
	PROCEDURE Procedure (value: Record): Record; BEGIN RETURN value END Procedure;
	END Test.

positive: procedure with record as return type returning compatible record

	MODULE Test;
	TYPE Record = RECORD END;
	PROCEDURE Procedure (value: RECORD (Record) END): Record; BEGIN RETURN value END Procedure;
	END Test.

negative: procedure with record as return type returning incompatible record

	MODULE Test;
	TYPE Record = RECORD END;
	PROCEDURE Procedure (value: Record): RECORD (Record) END; BEGIN RETURN value END Procedure;
	END Test.

negative: procedure with record as return type returning object

	MODULE Test;
	PROCEDURE Procedure (value: OBJECT END): RECORD END; BEGIN RETURN value END Procedure;
	END Test.

negative: procedure with record as return type returning base object

	MODULE Test;
	PROCEDURE Procedure (value: OBJECT): RECORD END; BEGIN RETURN value END Procedure;
	END Test.

negative: procedure with record as return type returning pointer to array

	MODULE Test;
	PROCEDURE Procedure (value: POINTER TO ARRAY 10 OF CHAR): RECORD END; BEGIN RETURN value END Procedure;
	END Test.

negative: procedure with record as return type returning pointer to record

	MODULE Test;
	PROCEDURE Procedure (value: POINTER TO RECORD END): RECORD END; BEGIN RETURN value END Procedure;
	END Test.

negative: procedure with record as return type returning procedure

	MODULE Test;
	PROCEDURE Procedure (value: PROCEDURE): RECORD END; BEGIN RETURN value END Procedure;
	END Test.

negative: procedure with object as return type returning boolean

	MODULE Test;
	PROCEDURE Procedure (value: BOOLEAN): OBJECT END; BEGIN RETURN value END Procedure;
	END Test.

negative: procedure with object as return type returning character

	MODULE Test;
	PROCEDURE Procedure (value: CHAR): OBJECT END; BEGIN RETURN value END Procedure;
	END Test.

negative: procedure with object as return type returning integer

	MODULE Test;
	PROCEDURE Procedure (value: SIGNED16): OBJECT END; BEGIN RETURN value END Procedure;
	END Test.

negative: procedure with object as return type returning real

	MODULE Test;
	PROCEDURE Procedure (value: FLOAT32): OBJECT END; BEGIN RETURN value END Procedure;
	END Test.

negative: procedure with object as return type returning set

	MODULE Test;
	PROCEDURE Procedure (value: SET): OBJECT END; BEGIN RETURN value END Procedure;
	END Test.

negative: procedure with object as return type returning array

	MODULE Test;
	PROCEDURE Procedure (value: ARRAY 10 OF CHAR): OBJECT END; BEGIN RETURN value END Procedure;
	END Test.

negative: procedure with object as return type returning record

	MODULE Test;
	PROCEDURE Procedure (value: RECORD END): OBJECT END; BEGIN RETURN value END Procedure;
	END Test.

positive: procedure with object as return type returning object

	MODULE Test;
	TYPE Object = OBJECT END Object;
	PROCEDURE Procedure (value: Object): Object; BEGIN RETURN value END Procedure;
	END Test.

positive: procedure with object as return type returning compatible object

	MODULE Test;
	TYPE Object = OBJECT END Object;
	PROCEDURE Procedure (value: OBJECT (Object) END): Object; BEGIN RETURN value END Procedure;
	END Test.

negative: procedure with object as return type returning incompatible object

	MODULE Test;
	TYPE Object = OBJECT END Object;
	PROCEDURE Procedure (value: Object): OBJECT (Object) END; BEGIN RETURN value END Procedure;
	END Test.

negative: procedure with object as return type returning base object

	MODULE Test;
	PROCEDURE Procedure (value: OBJECT): OBJECT END; BEGIN RETURN value END Procedure;
	END Test.

negative: procedure with object as return type returning pointer to array

	MODULE Test;
	PROCEDURE Procedure (value: POINTER TO ARRAY 10 OF CHAR): OBJECT END; BEGIN RETURN value END Procedure;
	END Test.

negative: procedure with object as return type returning pointer to record

	MODULE Test;
	PROCEDURE Procedure (value: POINTER TO RECORD END): OBJECT END; BEGIN RETURN value END Procedure;
	END Test.

negative: procedure with object as return type returning procedure

	MODULE Test;
	PROCEDURE Procedure (value: PROCEDURE): OBJECT END; BEGIN RETURN value END Procedure;
	END Test.

positive: procedure with object as return type returning nil pointer

	MODULE Test;
	PROCEDURE Procedure (): OBJECT END; BEGIN RETURN NIL END Procedure;
	END Test.

negative: procedure with base object as return type returning boolean

	MODULE Test;
	PROCEDURE Procedure (value: BOOLEAN): OBJECT; BEGIN RETURN value END Procedure;
	END Test.

negative: procedure with base object as return type returning character

	MODULE Test;
	PROCEDURE Procedure (value: CHAR): OBJECT; BEGIN RETURN value END Procedure;
	END Test.

negative: procedure with base object as return type returning integer

	MODULE Test;
	PROCEDURE Procedure (value: SIGNED16): OBJECT; BEGIN RETURN value END Procedure;
	END Test.

negative: procedure with base object as return type returning real

	MODULE Test;
	PROCEDURE Procedure (value: FLOAT32): OBJECT; BEGIN RETURN value END Procedure;
	END Test.

negative: procedure with base object as return type returning set

	MODULE Test;
	PROCEDURE Procedure (value: SET): OBJECT; BEGIN RETURN value END Procedure;
	END Test.

negative: procedure with base object as return type returning array

	MODULE Test;
	PROCEDURE Procedure (value: ARRAY 10 OF CHAR): OBJECT; BEGIN RETURN value END Procedure;
	END Test.

negative: procedure with base object as return type returning record

	MODULE Test;
	PROCEDURE Procedure (value: RECORD END): OBJECT; BEGIN RETURN value END Procedure;
	END Test.

positive: procedure with base object as return type returning object

	MODULE Test;
	PROCEDURE Procedure (value: OBJECT END): OBJECT; BEGIN RETURN value END Procedure;
	END Test.

positive: procedure with base object as return type returning base object

	MODULE Test;
	PROCEDURE Procedure (value: OBJECT): OBJECT; BEGIN RETURN value END Procedure;
	END Test.

negative: procedure with base object as return type returning pointer to array

	MODULE Test;
	PROCEDURE Procedure (value: POINTER TO ARRAY 10 OF CHAR): OBJECT; BEGIN RETURN value END Procedure;
	END Test.

negative: procedure with base object as return type returning procedure

	MODULE Test;
	PROCEDURE Procedure (value: PROCEDURE): OBJECT; BEGIN RETURN value END Procedure;
	END Test.

positive: procedure with base object as return type returning pointer to record

	MODULE Test;
	PROCEDURE Procedure (value: POINTER TO RECORD END): OBJECT; BEGIN RETURN value END Procedure;
	END Test.

positive: procedure with base object as return type returning nil pointer

	MODULE Test;
	PROCEDURE Procedure (): OBJECT; BEGIN RETURN NIL END Procedure;
	END Test.

negative: procedure with pointer to array as return type returning boolean

	MODULE Test;
	PROCEDURE Procedure (value: BOOLEAN): POINTER TO ARRAY 10 OF CHAR; BEGIN RETURN value END Procedure;
	END Test.

negative: procedure with pointer to array as return type returning character

	MODULE Test;
	PROCEDURE Procedure (value: CHAR): POINTER TO ARRAY 10 OF CHAR; BEGIN RETURN value END Procedure;
	END Test.

negative: procedure with pointer to array as return type returning integer

	MODULE Test;
	PROCEDURE Procedure (value: SIGNED16): POINTER TO ARRAY 10 OF CHAR; BEGIN RETURN value END Procedure;
	END Test.

negative: procedure with pointer to array as return type returning real

	MODULE Test;
	PROCEDURE Procedure (value: FLOAT32): POINTER TO ARRAY 10 OF CHAR; BEGIN RETURN value END Procedure;
	END Test.

negative: procedure with pointer to array as return type returning set

	MODULE Test;
	PROCEDURE Procedure (value: SET): POINTER TO ARRAY 10 OF CHAR; BEGIN RETURN value END Procedure;
	END Test.

negative: procedure with pointer to array as return type returning array

	MODULE Test;
	PROCEDURE Procedure (value: ARRAY 10 OF CHAR): POINTER TO ARRAY 10 OF CHAR; BEGIN RETURN value END Procedure;
	END Test.

negative: procedure with pointer to array as return type returning record

	MODULE Test;
	PROCEDURE Procedure (value: RECORD END): POINTER TO ARRAY 10 OF CHAR; BEGIN RETURN value END Procedure;
	END Test.

negative: procedure with pointer to array as return type returning object

	MODULE Test;
	PROCEDURE Procedure (value: OBJECT END): POINTER TO ARRAY 10 OF CHAR; BEGIN RETURN value END Procedure;
	END Test.

negative: procedure with pointer to array as return type returning base object

	MODULE Test;
	PROCEDURE Procedure (value: OBJECT): POINTER TO ARRAY 10 OF CHAR; BEGIN RETURN value END Procedure;
	END Test.

positive: procedure with pointer to array as return type returning compatible pointer to array

	MODULE Test;
	PROCEDURE Procedure (value: POINTER TO ARRAY 10 OF CHAR): POINTER TO ARRAY 10 OF CHAR; BEGIN RETURN value END Procedure;
	END Test.

negative: procedure with pointer to array as return type returning incompatible pointer to array

	MODULE Test;
	PROCEDURE Procedure (value: POINTER TO ARRAY 10 OF SET): POINTER TO ARRAY 10 OF CHAR; BEGIN RETURN value END Procedure;
	END Test.

negative: procedure with pointer to array as return type returning pointer to record

	MODULE Test;
	PROCEDURE Procedure (value: POINTER TO RECORD END): POINTER TO ARRAY 10 OF CHAR; BEGIN RETURN value END Procedure;
	END Test.

negative: procedure with pointer to array as return type returning procedure

	MODULE Test;
	PROCEDURE Procedure (value: PROCEDURE): POINTER TO ARRAY 10 OF CHAR; BEGIN RETURN value END Procedure;
	END Test.

positive: procedure with pointer to array as return type returning nil pointer

	MODULE Test;
	PROCEDURE Procedure (): POINTER TO ARRAY 10 OF CHAR; BEGIN RETURN NIL END Procedure;
	END Test.

negative: procedure with pointer to record as return type returning boolean

	MODULE Test;
	PROCEDURE Procedure (value: BOOLEAN): POINTER TO RECORD END; BEGIN RETURN value END Procedure;
	END Test.

negative: procedure with pointer to record as return type returning character

	MODULE Test;
	PROCEDURE Procedure (value: CHAR): POINTER TO RECORD END; BEGIN RETURN value END Procedure;
	END Test.

negative: procedure with pointer to record as return type returning integer

	MODULE Test;
	PROCEDURE Procedure (value: SIGNED16): POINTER TO RECORD END; BEGIN RETURN value END Procedure;
	END Test.

negative: procedure with pointer to record as return type returning real

	MODULE Test;
	PROCEDURE Procedure (value: FLOAT32): POINTER TO RECORD END; BEGIN RETURN value END Procedure;
	END Test.

negative: procedure with pointer to record as return type returning set

	MODULE Test;
	PROCEDURE Procedure (value: SET): POINTER TO RECORD END; BEGIN RETURN value END Procedure;
	END Test.

negative: procedure with pointer to record as return type returning array

	MODULE Test;
	PROCEDURE Procedure (value: ARRAY 10 OF CHAR): POINTER TO RECORD END; BEGIN RETURN value END Procedure;
	END Test.

negative: procedure with pointer to record as return type returning record

	MODULE Test;
	PROCEDURE Procedure (value: RECORD END): POINTER TO RECORD END; BEGIN RETURN value END Procedure;
	END Test.

negative: procedure with pointer to record as return type returning object

	MODULE Test;
	PROCEDURE Procedure (value: OBJECT END): POINTER TO RECORD END; BEGIN RETURN value END Procedure;
	END Test.

negative: procedure with pointer to record as return type returning base object

	MODULE Test;
	PROCEDURE Procedure (value: OBJECT): POINTER TO RECORD END; BEGIN RETURN value END Procedure;
	END Test.

negative: procedure with pointer to record as return type returning pointer to array

	MODULE Test;
	PROCEDURE Procedure (value: POINTER TO ARRAY 10 OF CHAR): POINTER TO RECORD END; BEGIN RETURN value END Procedure;
	END Test.

positive: procedure with pointer to record as return type returning pointer to record

	MODULE Test;
	TYPE Record = RECORD END;
	PROCEDURE Procedure (value: POINTER TO Record): POINTER TO Record; BEGIN RETURN value END Procedure;
	END Test.

positive: procedure with pointer to record as return type returning compatible pointer to record

	MODULE Test;
	TYPE Record = RECORD END;
	PROCEDURE Procedure (value: POINTER TO RECORD (Record) END): POINTER TO Record; BEGIN RETURN value END Procedure;
	END Test.

negative: procedure with pointer to record as return type returning incompatible pointer to record

	MODULE Test;
	TYPE Record = RECORD END;
	PROCEDURE Procedure (value: POINTER TO Record): POINTER TO RECORD (Record) END; BEGIN RETURN value END Procedure;
	END Test.

negative: procedure with pointer to record as return type returning procedure

	MODULE Test;
	PROCEDURE Procedure (value: PROCEDURE): POINTER TO RECORD END; BEGIN RETURN value END Procedure;
	END Test.

positive: procedure with pointer to record as return type returning nil pointer

	MODULE Test;
	PROCEDURE Procedure (): POINTER TO RECORD END; BEGIN RETURN NIL END Procedure;
	END Test.

negative: procedure with procedure as return type returning boolean

	MODULE Test;
	PROCEDURE Procedure (value: BOOLEAN): PROCEDURE; BEGIN RETURN value END Procedure;
	END Test.

negative: procedure with procedure as return type returning character

	MODULE Test;
	PROCEDURE Procedure (value: CHAR): PROCEDURE; BEGIN RETURN value END Procedure;
	END Test.

negative: procedure with procedure as return type returning integer

	MODULE Test;
	PROCEDURE Procedure (value: SIGNED16): PROCEDURE; BEGIN RETURN value END Procedure;
	END Test.

negative: procedure with procedure as return type returning real

	MODULE Test;
	PROCEDURE Procedure (value: FLOAT32): PROCEDURE; BEGIN RETURN value END Procedure;
	END Test.

negative: procedure with procedure as return type returning set

	MODULE Test;
	PROCEDURE Procedure (value: SET): PROCEDURE; BEGIN RETURN value END Procedure;
	END Test.

negative: procedure with procedure as return type returning array

	MODULE Test;
	PROCEDURE Procedure (value: ARRAY 10 OF CHAR): PROCEDURE; BEGIN RETURN value END Procedure;
	END Test.

negative: procedure with procedure as return type returning record

	MODULE Test;
	PROCEDURE Procedure (value: RECORD END): PROCEDURE; BEGIN RETURN value END Procedure;
	END Test.

negative: procedure with procedure as return type returning object

	MODULE Test;
	PROCEDURE Procedure (value: OBJECT END): PROCEDURE; BEGIN RETURN value END Procedure;
	END Test.

negative: procedure with procedure as return type returning base object

	MODULE Test;
	PROCEDURE Procedure (value: OBJECT): PROCEDURE; BEGIN RETURN value END Procedure;
	END Test.

negative: procedure with procedure as return type returning pointer to array

	MODULE Test;
	PROCEDURE Procedure (value: POINTER TO ARRAY 10 OF CHAR): PROCEDURE; BEGIN RETURN value END Procedure;
	END Test.

negative: procedure with procedure as return type returning pointer to record

	MODULE Test;
	PROCEDURE Procedure (value: POINTER TO RECORD END): PROCEDURE; BEGIN RETURN value END Procedure;
	END Test.

positive: procedure with procedure as return type returning compatible procedure

	MODULE Test;
	PROCEDURE Procedure (value: PROCEDURE): PROCEDURE; BEGIN RETURN value END Procedure;
	END Test.

negative: procedure with procedure as return type returning incompatible procedure

	MODULE Test;
	PROCEDURE Procedure (value: PROCEDURE (value: SIGNED16)): PROCEDURE; BEGIN RETURN value END Procedure;
	END Test.

positive: procedure with procedure as return type returning itself

	MODULE Test;
	TYPE Type = PROCEDURE (): Type;
	PROCEDURE Procedure (): Type; BEGIN RETURN Procedure END Procedure;
	END Test.

positive: procedure with procedure as return type returning nil pointer

	MODULE Test;
	PROCEDURE Procedure (): PROCEDURE; BEGIN RETURN NIL END Procedure;
	END Test.


# exit statement

negative: unbounded exit statement

	MODULE Test;
	BEGIN EXIT
	END Test.

positive: exit statement within loop

	MODULE Test;
	BEGIN LOOP EXIT END
	END Test.

negative: exit statement before loop

	MODULE Test;
	BEGIN EXIT ; LOOP END
	END Test.

negative: exit statement after loop

	MODULE Test;
	BEGIN LOOP END ; EXIT
	END Test.

positive: exit statement within nested loop

	MODULE Test;
	BEGIN LOOP LOOP EXIT END END
	END Test.

positive: exit statement before nested loop

	MODULE Test;
	BEGIN LOOP EXIT ; LOOP END END
	END Test.

positive: exit statement after nested loop

	MODULE Test;
	BEGIN LOOP LOOP END ; EXIT END
	END Test.


# assert statement

positive: assert statement with constant true condition

	MODULE Test;
	BEGIN ASSERT (TRUE);
	END Test.

negative: assert statement with constant false condition

	MODULE Test;
	BEGIN ASSERT (FALSE);
	END Test.

positive: unreachable assert statement with constant false condition

	MODULE Test;
	BEGIN IF FALSE THEN ASSERT (FALSE) END;
	END Test.

positive: assert statement with positive number

	MODULE Test;
	BEGIN ASSERT (TRUE, 5);
	END Test.

positive: assert statement with negative number

	MODULE Test;
	BEGIN ASSERT (TRUE, -5);
	END Test.

positive: assert statement with zero number

	MODULE Test;
	BEGIN ASSERT (TRUE, 0);
	END Test.

negative: assert statement with constant condition of type character

	MODULE Test;
	BEGIN ASSERT ('a');
	END Test.

negative: assert statement with constant condition of type integer

	MODULE Test;
	BEGIN ASSERT (5);
	END Test.

negative: assert statement with constant condition of type real

	MODULE Test;
	BEGIN ASSERT (4.5);
	END Test.

negative: assert statement with constant condition of type set

	MODULE Test;
	BEGIN ASSERT ({5});
	END Test.

negative: assert statement with constant condition of type string

	MODULE Test;
	BEGIN ASSERT ("condition");
	END Test.

negative: assert statement with constant condition of type nil pointer

	MODULE Test;
	BEGIN ASSERT (NIL);
	END Test.

positive: assert statement with condition of type boolean

	MODULE Test;
	VAR condition: BOOLEAN;
	BEGIN ASSERT (condition);
	END Test.

negative: assert statement with condition of type character

	MODULE Test;
	VAR condition: CHAR;
	BEGIN ASSERT (condition);
	END Test.

negative: assert statement with condition of type short integer

	MODULE Test;
	VAR condition: SIGNED8;
	BEGIN ASSERT (condition);
	END Test.

negative: assert statement with condition of type integer

	MODULE Test;
	VAR condition: SIGNED16;
	BEGIN ASSERT (condition);
	END Test.

negative: assert statement with condition of type long integer

	MODULE Test;
	VAR condition: SIGNED32;
	BEGIN ASSERT (condition);
	END Test.

negative: assert statement with condition of type huge integer

	MODULE Test;
	VAR condition: SIGNED64;
	BEGIN ASSERT (condition);
	END Test.

negative: assert statement with condition of type real

	MODULE Test;
	VAR condition: FLOAT32;
	BEGIN ASSERT (condition);
	END Test.

negative: assert statement with condition of type long real

	MODULE Test;
	VAR condition: FLOAT64;
	BEGIN ASSERT (condition);
	END Test.

negative: assert statement with condition of type set

	MODULE Test;
	VAR condition: SET;
	BEGIN ASSERT (condition);
	END Test.

negative: assert statement with condition of type array

	MODULE Test;
	VAR condition: ARRAY 10 OF CHAR;
	BEGIN ASSERT (condition);
	END Test.

negative: assert statement with condition of type record

	MODULE Test;
	VAR condition: RECORD END;
	BEGIN ASSERT (condition);
	END Test.

negative: assert statement with condition of type object

	MODULE Test;
	VAR condition: OBJECT;
	BEGIN ASSERT (condition);
	END Test.

negative: assert statement with condition of type pointer

	MODULE Test;
	VAR condition: POINTER TO RECORD END;
	BEGIN ASSERT (condition);
	END Test.

negative: assert statement with condition of type procedure

	MODULE Test;
	VAR condition: PROCEDURE;
	BEGIN ASSERT (condition);
	END Test.

negative: assert statement with import as condition

	MODULE Test;
	IMPORT condition := Dummy;
	BEGIN ASSERT (condition);
	END Test.

negative: assert statement with type as condition

	MODULE Test;
	TYPE condition = BOOLEAN
	BEGIN ASSERT (condition);
	END Test.

negative: assert statement with constant number of type character

	MODULE Test;
	BEGIN ASSERT (TRUE, 'a');
	END Test.

positive: assert statement with constant number of type integer

	MODULE Test;
	BEGIN ASSERT (TRUE, 5);
	END Test.

negative: assert statement with constant number of type real

	MODULE Test;
	BEGIN ASSERT (TRUE, 4.5);
	END Test.

negative: assert statement with constant number of type set

	MODULE Test;
	BEGIN ASSERT (TRUE, {5});
	END Test.

negative: assert statement with constant number of type string

	MODULE Test;
	BEGIN ASSERT (TRUE, "number");
	END Test.

negative: assert statement with constant number of type nil pointer

	MODULE Test;
	BEGIN ASSERT (TRUE, NIL);
	END Test.

negative: assert statement with number of type boolean

	MODULE Test;
	VAR number: BOOLEAN;
	BEGIN ASSERT (TRUE, number);
	END Test.

negative: assert statement with number of type character

	MODULE Test;
	VAR number: CHAR;
	BEGIN ASSERT (TRUE, number);
	END Test.

negative: assert statement with number of type short integer

	MODULE Test;
	VAR number: SIGNED8;
	BEGIN ASSERT (TRUE, number);
	END Test.

negative: assert statement with number of type integer

	MODULE Test;
	VAR number: SIGNED16;
	BEGIN ASSERT (TRUE, number);
	END Test.

negative: assert statement with number of type long integer

	MODULE Test;
	VAR number: SIGNED32;
	BEGIN ASSERT (TRUE, number);
	END Test.

negative: assert statement with number of type huge integer

	MODULE Test;
	VAR number: SIGNED64;
	BEGIN ASSERT (TRUE, number);
	END Test.

negative: assert statement with number of type real

	MODULE Test;
	VAR number: FLOAT32;
	BEGIN ASSERT (TRUE, number);
	END Test.

negative: assert statement with number of type long real

	MODULE Test;
	VAR number: FLOAT64;
	BEGIN ASSERT (TRUE, number);
	END Test.

negative: assert statement with number of type set

	MODULE Test;
	VAR number: SET;
	BEGIN ASSERT (TRUE, number);
	END Test.

negative: assert statement with number of type array

	MODULE Test;
	VAR number: ARRAY 10 OF CHAR;
	BEGIN ASSERT (TRUE, number);
	END Test.

negative: assert statement with number of type record

	MODULE Test;
	VAR number: RECORD END;
	BEGIN ASSERT (TRUE, number);
	END Test.

negative: assert statement with number of type object

	MODULE Test;
	VAR number: OBJECT;
	BEGIN ASSERT (TRUE, number);
	END Test.

negative: assert statement with number of type pointer

	MODULE Test;
	VAR number: POINTER TO RECORD END;
	BEGIN ASSERT (TRUE, number);
	END Test.

negative: assert statement with number of type procedure

	MODULE Test;
	VAR number: PROCEDURE;
	BEGIN ASSERT (TRUE, number);
	END Test.

negative: assert statement with import as number

	MODULE Test;
	IMPORT number := Dummy;
	BEGIN ASSERT (TRUE, number);
	END Test.

negative: assert statement with type as number

	MODULE Test;
	TYPE number = SIGNED16
	BEGIN ASSERT (TRUE, number);
	END Test.


# if statement

positive: if statement with constant true condition

	MODULE Test;
	BEGIN IF TRUE THEN END;
	END Test.

positive: if statement with constant false condition

	MODULE Test;
	BEGIN IF FALSE THEN END;
	END Test.

negative: if statement with constant condition of type character

	MODULE Test;
	BEGIN IF 'a' THEN END;
	END Test.

negative: if statement with constant condition of type integer

	MODULE Test;
	BEGIN IF 5 THEN END;
	END Test.

negative: if statement with constant condition of type real

	MODULE Test;
	BEGIN IF 4.5 THEN END;
	END Test.

negative: if statement with constant condition of type set

	MODULE Test;
	BEGIN IF {5} THEN END;
	END Test.

negative: if statement with constant condition of type string

	MODULE Test;
	BEGIN IF "condition" THEN END;
	END Test.

negative: if statement with constant condition of type nil pointer

	MODULE Test;
	BEGIN IF NIL THEN END;
	END Test.

positive: if statement with condition of type boolean

	MODULE Test;
	VAR condition: BOOLEAN;
	BEGIN IF condition THEN END;
	END Test.

negative: if statement with condition of type character

	MODULE Test;
	VAR condition: CHAR;
	BEGIN IF condition THEN END;
	END Test.

negative: if statement with condition of type short integer

	MODULE Test;
	VAR condition: SIGNED8;
	BEGIN IF condition THEN END;
	END Test.

negative: if statement with condition of type integer

	MODULE Test;
	VAR condition: SIGNED16;
	BEGIN IF condition THEN END;
	END Test.

negative: if statement with condition of type long integer

	MODULE Test;
	VAR condition: SIGNED32;
	BEGIN IF condition THEN END;
	END Test.

negative: if statement with condition of type huge integer

	MODULE Test;
	VAR condition: SIGNED64;
	BEGIN IF condition THEN END;
	END Test.

negative: if statement with condition of type real

	MODULE Test;
	VAR condition: FLOAT32;
	BEGIN IF condition THEN END;
	END Test.

negative: if statement with condition of type long real

	MODULE Test;
	VAR condition: FLOAT64;
	BEGIN IF condition THEN END;
	END Test.

negative: if statement with condition of type set

	MODULE Test;
	VAR condition: SET;
	BEGIN IF condition THEN END;
	END Test.

negative: if statement with condition of type array

	MODULE Test;
	VAR condition: ARRAY 10 OF CHAR;
	BEGIN IF condition THEN END;
	END Test.

negative: if statement with condition of type record

	MODULE Test;
	VAR condition: RECORD END;
	BEGIN IF condition THEN END;
	END Test.

negative: if statement with condition of type object

	MODULE Test;
	VAR condition: OBJECT;
	BEGIN IF condition THEN END;
	END Test.

negative: if statement with condition of type pointer

	MODULE Test;
	VAR condition: POINTER TO RECORD END;
	BEGIN IF condition THEN END;
	END Test.

negative: if statement with condition of type procedure

	MODULE Test;
	VAR condition: PROCEDURE;
	BEGIN IF condition THEN END;
	END Test.

negative: if statement with import as condition

	MODULE Test;
	IMPORT condition := Dummy;
	BEGIN IF condition THEN END;
	END Test.

negative: if statement with type as condition

	MODULE Test;
	TYPE condition = BOOLEAN;
	BEGIN IF condition THEN END;
	END Test.

positive: else if statement with constant true condition

	MODULE Test;
	BEGIN IF TRUE THEN ELSIF TRUE THEN END;
	END Test.

positive: else if statement with constant false condition

	MODULE Test;
	BEGIN IF TRUE THEN ELSIF FALSE THEN END;
	END Test.

negative: else if statement with constant condition of type character

	MODULE Test;
	BEGIN IF TRUE THEN ELSIF 'a' THEN END;
	END Test.

negative: else if statement with constant condition of type integer

	MODULE Test;
	BEGIN IF TRUE THEN ELSIF 5 THEN END;
	END Test.

negative: else if statement with constant condition of type real

	MODULE Test;
	BEGIN IF TRUE THEN ELSIF 4.5 THEN END;
	END Test.

negative: else if statement with constant condition of type set

	MODULE Test;
	BEGIN IF TRUE THEN ELSIF {5} THEN END;
	END Test.

negative: else if statement with constant condition of type string

	MODULE Test;
	BEGIN IF TRUE THEN ELSIF "condition" THEN END;
	END Test.

negative: else if statement with constant condition of type nil pointer

	MODULE Test;
	BEGIN IF TRUE THEN ELSIF NIL THEN END;
	END Test.

positive: else if statement with condition of type boolean

	MODULE Test;
	VAR condition: BOOLEAN;
	BEGIN IF TRUE THEN ELSIF condition THEN END;
	END Test.

negative: else if statement with condition of type character

	MODULE Test;
	VAR condition: CHAR;
	BEGIN IF TRUE THEN ELSIF condition THEN END;
	END Test.

negative: else if statement with condition of type short integer

	MODULE Test;
	VAR condition: SIGNED8;
	BEGIN IF TRUE THEN ELSIF condition THEN END;
	END Test.

negative: else if statement with condition of type integer

	MODULE Test;
	VAR condition: SIGNED16;
	BEGIN IF TRUE THEN ELSIF condition THEN END;
	END Test.

negative: else if statement with condition of type long integer

	MODULE Test;
	VAR condition: SIGNED32;
	BEGIN IF TRUE THEN ELSIF condition THEN END;
	END Test.

negative: else if statement with condition of type huge integer

	MODULE Test;
	VAR condition: SIGNED64;
	BEGIN IF TRUE THEN ELSIF condition THEN END;
	END Test.

negative: else if statement with condition of type real

	MODULE Test;
	VAR condition: FLOAT32;
	BEGIN IF TRUE THEN ELSIF condition THEN END;
	END Test.

negative: else if statement with condition of type long real

	MODULE Test;
	VAR condition: FLOAT64;
	BEGIN IF TRUE THEN ELSIF condition THEN END;
	END Test.

negative: else if statement with condition of type set

	MODULE Test;
	VAR condition: SET;
	BEGIN IF TRUE THEN ELSIF condition THEN END;
	END Test.

negative: else if statement with condition of type array

	MODULE Test;
	VAR condition: ARRAY 10 OF CHAR;
	BEGIN IF TRUE THEN ELSIF condition THEN END;
	END Test.

negative: else if statement with condition of type record

	MODULE Test;
	VAR condition: RECORD END;
	BEGIN IF TRUE THEN ELSIF condition THEN END;
	END Test.

negative: else if statement with condition of type object

	MODULE Test;
	VAR condition: OBJECT;
	BEGIN IF TRUE THEN ELSIF condition THEN END;
	END Test.

negative: else if statement with condition of type pointer

	MODULE Test;
	VAR condition: POINTER TO RECORD END;
	BEGIN IF TRUE THEN ELSIF condition THEN END;
	END Test.

negative: else if statement with condition of type procedure

	MODULE Test;
	VAR condition: PROCEDURE;
	BEGIN IF TRUE THEN ELSIF condition THEN END;
	END Test.

negative: else if statement with import as condition

	MODULE Test;
	IMPORT condition := Dummy;
	BEGIN IF TRUE THEN ELSIF condition THEN END;
	END Test.

negative: else if statement with type as condition

	MODULE Test;
	TYPE condition = BOOLEAN;
	BEGIN IF TRUE THEN ELSIF condition THEN END;
	END Test.


# halt statement

negative: halt statement with constant number of type character

	MODULE Test;
	BEGIN HALT ('a');
	END Test.

positive: halt statement with constant number of type integer

	MODULE Test;
	BEGIN HALT (105);
	END Test.

negative: halt statement with constant number of type real

	MODULE Test;
	BEGIN HALT (4.5);
	END Test.

negative: halt statement with constant number of type set

	MODULE Test;
	BEGIN HALT ({5});
	END Test.

negative: halt statement with constant number of type string

	MODULE Test;
	BEGIN HALT ("number");
	END Test.

negative: halt statement with constant number of type nil pointer

	MODULE Test;
	BEGIN HALT (NIL);
	END Test.

negative: halt statement with number of type boolean

	MODULE Test;
	VAR number: BOOLEAN;
	BEGIN HALT (number);
	END Test.

negative: halt statement with number of type character

	MODULE Test;
	VAR number: CHAR;
	BEGIN HALT (number);
	END Test.

negative: halt statement with number of type short integer

	MODULE Test;
	VAR number: SIGNED8;
	BEGIN HALT (number);
	END Test.

negative: halt statement with number of type integer

	MODULE Test;
	VAR number: SIGNED16;
	BEGIN HALT (number);
	END Test.

negative: halt statement with number of type long integer

	MODULE Test;
	VAR number: SIGNED32;
	BEGIN HALT (number);
	END Test.

negative: halt statement with number of type huge integer

	MODULE Test;
	VAR number: SIGNED64;
	BEGIN HALT (number);
	END Test.

negative: halt statement with number of type real

	MODULE Test;
	VAR number: FLOAT32;
	BEGIN HALT (number);
	END Test.

negative: halt statement with number of type long real

	MODULE Test;
	VAR number: FLOAT64;
	BEGIN HALT (number);
	END Test.

negative: halt statement with number of type set

	MODULE Test;
	VAR number: SET;
	BEGIN HALT (number);
	END Test.

negative: halt statement with number of type array

	MODULE Test;
	VAR number: ARRAY 10 OF CHAR;
	BEGIN HALT (number);
	END Test.

negative: halt statement with number of type record

	MODULE Test;
	VAR number: RECORD END;
	BEGIN HALT (number);
	END Test.

negative: halt statement with number of type object

	MODULE Test;
	VAR number: OBJECT;
	BEGIN HALT (number);
	END Test.

negative: halt statement with number of type pointer

	MODULE Test;
	VAR number: POINTER TO RECORD END;
	BEGIN HALT (number);
	END Test.

negative: halt statement with number of type procedure

	MODULE Test;
	VAR number: PROCEDURE;
	BEGIN HALT (number);
	END Test.

negative: halt statement with import as number

	MODULE Test;
	IMPORT number := Dummy;
	BEGIN HALT (number);
	END Test.

negative: halt statement with type as number

	MODULE Test;
	TYPE number = SIGNED16;
	BEGIN HALT (number);
	END Test.


# case statement

negative: case statement with constant boolean value

	MODULE Test;
	BEGIN CASE TRUE OF TRUE: END
	END Test.

positive: case statement with constant character value

	MODULE Test;
	BEGIN CASE 'a' OF 'a': END
	END Test.

negative: case statement with constant character value and unmatched case

	MODULE Test;
	BEGIN CASE 't' OF 'y': END
	END Test.

positive: case statement with constant character value and unmatched case and else

	MODULE Test;
	BEGIN CASE 'e' OF 0X: ELSE END
	END Test.

positive: case statement with constant short integer value

	MODULE Test;
	BEGIN CASE 10H OF 10H: END
	END Test.

positive: case statement with constant integer value

	MODULE Test;
	BEGIN CASE 1000H OF 1000H: END
	END Test.

positive: case statement with constant long integer value

	MODULE Test;
	BEGIN CASE 100000H OF 100000H: END
	END Test.

positive: case statement with constant huge integer value

	MODULE Test;
	BEGIN CASE 100000000H OF 100000000H: END
	END Test.

positive: case statement with constant integer value and matched case

	MODULE Test;
	BEGIN CASE 5 OF 5: END
	END Test.

negative: case statement with constant integer value and unmatched case

	MODULE Test;
	BEGIN CASE 1 OF 2: END
	END Test.

positive: case statement with constant integer value and unmatched case and else

	MODULE Test;
	BEGIN CASE 9 OF 4: ELSE END
	END Test.

negative: case statement with constant real value

	MODULE Test;
	BEGIN CASE 1.0 OF 1.0: END
	END Test.

negative: case statement with constant long real value

	MODULE Test;
	BEGIN CASE 1.D0 OF 1.D0: END
	END Test.

negative: case statement with constant set value

	MODULE Test;
	BEGIN CASE {} OF {}: END
	END Test.

negative: case statement with constant string value

	MODULE Test;
	BEGIN CASE "value" OF "value": END
	END Test.

negative: case statement with nil pointer value

	MODULE Test;
	BEGIN CASE NIL OF NIL: END
	END Test.

negative: case statement with variable boolean value

	MODULE Test;
	VAR value: BOOLEAN;
	BEGIN CASE value OF TRUE: END
	END Test.

positive: case statement with variable character value

	MODULE Test;
	VAR value: CHAR;
	BEGIN CASE value OF 3X: END
	END Test.

positive: case statement with variable short integer value

	MODULE Test;
	VAR value: SIGNED8;
	BEGIN CASE value OF 5: END
	END Test.

positive: case statement with variable integer value

	MODULE Test;
	VAR value: SIGNED16;
	BEGIN CASE value OF 10: END
	END Test.

positive: case statement with variable long integer value

	MODULE Test;
	VAR value: SIGNED32;
	BEGIN CASE value OF 9: END
	END Test.

positive: case statement with variable huge integer value

	MODULE Test;
	VAR value: SIGNED64;
	BEGIN CASE value OF 6: END
	END Test.

negative: case statement with variable real value

	MODULE Test;
	VAR value: FLOAT32;
	BEGIN CASE value OF 0.5: END
	END Test.

negative: case statement with variable long real value

	MODULE Test;
	VAR value: FLOAT32;
	BEGIN CASE value OF 0.D0: END
	END Test.

positive: case statement with variable set value

	MODULE Test;
	VAR value: SET;
	BEGIN CASE value OF {}: END
	END Test.

negative: case statement with variable array value

	MODULE Test;
	VAR value: ARRAY 10 OF CHAR;
	BEGIN CASE value OF value: END
	END Test.

negative: case statement with variable record value

	MODULE Test;
	VAR value: RECORD END;
	BEGIN CASE value OF value: END
	END Test.

negative: case statement with variable object value

	MODULE Test;
	VAR value: OBJECT END;
	BEGIN CASE value OF value: END
	END Test.

negative: case statement with variable base object value

	MODULE Test;
	VAR value: OBJECT;
	BEGIN CASE value OF value: END
	END Test.

negative: case statement with variable pointer to record value

	MODULE Test;
	VAR value: POINTER TO RECORD END;
	BEGIN CASE value OF value: END
	END Test.

negative: case statement with variable pointer to array value

	MODULE Test;
	VAR value: POINTER TO ARRAY OF CHAR;
	BEGIN CASE value OF value: END
	END Test.

negative: case statement with variable procedure value

	MODULE Test;
	VAR value: PROCEDURE;
	BEGIN CASE value OF value: END
	END Test.

negative: case statement with import value

	MODULE Test;
	IMPORT value := Dummy;
	BEGIN CASE value OF value: END
	END Test.

negative: case statement with type value

	MODULE Test;
	TYPE value = SIGNED16;
	BEGIN CASE value OF value: END
	END Test.

negative: character case statement with constant boolean case

	MODULE Test;
	VAR value: CHAR;
	BEGIN CASE value OF TRUE: END
	END Test.

positive: character case statement with constant character case

	MODULE Test;
	VAR value: CHAR;
	BEGIN CASE value OF 'a': END
	END Test.

negative: character case statement with constant short integer case

	MODULE Test;
	VAR value: CHAR;
	BEGIN CASE value OF 10H: END
	END Test.

negative: character case statement with constant integer case

	MODULE Test;
	VAR value: CHAR;
	BEGIN CASE value OF 1000H: END
	END Test.

negative: character case statement with constant long integer case

	MODULE Test;
	VAR value: CHAR;
	BEGIN CASE value OF 100000H: END
	END Test.

negative: character case statement with constant huge integer case

	MODULE Test;
	VAR value: CHAR;
	BEGIN CASE value OF 100000000H: END
	END Test.

negative: character case statement with constant real case

	MODULE Test;
	VAR value: CHAR;
	BEGIN CASE value OF 1.0: END
	END Test.

negative: character case statement with constant long real case

	MODULE Test;
	VAR value: CHAR;
	BEGIN CASE value OF 1.D0: END
	END Test.

negative: character case statement with constant set case

	MODULE Test;
	VAR value: CHAR;
	BEGIN CASE value OF {}: END
	END Test.

negative: character case statement with constant string case

	MODULE Test;
	VAR value: CHAR;
	BEGIN CASE value OF "value": END
	END Test.

negative: character case statement with nil pointer case

	MODULE Test;
	VAR value: CHAR;
	BEGIN CASE value OF NIL: END
	END Test.

negative: character case statement variable boolean case

	MODULE Test;
	VAR value: CHAR; case: BOOLEAN;
	BEGIN CASE value OF case: END
	END Test.

negative: character case statement with variable character case

	MODULE Test;
	VAR value, case: CHAR;
	BEGIN CASE value OF case: END
	END Test.

negative: character case statement with variable short integer case

	MODULE Test;
	VAR value: CHAR; case: SIGNED8;
	BEGIN CASE value OF case: END
	END Test.

negative: character case statement with variable integer case

	MODULE Test;
	VAR value: CHAR; case: SIGNED16;
	BEGIN CASE value OF case: END
	END Test.

negative: character case statement with variable long integer case

	MODULE Test;
	VAR value: CHAR; case: SIGNED32;
	BEGIN CASE value OF case: END
	END Test.

negative: character case statement with variable huge integer case

	MODULE Test;
	VAR value: CHAR; case: SIGNED64;
	BEGIN CASE value OF case: END
	END Test.

negative: character case statement with variable real case

	MODULE Test;
	VAR value: CHAR; case: FLOAT32;
	BEGIN CASE value OF case: END
	END Test.

negative: character case statement with variable long real case

	MODULE Test;
	VAR value: CHAR; case: FLOAT64;
	BEGIN CASE value OF case: END
	END Test.

negative: character case statement with variable set case

	MODULE Test;
	VAR value: CHAR; case: SET;
	BEGIN CASE value OF case: END
	END Test.

negative: character case statement with variable array case

	MODULE Test;
	VAR value: CHAR; case: ARRAY 10 OF CHAR;
	BEGIN CASE value OF case: END
	END Test.

negative: character case statement with variable record case

	MODULE Test;
	VAR value: CHAR; case: RECORD END;
	BEGIN CASE value OF case: END
	END Test.

negative: character case statement with variable object case

	MODULE Test;
	VAR value: CHAR; case: OBJECT END;
	BEGIN CASE value OF case: END
	END Test.

negative: character case statement with variable base object case

	MODULE Test;
	VAR value: CHAR; case: OBJECT;
	BEGIN CASE value OF case: END
	END Test.

negative: character case statement with variable pointer to record case

	MODULE Test;
	VAR value: CHAR; case: POINTER TO RECORD END;
	BEGIN CASE value OF case: END
	END Test.

negative: character case statement with variable pointer to array case

	MODULE Test;
	VAR value: CHAR; case: POINTER TO ARRAY OF CHAR;
	BEGIN CASE value OF case: END
	END Test.

negative: character case statement with variable procedure case

	MODULE Test;
	VAR value: CHAR; case: PROCEDURE;
	BEGIN CASE value OF case: END
	END Test.

negative: character case statement with import case

	MODULE Test;
	IMPORT case := Dummy;
	VAR value: CHAR;
	BEGIN CASE value OF case: END
	END Test.

negative: character case statement with type as case

	MODULE Test;
	TYPE case = SIGNED16;
	VAR value: CHAR;
	BEGIN CASE value OF case: END
	END Test.

negative: short integer case statement with constant boolean case

	MODULE Test;
	VAR value: SIGNED8;
	BEGIN CASE value OF TRUE: END
	END Test.

negative: short integer case statement with constant character case

	MODULE Test;
	VAR value: SIGNED8;
	BEGIN CASE value OF 'a': END
	END Test.

positive: short integer case statement with constant short integer case

	MODULE Test;
	VAR value: SIGNED8;
	BEGIN CASE value OF 10H: END
	END Test.

negative: short integer case statement with constant integer case

	MODULE Test;
	VAR value: SIGNED8;
	BEGIN CASE value OF 1000H: END
	END Test.

negative: short integer case statement with constant long integer case

	MODULE Test;
	VAR value: SIGNED8;
	BEGIN CASE value OF 100000H: END
	END Test.

negative: short integer case statement with constant huge integer case

	MODULE Test;
	VAR value: SIGNED8;
	BEGIN CASE value OF 100000000H: END
	END Test.

negative: short integer case statement with constant real case

	MODULE Test;
	VAR value: SIGNED8;
	BEGIN CASE value OF 1.0: END
	END Test.

negative: short integer case statement with constant long real case

	MODULE Test;
	VAR value: SIGNED8;
	BEGIN CASE value OF 1.D0: END
	END Test.

negative: short integer case statement with constant set case

	MODULE Test;
	VAR value: SIGNED8;
	BEGIN CASE value OF {}: END
	END Test.

negative: short integer case statement with constant string case

	MODULE Test;
	VAR value: SIGNED8;
	BEGIN CASE value OF "value": END
	END Test.

negative: short integer case statement with nil pointer case

	MODULE Test;
	VAR value: SIGNED8;
	BEGIN CASE value OF NIL: END
	END Test.

negative: short integer case statement variable boolean case

	MODULE Test;
	VAR value: SIGNED8; case: BOOLEAN;
	BEGIN CASE value OF case: END
	END Test.

negative: short integer case statement with variable character case

	MODULE Test;
	VAR value: SIGNED8; case: CHAR;
	BEGIN CASE value OF case: END
	END Test.

negative: short integer case statement with variable short integer case

	MODULE Test;
	VAR value, case: SIGNED8;
	BEGIN CASE value OF case: END
	END Test.

negative: short integer case statement with variable integer case

	MODULE Test;
	VAR value: SIGNED8; case: SIGNED16;
	BEGIN CASE value OF case: END
	END Test.

negative: short integer case statement with variable long integer case

	MODULE Test;
	VAR value: SIGNED8; case: SIGNED32;
	BEGIN CASE value OF case: END
	END Test.

negative: short integer case statement with variable huge integer case

	MODULE Test;
	VAR value: SIGNED8; case: SIGNED64;
	BEGIN CASE value OF case: END
	END Test.

negative: short integer case statement with variable real case

	MODULE Test;
	VAR value: SIGNED8; case: FLOAT32;
	BEGIN CASE value OF case: END
	END Test.

negative: short integer case statement with variable long real case

	MODULE Test;
	VAR value: SIGNED8; case: FLOAT64;
	BEGIN CASE value OF case: END
	END Test.

negative: short integer case statement with variable set case

	MODULE Test;
	VAR value: SIGNED8; case: SET;
	BEGIN CASE value OF case: END
	END Test.

negative: short integer case statement with variable array case

	MODULE Test;
	VAR value: SIGNED8; case: ARRAY 10 OF CHAR;
	BEGIN CASE value OF case: END
	END Test.

negative: short integer case statement with variable record case

	MODULE Test;
	VAR value: SIGNED8; case: RECORD END;
	BEGIN CASE value OF case: END
	END Test.

negative: short integer case statement with variable object case

	MODULE Test;
	VAR value: SIGNED8; case: OBJECT END;
	BEGIN CASE value OF case: END
	END Test.

negative: short integer case statement with variable base object case

	MODULE Test;
	VAR value: SIGNED8; case: OBJECT;
	BEGIN CASE value OF case: END
	END Test.

negative: short integer case statement with variable pointer to record case

	MODULE Test;
	VAR value: SIGNED8; case: POINTER TO RECORD END;
	BEGIN CASE value OF case: END
	END Test.

negative: short integer case statement with variable pointer to array case

	MODULE Test;
	VAR value: SIGNED8; case: POINTER TO ARRAY OF CHAR;
	BEGIN CASE value OF case: END
	END Test.

negative: short integer case statement with variable procedure case

	MODULE Test;
	VAR value: SIGNED8; case: PROCEDURE;
	BEGIN CASE value OF case: END
	END Test.

negative: short integer case statement with import case

	MODULE Test;
	IMPORT case := Dummy; VAR value: SIGNED8;
	BEGIN CASE value OF case: END
	END Test.

negative: short integer case statement with type as case

	MODULE Test;
	TYPE case = SIGNED16; VAR value: case;
	BEGIN CASE value OF case: END
	END Test.

negative: integer case statement with constant boolean case

	MODULE Test;
	VAR value: SIGNED16;
	BEGIN CASE value OF TRUE: END
	END Test.

negative: integer case statement with constant character case

	MODULE Test;
	VAR value: SIGNED16;
	BEGIN CASE value OF 'a': END
	END Test.

positive: integer case statement with constant short integer case

	MODULE Test;
	VAR value: SIGNED16;
	BEGIN CASE value OF 10H: END
	END Test.

positive: integer case statement with constant integer case

	MODULE Test;
	VAR value: SIGNED16;
	BEGIN CASE value OF 1000H: END
	END Test.

negative: integer case statement with constant long integer case

	MODULE Test;
	VAR value: SIGNED16;
	BEGIN CASE value OF 100000H: END
	END Test.

negative: integer case statement with constant huge integer case

	MODULE Test;
	VAR value: SIGNED16;
	BEGIN CASE value OF 100000000H: END
	END Test.

negative: integer case statement with constant real case

	MODULE Test;
	VAR value: SIGNED16;
	BEGIN CASE value OF 1.0: END
	END Test.

negative: integer case statement with constant long real case

	MODULE Test;
	VAR value: SIGNED16;
	BEGIN CASE value OF 1.D0: END
	END Test.

negative: integer case statement with constant set case

	MODULE Test;
	VAR value: SIGNED16;
	BEGIN CASE value OF {}: END
	END Test.

negative: integer case statement with constant string case

	MODULE Test;
	VAR value: SIGNED16;
	BEGIN CASE value OF "value": END
	END Test.

negative: integer case statement with nil pointer case

	MODULE Test;
	VAR value: SIGNED16;
	BEGIN CASE value OF NIL: END
	END Test.

negative: integer case statement variable boolean case

	MODULE Test;
	VAR value: SIGNED16; case: BOOLEAN;
	BEGIN CASE value OF case: END
	END Test.

negative: integer case statement with variable character case

	MODULE Test;
	VAR value: SIGNED16; case: CHAR;
	BEGIN CASE value OF case: END
	END Test.

negative: integer case statement with variable short integer case

	MODULE Test;
	VAR value: SIGNED16; case: SIGNED8;
	BEGIN CASE value OF case: END
	END Test.

negative: integer case statement with variable integer case

	MODULE Test;
	VAR value, case: SIGNED16;
	BEGIN CASE value OF case: END
	END Test.

negative: integer case statement with variable long integer case

	MODULE Test;
	VAR value: SIGNED16; case: SIGNED32;
	BEGIN CASE value OF case: END
	END Test.

negative: integer case statement with variable huge integer case

	MODULE Test;
	VAR value: SIGNED16; case: SIGNED64;
	BEGIN CASE value OF case: END
	END Test.

negative: integer case statement with variable real case

	MODULE Test;
	VAR value: SIGNED16; case: FLOAT32;
	BEGIN CASE value OF case: END
	END Test.

negative: integer case statement with variable long real case

	MODULE Test;
	VAR value: SIGNED16; case: FLOAT64;
	BEGIN CASE value OF case: END
	END Test.

negative: integer case statement with variable set case

	MODULE Test;
	VAR value: SIGNED16; case: SET;
	BEGIN CASE value OF case: END
	END Test.

negative: integer case statement with variable array case

	MODULE Test;
	VAR value: SIGNED16; case: ARRAY 10 OF CHAR;
	BEGIN CASE value OF case: END
	END Test.

negative: integer case statement with variable record case

	MODULE Test;
	VAR value: SIGNED16; case: RECORD END;
	BEGIN CASE value OF case: END
	END Test.

negative: integer case statement with variable object case

	MODULE Test;
	VAR value: SIGNED16; case: OBJECT END;
	BEGIN CASE value OF case: END
	END Test.

negative: integer case statement with variable base object case

	MODULE Test;
	VAR value: SIGNED16; case: OBJECT;
	BEGIN CASE value OF case: END
	END Test.

negative: integer case statement with variable pointer to record case

	MODULE Test;
	VAR value: SIGNED16; case: POINTER TO RECORD END;
	BEGIN CASE value OF case: END
	END Test.

negative: integer case statement with variable pointer to array case

	MODULE Test;
	VAR value: SIGNED16; case: POINTER TO ARRAY OF CHAR;
	BEGIN CASE value OF case: END
	END Test.

negative: integer case statement with variable procedure case

	MODULE Test;
	VAR value: SIGNED16; case: PROCEDURE;
	BEGIN CASE value OF case: END
	END Test.

negative: integer case statement with import case

	MODULE Test;
	IMPORT case := Dummy; VAR value: SIGNED16;
	BEGIN CASE value OF case: END
	END Test.

negative: integer case statement with type as case

	MODULE Test;
	TYPE case = SIGNED16; VAR value: case;
	BEGIN CASE value OF case: END
	END Test.

negative: long integer case statement with constant boolean case

	MODULE Test;
	VAR value: SIGNED32;
	BEGIN CASE value OF TRUE: END
	END Test.

negative: long integer case statement with constant character case

	MODULE Test;
	VAR value: SIGNED32;
	BEGIN CASE value OF 'a': END
	END Test.

positive: long integer case statement with constant short integer case

	MODULE Test;
	VAR value: SIGNED32;
	BEGIN CASE value OF 10H: END
	END Test.

positive: long integer case statement with constant integer case

	MODULE Test;
	VAR value: SIGNED32;
	BEGIN CASE value OF 1000H: END
	END Test.

positive: long integer case statement with constant long integer case

	MODULE Test;
	VAR value: SIGNED32;
	BEGIN CASE value OF 100000H: END
	END Test.

negative: long integer case statement with constant huge integer case

	MODULE Test;
	VAR value: SIGNED32;
	BEGIN CASE value OF 100000000H: END
	END Test.

negative: long integer case statement with constant real case

	MODULE Test;
	VAR value: SIGNED32;
	BEGIN CASE value OF 1.0: END
	END Test.

negative: long integer case statement with constant long real case

	MODULE Test;
	VAR value: SIGNED32;
	BEGIN CASE value OF 1.D0: END
	END Test.

negative: long integer case statement with constant set case

	MODULE Test;
	VAR value: SIGNED32;
	BEGIN CASE value OF {}: END
	END Test.

negative: long integer case statement with constant string case

	MODULE Test;
	VAR value: SIGNED32;
	BEGIN CASE value OF "value": END
	END Test.

negative: long integer case statement with nil pointer case

	MODULE Test;
	VAR value: SIGNED32;
	BEGIN CASE value OF NIL: END
	END Test.

negative: long integer case statement variable boolean case

	MODULE Test;
	VAR value: SIGNED32; case: BOOLEAN;
	BEGIN CASE value OF case: END
	END Test.

negative: long integer case statement with variable character case

	MODULE Test;
	VAR value: SIGNED32; case: CHAR;
	BEGIN CASE value OF case: END
	END Test.

negative: long integer case statement with variable short integer case

	MODULE Test;
	VAR value: SIGNED32; case: SIGNED8;
	BEGIN CASE value OF case: END
	END Test.

negative: long integer case statement with variable integer case

	MODULE Test;
	VAR value: SIGNED32; case: SIGNED16;
	BEGIN CASE value OF case: END
	END Test.

negative: long integer case statement with variable long integer case

	MODULE Test;
	VAR value, case: SIGNED32;
	BEGIN CASE value OF case: END
	END Test.

negative: long integer case statement with variable huge integer case

	MODULE Test;
	VAR value: SIGNED32; case: SIGNED64;
	BEGIN CASE value OF case: END
	END Test.

negative: long integer case statement with variable real case

	MODULE Test;
	VAR value: SIGNED32; case: FLOAT32;
	BEGIN CASE value OF case: END
	END Test.

negative: long integer case statement with variable long real case

	MODULE Test;
	VAR value: SIGNED32; case: FLOAT64;
	BEGIN CASE value OF case: END
	END Test.

negative: long integer case statement with variable set case

	MODULE Test;
	VAR value: SIGNED32; case: SET;
	BEGIN CASE value OF case: END
	END Test.

negative: long integer case statement with variable array case

	MODULE Test;
	VAR value: SIGNED32; case: ARRAY 10 OF CHAR;
	BEGIN CASE value OF case: END
	END Test.

negative: long integer case statement with variable record case

	MODULE Test;
	VAR value: SIGNED32; case: RECORD END;
	BEGIN CASE value OF case: END
	END Test.

negative: long integer case statement with variable object case

	MODULE Test;
	VAR value: SIGNED32; case: OBJECT END;
	BEGIN CASE value OF case: END
	END Test.

negative: long integer case statement with variable base object case

	MODULE Test;
	VAR value: SIGNED32; case: OBJECT;
	BEGIN CASE value OF case: END
	END Test.

negative: long integer case statement with variable pointer to record case

	MODULE Test;
	VAR value: SIGNED32; case: POINTER TO RECORD END;
	BEGIN CASE value OF case: END
	END Test.

negative: long integer case statement with variable pointer to array case

	MODULE Test;
	VAR value: SIGNED32; case: POINTER TO ARRAY OF CHAR;
	BEGIN CASE value OF case: END
	END Test.

negative: long integer case statement with variable procedure case

	MODULE Test;
	VAR value: SIGNED32; case: PROCEDURE;
	BEGIN CASE value OF case: END
	END Test.

negative: long integer case statement with import case

	MODULE Test;
	IMPORT case := Dummy; VAR value: SIGNED32;
	BEGIN CASE value OF case: END
	END Test.

negative: long integer case statement with type as case

	MODULE Test;
	TYPE case = SIGNED32; VAR value: case;
	BEGIN CASE value OF case: END
	END Test.

negative: huge integer case statement with constant boolean case

	MODULE Test;
	VAR value: SIGNED64;
	BEGIN CASE value OF TRUE: END
	END Test.

negative: huge integer case statement with constant character case

	MODULE Test;
	VAR value: SIGNED64;
	BEGIN CASE value OF 'a': END
	END Test.

positive: huge integer case statement with constant short integer case

	MODULE Test;
	VAR value: SIGNED64;
	BEGIN CASE value OF 10H: END
	END Test.

positive: huge integer case statement with constant integer case

	MODULE Test;
	VAR value: SIGNED64;
	BEGIN CASE value OF 1000H: END
	END Test.

positive: huge integer case statement with constant long integer case

	MODULE Test;
	VAR value: SIGNED64;
	BEGIN CASE value OF 100000H: END
	END Test.

positive: huge integer case statement with constant huge integer case

	MODULE Test;
	VAR value: SIGNED64;
	BEGIN CASE value OF 100000000H: END
	END Test.

negative: huge integer case statement with constant real case

	MODULE Test;
	VAR value: SIGNED64;
	BEGIN CASE value OF 1.0: END
	END Test.

negative: huge integer case statement with constant long real case

	MODULE Test;
	VAR value: SIGNED64;
	BEGIN CASE value OF 1.D0: END
	END Test.

negative: huge integer case statement with constant set case

	MODULE Test;
	VAR value: SIGNED64;
	BEGIN CASE value OF {}: END
	END Test.

negative: huge integer case statement with constant string case

	MODULE Test;
	VAR value: SIGNED64;
	BEGIN CASE value OF "value": END
	END Test.

negative: huge integer case statement with nil pointer case

	MODULE Test;
	VAR value: SIGNED64;
	BEGIN CASE value OF NIL: END
	END Test.

negative: huge integer case statement variable boolean case

	MODULE Test;
	VAR value: SIGNED64; case: BOOLEAN;
	BEGIN CASE value OF case: END
	END Test.

negative: huge integer case statement with variable character case

	MODULE Test;
	VAR value: SIGNED64; case: CHAR;
	BEGIN CASE value OF case: END
	END Test.

negative: huge integer case statement with variable short integer case

	MODULE Test;
	VAR value: SIGNED64; case: SIGNED8;
	BEGIN CASE value OF case: END
	END Test.

negative: huge integer case statement with variable integer case

	MODULE Test;
	VAR value: SIGNED64; case: SIGNED16;
	BEGIN CASE value OF case: END
	END Test.

negative: huge integer case statement with variable long integer case

	MODULE Test;
	VAR value: SIGNED64; case: SIGNED32;
	BEGIN CASE value OF case: END
	END Test.

negative: huge integer case statement with variable huge integer case

	MODULE Test;
	VAR value, case: SIGNED64;
	BEGIN CASE value OF case: END
	END Test.

negative: huge integer case statement with variable real case

	MODULE Test;
	VAR value: SIGNED64; case: FLOAT32;
	BEGIN CASE value OF case: END
	END Test.

negative: huge integer case statement with variable long real case

	MODULE Test;
	VAR value: SIGNED64; case: FLOAT64;
	BEGIN CASE value OF case: END
	END Test.

negative: huge integer case statement with variable set case

	MODULE Test;
	VAR value: SIGNED64; case: SET;
	BEGIN CASE value OF case: END
	END Test.

negative: huge integer case statement with variable array case

	MODULE Test;
	VAR value: SIGNED64; case: ARRAY 10 OF CHAR;
	BEGIN CASE value OF case: END
	END Test.

negative: huge integer case statement with variable record case

	MODULE Test;
	VAR value: SIGNED64; case: RECORD END;
	BEGIN CASE value OF case: END
	END Test.

negative: huge integer case statement with variable object case

	MODULE Test;
	VAR value: SIGNED64; case: OBJECT END;
	BEGIN CASE value OF case: END
	END Test.

negative: huge integer case statement with variable base object case

	MODULE Test;
	VAR value: SIGNED64; case: OBJECT;
	BEGIN CASE value OF case: END
	END Test.

negative: huge integer case statement with variable pointer to record case

	MODULE Test;
	VAR value: SIGNED64; case: POINTER TO RECORD END;
	BEGIN CASE value OF case: END
	END Test.

negative: huge integer case statement with variable pointer to array case

	MODULE Test;
	VAR value: SIGNED64; case: POINTER TO ARRAY OF CHAR;
	BEGIN CASE value OF case: END
	END Test.

negative: huge integer case statement with variable procedure case

	MODULE Test;
	VAR value: SIGNED64; case: PROCEDURE;
	BEGIN CASE value OF case: END
	END Test.

negative: huge integer case statement with import case

	MODULE Test;
	IMPORT case := Dummy; VAR value: SIGNED64;
	BEGIN CASE value OF case: END
	END Test.

negative: huge integer case statement with type as case

	MODULE Test;
	TYPE case = SIGNED64; VAR value: case;
	BEGIN CASE value OF case: END
	END Test.

positive: character case statement with multiple case range

	MODULE Test;
	VAR value: CHAR;
	BEGIN CASE value OF 0X..10X, 11X..20X: END;
	END Test.

positive: character case statement with empty case range

	MODULE Test;
	VAR value: CHAR;
	BEGIN CASE value OF 10X..10X: END;
	END Test.

negative: character case statement with invalid case range

	MODULE Test;
	VAR value: CHAR;
	BEGIN CASE value OF 10X..0X: END;
	END Test.

negative: character case statement with duplicated cases within same label

	MODULE Test;
	VAR value: CHAR;
	BEGIN CASE value OF 10X, 10X: END;
	END Test.

negative: character case statement with duplicated case ranges within same label

	MODULE Test;
	VAR value: CHAR;
	BEGIN CASE value OF 0X..10X, 10X..20X: END;
	END Test.

negative: character case statement with duplicated cases within different label

	MODULE Test;
	VAR value: CHAR;
	BEGIN CASE value OF 10X: | 10X: END;
	END Test.

negative: character case statement with duplicated case ranges within different label

	MODULE Test;
	VAR value: CHAR;
	BEGIN CASE value OF 0X..10X: | 10X..20X: END;
	END Test.

positive: character case statement with ascending cases

	MODULE Test;
	VAR value: CHAR;
	BEGIN CASE value OF 0X..5X, 6X, 7X..7X, 8X, 9X: | 10X..20X, 21X: | 22X, 23X..29X, 30X: END;
	END Test.

positive: character case statement with descending cases

	MODULE Test;
	VAR value: CHAR;
	BEGIN CASE value OF 30X, 23X..29X, 22X: | 21X, 10X..20X: | 0X..5X, 6X, 7X..7X, 8X, 9X: END;
	END Test.

positive: nested character case statement

	MODULE Test;
	VAR value: CHAR;
	BEGIN CASE value OF 0X..10X: CASE value OF 0X..10X: END END;
	END Test.

positive: integer case statement with negative case

	MODULE Test;
	VAR value: SIGNED16;
	BEGIN CASE value OF -10: END;
	END Test.

positive: integer case statement with zero case

	MODULE Test;
	VAR value: SIGNED16;
	BEGIN CASE value OF 0: END;
	END Test.

positive: integer case statement with positive case

	MODULE Test;
	VAR value: SIGNED16;
	BEGIN CASE value OF 10: END;
	END Test.

positive: integer case statement with multiple case range

	MODULE Test;
	VAR value: SIGNED16;
	BEGIN CASE value OF 0..10, 11..20: END;
	END Test.

positive: integer case statement with empty case range

	MODULE Test;
	VAR value: SIGNED16;
	BEGIN CASE value OF 10..10: END;
	END Test.

negative: integer case statement with invalid case range

	MODULE Test;
	VAR value: SIGNED16;
	BEGIN CASE value OF 10..0: END;
	END Test.

negative: integer case statement with duplicated cases within same label

	MODULE Test;
	VAR value: SIGNED16;
	BEGIN CASE value OF 10, 10: END;
	END Test.

negative: integer case statement with duplicated case ranges within same label

	MODULE Test;
	VAR value: SIGNED16;
	BEGIN CASE value OF 0..10, 10..20: END;
	END Test.

negative: integer case statement with duplicated cases within different label

	MODULE Test;
	VAR value: SIGNED16;
	BEGIN CASE value OF 10: | 10: END;
	END Test.

negative: integer case statement with duplicated case ranges within different label

	MODULE Test;
	VAR value: SIGNED16;
	BEGIN CASE value OF 0..10: | 10..20: END;
	END Test.

positive: integer case statement with ascending cases

	MODULE Test;
	VAR value: SIGNED16;
	BEGIN CASE value OF 0..5, 6, 7..7, 8, 9: | 10..20, 21: | 22, 23..29, 30: END;
	END Test.

positive: integer case statement with descending cases

	MODULE Test;
	VAR value: SIGNED16;
	BEGIN CASE value OF 30, 23..29, 22: | 21, 10..20: | 0..5, 6, 7..7, 8, 9: END;
	END Test.

positive: nested integer case statement

	MODULE Test;
	VAR value: SIGNED16;
	BEGIN CASE value OF 0..10: CASE value OF 0..10: END END;
	END Test.


# with statement

negative: with statement with constant boolean value

	MODULE Test;
	BEGIN WITH TRUE : BOOLEAN DO END;
	END Test.

negative: with statement with constant boolean value type

	MODULE Test;
	TYPE Type = BOOLEAN;
	BEGIN WITH TRUE : Type DO END;
	END Test.

negative: with statement with indirect constant boolean value

	MODULE Test;
	CONST Constant = TRUE;
	BEGIN WITH Constant : BOOLEAN DO END;
	END Test.

negative: with statement with indirect constant boolean value type

	MODULE Test;
	CONST Constant = TRUE;
	TYPE Type = BOOLEAN;
	BEGIN WITH Constant : Type DO END;
	END Test.

negative: with statement with constant character value

	MODULE Test;
	BEGIN WITH '0' : CHAR DO END;
	END Test.

negative: with statement with constant character value type

	MODULE Test;
	TYPE Type = CHAR;
	BEGIN WITH '0' : Type DO END;
	END Test.

negative: with statement with indirect constant character value

	MODULE Test;
	CONST Constant = '0';
	BEGIN WITH Constant : CHAR DO END;
	END Test.

negative: with statement with indirect constant character value type

	MODULE Test;
	CONST Constant = '0';
	TYPE Type = CHAR;
	BEGIN WITH Constant : Type DO END;
	END Test.

negative: with statement with constant integer value

	MODULE Test;
	BEGIN WITH 0 : SIGNED16 DO END;
	END Test.

negative: with statement with constant integer value type

	MODULE Test;
	TYPE Type = SIGNED16;
	BEGIN WITH 0 : Type DO END;
	END Test.

negative: with statement with indirect constant integer value

	MODULE Test;
	CONST Constant = 0;
	BEGIN WITH Constant : SIGNED16 DO END;
	END Test.

negative: with statement with indirect constant integer value type

	MODULE Test;
	CONST Constant = 0;
	TYPE Type = SIGNED16;
	BEGIN WITH Constant : Type DO END;
	END Test.

negative: with statement with constant real value

	MODULE Test;
	BEGIN WITH 0.0 : FLOAT32 DO END;
	END Test.

negative: with statement with constant real value type

	MODULE Test;
	TYPE Type = FLOAT32;
	BEGIN WITH 0.0 : Type DO END;
	END Test.

negative: with statement with indirect constant real value

	MODULE Test;
	CONST Constant = 0.0;
	BEGIN WITH Constant : FLOAT32 DO END;
	END Test.

negative: with statement with indirect constant real value type

	MODULE Test;
	CONST Constant = 0.0;
	TYPE Type = FLOAT32;
	BEGIN WITH Constant : Type DO END;
	END Test.

negative: with statement with constant set value

	MODULE Test;
	BEGIN WITH {} : SET DO END;
	END Test.

negative: with statement with constant set value type

	MODULE Test;
	TYPE Type = SET;
	BEGIN WITH {} : Type DO END;
	END Test.

negative: with statement with indirect constant set value

	MODULE Test;
	CONST Constant = {};
	BEGIN WITH Constant : SET DO END;
	END Test.

negative: with statement with indirect constant set value type

	MODULE Test;
	CONST Constant = {};
	TYPE Type = SET;
	BEGIN WITH Constant : Type DO END;
	END Test.

negative: with statement with constant string value

	MODULE Test;
	BEGIN WITH "string" : ARRAY OF CHAR DO END;
	END Test.

negative: with statement with constant string value type

	MODULE Test;
	TYPE Type = ARRAY OF CHAR;
	BEGIN WITH "string" : Type DO END;
	END Test.

negative: with statement with indirect constant string value

	MODULE Test;
	CONST Constant = "string";
	BEGIN WITH Constant : ARRAY OF CHAR DO END;
	END Test.

negative: with statement with indirect constant string value type

	MODULE Test;
	CONST Constant = "string";
	TYPE Type = ARRAY OF CHAR;
	BEGIN WITH Constant : Type DO END;
	END Test.

negative: with statement with nil pointer value

	MODULE Test;
	BEGIN WITH NIL : OBJECT DO END;
	END Test.

negative: with statement with nil pointer value type

	MODULE Test;
	TYPE Type = OBJECT;
	BEGIN WITH NIL : Type DO END;
	END Test.

negative: with statement with indirect nil pointer value

	MODULE Test;
	CONST Constant = NIL;
	TYPE Type = OBJECT;
	BEGIN WITH Constant : Type DO END;
	END Test.

negative: with statement with indirect nil pointer value type

	MODULE Test;
	TYPE Type = OBJECT;
	CONST Constant = NIL;
	BEGIN WITH Constant : Type DO END;
	END Test.

negative: with statement with variable boolean value

	MODULE Test;
	VAR value: BOOLEAN;
	BEGIN WITH value : BOOLEAN DO END;
	END Test.

negative: with statement with variable boolean value type

	MODULE Test;
	TYPE Type = BOOLEAN;
	VAR value: Type;
	BEGIN WITH value : Type DO END;
	END Test.

negative: with statement with variable character value

	MODULE Test;
	VAR value: CHAR;
	BEGIN WITH value : CHAR DO END;
	END Test.

negative: with statement with variable character value type

	MODULE Test;
	TYPE Type = CHAR;
	VAR value: Type;
	BEGIN WITH value : Type DO END;
	END Test.

negative: with statement with variable short integer value

	MODULE Test;
	VAR value: SIGNED8;
	BEGIN WITH value : SIGNED8 DO END;
	END Test.

negative: with statement with variable short integer value type

	MODULE Test;
	TYPE Type = SIGNED8;
	VAR value: Type;
	BEGIN WITH value : Type DO END;
	END Test.

negative: with statement with variable integer value

	MODULE Test;
	VAR value: SIGNED16;
	BEGIN WITH value : SIGNED16 DO END;
	END Test.

negative: with statement with variable integer value type

	MODULE Test;
	TYPE Type = SIGNED16;
	VAR value: Type;
	BEGIN WITH value : Type DO END;
	END Test.

negative: with statement with variable long integer value

	MODULE Test;
	VAR value: SIGNED32;
	BEGIN WITH value : SIGNED32 DO END;
	END Test.

negative: with statement with variable long integer value type

	MODULE Test;
	TYPE Type = SIGNED32;
	VAR value: Type;
	BEGIN WITH value : Type DO END;
	END Test.

negative: with statement with variable huge integer value

	MODULE Test;
	VAR value: SIGNED64;
	BEGIN WITH value : SIGNED64 DO END;
	END Test.

negative: with statement with variable huge integer value type

	MODULE Test;
	TYPE Type = SIGNED64;
	VAR value: Type;
	BEGIN WITH value : Type DO END;
	END Test.

negative: with statement with variable real value

	MODULE Test;
	VAR value: FLOAT32;
	BEGIN WITH value : FLOAT32 DO END;
	END Test.

negative: with statement with variable real value type

	MODULE Test;
	TYPE Type = FLOAT32;
	VAR value: Type;
	BEGIN WITH value : Type DO END;
	END Test.

negative: with statement with variable long real value

	MODULE Test;
	VAR value: FLOAT64;
	BEGIN WITH value : FLOAT64 DO END;
	END Test.

negative: with statement with variable long real value type

	MODULE Test;
	TYPE Type = FLOAT64;
	VAR value: Type;
	BEGIN WITH value : Type DO END;
	END Test.

negative: with statement with variable set value

	MODULE Test;
	VAR value: SET;
	BEGIN WITH value : SET DO END;
	END Test.

negative: with statement with variable set value type

	MODULE Test;
	TYPE Type = SET;
	VAR value: Type;
	BEGIN WITH value : Type DO END;
	END Test.

negative: with statement with variable array value

	MODULE Test;
	VAR value: ARRAY 10 OF CHAR;
	BEGIN WITH value : ARRAY 10 OF CHAR DO END;
	END Test.

negative: with statement with variable array value type

	MODULE Test;
	TYPE Type = ARRAY 10 OF CHAR;
	VAR value: Type;
	BEGIN WITH value : Type DO END;
	END Test.

negative: with statement with variable record value

	MODULE Test;
	PROCEDURE Procedure (VAR value: RECORD END);
	BEGIN WITH value : RECORD END DO END;
	END Procedure;
	END Test.

positive: with statement with same record type

	MODULE Test;
	TYPE Type = RECORD check: BOOLEAN END;
	PROCEDURE Procedure (VAR value, check: Type);
	BEGIN WITH value : Type DO check := value; value := check; ASSERT (value.check) END;
	END Procedure;
	END Test.

positive: with statement with nested record types

	MODULE Test;
	TYPE A = RECORD a: BOOLEAN END;
	TYPE B = RECORD (A) b: BOOLEAN END;
	TYPE C = RECORD (B) c: BOOLEAN END;
	PROCEDURE Procedure (VAR value: A);
	BEGIN WITH value : B DO WITH value : C DO ASSERT (value.c) END; ASSERT (value.b) END; ASSERT (value.a);
	END Procedure;
	END Test.

negative: with statement with invalid nested record types

	MODULE Test;
	TYPE A = RECORD END;
	TYPE B = RECORD (A) END;
	TYPE C = RECORD (A) END;
	PROCEDURE Procedure (VAR value: A);
	BEGIN WITH value : B DO WITH value : C DO END END;
	END Procedure;
	END Test.

positive: with statement with extending record type

	MODULE Test;
	TYPE Record = RECORD END; Type = RECORD (Record) check: BOOLEAN END;
	PROCEDURE Procedure (VAR value: Record; check: Type);
	BEGIN WITH value : Type DO check := value; value := check; ASSERT (value.check) END;
	END Procedure;
	END Test.

negative: with statement with static extending record type

	MODULE Test;
	TYPE Record = RECORD END; Type = RECORD (Record) check: BOOLEAN END;
	VAR value: Record; check: Type;
	BEGIN WITH value : Type DO check := value; value := check; ASSERT (value.check) END;
	END Test.

negative: with statement with extending record type and invalid assignment

	MODULE Test;
	TYPE Record = RECORD END; Type = RECORD (Record) END;
	PROCEDURE Procedure (VAR value, check: Record);
	BEGIN WITH value : Type DO value := check END;
	END Procedure;
	END Test.

negative: with statement with extended record type

	MODULE Test;
	TYPE Record = RECORD END; Type = Record;
	PROCEDURE Procedure (VAR value: RECORD (Record) END);
	BEGIN WITH value : Type DO END;
	END Procedure;
	END Test.

negative: with statement with incompatible record type

	MODULE Test;
	TYPE Type = RECORD END;
	PROCEDURE Procedure (VAR value: RECORD END);
	BEGIN WITH value : Type DO END;
	END Procedure;
	END Test.

negative: with statement with variable object value

	MODULE Test;
	VAR value: OBJECT END;
	BEGIN WITH value : OBJECT END DO END;
	END Test.

positive: with statement with same object type

	MODULE Test;
	TYPE Type = OBJECT VAR check: BOOLEAN END Type;
	VAR value, check: Type;
	BEGIN WITH value : Type DO check := value; value := check; ASSERT (value.check) END;
	END Test.

positive: with statement with nested object types

	MODULE Test;
	TYPE A = OBJECT VAR a: BOOLEAN END A;
	TYPE B = OBJECT (A) VAR b: BOOLEAN END B;
	TYPE C = OBJECT (B) VAR c: BOOLEAN END C;
	VAR value: A;
	BEGIN WITH value : B DO WITH value : C DO ASSERT (value.c) END; ASSERT (value.b) END; ASSERT (value.a);
	END Test.

negative: with statement with invalid nested object types

	MODULE Test;
	TYPE A = OBJECT END A;
	TYPE B = OBJECT (A) END B;
	TYPE C = OBJECT (A) END C;
	VAR value: A;
	BEGIN WITH value : B DO WITH value : C DO END END;
	END Test.

positive: with statement with extending object type

	MODULE Test;
	TYPE Object = OBJECT END Object; Type = OBJECT (Object) VAR check: BOOLEAN END Type;
	VAR value: Object; check: Type;
	BEGIN WITH value : Type DO check := value; value := check; ASSERT (value.check) END;
	END Test.

negative: with statement with extending object type and invalid assignment

	MODULE Test;
	TYPE Object = OBJECT END Object; Type = OBJECT (Object) END Type;
	VAR value, check: Object;
	BEGIN WITH value : Type DO value := check END;
	END Test.

negative: with statement with extended object type

	MODULE Test;
	TYPE Object = OBJECT END Object; Type = Object;
	VAR value: OBJECT (Object) END;
	BEGIN WITH value : Type DO END;
	END Test.

negative: with statement with incompatible object type

	MODULE Test;
	TYPE Type = OBJECT END Type;
	VAR value: OBJECT END;
	BEGIN WITH value : Type DO END;
	END Test.

negative: with statement with variable base object value

	MODULE Test;
	VAR value: OBJECT;
	BEGIN WITH value : OBJECT DO END;
	END Test.

positive: with statement with same base object type

	MODULE Test;
	TYPE Type = OBJECT;
	VAR value, check: Type;
	BEGIN WITH value : Type DO check := value; value := check END;
	END Test.

positive: with statement with nested base object types

	MODULE Test;
	TYPE A = OBJECT;
	TYPE B = OBJECT (A) VAR b: BOOLEAN END B;
	TYPE C = OBJECT (B) VAR c: BOOLEAN END C;
	VAR value: A;
	BEGIN WITH value : B DO WITH value : C DO ASSERT (value.c) END; ASSERT (value.b) END;
	END Test.

negative: with statement with invalid nested base object types

	MODULE Test;
	TYPE A = OBJECT;
	TYPE B = OBJECT (A) END B;
	TYPE C = OBJECT (A) END C;
	VAR value: A;
	BEGIN WITH value : B DO WITH value : C DO END END;
	END Test.

positive: with statement with extending base object type

	MODULE Test;
	TYPE Object = OBJECT; Type = OBJECT (Object) VAR check: BOOLEAN END Type;
	VAR value: Object; check: Type;
	BEGIN WITH value : Type DO check := value; value := check; ASSERT (value.check) END;
	END Test.

negative: with statement with extending base object type and invalid assignment

	MODULE Test;
	TYPE Object = OBJECT; Type = OBJECT (Object) END Type;
	VAR value, check: Object;
	BEGIN WITH value : Type DO value := check END;
	END Test.

negative: with statement with extended base object type

	MODULE Test;
	TYPE Object = OBJECT; Type = Object;
	VAR value: OBJECT (Object) END;
	BEGIN WITH value : Type DO END;
	END Test.

negative: with statement with self and same object type

	MODULE Test;
	TYPE Object = OBJECT
		BEGIN WITH SELF : Type DO END;
	END Object;
	TYPE Type = Object;
	END Test.

negative: with statement with self and extending object type

	MODULE Test;
	TYPE Object = OBJECT
		BEGIN WITH SELF : Type DO END;
	END Object;
	TYPE Type = OBJECT (Object) END Type;
	END Test.

negative: with statement with self and extended object type

	MODULE Test;
	TYPE Object = OBJECT (Type)
		BEGIN WITH SELF : Type DO END;
	END Object;
	TYPE Type = OBJECT END Type;
	END Test.

positive: with statement with object variable and self assignment

	MODULE Test;
	TYPE Object = OBJECT
		VAR value: Object;
		BEGIN WITH value : Type DO ASSERT (value.check); value := value END;
	END Object;
	TYPE Type = OBJECT (Object) VAR check: BOOLEAN; END Type;
	END Test.

positive: with statement with object variable and self assignment using self

	MODULE Test;
	TYPE Object = OBJECT
		VAR value: Object;
		BEGIN WITH value : Type DO ASSERT (value.check); value := SELF.value END;
	END Object;
	TYPE Type = OBJECT (Object) VAR check: BOOLEAN; END Type;
	END Test.

negative: with statement with object variable and assignment using another object instance

	MODULE Test;
	TYPE Object = OBJECT
		VAR value: Object;
		BEGIN WITH value : Type DO ASSERT (value.check); value := value.value END;
	END Object;
	TYPE Type = OBJECT (Object) VAR check: BOOLEAN; END Type;
	END Test.

negative: with statement with variable pointer to array value

	MODULE Test;
	VAR value: POINTER TO ARRAY 10 OF CHAR;
	BEGIN WITH value : POINTER TO ARRAY 10 OF CHAR DO END;
	END Test.

negative: with statement with variable pointer to array value type

	MODULE Test;
	TYPE Type = POINTER TO ARRAY 10 OF CHAR;
	VAR value: Type;
	BEGIN WITH value : Type DO END;
	END Test.

negative: with statement with variable pointer to record value

	MODULE Test;
	VAR value: POINTER TO RECORD END;
	BEGIN WITH value : POINTER TO RECORD END DO END;
	END Test.

positive: with statement with same pointer to record type

	MODULE Test;
	TYPE Type = POINTER TO RECORD check: BOOLEAN END;
	VAR value: Type; check: Type;
	BEGIN WITH value : Type DO check := value; value := check; ASSERT (value.check) END;
	END Test.

positive: with statement with nested pointer to record types

	MODULE Test;
	TYPE A = RECORD a: BOOLEAN END; PA = POINTER TO A;
	TYPE B = RECORD (A) b: BOOLEAN END; PB = POINTER TO B;
	TYPE C = RECORD (B) c: BOOLEAN END; PC = POINTER TO C;
	VAR value: PA;
	BEGIN WITH value : PB DO WITH value : PC DO ASSERT (value.c) END; ASSERT (value.b) END; ASSERT (value.a);
	END Test.

negative: with statement with invalid nested pointer to record types

	MODULE Test;
	TYPE A = RECORD a: BOOLEAN END; PA = POINTER TO A;
	TYPE B = RECORD (A) b: BOOLEAN END; PB = POINTER TO B;
	TYPE C = RECORD (A) c: BOOLEAN END; PC = POINTER TO C;
	VAR value: PA;
	BEGIN WITH value : PB DO WITH value : PC DO END END;
	END Test.

positive: with statement with extending pointer to record type

	MODULE Test;
	TYPE Record = RECORD END; Type = POINTER TO RECORD (Record) check: BOOLEAN END;
	VAR value: POINTER TO Record; check: Type;
	BEGIN WITH value : Type DO check := value; value := check; ASSERT (value.check) END;
	END Test.

negative: with statement with extending pointer to record type and invalid assignment

	MODULE Test;
	TYPE Record = RECORD END; Type = POINTER TO RECORD (Record) END;
	VAR value, check: POINTER TO Record;
	BEGIN WITH value : Type DO value := check END;
	END Test.

negative: with statement with extended pointer to record type

	MODULE Test;
	TYPE Record = RECORD END; Type = POINTER TO Record;
	VAR value: POINTER TO RECORD (Record) END;
	BEGIN WITH value : Type DO END;
	END Test.

negative: with statement with incompatible pointer to record type

	MODULE Test;
	TYPE Type = POINTER TO RECORD END;
	VAR value: POINTER TO RECORD END;
	BEGIN WITH value : Type DO END;
	END Test.

negative: with statement with variable procedure value

	MODULE Test;
	VAR value: PROCEDURE;
	BEGIN WITH value : PROCEDURE DO END;
	END Test.

negative: with statement with variable procedure value type

	MODULE Test;
	TYPE Type = PROCEDURE;
	VAR value: Type;
	BEGIN WITH value : Type DO END;
	END Test.


# new statement

negative: new statement on constant boolean

	MODULE Test;
	CONST Constant = TRUE;
	BEGIN NEW (Constant);
	END Test.

negative: new statement on constant character

	MODULE Test;
	CONST Constant = 'a';
	BEGIN NEW (Constant);
	END Test.

negative: new statement on constant integer

	MODULE Test;
	CONST Constant = 42;
	BEGIN NEW (Constant);
	END Test.

negative: new statement on constant real

	MODULE Test;
	CONST Constant = 0.1;
	BEGIN NEW (Constant);
	END Test.

negative: new statement on constant set

	MODULE Test;
	CONST Constant = {};
	BEGIN NEW (Constant);
	END Test.

negative: new statement on constant string

	MODULE Test;
	CONST Constant = "string";
	BEGIN NEW (Constant);
	END Test.

negative: new statement on nil pointer

	MODULE Test;
	CONST Constant = NIL;
	BEGIN NEW (Constant);
	END Test.

negative: new statement on boolean

	MODULE Test;
	VAR boolean: BOOLEAN;
	BEGIN NEW (boolean);
	END Test.

negative: new statement on character

	MODULE Test;
	VAR character: CHAR;
	BEGIN NEW (character);
	END Test.

negative: new statement on integer

	MODULE Test;
	VAR integer: SIGNED16;
	BEGIN NEW (integer);
	END Test.

negative: new statement on real

	MODULE Test;
	VAR real: FLOAT32;
	BEGIN NEW (real);
	END Test.

negative: new statement on set

	MODULE Test;
	VAR set: SET;
	BEGIN NEW (set);
	END Test.

negative: new statement on array

	MODULE Test;
	VAR array: ARRAY 10 OF CHAR;
	BEGIN NEW (array);
	END Test.

negative: new statement on record

	MODULE Test;
	VAR record: RECORD END;
	BEGIN NEW (record);
	END Test.

positive: new statement on object parameter

	MODULE Test;
	PROCEDURE Procedure (object: OBJECT END);
	BEGIN NEW (object);
	END Procedure;
	END Test.

positive: new statement on variable object parameter

	MODULE Test;
	PROCEDURE Procedure (VAR object: OBJECT END);
	BEGIN NEW (object);
	END Procedure;
	END Test.

negative: new statement on constant object parameter

	MODULE Test;
	PROCEDURE Procedure (CONST object: OBJECT END);
	BEGIN NEW (object);
	END Procedure;
	END Test.

negative: new statement on self

	MODULE Test;
	TYPE Object = OBJECT
		BEGIN NEW (SELF);
	END Object;
	END Test.

positive: new statement on object without initializer

	MODULE Test;
	VAR object: OBJECT END;
	BEGIN NEW (object);
	END Test.

negative: new statement on object without initializer and one argument

	MODULE Test;
	VAR object: OBJECT END;
	BEGIN NEW (object, 5);
	END Test.

positive: new statement on object with simple initializer

	MODULE Test;
	TYPE Object = OBJECT
		PROCEDURE &Initializer; END Initializer;
	END Object;
	VAR object: Object;
	BEGIN NEW (object);
	END Test.

negative: new statement on object with simple initializer and one argument

	MODULE Test;
	TYPE Object = OBJECT
		PROCEDURE &Initializer; END Initializer;
	END Object;
	VAR object: Object;
	BEGIN NEW (object, 5);
	END Test.

negative: new statement on object with complex initializer and no argument

	MODULE Test;
	TYPE Object = OBJECT
		PROCEDURE &Initializer (i: SIGNED16); END Initializer;
	END Object;
	VAR object: Object;
	BEGIN NEW (object);
	END Test.

positive: new statement on object with complex initializer and one argument

	MODULE Test;
	TYPE Object = OBJECT
		PROCEDURE &Initializer (i: SIGNED16); END Initializer;
	END Object;
	VAR object: Object;
	BEGIN NEW (object, 5);
	END Test.

positive: new statement on object with complex initializer and matching arguments

	MODULE Test;
	TYPE Object = OBJECT
		PROCEDURE &Initializer (i, j: SIGNED16; b: BOOLEAN); END Initializer;
	END Object;
	VAR object: Object;
	BEGIN NEW (object, 5, 6, TRUE);
	END Test.

negative: new statement on object with complex initializer and incompatible arguments

	MODULE Test;
	TYPE Object = OBJECT
		PROCEDURE &Initializer (i: SIGNED16); END Initializer;
	END Object;
	VAR object: Object;
	BEGIN NEW (object, TRUE);
	END Test.

positive: new statement on object with simple inherited initializer

	MODULE Test;
	TYPE Base = OBJECT
		PROCEDURE &Initializer; END Initializer;
	END Base;
	VAR object: OBJECT (Base) END;
	BEGIN NEW (object);
	END Test.

negative: new statement on object with simple inherited initializer and one argument

	MODULE Test;
	TYPE Base = OBJECT
		PROCEDURE &Initializer; END Initializer;
	END Base;
	VAR object: OBJECT (Base) END;
	BEGIN NEW (object, 5);
	END Test.

negative: new statement on object with complex inherited initializer and no argument

	MODULE Test;
	TYPE Base = OBJECT
		PROCEDURE &Initializer (i: SIGNED16); END Initializer;
	END Base;
	VAR object: OBJECT (Base) END;
	BEGIN NEW (object);
	END Test.

positive: new statement on object with complex inherited initializer and one argument

	MODULE Test;
	TYPE Base = OBJECT
		PROCEDURE &Initializer (i: SIGNED16); END Initializer;
	END Base;
	VAR object: OBJECT (Base) END;
	BEGIN NEW (object, 5);
	END Test.

positive: new statement on object with complex inherited initializer and matching arguments

	MODULE Test;
	TYPE Base = OBJECT
		PROCEDURE &Initializer(i, j: SIGNED16; b: BOOLEAN); END Initializer;
	END Base;
	VAR object: OBJECT (Base) END;
	BEGIN NEW (object, 5, 6, TRUE);
	END Test.

positive: new statement on object with simple overridden initializer

	MODULE Test;
	TYPE Base = OBJECT
		PROCEDURE &InitBase (i: SIGNED16); END InitBase;
	END Base;
	TYPE Object = OBJECT (Base)
		PROCEDURE &InitObject; BEGIN InitBase (5) END InitObject;
	END Object;
	VAR object: Object;
	BEGIN NEW (object);
	END Test.

negative: new statement on object with simple overridden initializer and one argument

	MODULE Test;
	TYPE Base = OBJECT
		PROCEDURE &InitBase (i: SIGNED16); END InitBase;
	END Base;
	TYPE Object = OBJECT (Base)
		PROCEDURE &InitObject; END InitObject;
	END Object;
	VAR object: Object;
	BEGIN NEW (object, 5);
	END Test.

negative: new statement on object with complex overridden initializer and no argument

	MODULE Test;
	TYPE Base = OBJECT
		PROCEDURE &InitBase; END InitBase;
	END Base;
	TYPE Object = OBJECT (Base)
		PROCEDURE &InitObject (i: SIGNED16); END InitObject;
	END Object;
	VAR object: Object;
	BEGIN NEW (object);
	END Test.

positive: new statement on object with complex overridden initializer and one argument

	MODULE Test;
	TYPE Base = OBJECT
		PROCEDURE &InitBase; END InitBase;
	END Base;
	TYPE Object = OBJECT (Base)
		PROCEDURE &InitObject (i: SIGNED16); BEGIN InitBase END InitObject;
	END Object;
	VAR object: Object;
	BEGIN NEW (object, 5);
	END Test.

positive: new statement on object with complex overridden initializer and matching arguments

	MODULE Test;
	TYPE Base = OBJECT
		PROCEDURE &InitBase (r: FLOAT32; s: SET); END InitBase;
	END Base;
	TYPE Object = OBJECT (Base)
		PROCEDURE &InitObject (i, j: SIGNED16; b: BOOLEAN); BEGIN InitBase (0, {}) END InitObject;
	END Object;
	VAR object: Object;
	BEGIN NEW (object, 5, 6, TRUE);
	END Test.

positive: new statement on pointer to array with no dimension

	MODULE Test;
	VAR array: POINTER TO ARRAY 10 OF CHAR;
	BEGIN NEW (array);
	END Test.

positive: new statement on pointer to array parameter

	MODULE Test;
	PROCEDURE Procedure (array: POINTER TO ARRAY 10 OF CHAR);
	BEGIN NEW (array);
	END Procedure;
	END Test.

positive: new statement on variable pointer to array parameter

	MODULE Test;
	PROCEDURE Procedure (VAR array: POINTER TO ARRAY 10 OF CHAR);
	BEGIN NEW (array);
	END Procedure;
	END Test.

negative: new statement on constant pointer to array parameter

	MODULE Test;
	PROCEDURE Procedure (CONST array: POINTER TO ARRAY 10 OF CHAR);
	BEGIN NEW (array);
	END Procedure;
	END Test.

negative: new statement on pointer to open array with no dimension

	MODULE Test;
	VAR array: POINTER TO ARRAY OF CHAR;
	BEGIN NEW (array);
	END Test.

positive: new statement on pointer to open array with one dimension

	MODULE Test;
	VAR array: POINTER TO ARRAY OF CHAR;
	BEGIN NEW (array, 5);
	END Test.

negative: new statement on pointer to open array with incompatible dimension

	MODULE Test;
	VAR array: POINTER TO ARRAY OF CHAR;
	BEGIN NEW (array, 10X);
	END Test.

negative: new statement on pointer to open array with negative dimension

	MODULE Test;
	VAR array: POINTER TO ARRAY OF CHAR;
	BEGIN NEW (array, -5);
	END Test.

positive: new statement on pointer to open array with zero dimension

	MODULE Test;
	VAR array: POINTER TO ARRAY OF CHAR;
	BEGIN NEW (array, 0);
	END Test.

negative: new statement on pointer to twice open array with no dimension

	MODULE Test;
	VAR array: POINTER TO ARRAY OF ARRAY 10 OF ARRAY OF CHAR;
	BEGIN NEW (array);
	END Test.

negative: new statement on pointer to twice open array with one dimension

	MODULE Test;
	VAR array: POINTER TO ARRAY OF ARRAY 10 OF ARRAY OF CHAR;
	BEGIN NEW (array, 5);
	END Test.

positive: new statement on pointer to twice open array with two dimensions

	MODULE Test;
	VAR array: POINTER TO ARRAY OF ARRAY OF ARRAY 10 OF CHAR;
	BEGIN NEW (array, 5, 10);
	END Test.

positive: new statement on pointer to record

	MODULE Test;
	VAR record: POINTER TO RECORD END;
	BEGIN NEW (record);
	END Test.

positive: new statement on pointer to record parameter

	MODULE Test;
	PROCEDURE Procedure (record: POINTER TO RECORD END);
	BEGIN NEW (record);
	END Procedure;
	END Test.

positive: new statement on variable pointer to record parameter

	MODULE Test;
	PROCEDURE Procedure (VAR record: POINTER TO RECORD END);
	BEGIN NEW (record);
	END Procedure;
	END Test.

negative: new statement on constant pointer to record parameter

	MODULE Test;
	PROCEDURE Procedure (CONST record: POINTER TO RECORD END);
	BEGIN NEW (record);
	END Procedure;
	END Test.

negative: new statement on pointer to record with argument

	MODULE Test;
	VAR record: POINTER TO RECORD END;
	BEGIN NEW (record, 1);
	END Test.

negative: new statement on pointer to record with arguments

	MODULE Test;
	VAR record: POINTER TO RECORD END;
	BEGIN NEW (record, 1, 2);
	END Test.

negative: new statement on procedure

	MODULE Test;
	VAR procedure: PROCEDURE;
	BEGIN NEW (procedure);
	END Test.


# increment statement

negative: increment statement on constant boolean

	MODULE Test;
	CONST Constant = TRUE;
	BEGIN INC (Constant);
	END Test.

negative: increment statement on constant character

	MODULE Test;
	CONST Constant = 'a';
	BEGIN INC (Constant);
	END Test.

negative: increment statement on constant integer

	MODULE Test;
	CONST Constant = 42;
	BEGIN INC (Constant);
	END Test.

negative: increment statement on constant real

	MODULE Test;
	CONST Constant = 0.1;
	BEGIN INC (Constant);
	END Test.

negative: increment statement on constant set

	MODULE Test;
	CONST Constant = {};
	BEGIN INC (Constant);
	END Test.

negative: increment statement on constant string

	MODULE Test;
	CONST Constant = "string";
	BEGIN INC (Constant);
	END Test.

negative: increment statement on nil pointer

	MODULE Test;
	CONST Constant = NIL;
	BEGIN INC (Constant);
	END Test.

negative: increment statement on boolean

	MODULE Test;
	VAR boolean: BOOLEAN;
	BEGIN INC (boolean);
	END Test.

negative: increment statement on character

	MODULE Test;
	VAR character: CHAR;
	BEGIN INC (character);
	END Test.

positive: increment statement on short integer

	MODULE Test;
	VAR integer: SIGNED8;
	BEGIN INC (integer);
	END Test.

positive: increment statement on integer

	MODULE Test;
	VAR integer: SIGNED16;
	BEGIN INC (integer);
	END Test.

positive: increment statement on long integer

	MODULE Test;
	VAR integer: SIGNED32;
	BEGIN INC (integer);
	END Test.

positive: increment statement on huge integer

	MODULE Test;
	VAR integer: SIGNED64;
	BEGIN INC (integer);
	END Test.

positive: increment statement on integer parameter

	MODULE Test;
	PROCEDURE Procedure (integer: SIGNED16);
	BEGIN INC (integer);
	END Procedure;
	END Test.

positive: increment statement on variable integer parameter

	MODULE Test;
	PROCEDURE Procedure (VAR integer: SIGNED16);
	BEGIN INC (integer);
	END Procedure;
	END Test.

negative: increment statement on constant integer parameter

	MODULE Test;
	PROCEDURE Procedure (CONST integer: SIGNED16);
	BEGIN INC (integer);
	END Procedure;
	END Test.

negative: increment statement on real

	MODULE Test;
	VAR real: FLOAT32;
	BEGIN INC (real);
	END Test.

negative: increment statement on set

	MODULE Test;
	VAR set: SET;
	BEGIN INC (set);
	END Test.

negative: increment statement on array

	MODULE Test;
	VAR array: ARRAY 10 OF CHAR;
	BEGIN INC (array);
	END Test.

negative: increment statement on record

	MODULE Test;
	VAR record: RECORD END;
	BEGIN INC (record);
	END Test.

negative: increment statement on object

	MODULE Test;
	VAR object: OBJECT END;
	BEGIN INC (object);
	END Test.

negative: increment statement on pointer to array

	MODULE Test;
	VAR pointer: POINTER TO ARRAY 10 OF CHAR;
	BEGIN INC (pointer);
	END Test.

negative: increment statement on pointer to record

	MODULE Test;
	VAR pointer: POINTER TO ARRAY 10 OF CHAR;
	BEGIN INC (pointer);
	END Test.

negative: increment statement on procedure

	MODULE Test;
	VAR procedure: PROCEDURE;
	BEGIN INC (procedure);
	END Test.

negative: increment statement with constant boolean as increment

	MODULE Test;
	CONST Constant = TRUE;
	VAR integer: SIGNED16;
	BEGIN INC (integer, Constant);
	END Test.

negative: increment statement with constant character as increment

	MODULE Test;
	CONST Constant = 'a';
	VAR integer: SIGNED16;
	BEGIN INC (integer, Constant);
	END Test.

positive: increment statement with constant integer as increment

	MODULE Test;
	CONST Constant = 42;
	VAR integer: SIGNED16;
	BEGIN INC (integer, Constant);
	END Test.

positive: increment statement with constant negative integer as increment

	MODULE Test;
	VAR integer: SIGNED16;
	BEGIN INC (integer, -5);
	END Test.

positive: increment statement with zero as increment

	MODULE Test;
	VAR integer: SIGNED16;
	BEGIN INC (integer, 0);
	END Test.

positive: increment statement with constant positive integer as increment

	MODULE Test;
	VAR integer: SIGNED16;
	BEGIN INC (integer, 5);
	END Test.

negative: increment statement with constant real as increment

	MODULE Test;
	CONST Constant = 0.1;
	VAR integer: SIGNED16;
	BEGIN INC (integer, Constant);
	END Test.

negative: increment statement with constant set as increment

	MODULE Test;
	CONST Constant = {};
	VAR integer: SIGNED16;
	BEGIN INC (integer, Constant);
	END Test.

negative: increment statement with constant string as increment

	MODULE Test;
	CONST Constant = "string";
	VAR integer: SIGNED16;
	BEGIN INC (integer, Constant);
	END Test.

negative: increment statement with nil pointer as increment

	MODULE Test;
	CONST Constant = NIL;
	VAR integer: SIGNED16;
	BEGIN INC (integer, Constant);
	END Test.

negative: increment statement with boolean as increment

	MODULE Test;
	VAR integer: SIGNED16; increment: BOOLEAN;
	BEGIN INC (integer, increment);
	END Test.

negative: increment statement with character as increment

	MODULE Test;
	VAR integer: SIGNED16; increment: CHAR;
	BEGIN INC (integer, increment);
	END Test.

positive: increment statement on short integer with short integer as increment

	MODULE Test;
	VAR integer, increment: SIGNED8;
	BEGIN INC (integer, increment);
	END Test.

negative: increment statement on short integer with integer as increment

	MODULE Test;
	VAR integer: SIGNED8; increment: SIGNED16;
	BEGIN INC (integer, increment);
	END Test.

negative: increment statement on short integer with long integer as increment

	MODULE Test;
	VAR integer: SIGNED8; increment: SIGNED32;
	BEGIN INC (integer, increment);
	END Test.

negative: increment statement on short integer with huge integer as increment

	MODULE Test;
	VAR integer: SIGNED8; increment: SIGNED64;
	BEGIN INC (integer, increment);
	END Test.

positive: increment statement on integer with short integer as increment

	MODULE Test;
	VAR integer: SIGNED16; increment: SIGNED8;
	BEGIN INC (integer, increment);
	END Test.

positive: increment statement on integer with integer as increment

	MODULE Test;
	VAR integer, increment: SIGNED16;
	BEGIN INC (integer, increment);
	END Test.

negative: increment statement on integer with long integer as increment

	MODULE Test;
	VAR integer: SIGNED16; increment: SIGNED32;
	BEGIN INC (integer, increment);
	END Test.

negative: increment statement on integer with huge integer as increment

	MODULE Test;
	VAR integer: SIGNED16; increment: SIGNED64;
	BEGIN INC (integer, increment);
	END Test.

positive: increment statement on long integer with short integer as increment

	MODULE Test;
	VAR integer: SIGNED32; increment: SIGNED8;
	BEGIN INC (integer, increment);
	END Test.

positive: increment statement on long integer with integer as increment

	MODULE Test;
	VAR integer: SIGNED32; increment: SIGNED16;
	BEGIN INC (integer, increment);
	END Test.

positive: increment statement on long integer with long integer as increment

	MODULE Test;
	VAR integer, increment: SIGNED32;
	BEGIN INC (integer, increment);
	END Test.

negative: increment statement on long integer with huge integer as increment

	MODULE Test;
	VAR integer: SIGNED32; increment: SIGNED64;
	BEGIN INC (integer, increment);
	END Test.

positive: increment statement on huge integer with short integer as increment

	MODULE Test;
	VAR integer: SIGNED64; increment: SIGNED8;
	BEGIN INC (integer, increment);
	END Test.

positive: increment statement on huge integer with integer as increment

	MODULE Test;
	VAR integer: SIGNED64; increment: SIGNED16;
	BEGIN INC (integer, increment);
	END Test.

positive: increment statement on huge integer with long integer as increment

	MODULE Test;
	VAR integer: SIGNED64; increment: SIGNED32;
	BEGIN INC (integer, increment);
	END Test.

positive: increment statement on huge integer with huge integer as increment

	MODULE Test;
	VAR integer, increment: SIGNED64;
	BEGIN INC (integer, increment);
	END Test.

positive: increment statement with integer parameter as increment

	MODULE Test;
	PROCEDURE Procedure (increment: SIGNED16);
	VAR integer: SIGNED16;
	BEGIN INC (integer, increment);
	END Procedure;
	END Test.

positive: increment statement with variable integer parameter as increment

	MODULE Test;
	PROCEDURE Procedure (VAR increment: SIGNED16);
	VAR integer: SIGNED16;
	BEGIN INC (integer, increment);
	END Procedure;
	END Test.

positive: increment statement with constant integer parameter as increment

	MODULE Test;
	PROCEDURE Procedure (CONST increment: SIGNED16);
	VAR integer: SIGNED16;
	BEGIN INC (integer, increment);
	END Procedure;
	END Test.

negative: increment statement with real as increment

	MODULE Test;
	VAR integer: SIGNED16; increment: FLOAT32;
	BEGIN INC (integer, increment);
	END Test.

negative: increment statement with set as increment

	MODULE Test;
	VAR integer: SIGNED16; increment: SET;
	BEGIN INC (integer, increment);
	END Test.

negative: increment statement with array as increment

	MODULE Test;
	VAR integer: SIGNED16; increment: ARRAY 10 OF CHAR;
	BEGIN INC (integer, increment);
	END Test.

negative: increment statement with record as increment

	MODULE Test;
	VAR integer: SIGNED16; increment: RECORD END;
	BEGIN INC (integer, increment);
	END Test.

negative: increment statement with object as increment

	MODULE Test;
	VAR integer: SIGNED16; increment: OBJECT END;
	BEGIN INC (integer, increment);
	END Test.

negative: increment statement with pointer to array as increment

	MODULE Test;
	VAR integer: SIGNED16; increment: POINTER TO ARRAY 10 OF CHAR;
	BEGIN INC (integer, increment);
	END Test.

negative: increment statement with pointer to record as increment

	MODULE Test;
	VAR integer: SIGNED16; increment: POINTER TO ARRAY 10 OF CHAR;
	BEGIN INC (integer, increment);
	END Test.

negative: increment statement with procedure as increment

	MODULE Test;
	VAR integer: SIGNED16; increment: PROCEDURE;
	BEGIN INC (integer, increment);
	END Test.


# decrement statement

negative: decrement statement on constant boolean

	MODULE Test;
	CONST Constant = TRUE;
	BEGIN DEC (Constant);
	END Test.

negative: decrement statement on constant character

	MODULE Test;
	CONST Constant = 'a';
	BEGIN DEC (Constant);
	END Test.

negative: decrement statement on constant integer

	MODULE Test;
	CONST Constant = 42;
	BEGIN DEC (Constant);
	END Test.

negative: decrement statement on constant real

	MODULE Test;
	CONST Constant = 0.1;
	BEGIN DEC (Constant);
	END Test.

negative: decrement statement on constant set

	MODULE Test;
	CONST Constant = {};
	BEGIN DEC (Constant);
	END Test.

negative: decrement statement on constant string

	MODULE Test;
	CONST Constant = "string";
	BEGIN DEC (Constant);
	END Test.

negative: decrement statement on nil pointer

	MODULE Test;
	CONST Constant = NIL;
	BEGIN DEC (Constant);
	END Test.

negative: decrement statement on boolean

	MODULE Test;
	VAR boolean: BOOLEAN;
	BEGIN DEC (boolean);
	END Test.

negative: decrement statement on character

	MODULE Test;
	VAR character: CHAR;
	BEGIN DEC (character);
	END Test.

positive: decrement statement on short integer

	MODULE Test;
	VAR integer: SIGNED8;
	BEGIN DEC (integer);
	END Test.

positive: decrement statement on integer

	MODULE Test;
	VAR integer: SIGNED16;
	BEGIN DEC (integer);
	END Test.

positive: decrement statement on long integer

	MODULE Test;
	VAR integer: SIGNED32;
	BEGIN DEC (integer);
	END Test.

positive: decrement statement on huge integer

	MODULE Test;
	VAR integer: SIGNED64;
	BEGIN DEC (integer);
	END Test.

positive: decrement statement on integer parameter

	MODULE Test;
	PROCEDURE Procedure (integer: SIGNED16);
	BEGIN DEC (integer);
	END Procedure;
	END Test.

positive: decrement statement on variable integer parameter

	MODULE Test;
	PROCEDURE Procedure (VAR integer: SIGNED16);
	BEGIN DEC (integer);
	END Procedure;
	END Test.

negative: decrement statement on constant integer parameter

	MODULE Test;
	PROCEDURE Procedure (CONST integer: SIGNED16);
	BEGIN DEC (integer);
	END Procedure;
	END Test.

negative: decrement statement on real

	MODULE Test;
	VAR real: FLOAT32;
	BEGIN DEC (real);
	END Test.

negative: decrement statement on set

	MODULE Test;
	VAR set: SET;
	BEGIN DEC (set);
	END Test.

negative: decrement statement on array

	MODULE Test;
	VAR array: ARRAY 10 OF CHAR;
	BEGIN DEC (array);
	END Test.

negative: decrement statement on record

	MODULE Test;
	VAR record: RECORD END;
	BEGIN DEC (record);
	END Test.

negative: decrement statement on object

	MODULE Test;
	VAR object: OBJECT END;
	BEGIN DEC (object);
	END Test.

negative: decrement statement on pointer to array

	MODULE Test;
	VAR pointer: POINTER TO ARRAY 10 OF CHAR;
	BEGIN DEC (pointer);
	END Test.

negative: decrement statement on pointer to record

	MODULE Test;
	VAR pointer: POINTER TO ARRAY 10 OF CHAR;
	BEGIN DEC (pointer);
	END Test.

negative: decrement statement on procedure

	MODULE Test;
	VAR procedure: PROCEDURE;
	BEGIN DEC (procedure);
	END Test.

negative: decrement statement with constant boolean as increment

	MODULE Test;
	CONST Constant = TRUE;
	VAR integer: SIGNED16;
	BEGIN DEC (integer, Constant);
	END Test.

negative: decrement statement with constant character as increment

	MODULE Test;
	CONST Constant = 'a';
	VAR integer: SIGNED16;
	BEGIN DEC (integer, Constant);
	END Test.

positive: decrement statement with constant integer as increment

	MODULE Test;
	CONST Constant = 42;
	VAR integer: SIGNED16;
	BEGIN DEC (integer, Constant);
	END Test.

positive: decrement statement with constant negative integer as increment

	MODULE Test;
	VAR integer: SIGNED16;
	BEGIN DEC (integer, -5);
	END Test.

positive: decrement statement with zero as increment

	MODULE Test;
	VAR integer: SIGNED16;
	BEGIN DEC (integer, 0);
	END Test.

positive: decrement statement with constant positive integer as increment

	MODULE Test;
	VAR integer: SIGNED16;
	BEGIN DEC (integer, 5);
	END Test.

negative: decrement statement with constant real as increment

	MODULE Test;
	CONST Constant = 0.1;
	VAR integer: SIGNED16;
	BEGIN DEC (integer, Constant);
	END Test.

negative: decrement statement with constant set as increment

	MODULE Test;
	CONST Constant = {};
	VAR integer: SIGNED16;
	BEGIN DEC (integer, Constant);
	END Test.

negative: decrement statement with constant string as increment

	MODULE Test;
	CONST Constant = "string";
	VAR integer: SIGNED16;
	BEGIN DEC (integer, Constant);
	END Test.

negative: decrement statement with nil pointer as increment

	MODULE Test;
	CONST Constant = NIL;
	VAR integer: SIGNED16;
	BEGIN DEC (integer, Constant);
	END Test.

negative: decrement statement with boolean as increment

	MODULE Test;
	VAR integer: SIGNED16; increment: BOOLEAN;
	BEGIN DEC (integer, increment);
	END Test.

negative: decrement statement with character as increment

	MODULE Test;
	VAR integer: SIGNED16; increment: CHAR;
	BEGIN DEC (integer, increment);
	END Test.

positive: decrement statement on short integer with short integer as increment

	MODULE Test;
	VAR integer, increment: SIGNED8;
	BEGIN DEC (integer, increment);
	END Test.

negative: decrement statement on short integer with integer as increment

	MODULE Test;
	VAR integer: SIGNED8; increment: SIGNED16;
	BEGIN DEC (integer, increment);
	END Test.

negative: decrement statement on short integer with long integer as increment

	MODULE Test;
	VAR integer: SIGNED8; increment: SIGNED32;
	BEGIN DEC (integer, increment);
	END Test.

negative: decrement statement on short integer with huge integer as increment

	MODULE Test;
	VAR integer: SIGNED8; increment: SIGNED64;
	BEGIN DEC (integer, increment);
	END Test.

positive: decrement statement on integer with short integer as increment

	MODULE Test;
	VAR integer: SIGNED16; increment: SIGNED8;
	BEGIN DEC (integer, increment);
	END Test.

positive: decrement statement on integer with integer as increment

	MODULE Test;
	VAR integer, increment: SIGNED16;
	BEGIN DEC (integer, increment);
	END Test.

negative: decrement statement on integer with long integer as increment

	MODULE Test;
	VAR integer: SIGNED16; increment: SIGNED32;
	BEGIN DEC (integer, increment);
	END Test.

negative: decrement statement on integer with huge integer as increment

	MODULE Test;
	VAR integer: SIGNED16; increment: SIGNED64;
	BEGIN DEC (integer, increment);
	END Test.

positive: decrement statement on long integer with short integer as increment

	MODULE Test;
	VAR integer: SIGNED32; increment: SIGNED8;
	BEGIN DEC (integer, increment);
	END Test.

positive: decrement statement on long integer with integer as increment

	MODULE Test;
	VAR integer: SIGNED32; increment: SIGNED16;
	BEGIN DEC (integer, increment);
	END Test.

positive: decrement statement on long integer with long integer as increment

	MODULE Test;
	VAR integer, increment: SIGNED32;
	BEGIN DEC (integer, increment);
	END Test.

negative: decrement statement on long integer with huge integer as increment

	MODULE Test;
	VAR integer: SIGNED32; increment: SIGNED64;
	BEGIN DEC (integer, increment);
	END Test.

positive: decrement statement on huge integer with short integer as increment

	MODULE Test;
	VAR integer: SIGNED64; increment: SIGNED8;
	BEGIN DEC (integer, increment);
	END Test.

positive: decrement statement on huge integer with integer as increment

	MODULE Test;
	VAR integer: SIGNED64; increment: SIGNED16;
	BEGIN DEC (integer, increment);
	END Test.

positive: decrement statement on huge integer with long integer as increment

	MODULE Test;
	VAR integer: SIGNED64; increment: SIGNED32;
	BEGIN DEC (integer, increment);
	END Test.

positive: decrement statement on huge integer with huge integer as increment

	MODULE Test;
	VAR integer, increment: SIGNED64;
	BEGIN DEC (integer, increment);
	END Test.

positive: decrement statement with integer parameter as increment

	MODULE Test;
	PROCEDURE Procedure (increment: SIGNED16);
	VAR integer: SIGNED16;
	BEGIN DEC (integer, increment);
	END Procedure;
	END Test.

positive: decrement statement with variable integer parameter as increment

	MODULE Test;
	PROCEDURE Procedure (VAR increment: SIGNED16);
	VAR integer: SIGNED16;
	BEGIN DEC (integer, increment);
	END Procedure;
	END Test.

positive: decrement statement with constant integer parameter as increment

	MODULE Test;
	PROCEDURE Procedure (CONST increment: SIGNED16);
	VAR integer: SIGNED16;
	BEGIN DEC (integer, increment);
	END Procedure;
	END Test.

negative: decrement statement with real as increment

	MODULE Test;
	VAR integer: SIGNED16; increment: FLOAT32;
	BEGIN DEC (integer, increment);
	END Test.

negative: decrement statement with set as increment

	MODULE Test;
	VAR integer: SIGNED16; increment: SET;
	BEGIN DEC (integer, increment);
	END Test.

negative: decrement statement with array as increment

	MODULE Test;
	VAR integer: SIGNED16; increment: ARRAY 10 OF CHAR;
	BEGIN DEC (integer, increment);
	END Test.

negative: decrement statement with record as increment

	MODULE Test;
	VAR integer: SIGNED16; increment: RECORD END;
	BEGIN DEC (integer, increment);
	END Test.

negative: decrement statement with object as increment

	MODULE Test;
	VAR integer: SIGNED16; increment: OBJECT END;
	BEGIN DEC (integer, increment);
	END Test.

negative: decrement statement with pointer to array as increment

	MODULE Test;
	VAR integer: SIGNED16; increment: POINTER TO ARRAY 10 OF CHAR;
	BEGIN DEC (integer, increment);
	END Test.

negative: decrement statement with pointer to record as increment

	MODULE Test;
	VAR integer: SIGNED16; increment: POINTER TO ARRAY 10 OF CHAR;
	BEGIN DEC (integer, increment);
	END Test.

negative: decrement statement with procedure as increment

	MODULE Test;
	VAR integer: SIGNED16; increment: PROCEDURE;
	BEGIN DEC (integer, increment);
	END Test.


# include statement

negative: include statement on constant boolean

	MODULE Test;
	CONST Constant = TRUE;
	BEGIN INCL (Constant, 0);
	END Test.

negative: include statement on constant character

	MODULE Test;
	CONST Constant = 'a';
	BEGIN INCL (Constant, 0);
	END Test.

negative: include statement on constant integer

	MODULE Test;
	CONST Constant = 42;
	BEGIN INCL (Constant, 0);
	END Test.

negative: include statement on constant real

	MODULE Test;
	CONST Constant = 0.1;
	BEGIN INCL (Constant, 0);
	END Test.

negative: include statement on constant set

	MODULE Test;
	CONST Constant = {};
	BEGIN INCL (Constant, 0);
	END Test.

negative: include statement on constant string

	MODULE Test;
	CONST Constant = "string";
	BEGIN INCL (Constant, 0);
	END Test.

negative: include statement on nil pointer

	MODULE Test;
	CONST Constant = NIL;
	BEGIN INCL (Constant, 0);
	END Test.

negative: include statement on boolean

	MODULE Test;
	VAR boolean: BOOLEAN;
	BEGIN INCL (boolean, 0);
	END Test.

negative: include statement on character

	MODULE Test;
	VAR character: CHAR;
	BEGIN INCL (character, 0);
	END Test.

negative: include statement on integer

	MODULE Test;
	VAR integer: SIGNED16;
	BEGIN INCL (integer, 0);
	END Test.

negative: include statement on real

	MODULE Test;
	VAR real: FLOAT32;
	BEGIN INCL (real, 0);
	END Test.

negative: include statement on set with constant boolean

	MODULE Test;
	VAR set: SET;
	BEGIN INCL (set, TRUE);
	END Test.

negative: include statement on set with constant character

	MODULE Test;
	VAR set: SET;
	BEGIN INCL (set, 'f');
	END Test.

positive: include statement on set with positive constant integer

	MODULE Test;
	VAR set: SET;
	BEGIN INCL (set, 5);
	END Test.

negative: include statement on set with constant integer exceeding valid range

	MODULE Test;
	VAR set: SET;
	BEGIN INCL (set, 5654);
	END Test.

positive: include statement on set with zero

	MODULE Test;
	VAR set: SET;
	BEGIN INCL (set, 0);
	END Test.

negative: include statement on set with negative constant integer

	MODULE Test;
	VAR set: SET;
	BEGIN INCL (set, -5);
	END Test.

positive: include statement on set parameter

	MODULE Test;
	PROCEDURE Procedure (set: SET);
	BEGIN INCL (set, 0);
	END Procedure;
	END Test.

positive: include statement on variable set parameter

	MODULE Test;
	PROCEDURE Procedure (VAR set: SET);
	BEGIN INCL (set, 0);
	END Procedure;
	END Test.

negative: include statement on constant set parameter

	MODULE Test;
	PROCEDURE Procedure (CONST set: SET);
	BEGIN INCL (set, 0);
	END Procedure;
	END Test.

positive: include statement on set with integer parameter

	MODULE Test;
	PROCEDURE Procedure (integer: SIGNED16);
	VAR set: SET;
	BEGIN INCL (set, integer);
	END Procedure;
	END Test.

positive: include statement on set with variable integer parameter

	MODULE Test;
	PROCEDURE Procedure (VAR integer: SIGNED16);
	VAR set: SET;
	BEGIN INCL (set, integer);
	END Procedure;
	END Test.

positive: include statement on set with constant integer parameter

	MODULE Test;
	PROCEDURE Procedure (CONST integer: SIGNED16);
	VAR set: SET;
	BEGIN INCL (set, integer);
	END Procedure;
	END Test.

negative: include statement on set with constant real

	MODULE Test;
	VAR set: SET;
	BEGIN INCL (set, 0.0);
	END Test.

negative: include statement on set with constant set

	MODULE Test;
	VAR set: SET;
	BEGIN INCL (set, {});
	END Test.

negative: include statement on set with constant string

	MODULE Test;
	VAR set: SET;
	BEGIN INCL (set, "element");
	END Test.

negative: include statement on set with nil pointer

	MODULE Test;
	VAR set: SET;
	BEGIN INCL (set, NIL);
	END Test.

negative: include statement on set with boolean

	MODULE Test;
	VAR set: SET; boolean: BOOLEAN;
	BEGIN INCL (set, boolean);
	END Test.

negative: include statement on set with character

	MODULE Test;
	VAR set: SET; character: CHAR;
	BEGIN INCL (set, character);
	END Test.

positive: include statement on set with short integer

	MODULE Test;
	VAR set: SET; integer: SIGNED8;
	BEGIN INCL (set, integer);
	END Test.

positive: include statement on set with integer

	MODULE Test;
	VAR set: SET; integer: SIGNED16;
	BEGIN INCL (set, integer);
	END Test.

positive: include statement on set with long integer

	MODULE Test;
	VAR set: SET; integer: SIGNED32;
	BEGIN INCL (set, integer);
	END Test.

positive: include statement on set with huge integer

	MODULE Test;
	VAR set: SET; integer: SIGNED64;
	BEGIN INCL (set, integer);
	END Test.

negative: include statement on set with real

	MODULE Test;
	VAR set: SET; real: FLOAT32;
	BEGIN INCL (set, real);
	END Test.

negative: include statement on array

	MODULE Test;
	VAR array: ARRAY 10 OF CHAR;
	BEGIN INCL (array, 0);
	END Test.

negative: include statement on record

	MODULE Test;
	VAR record: RECORD END;
	BEGIN INCL (record, 0);
	END Test.

negative: include statement on object

	MODULE Test;
	VAR object: OBJECT END;
	BEGIN INCL (object, 0);
	END Test.

negative: include statement on pointer to array

	MODULE Test;
	VAR pointer: POINTER TO ARRAY 10 OF CHAR;
	BEGIN INCL (pointer, 0);
	END Test.

negative: include statement on pointer to record

	MODULE Test;
	VAR pointer: POINTER TO ARRAY 10 OF CHAR;
	BEGIN INCL (pointer, 0);
	END Test.

negative: include statement on procedure

	MODULE Test;
	VAR procedure: PROCEDURE;
	BEGIN INCL (procedure, 0);
	END Test.


# exclude statement

negative: exclude statement on constant boolean

	MODULE Test;
	CONST Constant = TRUE;
	BEGIN EXCL (Constant, 0);
	END Test.

negative: exclude statement on constant character

	MODULE Test;
	CONST Constant = 'a';
	BEGIN EXCL (Constant, 0);
	END Test.

negative: exclude statement on constant integer

	MODULE Test;
	CONST Constant = 42;
	BEGIN EXCL (Constant, 0);
	END Test.

negative: exclude statement on constant real

	MODULE Test;
	CONST Constant = 0.1;
	BEGIN EXCL (Constant, 0);
	END Test.

negative: exclude statement on constant set

	MODULE Test;
	CONST Constant = {};
	BEGIN EXCL (Constant, 0);
	END Test.

negative: exclude statement on constant string

	MODULE Test;
	CONST Constant = "string";
	BEGIN EXCL (Constant, 0);
	END Test.

negative: exclude statement on nil pointer

	MODULE Test;
	CONST Constant = NIL;
	BEGIN EXCL (Constant, 0);
	END Test.

negative: exclude statement on boolean

	MODULE Test;
	VAR boolean: BOOLEAN;
	BEGIN EXCL (boolean, 0);
	END Test.

negative: exclude statement on character

	MODULE Test;
	VAR character: CHAR;
	BEGIN EXCL (character, 0);
	END Test.

negative: exclude statement on integer

	MODULE Test;
	VAR integer: SIGNED16;
	BEGIN EXCL (integer, 0);
	END Test.

negative: exclude statement on real

	MODULE Test;
	VAR real: FLOAT32;
	BEGIN EXCL (real, 0);
	END Test.

negative: exclude statement on set with constant boolean

	MODULE Test;
	VAR set: SET;
	BEGIN EXCL (set, TRUE);
	END Test.

negative: exclude statement on set with constant character

	MODULE Test;
	VAR set: SET;
	BEGIN EXCL (set, 'f');
	END Test.

positive: exclude statement on set with positive constant integer

	MODULE Test;
	VAR set: SET;
	BEGIN EXCL (set, 5);
	END Test.

negative: exclude statement on set with constant integer exceeding valid range

	MODULE Test;
	VAR set: SET;
	BEGIN EXCL (set, 5654);
	END Test.

positive: exclude statement on set with zero

	MODULE Test;
	VAR set: SET;
	BEGIN EXCL (set, 0);
	END Test.

negative: exclude statement on set with negative constant integer

	MODULE Test;
	VAR set: SET;
	BEGIN EXCL (set, -5);
	END Test.

positive: exclude statement on set parameter

	MODULE Test;
	PROCEDURE Procedure (set: SET);
	BEGIN EXCL (set, 0);
	END Procedure;
	END Test.

positive: exclude statement on variable set parameter

	MODULE Test;
	PROCEDURE Procedure (VAR set: SET);
	BEGIN EXCL (set, 0);
	END Procedure;
	END Test.

negative: exclude statement on constant set parameter

	MODULE Test;
	PROCEDURE Procedure (CONST set: SET);
	BEGIN EXCL (set, 0);
	END Procedure;
	END Test.

positive: exclude statement on set with integer parameter

	MODULE Test;
	PROCEDURE Procedure (integer: SIGNED16);
	VAR set: SET;
	BEGIN EXCL (set, integer);
	END Procedure;
	END Test.

positive: exclude statement on set with variable integer parameter

	MODULE Test;
	PROCEDURE Procedure (VAR integer: SIGNED16);
	VAR set: SET;
	BEGIN EXCL (set, integer);
	END Procedure;
	END Test.

positive: exclude statement on set with constant integer parameter

	MODULE Test;
	PROCEDURE Procedure (CONST integer: SIGNED16);
	VAR set: SET;
	BEGIN EXCL (set, integer);
	END Procedure;
	END Test.

negative: exclude statement on set with constant real

	MODULE Test;
	VAR set: SET;
	BEGIN EXCL (set, 0.0);
	END Test.

negative: exclude statement on set with constant set

	MODULE Test;
	VAR set: SET;
	BEGIN EXCL (set, {});
	END Test.

negative: exclude statement on set with constant string

	MODULE Test;
	VAR set: SET;
	BEGIN EXCL (set, "element");
	END Test.

negative: exclude statement on set with nil pointer

	MODULE Test;
	VAR set: SET;
	BEGIN EXCL (set, NIL);
	END Test.

negative: exclude statement on set with boolean

	MODULE Test;
	VAR set: SET; boolean: BOOLEAN;
	BEGIN EXCL (set, boolean);
	END Test.

negative: exclude statement on set with character

	MODULE Test;
	VAR set: SET; character: CHAR;
	BEGIN EXCL (set, character);
	END Test.

positive: exclude statement on set with short integer

	MODULE Test;
	VAR set: SET; integer: SIGNED8;
	BEGIN EXCL (set, integer);
	END Test.

positive: exclude statement on set with integer

	MODULE Test;
	VAR set: SET; integer: SIGNED16;
	BEGIN EXCL (set, integer);
	END Test.

positive: exclude statement on set with long integer

	MODULE Test;
	VAR set: SET; integer: SIGNED32;
	BEGIN EXCL (set, integer);
	END Test.

positive: exclude statement on set with huge integer

	MODULE Test;
	VAR set: SET; integer: SIGNED64;
	BEGIN EXCL (set, integer);
	END Test.

negative: exclude statement on set with real

	MODULE Test;
	VAR set: SET; real: FLOAT32;
	BEGIN EXCL (set, real);
	END Test.

negative: exclude statement on array

	MODULE Test;
	VAR array: ARRAY 10 OF CHAR;
	BEGIN EXCL (array, 0);
	END Test.

negative: exclude statement on record

	MODULE Test;
	VAR record: RECORD END;
	BEGIN EXCL (record, 0);
	END Test.

negative: exclude statement on object

	MODULE Test;
	VAR object: OBJECT END;
	BEGIN EXCL (object, 0);
	END Test.

negative: exclude statement on pointer to array

	MODULE Test;
	VAR pointer: POINTER TO ARRAY 10 OF CHAR;
	BEGIN EXCL (pointer, 0);
	END Test.

negative: exclude statement on pointer to record

	MODULE Test;
	VAR pointer: POINTER TO ARRAY 10 OF CHAR;
	BEGIN EXCL (pointer, 0);
	END Test.

negative: exclude statement on procedure

	MODULE Test;
	VAR procedure: PROCEDURE;
	BEGIN EXCL (procedure, 0);
	END Test.


# copy statement

negative: copy statement on boolean

	MODULE Test;
	VAR source, dest: BOOLEAN;
	BEGIN COPY (source, dest);
	END Test.

negative: copy statement on character

	MODULE Test;
	VAR source, dest: CHAR;
	BEGIN COPY (source, dest);
	END Test.

negative: copy statement on integer

	MODULE Test;
	VAR source, dest: SIGNED16;
	BEGIN COPY (source, dest);
	END Test.

negative: copy statement on real

	MODULE Test;
	VAR source, dest: FLOAT32;
	BEGIN COPY (source, dest);
	END Test.

negative: copy statement on set

	MODULE Test;
	VAR source, dest: SET;
	BEGIN COPY (source, dest);
	END Test.

negative: copy statement on array of boolean

	MODULE Test;
	VAR source, dest: ARRAY 10 OF BOOLEAN;
	BEGIN COPY (source, dest);
	END Test.

positive: copy statement on array of character

	MODULE Test;
	VAR source, dest: ARRAY 10 OF CHAR;
	BEGIN COPY (source, dest);
	END Test.

positive: copy statement on array of character and longer array of character

	MODULE Test;
	VAR source: ARRAY 10 OF CHAR; dest: ARRAY 20 OF CHAR;
	BEGIN COPY (source, dest);
	END Test.

positive: copy statement on array of character and shorter array of character

	MODULE Test;
	VAR source: ARRAY 20 OF CHAR; dest: ARRAY 10 OF CHAR;
	BEGIN source[9] := 0X; COPY (source, dest);
	END Test.

positive: copy statement on string and longer array of character

	MODULE Test;
	CONST Source = "source";
	VAR dest: ARRAY 10 OF CHAR;
	BEGIN COPY (Source, dest);
	END Test.

negative: copy statement on string and shorter array of character

	MODULE Test;
	CONST Source = "longer source";
	VAR dest: ARRAY 10 OF CHAR;
	BEGIN COPY (Source, dest);
	END Test.

negative: copy statement on array of character and string

	MODULE Test;
	CONST Dest = "dest";
	VAR source: ARRAY 10 OF CHAR;
	BEGIN COPY (source, Dest);
	END Test.

positive: copy statement with array of character parameter as source

	MODULE Test;
	PROCEDURE Procedure (source: ARRAY 10 OF CHAR);
	VAR dest: ARRAY 10 OF CHAR;
	BEGIN COPY (source, dest);
	END Procedure;
	END Test.

positive: copy statement with variable array of character parameter as source

	MODULE Test;
	PROCEDURE Procedure (VAR source: ARRAY 10 OF CHAR);
	VAR dest: ARRAY 10 OF CHAR;
	BEGIN COPY (source, dest);
	END Procedure;
	END Test.

positive: copy statement with constant array of character parameter as source

	MODULE Test;
	PROCEDURE Procedure (CONST source: ARRAY 10 OF CHAR);
	VAR dest: ARRAY 10 OF CHAR;
	BEGIN COPY (source, dest);
	END Procedure;
	END Test.

positive: copy statement with open array of character parameter as source

	MODULE Test;
	PROCEDURE Procedure (source: ARRAY OF CHAR);
	VAR dest: ARRAY 10 OF CHAR;
	BEGIN COPY (source, dest);
	END Procedure;
	END Test.

positive: copy statement with open variable array of character parameter as source

	MODULE Test;
	PROCEDURE Procedure (VAR source: ARRAY OF CHAR);
	VAR dest: ARRAY 10 OF CHAR;
	BEGIN COPY (source, dest);
	END Procedure;
	END Test.

positive: copy statement with open constant array of character parameter as source

	MODULE Test;
	PROCEDURE Procedure (CONST source: ARRAY OF CHAR);
	VAR dest: ARRAY 10 OF CHAR;
	BEGIN COPY (source, dest);
	END Procedure;
	END Test.

positive: copy statement with array of character parameter as destination

	MODULE Test;
	PROCEDURE Procedure (dest: ARRAY 10 OF CHAR);
	VAR source: ARRAY 10 OF CHAR;
	BEGIN COPY (source, dest);
	END Procedure;
	END Test.

positive: copy statement with variable array of character parameter as destination

	MODULE Test;
	PROCEDURE Procedure (VAR dest: ARRAY 10 OF CHAR);
	VAR source: ARRAY 10 OF CHAR;
	BEGIN COPY (source, dest);
	END Procedure;
	END Test.

negative: copy statement with constant array of character parameter as destination

	MODULE Test;
	PROCEDURE Procedure (CONST dest: ARRAY 10 OF CHAR);
	VAR source: ARRAY 10 OF CHAR;
	BEGIN COPY (source, dest);
	END Procedure;
	END Test.

positive: copy statement with open array of character parameter as destination

	MODULE Test;
	PROCEDURE Procedure (dest: ARRAY OF CHAR);
	VAR source: ARRAY 10 OF CHAR;
	BEGIN COPY (source, dest);
	END Procedure;
	END Test.

positive: copy statement with open variable array of character parameter as destination

	MODULE Test;
	PROCEDURE Procedure (VAR dest: ARRAY OF CHAR);
	VAR source: ARRAY 10 OF CHAR;
	BEGIN COPY (source, dest);
	END Procedure;
	END Test.

negative: copy statement with open constant array of character parameter as destination

	MODULE Test;
	PROCEDURE Procedure (CONST dest: ARRAY OF CHAR);
	VAR source: ARRAY 10 OF CHAR;
	BEGIN COPY (source, dest);
	END Procedure;
	END Test.

positive: copy statement with string as source and array of character parameter as destination

	MODULE Test;
	PROCEDURE Procedure (dest: ARRAY 10 OF CHAR);
	BEGIN COPY ("source", dest);
	END Procedure;
	END Test.

positive: copy statement with string as source and variable array of character parameter as destination

	MODULE Test;
	PROCEDURE Procedure (VAR dest: ARRAY 10 OF CHAR);
	BEGIN COPY ("source", dest);
	END Procedure;
	END Test.

negative: copy statement with string as source and constant array of character parameter as destination

	MODULE Test;
	PROCEDURE Procedure (CONST dest: ARRAY 10 OF CHAR);
	BEGIN COPY ("source", dest);
	END Procedure;
	END Test.

positive: copy statement with string as source and open array of character parameter as destination

	MODULE Test;
	PROCEDURE Procedure (dest: ARRAY OF CHAR);
	BEGIN COPY ("source", dest);
	END Procedure;
	END Test.

positive: copy statement with string as source and open variable array of character parameter as destination

	MODULE Test;
	PROCEDURE Procedure (VAR dest: ARRAY OF CHAR);
	BEGIN COPY ("source", dest);
	END Procedure;
	END Test.

negative: copy statement with string as source and open constant array of character parameter as destination

	MODULE Test;
	PROCEDURE Procedure (CONST dest: ARRAY OF CHAR);
	BEGIN COPY ("source", dest);
	END Procedure;
	END Test.

negative: copy statement on array of integer

	MODULE Test;
	VAR source, dest: ARRAY 10 OF SIGNED16;
	BEGIN COPY (source, dest);
	END Test.

negative: copy statement on array of real

	MODULE Test;
	VAR source, dest: ARRAY 10 OF FLOAT32;
	BEGIN COPY (source, dest);
	END Test.

negative: copy statement on array of set

	MODULE Test;
	VAR source, dest: ARRAY 10 OF SET;
	BEGIN COPY (source, dest);
	END Test.

negative: copy statement on array of record

	MODULE Test;
	VAR source, dest: ARRAY 10 OF RECORD END;
	BEGIN COPY (source, dest);
	END Test.

negative: copy statement on array of object

	MODULE Test;
	VAR source, dest: ARRAY 10 OF OBJECT END;
	BEGIN COPY (source, dest);
	END Test.

negative: copy statement on array of base object

	MODULE Test;
	VAR source, dest: ARRAY 10 OF OBJECT;
	BEGIN COPY (source, dest);
	END Test.

negative: copy statement on array of pointer to array

	MODULE Test;
	VAR source, dest: ARRAY 10 OF POINTER TO ARRAY OF CHAR;
	BEGIN COPY (source, dest);
	END Test.

negative: copy statement on array of pointer to record

	MODULE Test;
	VAR source, dest: ARRAY 10 OF POINTER TO RECORD END;
	BEGIN COPY (source, dest);
	END Test.

negative: copy statement on array of procedure

	MODULE Test;
	VAR source, dest: ARRAY 10 OF PROCEDURE;
	BEGIN COPY (source, dest);
	END Test.

negative: copy statement on record

	MODULE Test;
	VAR source, dest: RECORD END;
	BEGIN COPY (source, dest);
	END Test.

negative: copy statement on object

	MODULE Test;
	VAR source, dest: OBJECT END;
	BEGIN COPY (source, dest);
	END Test.

negative: copy statement on base object

	MODULE Test;
	VAR source, dest: OBJECT;
	BEGIN COPY (source, dest);
	END Test.

negative: copy statement on pointer to array

	MODULE Test;
	VAR source, dest: POINTER TO ARRAY 10 OF CHAR;
	BEGIN COPY (source, dest);
	END Test.

negative: copy statement on pointer to record

	MODULE Test;
	VAR source, dest: POINTER TO RECORD END;
	BEGIN COPY (source, dest);
	END Test.

negative: copy statement on procedure

	MODULE Test;
	VAR source, dest: PROCEDURE;
	BEGIN COPY (source, dest);
	END Test.


# overriding object procedures

positive: overriding same object procedure

	MODULE Test;
	TYPE A = OBJECT PROCEDURE P; END P; END A;
	TYPE B = OBJECT (A) PROCEDURE P; END P; END B;
	END Test.

positive: deep overriding same object procedure

	MODULE Test;
	TYPE A = OBJECT PROCEDURE P; END P; END A;
	TYPE B = OBJECT (A) END B;
	TYPE C = OBJECT (D) PROCEDURE P; END P; END C;
	TYPE D = OBJECT (B) END D;
	END Test.

negative: deep overriding same object procedure with different return type

	MODULE Test;
	TYPE A = OBJECT PROCEDURE P; END P; END A;
	TYPE B = OBJECT (A) END B;
	TYPE C = OBJECT (D) PROCEDURE P (): A; END P; END C;
	TYPE D = OBJECT (B) END D;
	END Test.

positive: deep overriding same object procedure with same symbol in-between

	MODULE Test;
	TYPE A = OBJECT PROCEDURE P; END P; END A;
	TYPE B = OBJECT (A) VAR P: A END B;
	TYPE C = OBJECT (D) PROCEDURE P; END P; END C;
	TYPE D = OBJECT (B) END D;
	END Test.

negative: deep overriding same object procedure with different return type and same symbol in-between

	MODULE Test;
	TYPE A = OBJECT PROCEDURE P; END P; END A;
	TYPE B = OBJECT (A) VAR P: A END B;
	TYPE C = OBJECT (D) PROCEDURE P (): A; END P; END C;
	TYPE D = OBJECT (B) END D;
	END Test.

negative: overriding same object procedure with one parameter

	MODULE Test;
	TYPE A = OBJECT PROCEDURE P; END P; END A;
	TYPE B = OBJECT (A) PROCEDURE P (p: A); END P; END B;
	END Test.

negative: overriding same object procedure with no parameter

	MODULE Test;
	TYPE A = OBJECT PROCEDURE P (p: A); END P; END A;
	TYPE B = OBJECT (A) PROCEDURE P; END P; END B;
	END Test.

positive: overriding same object procedure with parameter

	MODULE Test;
	TYPE A = OBJECT PROCEDURE P (p: A); END P; END A;
	TYPE B = OBJECT (A) PROCEDURE P (p: A); END P; END B;
	END Test.

negative: overriding same object procedure with var parameter

	MODULE Test;
	TYPE A = OBJECT PROCEDURE P (p: A); END P; END A;
	TYPE B = OBJECT (A) PROCEDURE P (VAR p: A); END P; END B;
	END Test.

negative: overriding same object procedure with const parameter

	MODULE Test;
	TYPE A = OBJECT PROCEDURE P (p: A); END P; END A;
	TYPE B = OBJECT (A) PROCEDURE P (CONST p: A); END P; END B;
	END Test.

negative: overriding same object procedure with var parameter with parameter

	MODULE Test;
	TYPE A = OBJECT PROCEDURE P (VAR p: A); END P; END A;
	TYPE B = OBJECT (A) PROCEDURE P (p: A); END P; END B;
	END Test.

positive: overriding same object procedure with var parameter with var parameter

	MODULE Test;
	TYPE A = OBJECT PROCEDURE P (VAR p: A); END P; END A;
	TYPE B = OBJECT (A) PROCEDURE P (VAR p: A); END P; END B;
	END Test.

negative: overriding same object procedure with var parameter with const parameter

	MODULE Test;
	TYPE A = OBJECT PROCEDURE P (VAR p: A); END P; END A;
	TYPE B = OBJECT (A) PROCEDURE P (CONST p: A); END P; END B;
	END Test.

negative: overriding same object procedure with const parameter with parameter

	MODULE Test;
	TYPE A = OBJECT PROCEDURE P (CONST p: A); END P; END A;
	TYPE B = OBJECT (A) PROCEDURE P (p: A); END P; END B;
	END Test.

negative: overriding same object procedure with const parameter with var parameter

	MODULE Test;
	TYPE A = OBJECT PROCEDURE P (CONST p: A); END P; END A;
	TYPE B = OBJECT (A) PROCEDURE P (VAR p: A); END P; END B;
	END Test.

positive: overriding same object procedure with const parameter with const parameter

	MODULE Test;
	TYPE A = OBJECT PROCEDURE P (CONST p: A); END P; END A;
	TYPE B = OBJECT (A) PROCEDURE P (CONST p: A); END P; END B;
	END Test.

positive: overriding same object procedure with same parameter type

	MODULE Test;
	TYPE A = OBJECT PROCEDURE P (p: A); END P; END A;
	TYPE B = OBJECT (A) PROCEDURE P (p: A); END P; END B;
	END Test.

negative: overriding same object procedure with covariant parameter type

	MODULE Test;
	TYPE A = OBJECT PROCEDURE P (p: A); END P; END A;
	TYPE B = OBJECT (A) PROCEDURE P (p: B); END P; END B;
	END Test.

negative: overriding same object procedure with contravariant parameter type

	MODULE Test;
	TYPE A = OBJECT PROCEDURE P (p: B); END P; END A;
	TYPE B = OBJECT (A) PROCEDURE P (p: A); END P; END B;
	END Test.

negative: overriding same object procedure with different parameter type

	MODULE Test;
	TYPE A = OBJECT PROCEDURE P (p: SET); END P; END A;
	TYPE B = OBJECT (A) PROCEDURE P (p: CHAR); END P; END B;
	END Test.

positive: overriding object procedure with same return type

	MODULE Test;
	TYPE A = OBJECT PROCEDURE P(): A; END P; END A;
	TYPE B = OBJECT (A) PROCEDURE P(): A; END P; END B;
	END Test.

negative: overriding object procedure with covariant return type

	MODULE Test;
	TYPE A = OBJECT PROCEDURE P(): A; END P; END A;
	TYPE B = OBJECT (A) PROCEDURE P(): B; END P; END B;
	END Test.

negative: overriding object procedure with contravariant return type

	MODULE Test;
	TYPE A = OBJECT PROCEDURE P(): B; END P; END A;
	TYPE B = OBJECT (A) PROCEDURE P(): A; END P; END B;
	END Test.

negative: overriding object procedure with different return type

	MODULE Test;
	TYPE A = OBJECT PROCEDURE P(): SET; END P; END A;
	TYPE B = OBJECT (A) PROCEDURE P(): CHAR; END P; END B;
	END Test.

negative: super call on procedure variable in module

	MODULE Test;
	VAR procedure: PROCEDURE;
	BEGIN procedure^
	END Test.

negative: super call on procedure variable in procedure

	MODULE Test;
	PROCEDURE Procedure;
		VAR procedure: PROCEDURE;
		BEGIN procedure^
	END Procedure;
	END Test.

negative: super call on procedure variable in object

	MODULE Test;
	TYPE Object = OBJECT
		VAR procedure: PROCEDURE;
		BEGIN procedure^
	END Object;
	END Test.

negative: super call on hidden procedure variable in object

	MODULE Test;
	TYPE Base = OBJECT
		VAR procedure: PROCEDURE;
	END Base;
	TYPE Derived = OBJECT (Base)
		BEGIN procedure^
	END Derived;
	END Test.

negative: super call on hiding procedure variable in object

	MODULE Test;
	TYPE Base = OBJECT
		VAR procedure: PROCEDURE;
	END Base;
	TYPE Derived = OBJECT (Base)
		VAR procedure: PROCEDURE;
		BEGIN procedure^
	END Derived;
	END Test.

negative: super call to procedure in module

	MODULE Test;
	PROCEDURE Procedure; END Procedure;
	BEGIN Procedure^
	END Test.

negative: super call to procedure in procedure

	MODULE Test;
	PROCEDURE Procedure;
		PROCEDURE Procedure; END Procedure;
	BEGIN Procedure^
	END Procedure;
	END Test.

negative: super call to non-overriding procedure in object

	MODULE Test;
	TYPE Object = OBJECT
		PROCEDURE Procedure; END Procedure;
		BEGIN Procedure^
	END Object;
	END Test.

negative: super call to non-overridden procedure in object

	MODULE Test;
	TYPE Base = OBJECT
		PROCEDURE Procedure; END Procedure;
	END Base;
	TYPE Derived = OBJECT (Base)
		BEGIN Procedure^
	END Derived;
	END Test.

positive: super call to overridden procedure in object

	MODULE Test;
	TYPE Base = OBJECT
		PROCEDURE Procedure; END Procedure;
	END Base;
	TYPE Derived = OBJECT (Base)
		PROCEDURE Procedure; END Procedure;
		BEGIN Procedure^
	END Derived;
	END Test.

negative: qualified super call to overridden but non-overriding procedure in object

	MODULE Test;
	TYPE A = OBJECT
		PROCEDURE Procedure; END Procedure;
	END A;
	TYPE B = OBJECT (A)
		PROCEDURE Procedure; END Procedure;
	END B;
	TYPE C = OBJECT (B)
		BEGIN SELF.Procedure^
	END C;
	END Test.

negative: qualified super call on reference to overridden procedure in object

	MODULE Test;
	TYPE Base = OBJECT
		PROCEDURE Procedure; END Procedure;
	END Base;
	TYPE Derived = OBJECT (Base)
		VAR object: Derived;
		PROCEDURE Procedure; END Procedure;
		BEGIN object.Procedure^
	END Derived;
	END Test.

negative: qualified super call on reference to overridden procedure in module

	MODULE Test;
	TYPE Base = OBJECT
		PROCEDURE Procedure; END Procedure;
	END Base;
	TYPE Derived = OBJECT (Base)
		PROCEDURE Procedure; END Procedure;
	END Derived;
	VAR object: Derived;
	BEGIN object.Procedure^
	END Test.


# flags

negative: procedure illegaly marked delegate

	MODULE Test;
	PROCEDURE {DELEGATE} P; END P;
	END Test.

negative: procedure illegaly marked untraced

	MODULE Test;
	PROCEDURE {UNTRACED} P; END P;
	END Test.

positive: pointer to array variable marked untraced

	MODULE Test;
	VAR a {UNTRACED}: POINTER TO ARRAY OF CHAR;
	END Test.

positive: pointer to record variable marked untraced

	MODULE Test;
	VAR a {UNTRACED}: POINTER TO RECORD END;
	END Test.

negative: non-pointer variable marked untraced

	MODULE Test;
	VAR a {UNTRACED}: SIGNED32;
	END Test.

negative: variable marked delegate
	MODULE Test;
	VAR a{DELEGATE}: PROCEDURE;
	END Test.

positive: delegate procedure type

	MODULE Test;
	TYPE TP=PROCEDURE{DELEGATE};
	END Test.

positive: delegate procedure type with arguments

	MODULE Test;
	TYPE TP=PROCEDURE{DELEGATE}(a: SIGNED32): SIGNED32;
	END Test.

positive: delegate procedure variable assignment

	MODULE Test;
	VAR p:PROCEDURE{DELEGATE};
	PROCEDURE P; END P;
	BEGIN p := P
	END Test.

positive: delegate procedure variable nil assignment

	MODULE Test;
	VAR p: PROCEDURE{DELEGATE};
	BEGIN p := NIL
	END Test.

positive: delegate procedure variable assignment in exclusive block

	MODULE Test;
	VAR p:PROCEDURE{DELEGATE};
	PROCEDURE P; END P;
	BEGIN {EXCLUSIVE} p := P
	END Test.

positive: delegate procedure variable nil assignment in exclusive block

	MODULE Test;
	VAR p: PROCEDURE{DELEGATE};
	BEGIN {EXCLUSIVE} p := NIL
	END Test.

positive: delegate procedure variable assigned to method

	MODULE Test;
	TYPE O=OBJECT PROCEDURE P; END P; END O;
	VAR o:O; p:PROCEDURE{DELEGATE};
	BEGIN p := o.P
	END Test.

negative: non-delegate procedure variable assigned to method

	MODULE Test;
	TYPE O=OBJECT PROCEDURE P; END P; END O;
	VAR o:O; p:PROCEDURE;
	BEGIN p := o.P
	END Test.


# signatures

positive: signature matching extension of object

	MODULE Test;
	TYPE O=OBJECT
			PROCEDURE P; END P;
			PROCEDURE Q(i: SIGNED16); END Q;
			PROCEDURE R(i: SIGNED32): SIGNED32; END R;
		END O;
	TYPE OO=OBJECT(O);
			PROCEDURE P; END P;
			PROCEDURE Q(i: SIGNED16); END Q;
			PROCEDURE R(i: SIGNED32): SIGNED32; END R;
		END OO;
	END Test.

negative: extension of objects with nonmatching signature: parameter incompatible

	MODULE Test;
	TYPE O=OBJECT
			PROCEDURE P(i: SIGNED16); END P;
	END O;
	TYPE OO=OBJECT(O)
			PROCEDURE P(i: SIGNED32); END P;
	END OO;
	END Test.

positive: extension of object matching signature: constructor extends non-constructor

	MODULE Test;
	TYPE O=OBJECT
			PROCEDURE P; END P;
		END O;
	TYPE OO=OBJECT(O);
			PROCEDURE &P; END P;
		END OO;
	END Test.

negative: extension of object with nonmatching signature: non-constructor extends constructor

	MODULE Test;
	TYPE O=OBJECT
			PROCEDURE &P; END P;
		END O;
	TYPE OO=OBJECT(O);
			PROCEDURE P; END P;
		END OO;
	END Test.

positive: non-exported constructor used in same module

	MODULE Dummy;
	TYPE O*=OBJECT
		PROCEDURE & Init (x: SIGNED32; CONST y: ARRAY OF CHAR);
		END Init;
	END O;
	VAR o:O;
	BEGIN
		NEW(o,10,"test")
	END Dummy.

negative: non-exported constructor used as method in different module

	MODULE Test;
	IMPORT Dummy;
	VAR a: Dummy.O;
	BEGIN
		a.Init(10,"test")
	END Test.

negative: non-exported constructor used as constructor in different module

	MODULE Test;
	IMPORT Dummy;
	VAR a: Dummy.O;
	BEGIN
		NEW(a,10,"test");
	END Test.

positive: non-exported constructor overwritten by new constructor with different name in different module

	MODULE Test;
	IMPORT Dummy;
	TYPE O=OBJECT (Dummy.O)
		PROCEDURE & InitX(a,b: SIGNED32); END InitX;
	END O;
	VAR a: O;
	BEGIN
		NEW(a,10,20);
	END Test.

positive: non-exported constructor overwritten by new constructor with same name in different module

	MODULE Test;
	IMPORT Dummy;
	TYPE O=OBJECT (Dummy.O)
		PROCEDURE & Init(a,b: SIGNED32); END Init;
	END O;
	VAR a: O;
	BEGIN
		NEW(a,10,20);
	END Test.

positive: exported constructor used in same module

	MODULE Dummy;
	TYPE O*=OBJECT
		PROCEDURE & Init* (x: SIGNED32; CONST y: ARRAY OF CHAR);
		END Init;
	END O;
	VAR o:O;
	BEGIN
		NEW(o,10,"test")
	END Dummy.

positive: exported constructor used as method in different module

	MODULE Test;
	IMPORT Dummy;
	VAR a: Dummy.O;
	BEGIN
		a.Init(10,"test")
	END Test.

positive: exported constructor used as constructor in different module

	MODULE Test;
	IMPORT Dummy;
	VAR a: Dummy.O;
	BEGIN
		NEW(a,10,"test");
	END Test.

positive: exported constructor overwritten by new constructor with different name and non-matching signature in different module

	MODULE Test;
	IMPORT Dummy;
	TYPE O=OBJECT (Dummy.O)
		PROCEDURE & InitX(a,b: SIGNED32); END InitX;
	END O;
	VAR a: O;
	BEGIN
		NEW(a,10,20);
	END Test.

negative: non-exported constructor overwritten by new constructor with same name and non-matching signature in different module

	MODULE Test;
	IMPORT Dummy;
	TYPE O=OBJECT (Dummy.O)
		PROCEDURE & Init(a,b: SIGNED32); END Init;
	END O;
	END Test.

positive: non-exported constructor overwritten by new constructor with same name and matching signature in different module

	MODULE Test;
	IMPORT Dummy;
	TYPE O=OBJECT (Dummy.O)
		PROCEDURE & Init(a: SIGNED32; CONST name: ARRAY OF CHAR); END Init;
	END O;
	VAR a: O;
	BEGIN
		NEW(a,10,"test");
	END Test.

negative: new on object with non-exported constructor with empty parameter list

	MODULE Dummy;
	TYPE O*=OBJECT
		PROCEDURE & Init;
		END Init;
	END O;
	END Dummy.

	MODULE Test;
	IMPORT Dummy;
	VAR o: Dummy.O;
	BEGIN NEW(o)
	END Test.

# realtime objects

positive: plain realtime object

	MODULE Test;
	TYPE A = OBJECT {REALTIME} END A;
	END Test.

positive: realtime pointer to record

	MODULE Test;
	TYPE A = POINTER {REALTIME} TO RECORD END;
	END Test.

positive: realtime pointer to array

	MODULE Test;
	TYPE A = POINTER {REALTIME} TO ARRAY OF CHAR;
	END Test.

positive: realtime object containing basic type fields

	MODULE Test;
	IMPORT SYSTEM;
	TYPE A = OBJECT {REALTIME}
		VAR a0: CHAR; a1: SIGNED8; a2: SIGNED16; a3: SIGNED32; a4: SIGNED64; a5: FLOAT32;
			a6: FLOAT64; a7: BOOLEAN; a8: SET; a9: ADDRESS; a10:SIZE; a11: SYSTEM.BYTE;
	END A;
	END Test.

positive: realtime pointer to record that contains basic type fields

	MODULE Test;
	IMPORT SYSTEM;
	TYPE A = POINTER {REALTIME} TO RECORD
		a0: CHAR; a1: SIGNED8; a2: SIGNED16; a3: SIGNED32; a4: SIGNED64; a5: FLOAT32;
		a6: FLOAT64; a7: BOOLEAN; a8: SET; a9: ADDRESS; a10:SIZE; a11: SYSTEM.BYTE;
	END;
	END Test.

positive: realtime pointer to array where the elements contain basic type fields

	MODULE Test;
	IMPORT SYSTEM;
	TYPE A0 = POINTER {REALTIME} TO ARRAY OF RECORD
		a0: CHAR; a1: SIGNED8; a2: SIGNED16; a3: SIGNED32; a4: SIGNED64; a5: FLOAT32;
		a6: FLOAT64; a7: BOOLEAN; a8: SET; a9: ADDRESS; a10:SIZE; a11: SYSTEM.BYTE;
	END;
	END Test.

positive: realtime object containing enumeration type field

	MODULE Test;
	TYPE Color = ENUM red, green, blue END;
		RTObject = OBJECT {REALTIME} VAR color: Color; END RTObject;
	END Test.

positive: realtime object containing non-basic type realtime fields

	MODULE Test;
	TYPE A = OBJECT {REALTIME} END A;
	B = OBJECT {REALTIME} VAR a: A; b: B; END B;
	END Test.

positive: realtime pointer to record that contains non-basic type fields

	MODULE Test;
	TYPE A = POINTER {REALTIME} TO RECORD END;
	B = POINTER {REALTIME} TO RECORD a: A; b: B END;
	END Test.

positive: realtime pointer to array where the elements contain non-basic realtime fields

	MODULE Test;
	TYPE A = POINTER {REALTIME} TO RECORD END;
	B = POINTER {REALTIME} TO ARRAY OF RECORD a: A; b: B END;
	END Test.

negative: realtime object containing non-realtime any pointer

	MODULE Test;
	TYPE A = OBJECT {REALTIME} VAR a0: ANY END A;
	END Test;

negative: realtime object containing non-realtime pointer to record

	MODULE Test;
	TYPE A = OBJECT {REALTIME} VAR a0: POINTER TO RECORD END END A;
	END Test;

negative: realtime object containing non-realtime pointer to array

	MODULE Test;
	TYPE A = OBJECT {REALTIME} VAR a0: POINTER TO ARRAY OF CHAR END A;
	END Test;

negative: realtime object containing non-realtime object reference

	MODULE Test;
	TYPE A = OBJECT END A;
		B = OBJECT {REALTIME} b: A END B;
	END Test;

positive: realtime object containing record variable with realtime fields

	MODULE Test;
	TYPE A = OBJECT {REALTIME} VAR a: RECORD k: SIGNED8; l: SIGNED16; m: A END END A;
	END Test.

positive: realtime object containing record variable with realtime pointers

	MODULE Test;
	TYPE A = OBJECT {REALTIME} VAR a: RECORD p0: POINTER {REALTIME} TO RECORD END;
	p1: POINTER {REALTIME} TO ARRAY OF CHAR; END; END A;
	END Test.

negative: realtime object containing record variable with a non-realtime any pointer

	MODULE Test;
	TYPE A = OBJECT {REALTIME} VAR a: RECORD p: ANY END; END A;
	END Test.

negative: realtime object containing record variable with a non-realtime record pointer

	MODULE Test;
	TYPE A = OBJECT {REALTIME} VAR a: RECORD p: POINTER TO RECORD END; END; END A;
	END Test.

negative: realtime object containing record variable with a non-realtime array pointer

	MODULE Test;
	TYPE A = OBJECT {REALTIME} VAR a: RECORD p: POINTER TO ARRAY OF CHAR END; END A;
	END Test.

positive: non-realtime object containing reference to realtime object

	MODULE Test;
	TYPE A = OBJECT {REALTIME} VAR a0: SIGNED32; a1: CHAR; END A;
	B = OBJECT VAR a: A; END B;
	END Test.

positive: extension of realtime object declared as realtime object

	MODULE Test;
	TYPE A = OBJECT {REALTIME} VAR a0: CHAR; a1: SET; END A;
	B = OBJECT {REALTIME} (A) VAR b0: SIGNED16; b1: SIGNED32; END B;
	END Test.

positive: variable of realtime pointer to record type

	MODULE Test;
	VAR p: POINTER {REALTIME} TO RECORD k, l: SIGNED32 END;
	END Test.

positive: variable of realtime pointer to array type

	MODULE Test;
	VAR p: POINTER {REALTIME} TO ARRAY OF BOOLEAN;
	END Test.

negative: realtime extension of non-realtime object

	MODULE Test;
	TYPE A = OBJECT VAR a0: CHAR; a1: SET; END A;
	B = OBJECT {REALTIME} (A) VAR b0: SIGNED16; b1: SIGNED32; END B;
	END Test.

negative: non-realtime extension of realtime object

	MODULE Test;
	TYPE A = OBJECT {REALTIME} VAR a0: CHAR; a1: SET; END A;
	B = OBJECT (A) VAR b0: SIGNED16; b1: SIGNED32; END B;
	END Test.

positive: record extensions - both record types are implicit realtime objects

	MODULE Test;
	TYPE A = RECORD a0: CHAR; a1: SET; END;
	B = RECORD (A) b0: SIGNED16; b1: SIGNED32; END;
	AP = POINTER {REALTIME} TO A;
	BP = POINTER {REALTIME} TO B;
	END Test.

negative: record extensions - only base type is realtime object

	MODULE Test;
	TYPE A = RECORD a0: CHAR; a1: SET; END;
	B = RECORD (A) b0: SIGNED16; b1: ANY; END;
	AP = POINTER {REALTIME} TO A;
	BP = POINTER {REALTIME} TO B;
	END Test.

positive: extension of realtime pointer

	MODULE Test;
	TYPE R = RECORD r0, r1: SIGNED32; END;
	P = POINTER {REALTIME} TO Q;
	Q = RECORD (R) q0, q1: SIGNED32; END;
	S = OBJECT {REALTIME} (P) VAR s0, s1: SIGNED32; END S;
	END Test.

positive: module Dummy for realtime and non-realtime types

	MODULE Dummy;
	TYPE RTRec* = RECORD r0: SIGNED32; r1: CHAR; END;
	NRTRec* = RECORD n0: SIGNED32; n1: ANY; END;
	RTO* = OBJECT {REALTIME} VAR m0: SET; END RTO;
	NRTO0* = OBJECT VAR p: ANY; END NRTO0;
	NRTO1* = OBJECT VAR k: SIGNED32; END NRTO1;
	END Dummy.

positive: realtime pointer to (realtime) record from imported module

	MODULE Test;
	IMPORT Dummy;
	TYPE RTPtr = POINTER {REALTIME} TO Dummy.RTRec;
	END Test.

positive: non-realtime pointer to (non-realtime) record from imported module

	MODULE Test;
	IMPORT Dummy;
	TYPE NRTPtr = POINTER TO Dummy.NRTRec;
	END Test.

positive: non-realtime pointer to (realtime) record from imported module

	MODULE Test;
	IMPORT Dummy;
	TYPE NRTPtr = POINTER TO Dummy.RTRec;
	END Test.

negative: realtime pointer to (non-realtime) record from imported module

	MODULE Test;
	IMPORT Dummy;
	TYPE RTPtr = POINTER {REALTIME} TO Dummy.NRTRec;
	END Test.

positive: realtime extension of imported realtime object

	MODULE Test;
	IMPORT Dummy;
	TYPE RTE = OBJECT {REALTIME} (Dummy.RTO) VAR t0: POINTER {REALTIME} TO ARRAY OF CHAR; END RTE;
	END Test.

negative: non-realtime extension of imported realtime object

	MODULE Test;
	IMPORT Dummy;
	TYPE NRTE = OBJECT (Dummy.RTO) VAR k: SIGNED32; END NRTE;
	END Test.

positive: non-realtime extension of imported non-realtime object that contains non-realtime fields

	MODULE Test;
	IMPORT Dummy;
	TYPE NRTE = OBJECT (Dummy.NRTO0) VAR c: CHAR; END NRTE;
	END Test.

positive: non-realtime extension of imported non-realtime object that contains only realtime fields

	MODULE Test;
	IMPORT Dummy;
	TYPE NRTE = OBJECT (Dummy.NRTO1) VAR c: CHAR; END NRTE;
	END Test.


# realtime procedures

positive: procedure marked as realtime

	MODULE Test;
	PROCEDURE {REALTIME} P; END P;
	END Test.

positive: calling realtime procedure in non-realtime procedure

	MODULE Test;
	PROCEDURE {REALTIME} RTP; END RTP;
	PROCEDURE NRTP; BEGIN RTP; END NRTP;
	END Test.

positive: recursive call of realtime procedure

	MODULE Test;
	PROCEDURE {REALTIME} RTP; BEGIN RTP; END RTP;
	END Test.

negative: calling non-realtime procedure in realtime procedure

	MODULE Test;
	PROCEDURE NRTP; END NRTP;
	PROCEDURE {REALTIME} RTP; BEGIN NRTP; END RTP;
	END Test.

negative: new statement in realtime procedure

	MODULE Test;
	PROCEDURE {REALTIME} P;
	VAR p: POINTER TO RECORD END;
	BEGIN NEW (p);
	END P;
	END Test.

negative: exclusive block in realtime procedure

	MODULE Test;
	PROCEDURE {REALTIME} P;
	BEGIN {EXCLUSIVE}
	END P;
	END Test.

negative: await statement in realtime procedure

	MODULE Test;
	VAR condition: BOOLEAN;
	PROCEDURE {REALTIME} P;
	BEGIN AWAIT (condition);
	END P;
	END Test.

positive: realtime procedure variable to non-realtime procedure variable assignment

	MODULE Test;
	VAR rtp: PROCEDURE {REALTIME}; nrtp: PROCEDURE;
	BEGIN nrtp := rtp;
	END Test.

positive: realtime procedure variable to realtime procedure variable assignment

	MODULE Test;
	VAR rtp: PROCEDURE {REALTIME};
	BEGIN rtp := rtp;
	END Test.

negative: non-realtime procedure variable to realtime procedure variable assignment

	MODULE Test;
	VAR rtp: PROCEDURE {REALTIME}; nrtp: PROCEDURE;
	BEGIN rtp := nrtp;
	END Test.

negative: module body marked as realtime

	MODULE Test;
	BEGIN {REALTIME}
	END Test.

negative: procedure body marked as realtime

	MODULE Test;
	PROCEDURE P;
	BEGIN {REALTIME}
	END P;
	END Test.

positive: passive object body marked as realtime

	MODULE Test;
	TYPE Object = OBJECT
	BEGIN {REALTIME}
	END Object;
	END Test.

positive: calling realtime procedure in passive object body marked as realtime

	MODULE Test;
	TYPE Object = OBJECT {REALTIME}
	PROCEDURE {REALTIME} P; END P;
	BEGIN {REALTIME} P;
	END Object;
	END Test.

negative: calling non-realtime procedure in passive object body marked as realtime

	MODULE Test;
	TYPE Object = OBJECT
	PROCEDURE P; END P;
	BEGIN {REALTIME} P;
	END Object;
	END Test.

positive: active object body marked as realtime

	MODULE Test;
	TYPE Object = OBJECT
	BEGIN {ACTIVE, REALTIME}
	END Object;
	END Test.

positive: calling realtime procedure in active object body marked as realtime

	MODULE Test;
	TYPE Object = OBJECT {REALTIME}
	PROCEDURE {REALTIME} P; END P;
	BEGIN {ACTIVE, REALTIME} P;
	END Object;
	END Test.

negative: declaring realtime procedure/method in non-realtime object

	MODULE Test;
	TYPE A = OBJECT
	PROCEDURE {REALTIME} P;
	END P;
	END A;
	END Test.

negative: calling non-realtime procedure in active object body marked as realtime

	MODULE Test;
	TYPE Object = OBJECT
	PROCEDURE P; END P;
	BEGIN {ACTIVE, REALTIME} P;
	END Object;
	END Test.

positive: overwriting realtime procedure with realtime procedure

	MODULE Test;
	TYPE Base = OBJECT {REALTIME}
	PROCEDURE {REALTIME} P; END P;
	END Base;
	TYPE Object = OBJECT {REALTIME} (Base)
	PROCEDURE {REALTIME} P; END P;
	END Object;
	END Test.

negative: overwriting non-realtime procedure with realtime procedure

	MODULE Test;
	TYPE Base = OBJECT {REALTIME}
	PROCEDURE P; END P;
	END Base;
	TYPE Object = OBJECT {REALTIME} (Base)
	PROCEDURE {REALTIME} P; END P;
	END Object;
	END Test.

negative: overwriting realtime procedure with non-realtime procedure

	MODULE Test;
	TYPE Base = OBJECT {REALTIME}
	PROCEDURE {REALTIME} P; END P;
	END Base;
	TYPE Object = OBJECT {REALTIME} (Base)
	PROCEDURE P; END P;
	END Object;
	END Test.

positive: exporting realtime procedure

	MODULE Dummy;
	PROCEDURE {REALTIME} P*;
	BEGIN END P;
	PROCEDURE {REALTIME} Pp*(i: SIGNED32);
	BEGIN END Pp;
	PROCEDURE Q*;
	BEGIN END Q;
	END Dummy.

positive: using imported realtime procedure in realtime and non-realtime procedure

	MODULE Test;
	IMPORT Dummy;
	PROCEDURE {REALTIME} P;
	BEGIN Dummy.P; Dummy.Pp(10)
	END P;
	PROCEDURE Q;
	BEGIN Dummy.P
	END Q;
	END Test.

negative: using imported non-realtime procedure in realtime procedure

	MODULE Test;
	IMPORT Dummy;
	PROCEDURE {REALTIME} P;
	BEGIN Dummy.Q; Dummy.Pp(10)
	END P;
	END Test.

positive: use of basic type realtime variables and parameters in realtime procedure

	MODULE Test;
	PROCEDURE {REALTIME} P(VAR k: SIGNED32);
	VAR l: SET;
	BEGIN l:= {}; k:= 5;
	END P;
	END Test.

positive: use of structured realtime variables in realtime procedure

	MODULE Test;
	TYPE A = OBJECT {REALTIME} VAR k, l: SIGNED32 END A;
	PROCEDURE {REALTIME} P(VAR a: A);
	BEGIN a.k := 0; a.l := 0;
	END P;
	END Test.

negative: use of non-realtime variables in realtime procedure

	MODULE Test;
	PROCEDURE {REALTIME} P(VAR a: POINTER TO ARRAY OF CHAR);
	VAR i: SIGNED32
	BEGIN FOR i := 0 TO LEN(a) DO a[i] := '' END;
	END P;
	END Test.

positive: use of string constant (of implicit realtime type) in realtime procedure

	MODULE Test;
	PROCEDURE {REALTIME} P;
	VAR a: ARRAY 10 OF CHAR;
	BEGIN a := "AA";
	END P;
	END Test.

positive: module Dummy for realtime and non-realtime types and variables

	MODULE Dummy;
	TYPE RTRec* = RECORD i*: SIGNED32; END;
	NRTRec* = RECORD p*: ANY; END;
	RTO* = OBJECT {REALTIME} VAR s: SET; END RTO;
	NRTO* = OBJECT VAR p: ANY; END NRTO;
	VAR rtrec*: RTRec;
	nrtrec*: NRTRec;
	PROCEDURE {REALTIME} P*;
	END P;
	PROCEDURE Q*;
	END Q;
	END Dummy.

positive: use of imported realtime type in realtime procedure

	MODULE Test;
	IMPORT Dummy;
	PROCEDURE {REALTIME} P(VAR r: Dummy.RTO);
	END P;
	END Test.

negative: use of imported non-realtime type in realtime procedure

	MODULE Test;
	IMPORT Dummy;
	PROCEDURE {REALTIME} P(VAR n: Dummy.NRTO);
	END P;
	END Test.

positive: use of imported realtime variable in realtime procedure

	MODULE Test;
	IMPORT Dummy;
	PROCEDURE {REALTIME} P;
	BEGIN Dummy.rtrec.i := 0;
	END P;
	END Test.

negative: use of imported non-realtime variable in realtime procedure

	MODULE Test;
	IMPORT Dummy;
	PROCEDURE {REALTIME} P;
	BEGIN Dummy.nrtrec.p := NIL;
	END P;
	END Test.

positive: use of imported realtime variable in non-realtime procedure

	MODULE Test;
	IMPORT Dummy;
	PROCEDURE P;
	BEGIN Dummy.rtrec.i := 0;
	END P;
	END Test.

positive: use of imported non-realtime variable in non-realtime procedure

	MODULE Test;
	IMPORT Dummy;
	PROCEDURE P;
	BEGIN Dummy.nrtrec.p := NIL;
	END P;
	END Test.

positive: realtime procedure used as parameter in realtime procedure

	MODULE Test;
	TYPE RTPT = PROCEDURE {REALTIME};
	VAR rtp: PROCEDURE {REALTIME};
	PROCEDURE {REALTIME} P(rtp: RTPT);
	END P;
	BEGIN P(rtp);
	END Test.

negative: non-realtime procedure as parameter in realtime procedure

	MODULE Test;
	TYPE RTPT = PROCEDURE {REALTIME};
	VAR rtp: PROCEDURE;
	PROCEDURE {REALTIME} P(rtp: RTPT);
	END P;
	BEGIN P(rtp);
	END Test.

positive: realtime procedure used as var-parameter in realtime procedure

	MODULE Test;
	TYPE RTPT = PROCEDURE {REALTIME};
	VAR rtp: PROCEDURE {REALTIME};
	PROCEDURE {REALTIME} P(VAR rtp: RTPT);
	END P;
	BEGIN P(rtp);
	END Test.

negative: use of exclusive section in realtime module procedure

	MODULE Test;
	PROCEDURE {REALTIME} P;
	BEGIN {EXCLUSIVE}
	END P;
	END Test.

# handling of untraced flag

positive: untraced flag on pointer to record

	MODULE Test;
	TYPE P= POINTER TO RECORD END;
	VAR x {UNTRACED}: P;
	END Test.

positive: untraced flag on object

	MODULE Test;
	TYPE P= OBJECT END P;
	VAR x {UNTRACED}: P;
	END Test.

positive: untraced flag on pointer to array

	MODULE Test;
	TYPE P=POINTER TO ARRAY OF CHAR;
	VAR x {UNTRACED}: P;
	END Test.

positive: untraced flag on delegate procedure

	MODULE Test;
	TYPE P=PROCEDURE {DELEGATE};
	VAR x {UNTRACED}: P;
	END Test.

negative: untraced flag on basic type

	MODULE Test;
	TYPE P=SIGNED32;
	VAR x{UNTRACED}: P;
	END Test.

negative: untraced flag on procedure type

	MODULE Test;
	TYPE P= PROCEDURE;
	VAR x{UNTRACED}: P;
	END Test.

negative: untraced flag on record type;

	MODULE Test;
	TYPE P=RECORD END;
	VAR x{UNTRACED}: P;
	END Test.


#miscellaneous

positive: system address type size

	MODULE Test;
	IMPORT SYSTEM;
	VAR a: SIGNED32;
	BEGIN a := SIZEOF(ADDRESS)
	END Test.

negative: system address function on size-incompatible type

	MODULE Test;
	IMPORT SYSTEM;
	VAR a: SIGNED8;
	BEGIN a := SYSTEM.ADR(a)
	END Test.

positive: system address function on size-compatible type

	MODULE Test;
	IMPORT SYSTEM;
	VAR a: SIGNED64;
	BEGIN a := SYSTEM.ADR(a)
	END Test.

positive: unsigned system address function

	MODULE Test;
	IMPORT SYSTEM;
	VAR a: ADDRESS;
	BEGIN a := SYSTEM.ADR(a)
	END Test.

positive: mixture of 32 and 8 bit types implying high register pressure by using an array

	MODULE Test;
	VAR b: ARRAY 2 OF CHAR; a: SIGNED32; ch: CHAR;
	BEGIN
		b[a] := CHR(((a MOD 0AH) + 30H))
	END Test.

positive: system.val

	MODULE Test;
	IMPORT SYSTEM;
	VAR a: SIGNED32; b: FLOAT32; c: POINTER TO ARRAY OF CHAR; i: SIGNED16; ch: CHAR;
	BEGIN
		a := SYSTEM.VAL(SIGNED32,a);
		a := SYSTEM.VAL(SIGNED32,c);
		a := SYSTEM.VAL(SIGNED32,b);
		a := SYSTEM.VAL(SIGNED32,i);
		a := SYSTEM.VAL(SIGNED32,ch);
	END Test.

positive: shift of unsigned type by signed value

	MODULE Test;
	IMPORT SYSTEM;
	VAR ebx: SET;
	BEGIN
		ebx := LSH(ebx, -16)
	END Test.

positive: shift of unsigned type by signed variable

	MODULE Test;
	IMPORT SYSTEM;
	VAR ebx: SET; a: SIGNED32;
	BEGIN
		ebx := LSH(ebx, a)
	END Test.

positive: assignment of converted unsigned type to signed type

	MODULE Test;
	IMPORT SYSTEM;
	VAR ebx: SET; a,i: SIGNED32;
	BEGIN
		i := SYSTEM.VAL(SIGNED32, LSH(ebx * {16..23}, -16));
	END Test.

positive: getprocedure builtin call

	MODULE Test;
	TYPE
		R= RECORD END;
		MyO= OBJECT END MyO;
	VAR
		p: PROCEDURE;
		q: PROCEDURE(r: R);
		r: PROCEDURE():MyO;
		s: PROCEDURE(p: MyO): MyO;
		t: PROCEDURE(p:MyO);
		u: PROCEDURE(r: R): MyO;
	BEGIN
		GETPROCEDURE("TestModule","TestProcedure",p);
		GETPROCEDURE("X","Y",p);
		GETPROCEDURE("TestModule","TestProcedure",p);
		GETPROCEDURE("TestModule","TestProcedure",q);
		GETPROCEDURE("TestModule","TestProcedure",r);
		GETPROCEDURE("TestModule","TestProcedure",t);
		GETPROCEDURE("TestModule","TestProcedure",s);
		GETPROCEDURE("TestModule","TestProcedure",u);
	END Test.

negative: procedure call designator returning nil as index

	MODULE Test;
	VAR a: ARRAY 32 OF CHAR; c: CHAR;

	PROCEDURE P;
	BEGIN
	END P;

	BEGIN
		c := a[P()];
	END Test.

negative: procedure call designator returning nil in binary expression

	MODULE Test;
	VAR a,b: SIGNED32;

	PROCEDURE P;
	BEGIN
	END P;

	BEGIN
		a := b + P();
	END Test.

positive: module exporting procedure variable with return type

	MODULE Dummy;
	VAR
		p-: PROCEDURE(a,b: SIGNED32): SIGNED32;
	END Dummy.

positive: module importing procedure variable with return type

	MODULE Test;
	IMPORT Dummy;
	VAR a: SIGNED32;
	BEGIN
		a := a + Dummy.p(0,0);
	END Test.

positive: passing NIL parameter on WINAPI string parameter

	MODULE Test;
	IMPORT SYSTEM;
	VAR
	p: PROCEDURE{WINAPI}(CONST a: ARRAY OF CHAR);
	BEGIN
		p(NIL);
	END Test.

positive: SYSTEM.TYPECODE on records, pointer to record and object

	MODULE Test;
	IMPORT SYSTEM;
	TYPE
		R1=RECORD END; R2=RECORD (R1) END;
		P1= POINTER TO RECORD END; P2=POINTER TO RECORD (P1) END;
		O1 = OBJECT END O1; O2=OBJECT(O1) END O2;

	PROCEDURE P(VAR r: R1; p: P1; o: O1);
	VAR a: ADDRESS;
	BEGIN
		IF r IS R2 THEN END;
		a := SYSTEM.TYPECODE(R2);
		IF p IS P2 THEN END;
		a := SYSTEM.TYPECODE(P2);
		IF o IS O2 THEN END;
		a := SYSTEM.TYPECODE(O2);
	END P;

	END Test.

negative: SYSTEM.TYPECODE with basic type

	MODULE Test;
	IMPORT SYSTEM;
	TYPE
		T = SIGNED16;
	VAR
		a: SIGNED32;

	BEGIN
		a:= SYSTEM.TYPECODE(T);
	END Test.

negative: SYSTEM.TYPECODE with ANY type

	MODULE Test;
	IMPORT SYSTEM;
	TYPE
		T = ANY;
	VAR
		a: SIGNED32;

	BEGIN
		a:= SYSTEM.TYPECODE(T);
	END Test.


negative: SYSTEM.TYPECODE with OBJECT type

	MODULE Test;
	IMPORT SYSTEM;
	TYPE
		T = OBJECT;
	VAR
		a: SIGNED32;

	BEGIN
		a:= SYSTEM.TYPECODE(T);
	END Test.


negative: SYSTEM.TYPECODE with static array

	MODULE Test;
	IMPORT SYSTEM;
	TYPE
		T = ARRAY 32 OF CHAR;
	VAR
		a: SIGNED32;

	BEGIN
		a:= SYSTEM.TYPECODE(T);
	END Test.

negative: SYSTEM.TYPECODE with pointer to static array

	MODULE Test;
	IMPORT SYSTEM;
	TYPE
		T = POINTER TO ARRAY 32 OF SIGNED32;
	VAR
		a: SIGNED32;

	BEGIN
		a:= SYSTEM.TYPECODE(T);
	END Test.

negative: SYSTEM.TYPECODE with pointer to dynamic array without pointers

	MODULE Test;
	IMPORT SYSTEM;
	TYPE
		T = POINTER TO ARRAY OF SIGNED32;
	VAR
		a: SIGNED32;

	BEGIN
		a:= SYSTEM.TYPECODE(T);
	END Test.

positive: SYSTEM.HALT statement

	MODULE Test;
	IMPORT SYSTEM;
	BEGIN
		SYSTEM.HALT(100);
		SYSTEM.HALT(10);
	END Test.

positive: HALT statement with small parameter

	MODULE Test;
	BEGIN HALT(14)
	END Test.

positive: pass a one and two character array as string and pass one array character as character

	MODULE Test;

	PROCEDURE P(CONST s: ARRAY OF CHAR);
	BEGIN END P;

	PROCEDURE Q(CONST c: CHAR);
	BEGIN END Q;


	BEGIN P("a"); P("ab"); Q("a"); P('a'); P('ab'); Q('a');
	END Test.

positive: assign one character array to character

	MODULE Test;
	VAR a: CHAR;
	BEGIN a := "a"
	END Test.

negative: assign a character to a string

	MODULE Test;
	VAR a: ARRAY 2 OF CHAR;
	BEGIN a := 0X;
	END Test.

negative: pass a character value as a string

	MODULE Test;
	PROCEDURE P(CONST a: ARRAY OF CHAR);
	BEGIN	END P;
	BEGIN P(0X);
	END Test.

positive: assign a string of length zero to variable parameter

	MODULE Test;

	PROCEDURE P(VAR a: ARRAY OF CHAR);
	BEGIN
		a := "";
	END P;

	END Test.

positive: index array of record and pass as parameter

	MODULE Test;

	TYPE R=RECORD END;
	VAR a: ARRAY 32 OF R;

	PROCEDURE P(CONST r: R);
	BEGIN END P;

	BEGIN P(a[10]);
	END Test.

positive: export of a type
	MODULE Dummy;
	TYPE R*=RECORD END;
	END Dummy.

positive: reexport a type

	MODULE Test;
	IMPORT Dummy;
		PROCEDURE P*(VAR r: Dummy.R);
		BEGIN	END P;
	END Test.

positive: new on pointer to array containing pointers (any)

	MODULE Test;
	VAR a: POINTER TO ARRAY OF ANY;
	BEGIN NEW(a,10)	END Test.

positive: new on pointer to array containing pointers (delegates)

	MODULE Test;
	TYPE delegate = PROCEDURE{DELEGATE}(x: SIGNED32);
	VAR a: POINTER TO ARRAY OF delegate;
	BEGIN NEW(a,10) END Test.

positive: new on pointer to array containing pointers (objects)
	MODULE Test;
	TYPE object = OBJECT END object;
	VAR a: POINTER TO ARRAY OF object;
	BEGIN NEW(a,10) END Test.

positive: new on pointer to array containing pointers (record with pointer)
	MODULE Test;
	TYPE
		r1 = RECORD a: SIGNED32; b: POINTER TO r1 END;
		r2 = RECORD r: r1 END;
		record = RECORD (r2) b: SIGNED32 END;
	VAR a: POINTER TO ARRAY OF record;
	BEGIN NEW(a,10) END Test.

positive: export object with field

	MODULE Dummy;
	TYPE
		Volume* = OBJECT
		VAR size-: SIGNED32
		END Volume;
	END Dummy.

positive: import object with field

	MODULE Test;
	IMPORT Dummy;
	TYPE
		File = OBJECT
		VAR
		vol: Dummy.Volume;
		PROCEDURE P;
		VAR size: SIGNED32;
		BEGIN
		size := vol.size;
		END P;
		END File;

	END Test.


positive: export string value

	MODULE Dummy;
	CONST str*="myString";
	END Dummy.

positive: import and use string value

	MODULE Test;
	IMPORT Dummy;

	PROCEDURE P(str: ARRAY OF CHAR);
	BEGIN
	END P;

	BEGIN P(Dummy.str);
	END Test.

positive: boolean in record designator in pointer to array

	MODULE Test;
	TYPE
		R= RECORD a,b: BOOLEAN END;
		P= POINTER TO ARRAY OF R;
		B= ARRAY 20 OF BOOLEAN;
	VAR p:P; b:B;
	BEGIN ASSERT(p[10].b); ASSERT(b[10]);
	END Test.

positive: formal array of system.byte parameter used with basic actual parameter

	MODULE Test;
	IMPORT SYSTEM;

	VAR a: ARRAY 32 OF CHAR; b: SIGNED32;

	PROCEDURE P(CONST a: ARRAY OF SYSTEM.BYTE);
	BEGIN
	END P;

	BEGIN P(a); P(b); P(a[0]);
	END Test.

positive: module exporting OBJECT

	MODULE Dummy;
	VAR a*: OBJECT;
	END Dummy.

positive: module importing OBJECT

	MODULE Test;
	IMPORT Dummy;
	PROCEDURE P(a: OBJECT);
	BEGIN
	END P;

	BEGIN P(Dummy.a);
	END Test.

positive: binary MIN function

	MODULE Test;
	CONST min = MIN(10,20);
	VAR a,b: SIGNED32; r1,r2: FLOAT32;
	BEGIN
		a := MIN(a,b);
		r1 := MIN(r1,r2);
		a := MIN(a,256);
		r1 := MIN(r1,20);
		r1 := MIN(2.0,200);
		ASSERT(MIN(1,10)=1);
		ASSERT(MIN(-10,10)=-10);
	END Test.


positive: binary MAX function

	MODULE Test;
	CONST min = MAX(10,20);
	VAR a,b: SIGNED32; r1,r2: FLOAT32;
	BEGIN
		a := MAX(a,b);
		r1 := MAX(r1,r2);
		a := MAX(a,256);
		r1 := MAX(r1,20);
		r1 := MAX(2.0,200);
		ASSERT(MAX(1,10)=10);
		ASSERT(MAX(-10,10)=10);
	END Test.

positive: method returning a delegate type

	MODULE Test;
	IMPORT SYSTEM;

	TYPE Proc = PROCEDURE{DELEGATE};
	TYPE O= OBJECT
		VAR

		PROCEDURE P;
		BEGIN END P;

		PROCEDURE Q(): Proc;
		BEGIN
			RETURN P;
		END Q;

		END O;

	VAR x: Proc; o:O;

	BEGIN x := o.Q(); x:= x;
	END Test.

positive: type test on pointer returned by procedure

	MODULE Test;
	TYPE O = OBJECT END O;
	PROCEDURE P(): OBJECT; BEGIN RETURN NIL; END P;
	BEGIN ASSERT(P() IS O);
	END Test.

positive: delegate array element assignment

	MODULE Test;
	IMPORT SYSTEM;
	TYPE Handler= PROCEDURE{DELEGATE};
	VAR
	handlers: ARRAY 6 OF Handler; h: Handler;
	BEGIN handlers[3] := h;
	END Test.

positive: large stack size

	MODULE Test;
	CONST stackSize = 10000H;

	PROCEDURE P;
	VAR a: ARRAY stackSize OF CHAR;
	BEGIN
	END P;

	PROCEDURE Q;
	VAR a: ARRAY 100 OF CHAR;
	BEGIN
	END Q;

	END Test.

positive: shortint variable multiplied by shortint value (8bit multiply)

	MODULE Test;

	PROCEDURE P;
	VAR a: SIGNED8;
	BEGIN
		IF a = a*3 THEN END;
	END P;

	END Test.

positive: with statement on object field

	MODULE Test;
	TYPE Object = OBJECT VAR a: SIGNED32; END Object;
	TYPE Object2 = OBJECT (Object) VAR a: Object; END Object2;
	TYPE Object3 = OBJECT VAR a: Object; BEGIN WITH a: Object2 DO a.a.a := a.a.a; END; END Object3;
	END Test.

negative: access to different instance of a with-guarded variable

	MODULE Test;

	TYPE A = OBJECT END A;
	TYPE B = OBJECT (A)
	VAR a: A;
	BEGIN WITH a: B DO a.a.a := NIL END;
	END B;
	END Test.

positive: use of SYSTEM.NEW

	MODULE Test;
	IMPORT SYSTEM;
	VAR any: ANY;
	BEGIN SYSTEM.NEW(any,100);
	END Test.

positive: expression involving a reordering of floating point stack

	MODULE Test;
	VAR x,y: FLOAT64;

	PROCEDURE Sqrt(x: FLOAT32): FLOAT32;
	BEGIN END Sqrt;
	BEGIN
		x := x*y + Sqrt(SHORT(x)) + x*y;
	END Test.

positive: use string length with different lengths (to check side-effects on length field in string value)

	MODULE Test;
	TYPE
		String = ARRAY 128 OF CHAR;

		PROCEDURE PutBareName ( VAR name : String);
		VAR ix : SIGNED32;
		BEGIN
			WHILE (ix<LEN(name)) DO END;
		END PutBareName;

		PROCEDURE AddUserToName (VAR thisName : String);
		VAR pos : SIGNED16;
		BEGIN
			IF pos < LEN (thisName)  THEN END;
		END AddUserToName;
	END Test.

positive: SYSTEM.BYTE varpar

	MODULE Test;
	IMPORT SYSTEM;
	VAR c: CHAR;
	PROCEDURE P(VAR x: SYSTEM.BYTE);
	BEGIN
	END P;
	BEGIN
		P(c);
	END Test.

positive: write a SYSTEM.BYTE varpar without conversion

	MODULE Test;

	IMPORT SYSTEM;

	PROCEDURE P(VAR buf: SYSTEM.BYTE);
	VAR s1,s2: SIGNED8;
	BEGIN
		buf := s2*16 + (s1 MOD 16)
	END P;

	END Test.

positive: use a value for a the address in SYSTEM.GET

	MODULE Test;

	IMPORT SYSTEM;

	PROCEDURE P(VAR buf: SYSTEM.BYTE);
	VAR adr: ADDRESS;
	BEGIN
	adr := 0;
	SYSTEM.GET (040EH, SYSTEM.VAL (SIGNED16, adr));	(* EBDA address *)
	END P;

	END Test.

negative: use a non variable for destination in SYSTEM.GET

	MODULE Test;

	IMPORT SYSTEM;

	PROCEDURE P(VAR buf: SYSTEM.BYTE);
	VAR adr: ADDRESS;
	BEGIN
		SYSTEM.GET (adr, adr+1);	(* EBDA address *)
	END P;

	END Test.

positive: negative values in address

	MODULE Test;
	IMPORT SYSTEM;
	VAR a: ADDRESS;
	BEGIN
		a := -1;
	END Test.

positive: negative values in address in SYSTEM.GET

	MODULE Test;
	IMPORT SYSTEM;
	VAR a: SIGNED32;
	BEGIN
		SYSTEM.GET(-1,a)
	END Test.

positive: ugly system.val with records

	MODULE Test;

	IMPORT SYSTEM;

	TYPE Record= RECORD a,b: SIGNED32 END;

	PROCEDURE P(VAR r: Record);
	VAR a: SIGNED32;
	BEGIN
		P(SYSTEM.VAL(Record,a));
	END P;

	PROCEDURE Q(r: Record);
	VAR a: SIGNED32;
	BEGIN
		Q(SYSTEM.VAL(Record,a));
	END Q;

	END Test.

positive: call an empty inline code
	MODULE Test;
	IMPORT SYSTEM;
	PROCEDURE -P;
	CODE{SYSTEM.i386}
	END P;
	BEGIN P;
	END Test.

positive: export inline code with reference to (local) constant
	MODULE Test;
	IMPORT SYSTEM;
	PROCEDURE -P*;
	CONST const=16;
	CODE{SYSTEM.i386}
		MOV EAX,const
	END P;
	END Test.

positive: export and import real number
	MODULE A;
	CONST
	e*=1.2345D0;
	END A.

	MODULE Test;
	IMPORT A;
	CONST e=1.2345D0;
	BEGIN
		ASSERT(A.e = e);
	END Test.

positive: addition of ADDRESS and SIZE
	MODULE Test;
	IMPORT SYSTEM;
	VAR a: ADDRESS; s: SIZE;

	BEGIN
		a := a + s;
	END Test.

positive: implicit SIGNED64 conversion in comparison
	MODULE Test;
	VAR h: SIGNED64;
	BEGIN
		IF h < 0 THEN END
	END Test.

positive: ADDRESS as variable in for loop
	MODULE Test;
	IMPORT SYSTEM;
	VAR a,b,i: ADDRESS;
	BEGIN
		FOR i := a TO b DO
		END;
	END Test.

positive: subtract a ADDRESS from ADDRESS
	MODULE Test;
	IMPORT SYSTEM;
	VAR a,b: ADDRESS; size: SIZE;
	BEGIN
		size := a-b;
		size := -size
	END Test.

negative: LONG conversion on ADDRESS
	MODULE Test;
	IMPORT SYSTEM;
	VAR a: ADDRESS; v: SIGNED64;
	BEGIN
		v := LONG(a)
	END Test.

positive: add negative value to ADDRESS
	MODULE Test;
	IMPORT SYSTEM;
	VAR a: ADDRESS;
	CONST const = -4;
	BEGIN
		a := a + const;
	END Test.

positive: unary negation of ADDRESS
	MODULE Test;
	IMPORT SYSTEM;
	VAR a: ADDRESS;
	BEGIN
		a := a + (-a) MOD 4;
	END Test.

positive: export and import ADDRESS parameter
	MODULE A;
	IMPORT SYSTEM;
	PROCEDURE P*(VAR a: ADDRESS);
	BEGIN
	END P;
	END A.

	MODULE Test;
	IMPORT SYSTEM,A;
	VAR a: ADDRESS;
	BEGIN A.P(a)
	END Test.

positive: use ADDRESS as array index
	MODULE Test;
	IMPORT SYSTEM;
	VAR a: ADDRESS; b: ARRAY 32 OF ADDRESS;
	BEGIN b[a] := b[a]
	END Test.

positive: long jumps (backend test for TRM)
	MODULE Test;
	PROCEDURE LongJumpBackwards;
	VAR a,b,c: SIGNED32;
	BEGIN
		REPEAT
			a := b + c; a := b + c;	a := b + c; a := b + c;	a := b + c; a := b + c; a := b + c;	a := b + c; a := b + c;	a := b + c; a := b + c; a := b + c;	a := b + c; a := b + c;	a := b + c;
			a := b + c; a := b + c;	a := b + c; a := b + c;	a := b + c; a := b + c; a := b + c;	a := b + c; a := b + c;	a := b + c; a := b + c; a := b + c;	a := b + c; a := b + c;	a := b + c;
			a := b + c; a := b + c;	a := b + c; a := b + c;	a := b + c; a := b + c; a := b + c;	a := b + c; a := b + c;	a := b + c; a := b + c; a := b + c;	a := b + c; a := b + c;	a := b + c;
			a := b + c; a := b + c;	a := b + c; a := b + c;	a := b + c; a := b + c; a := b + c;	a := b + c; a := b + c;	a := b + c; a := b + c; a := b + c;	a := b + c; a := b + c;	a := b + c;
			a := b + c; a := b + c;	a := b + c; a := b + c;	a := b + c; a := b + c; a := b + c;	a := b + c; a := b + c;	a := b + c; a := b + c; a := b + c;	a := b + c; a := b + c;	a := b + c;
			a := b + c; a := b + c;	a := b + c; a := b + c;	a := b + c; a := b + c; a := b + c;	a := b + c; a := b + c;	a := b + c; a := b + c; a := b + c;	a := b + c; a := b + c;	a := b + c;
			a := b + c; a := b + c;	a := b + c; a := b + c;	a := b + c; a := b + c; a := b + c;	a := b + c; a := b + c;	a := b + c; a := b + c; a := b + c;	a := b + c; a := b + c;	a := b + c;
			a := b + c; a := b + c;	a := b + c; a := b + c;	a := b + c; a := b + c; a := b + c;	a := b + c; a := b + c;	a := b + c; a := b + c; a := b + c;	a := b + c; a := b + c;	a := b + c;
		UNTIL a<b
	END LongJumpBackwards;
	PROCEDURE LongJumpForwards;
	VAR a,b,c: SIGNED32;
	BEGIN
		IF a>=b THEN
			a := b + c; a := b + c;	a := b + c; a := b + c;	a := b + c; a := b + c; a := b + c;	a := b + c; a := b + c;	a := b + c; a := b + c; a := b + c;	a := b + c; a := b + c;	a := b + c;
			a := b + c; a := b + c;	a := b + c; a := b + c;	a := b + c; a := b + c; a := b + c;	a := b + c; a := b + c;	a := b + c; a := b + c; a := b + c;	a := b + c; a := b + c;	a := b + c;
			a := b + c; a := b + c;	a := b + c; a := b + c;	a := b + c; a := b + c; a := b + c;	a := b + c; a := b + c;	a := b + c; a := b + c; a := b + c;	a := b + c; a := b + c;	a := b + c;
			a := b + c; a := b + c;	a := b + c; a := b + c;	a := b + c; a := b + c; a := b + c;	a := b + c; a := b + c;	a := b + c; a := b + c; a := b + c;	a := b + c; a := b + c;	a := b + c;
			a := b + c; a := b + c;	a := b + c; a := b + c;	a := b + c; a := b + c; a := b + c;	a := b + c; a := b + c;	a := b + c; a := b + c; a := b + c;	a := b + c; a := b + c;	a := b + c;
			a := b + c; a := b + c;	a := b + c; a := b + c;	a := b + c; a := b + c; a := b + c;	a := b + c; a := b + c;	a := b + c; a := b + c; a := b + c;	a := b + c; a := b + c;	a := b + c;
			a := b + c; a := b + c;	a := b + c; a := b + c;	a := b + c; a := b + c; a := b + c;	a := b + c; a := b + c;	a := b + c; a := b + c; a := b + c;	a := b + c; a := b + c;	a := b + c;
			a := b + c; a := b + c;	a := b + c; a := b + c;	a := b + c; a := b + c; a := b + c;	a := b + c; a := b + c;	a := b + c; a := b + c; a := b + c;	a := b + c; a := b + c;	a := b + c;
		END;
	END LongJumpForwards;
	END Test.

positive: expressions of type real with longint divisions
	MODULE Test;
	    PROCEDURE Do*(x: FLOAT32): FLOAT32;
	    VAR v: FLOAT32;
	    BEGIN
	        v := x * (x * (x * (x * ((11 / 11520) - x * (1 / 14400)) - 583 / 69120) + 14597 / 276480) - 156409 / 737280) + 381773117 / 928972800;
	        RETURN v;
	    END Do;
	END Test.

negative: invalid arrow designator
	MODULE Test;
	VAR s: ARRAY 128 OF CHAR;
	BEGIN
		COPY("WMClock.Open~", s)^;
	END Test.

positive: tests of MIN and MAX
	MODULE Test;

	PROCEDURE TestMinMax*();
	BEGIN
	    ASSERT(-128 = MIN(SIGNED8)); ASSERT(127 = MAX(SIGNED8));
	    ASSERT(-32768 = MIN(SIGNED16)); ASSERT(32767 = MAX(SIGNED16));
	    ASSERT(-2147483648 = MIN(SIGNED32)); ASSERT(2147483647 = MAX(SIGNED32));
	    ASSERT(-9223372036854775807-1 = MIN(SIGNED64)); ASSERT(9223372036854775807 = MAX(SIGNED64));

	    ASSERT(-128 = MIN(SIGNED8)); ASSERT(127 = MAX(SIGNED8));
	    ASSERT(-32768 = MIN(SIGNED16)); ASSERT(32767 = MAX(SIGNED16));
	    ASSERT(-2147483648 = MIN(SIGNED32)); ASSERT(2147483647 = MAX(SIGNED32));
	    ASSERT(-9223372036854775807 -1  = MIN(SIGNED64)); ASSERT(9223372036854775807 = MAX(SIGNED64));

	    ASSERT(0 = MIN(UNSIGNED8)); ASSERT(255 = MAX(UNSIGNED8));
	    ASSERT(0 = MIN(UNSIGNED16)); ASSERT(65535 = MAX(UNSIGNED16));
	    ASSERT(0 = MIN(UNSIGNED32)); ASSERT(4294967295 = MAX(UNSIGNED32));
	    ASSERT(0 = MIN(UNSIGNED64)); ASSERT(SIGNED64(-1) = MAX(UNSIGNED64));
	END TestMinMax;

	BEGIN
	END Test.

negative: conversion float to unsigned data type
	MODULE Test;
	VAR real: FLOAT32;
	VAR unsigned8: UNSIGNED8;
	BEGIN
	    unsigned8 := UNSIGNED8(real);
	END Test.

negative: use array of size for array size
	MODULE Test;
	CONST Data = [10,20];
	VAR a: ARRAY LEN(Data) OF SIGNED32;
	END Test.

positive: use array size for array size
	MODULE Test;
	CONST Data = [10,20];
	VAR a: ARRAY LEN(Data,0) OF SIGNED32;
	END Test.

