# Oberon language test and validation suite

# test halt and assert statements and simple procedure call (basics for the test suite)

positive: empty module

	MODULE Test;
	END Test.

negative: simple halt

	MODULE Test;
	BEGIN HALT (1234);
	END Test.

positive: satisified assertion

	MODULE Test;
	VAR b: BOOLEAN;
	BEGIN b := TRUE; ASSERT (b);
	END Test.

negative: unsatisified assertion

	MODULE Test;
	VAR b: BOOLEAN;
	BEGIN b := FALSE; ASSERT (b);
	END Test.

negative: simple halt in global procedure

	MODULE Test;
	PROCEDURE Procedure;
	BEGIN HALT (1234);
	END Procedure;
	BEGIN Procedure;
	END Test.

positive: satisified assertion in global procedure

	MODULE Test;
	PROCEDURE Procedure;
	VAR b: BOOLEAN;
	BEGIN b := TRUE; ASSERT (b);
	END Procedure;
	BEGIN Procedure;
	END Test.

negative: unsatisified assertion in global procedure

	MODULE Test;
	PROCEDURE Procedure;
	VAR b: BOOLEAN;
	BEGIN b := FALSE; ASSERT (b);
	END Procedure;
	BEGIN Procedure;
	END Test.

positive: parameterless procedure call

	MODULE Test;
	VAR called: BOOLEAN;

		PROCEDURE P;
		BEGIN
			called := TRUE;
		END P;
	BEGIN
		called := FALSE;
		P;
		ASSERT(called);
	END Test.


# basic types storage test

positive: Char stored in PAF

	MODULE Test;

	PROCEDURE Char;
	VAR a,b: CHAR;
	BEGIN
		a := 'a';
		b := a;
		ASSERT(b = 'a');
	END Char;

	BEGIN
		Char;
	END Test.

positive: Shortint stored in PAF

	MODULE Test;

	PROCEDURE Shortint;
	VAR a,b: SHORTINT;
	BEGIN
		a := 13;
		b := a;
		ASSERT(b = 13);
	END Shortint;

	BEGIN
		Shortint;
	END Test.

positive: Integer stored in PAF

	MODULE Test;

	PROCEDURE Integer;
	VAR a,b: INTEGER;
	BEGIN
		a := 2233;
		b := a;
		ASSERT(b = 2233);
	END Integer;

	BEGIN
		Integer;
	END Test.

positive: Longint stored in PAF

	MODULE Test;

	PROCEDURE Longint;
	VAR a,b: LONGINT;
	BEGIN
		a := 70800;
		b := a;
		ASSERT(b = 70800);
	END Longint;

	BEGIN
		Longint;
	END Test.

positive: Hugeint stored in PAF

	MODULE Test;

	PROCEDURE Hugeint;
	VAR a,b: HUGEINT;
	BEGIN
		a := 70800;
		b := a;
		ASSERT(b = 70800);
	END Hugeint;

	BEGIN
		Hugeint;
	END Test.

positive: Real stored in PAF

	MODULE Test;

	PROCEDURE Real;
	VAR a,b: REAL;
	BEGIN
		a := 888;
		b := a;
		ASSERT(b = 888);
	END Real;

	BEGIN
		Real;
	END Test.

positive: Longreal stored in PAF

	MODULE Test;

	PROCEDURE Longreal;
	VAR a,b: LONGREAL;
	BEGIN
		a := 888;
		b := a;
		ASSERT(b = 888);
	END Longreal;

	BEGIN
		Longreal;
	END Test.

positive: Set stored in PAF

	MODULE Test;

	PROCEDURE Set;
	VAR a,b: SET;
	BEGIN
		a := {1,2,8,9,31};
		b := a;
		ASSERT(b = {1,2,8,9,31});
	END Set;

	BEGIN
		Set;
	END Test.

positive: Boolean stored in PAF

	MODULE Test;

	PROCEDURE Boolean;
	VAR a,b,c: BOOLEAN;
	BEGIN
		a := FALSE;
		b := TRUE;
		c := FALSE;
		ASSERT(b = TRUE);
	END Boolean;

	BEGIN
		Boolean;
	END Test.


# constant declarations

positive: expression containing a constant

	MODULE Test;
	CONST N = 10000;
	VAR i: INTEGER;
	BEGIN i := N - 1; ASSERT (i = 9999);
	END Test.

positive: lengths of string constants

	MODULE Test;
	CONST String = "This string is not empty";
	CONST Copy = String;

	PROCEDURE Assert (CONST str: ARRAY OF CHAR);
	BEGIN ASSERT (LEN (str) # 0);
	END Assert;

	BEGIN Assert (String); Assert (Copy);
	END Test.


# basic type declarations

positive: constant boolean assignment

	MODULE Test;
	VAR b: BOOLEAN;
	BEGIN b := TRUE; ASSERT (b = TRUE);
	END Test.

positive: variable boolean assignment

	MODULE Test;
	VAR b1, b2: BOOLEAN;
	BEGIN b1 := TRUE; b2 := FALSE; b2 := b1; ASSERT (b2 = TRUE);
	END Test.

positive: boolean equality

	MODULE Test;
	VAR b1, b2: BOOLEAN;
	BEGIN b1 := TRUE; b2 := b1; ASSERT (b1 = b2); b1 := FALSE; b2 := b1; ASSERT (b1 = b2);
	END Test.

positive: array of boolean values

	MODULE Test;
	VAR b: ARRAY 2 OF BOOLEAN;
	BEGIN b[1] := TRUE; ASSERT (b[1]);
	END Test.

positive: constant character assignment

	MODULE Test;
	VAR c: CHAR;
	BEGIN c := 'c'; ASSERT (c = 'c');
	END Test.

positive: variable character assignment

	MODULE Test;
	VAR c1, c2: CHAR;
	BEGIN c1 := 'A'; c2 := 'B'; c2 := c1; ASSERT (c2 = 'A');
	END Test.

positive: char array variable assignment

	MODULE Test;
	VAR v: ARRAY 2 OF CHAR;
	BEGIN v[0] := CHR(92); ASSERT (ORD(v[0]) = 92);
	END Test.

positive: heximal character value assignment

	MODULE Test;
	VAR c: CHAR;
	BEGIN c := 020X; ASSERT (c = ' ');
	END Test.

positive: constant integer assignment

	MODULE Test;
	VAR i: INTEGER;
	BEGIN i := 2; ASSERT (i = 2);
	END Test.

positive: variable integer assignment

	MODULE Test;
	VAR i1, i2: INTEGER;
	BEGIN i1 := 45; i2 := 64; i2 := i1; ASSERT (i1 = 45);
	END Test.

positive: constant real assignment

	MODULE Test;
	VAR r: REAL;
	BEGIN r := 2; ASSERT (r = 2);
	END Test.

positive: variable real assignment

	MODULE Test;
	VAR r1, r2: REAL;
	BEGIN r1 := 2.25; r2 := 3.75; r2 := r1; ASSERT (r1 = 2.25);
	END Test.

positive: real value assignment to real variable

	MODULE Test;
	VAR r: REAL;
	BEGIN r := 1.25; ASSERT (r = 1.25);
	END Test.

positive: constant set assignment

	MODULE Test;
	VAR s: SET;
	BEGIN s := {1}; ASSERT (1 IN s);
	END Test.

positive: variable set assignment

	MODULE Test;
	VAR s1, s2: SET; i: INTEGER;
	BEGIN i := 5; s1 := {i}; s2 := {}; s2 := s1; ASSERT (i IN s2);
	END Test.

positive: set inclusions

	MODULE Test;
	VAR s: SET; i, j, k: INTEGER;
	BEGIN i := 1; j := 3; k := 7; s := {1, 3, 5..8}; ASSERT ((i IN s) & (j IN s) & (k IN s));
	END Test.

negative: set value out of bounds at maximum

	MODULE Test;
	VAR n: INTEGER; s: SET;
	BEGIN n := MAX(SET) + 1; s := {n};
	END Test.

negative: set value out of bounds at minimum

	MODULE Test;
	VAR n: INTEGER; s: SET;
	BEGIN n := MIN(SET) - 1; s := {n};
	END Test.


# array type declarations

negative: array out of bounds while reading

	MODULE Test;
	VAR a: ARRAY 1 OF INTEGER; r, i: INTEGER;
	BEGIN a[0] := 0; i := 1; r := a[i];
	END Test.

negative: array out of bounds while writing

	MODULE Test;
	VAR a: ARRAY 1 OF INTEGER; i: INTEGER;
	BEGIN i := 1; a[i] := 0;
	END Test.

positive: index of array element is record variable

	MODULE Test;
	TYPE R = RECORD i: INTEGER END;
	VAR ai: ARRAY 2 OF INTEGER; ar: ARRAY 2 OF R;
	BEGIN ai[0] := 0; ai[1] := 5; ar[0].i := 1; ASSERT (ai[ar[ai[0]].i] = 5);
	END Test.

positive: one-dimensional array element assignment

	MODULE Test;
	VAR a: ARRAY 2 OF CHAR;
	BEGIN a[1] := 'c'; ASSERT (a[1] = 'c');
	END Test.

positive: two-dimensional array element assignment

	MODULE Test;
	VAR a: ARRAY 2, 2 OF BOOLEAN;
	BEGIN a[1, 1] := TRUE; ASSERT (a[1, 1] = TRUE);
	END Test.


# record type declarations

positive: record initialization

	MODULE Test;
	VAR r: RECORD i: INTEGER END;
	BEGIN r.i := 5; ASSERT (r.i = 5);
	END Test.

positive: record copies

	MODULE Test;
	VAR a, b: RECORD i, j: INTEGER END;
	BEGIN a.i := 1; a.j := 2; b := a; ASSERT (b.i = 1); ASSERT (b.j = 2);
	END Test.


# pointer type declarations

positive: dynamic record allocation with new

	MODULE Test;
	VAR p: POINTER TO RECORD x: INTEGER END;
	BEGIN NEW (p); ASSERT (p # NIL); p.x := 3; ASSERT (p.x = 3);
	END Test.

positive: valid type guard test

	MODULE Test;
	TYPE R1 = RECORD END; R2 = RECORD (R1) END; P1 = POINTER TO R1; P2 = POINTER TO R2;
	VAR p1: P1; p2: P2;
	BEGIN NEW (p2); p1 := p2; p2 := p1(P2);
	END Test.


# procedure type declarations

positive: procedure type with value parameter

	MODULE Test;
	VAR a: ARRAY 5 OF REAL; i: INTEGER; r: REAL;

	PROCEDURE Iterate (VAR a: ARRAY OF REAL; p : PROCEDURE (r: REAL));
	VAR i: LONGINT;
	BEGIN FOR i := 0 TO LEN (a) - 1 DO p (a[i]) END;
	END Iterate;

	PROCEDURE Accummulate (v: REAL);
	BEGIN r := r + v;
	END Accummulate;

	BEGIN FOR i := 0 TO 4 DO a[i] := i END; r := 0; Iterate (a, Accummulate); ASSERT (r = 10);
	END Test.

positive: procedure type with var parameter

	MODULE Test;
	VAR i: INTEGER; k: REAL; p: PROCEDURE (VAR r: REAL; b: REAL);

	PROCEDURE Accummulate (VAR r: REAL; v: REAL);
	BEGIN r := r + v;
	END Accummulate;

	BEGIN k := 0; p := Accummulate; FOR i := 0 TO 4 DO p (k, i) END; ASSERT (k = 10);
	END Test.

positive: procedure type with result type

	MODULE Test;
	VAR r: REAL; p: PROCEDURE (a, b: REAL): REAL;

	PROCEDURE Add (a, b: REAL): REAL;
	BEGIN RETURN a + b;
	END Add;

	BEGIN p := Add; r := p (3, 4); ASSERT (r = 7);
	END Test.

positive: procedure type with result type in record

	MODULE Test;
	VAR r: REAL; p: RECORD p: PROCEDURE (a, b: REAL): REAL END;

	PROCEDURE Add (a, b: REAL): REAL;
	BEGIN RETURN a + b;
	END Add;

	BEGIN p.p := Add; r := p.p (3, 4); ASSERT (r = 7);
	END Test.

positive: procedure array

	MODULE Test;
	VAR i: INTEGER; a: ARRAY 10 OF PROCEDURE (VAR a: INTEGER);

	PROCEDURE Add3 (VAR v: INTEGER);
	BEGIN INC (v, 3);
	END Add3;

	BEGIN i := 3; a[6] := Add3; a[6] (i); ASSERT (i = 6); a[i](i); ASSERT (i = 9);
	END Test.

positive: procedure array with return type

	MODULE Test;
	VAR i: INTEGER; a: ARRAY 10 OF PROCEDURE (i: INTEGER): INTEGER;

	PROCEDURE Add2 (v: INTEGER): INTEGER;
	BEGIN RETURN v + 2;
	END Add2;

	BEGIN a[3] := Add2; i := a[3](1); ASSERT (i = 3); INC (i, a[i](i)); ASSERT (i = 8);
	END Test.


# conversions

positive: constant positive real to integer conversion

	MODULE Test;
	VAR i: LONGINT;
	BEGIN i := ENTIER (3.5); ASSERT (i = 3);
	END Test.

positive: constant negative real to integer conversion

	MODULE Test;
	VAR i: LONGINT;
	BEGIN i := ENTIER (-3.5); ASSERT (i = -4);
	END Test.

positive: positive real to integer conversion

	MODULE Test;
	VAR r: REAL; i: LONGINT;
	BEGIN r := 3.5; i := ENTIER (r); ASSERT (i = 3);
	END Test.


positive: negative real to integer conversion

	MODULE Test;
	VAR r: REAL; i: LONGINT;
	BEGIN r := -3.5; i := ENTIER (r); ASSERT (i = -4);
	END Test.


# variable declarations

positive: two-dimensional array assignment

	MODULE Test;
	VAR a: ARRAY 8, 12 OF INTEGER;
	BEGIN a[1, 2] := 3; ASSERT (a[1][2] = 3);
	END Test.

positive: two-dimensional open array assignment

	MODULE Test;
	VAR a: ARRAY 8, 12 OF INTEGER;

	PROCEDURE P (VAR b: ARRAY OF ARRAY OF INTEGER);
	BEGIN b[1][2] := 3;
	END P;

	BEGIN P (a); ASSERT (a[1][2] = 3);
	END Test.


# operations

positive: logical operations

	MODULE Test;
	VAR a, b: BOOLEAN;
	BEGIN
		a := FALSE; ASSERT (~a);
		b := FALSE; ASSERT (~a & ~b); ASSERT (~a OR ~b);
		b := TRUE; ASSERT (~a & b); ASSERT (~a OR b);
		a := TRUE; ASSERT (a);
		b := FALSE; ASSERT (a & ~b); ASSERT (a OR ~b);
		b := TRUE; ASSERT (a & b); ASSERT (a OR b);
	END Test.

positive: arithmetic operations

	MODULE Test;
	VAR a, b: INTEGER;
	BEGIN
		a := 9; b := 7;
		ASSERT (+a = 9); ASSERT (+b = 7);
		ASSERT (-a = -9); ASSERT (-b = -7);
		ASSERT (a + b = 16); ASSERT (b + a = 16);
		ASSERT (a - b = 2); ASSERT (b - a = -2);
		ASSERT (a * b = 63); ASSERT (b * a = 63);
		ASSERT (a DIV b = 1); ASSERT (b DIV a = 0);
		ASSERT (a MOD b = 2); ASSERT (b MOD a = 7);
	END Test.

positive: set operations

	MODULE Test;
	VAR a, b, c: SET;
	BEGIN
		a := {0, 1, 2}; ASSERT (a = {0..2}); ASSERT ((0 IN a) & (1 IN a) & (2 IN a) & ~(3 IN a) & ~(4 IN a));
		b := {2, 3, 4}; ASSERT (b = {2..4}); ASSERT (~(0 IN b) & ~(1 IN b) & (2 IN b) & (3 IN b) & (4 IN b));
		c := a + b; ASSERT (c = {0..4}); ASSERT ((0 IN c) & (1 IN c) & (2 IN c) & (3 IN c) & (4 IN c));
		c := a - b; ASSERT (c = {0..1}); ASSERT ((0 IN c) & (1 IN c) & ~(2 IN c) & ~(3 IN c) & ~(4 IN c));
		c := a * b; ASSERT (c = {2..2}); ASSERT (~(0 IN c) & ~(1 IN c) & (2 IN c) & ~(3 IN c) & ~(4 IN c));
		c := a / b; ASSERT (c = {0..1, 3..4}); ASSERT ((0 IN c) & (1 IN c) & ~(2 IN c) & (3 IN c) & (4 IN c));
	END Test.

positive: relations

	MODULE Test;
	VAR ai, bi: INTEGER; as, bs: SET; ar, br: REAL;
	BEGIN
		ai := 0; bi := 1; ASSERT (~(ai = bi)); ASSERT (ai # bi); ASSERT (ai < bi); ASSERT (ai <= bi); ASSERT (~(ai > bi)); ASSERT (~(ai >= bi));
		as := {1}; bs := {1, 2}; ASSERT (~(as = bs)); ASSERT (as # bs); ASSERT (as < bs); ASSERT (as <= bs); ASSERT (~(as > bs)); ASSERT (~(as >= bs));
		ar := 0; br := 1; ASSERT (~(ar = br)); ASSERT (ar # br); ASSERT (ar < br); ASSERT (ar <= br); ASSERT (~(ar > br)); ASSERT (~(ar >= br));
	END Test.

# operators

positive: relational operations on booleans

	MODULE Test;
	VAR value: BOOLEAN;
	BEGIN
		value := TRUE;
		ASSERT (value = TRUE); ASSERT (~(value = FALSE)); ASSERT (value = value);
		ASSERT (value # FALSE); ASSERT (~(value # TRUE)); ASSERT (~(value # value));
		value := FALSE;
		ASSERT (value = FALSE); ASSERT (~(value = TRUE)); ASSERT (value = value);
		ASSERT (value # TRUE); ASSERT (~(value # FALSE)); ASSERT (~(value # value));
	END Test.

positive: complement on booleans

	MODULE Test;
	VAR value: BOOLEAN;
	BEGIN
		value := TRUE; ASSERT (value); ASSERT (~~value);
		value := FALSE; ASSERT (~value); ASSERT (~~~value);
	END Test.

positive: logical and on booleans

	MODULE Test;
	VAR a, b: BOOLEAN;
	BEGIN
		a := FALSE; b := FALSE; ASSERT (a & b = FALSE);
		a := FALSE; b := TRUE; ASSERT (a & b = FALSE);
		a := TRUE; b := FALSE; ASSERT (a & b = FALSE);
		a := TRUE; b := TRUE; ASSERT (a & b = TRUE);
	END Test.

positive: logical and on boolean return values

	MODULE Test;
	PROCEDURE True (): BOOLEAN; BEGIN RETURN TRUE; END True;
	PROCEDURE False (): BOOLEAN; BEGIN RETURN FALSE; END False;
	BEGIN
		ASSERT (False () & False () = FALSE);
		ASSERT (False () & True () = FALSE);
		ASSERT (True () & False () = FALSE);
		ASSERT (True () & True () = TRUE);
	END Test.

positive: logical or on booleans

	MODULE Test;
	VAR a, b: BOOLEAN;
	BEGIN
		a := FALSE; b := FALSE; ASSERT (a OR b = FALSE);
		a := FALSE; b := TRUE; ASSERT (a OR b = TRUE);
		a := TRUE; b := FALSE; ASSERT (a OR b = TRUE);
		a := TRUE; b := TRUE; ASSERT (a OR b = TRUE);
	END Test.

positive: logical or on boolean return values

	MODULE Test;
	PROCEDURE True (): BOOLEAN; BEGIN RETURN TRUE; END True;
	PROCEDURE False (): BOOLEAN; BEGIN RETURN FALSE; END False;
	BEGIN
		ASSERT (False () OR False () = FALSE);
		ASSERT (False () OR True () = TRUE);
		ASSERT (True () OR False () = TRUE);
		ASSERT (True () OR True () = TRUE);
	END Test.

positive: short-circuit evaluation

	MODULE Test;
	PROCEDURE True (): BOOLEAN; BEGIN RETURN TRUE; END True;
	PROCEDURE False (): BOOLEAN; BEGIN RETURN FALSE; END False;
	PROCEDURE Halt (): BOOLEAN; BEGIN HALT (1234); END Halt;
	BEGIN
		ASSERT (False () & Halt () = FALSE);
		ASSERT (True () OR Halt () = TRUE);
	END Test.

positive: relational operations on characters

	MODULE Test;
	VAR value: CHAR;
	BEGIN
		value := 'a';
		ASSERT (value = 'a'); ASSERT (~(value = 'b')); ASSERT (value = value);
		ASSERT (value # 'b'); ASSERT (~(value # 'a')); ASSERT (~(value # value));
		ASSERT (value < 'z'); ASSERT (~(value < 0X)); ASSERT (~(value < value));
		ASSERT (value <= 'z'); ASSERT (~(value <= 0X)); ASSERT (value <= value);
		ASSERT (value > 0X); ASSERT (~(value > 'z')); ASSERT (~(value > value));
		ASSERT (value >= 0X); ASSERT (~(value >= 'z')); ASSERT (value >= value);
	END Test.

positive: capital letter of character

	MODULE Test;
	VAR value: CHAR;
	BEGIN
		value := '0'; ASSERT (CAP (value) = '0'); ASSERT (CAP (value) = CAP ('0'));
		value := '9'; ASSERT (CAP (value) = '9'); ASSERT (CAP (value) = CAP ('9'));
		value := 'a'; ASSERT (CAP (value) = 'A'); ASSERT (CAP (value) = CAP ('a'));
		value := 'z'; ASSERT (CAP (value) = 'Z'); ASSERT (CAP (value) = CAP ('z'));
		value := 'A'; ASSERT (CAP (value) = 'A'); ASSERT (CAP (value) = CAP ('A'));
		value := 'Z'; ASSERT (CAP (value) = 'Z'); ASSERT (CAP (value) = CAP ('Z'));
	END Test.

positive: ordinal value of character

	MODULE Test;
	VAR value: CHAR; i: INTEGER;
	BEGIN
		value := '0'; ASSERT (ORD (value) = ORD ('0'));
		value := '9'; ASSERT (ORD (value) = ORD ('9'));
		value := 'a'; ASSERT (ORD (value) = ORD ('a'));
		value := 'z'; ASSERT (ORD (value) = ORD ('z'));
		value := 'A'; ASSERT (ORD (value) = ORD ('A'));
		value := 'Z'; ASSERT (ORD (value) = ORD ('Z'));
		FOR i := ORD (0X) TO ORD (0FFX) DO value := CHR (i); ASSERT (ORD (value) = i); END;
	END Test.

positive: relational operations on short integers

	MODULE Test;
	VAR value: SHORTINT;
	BEGIN
		value := 5;
		ASSERT (value = 5); ASSERT (~(value = 6)); ASSERT (value = value);
		ASSERT (value # 6); ASSERT (~(value # 5)); ASSERT (~(value # value));
		ASSERT (value < 6); ASSERT (~(value < 4)); ASSERT (~(value < value));
		ASSERT (value <= 6); ASSERT (~(value <= 4)); ASSERT (value <= value);
		ASSERT (value > 4); ASSERT (~(value > 6)); ASSERT (~(value > value));
		ASSERT (value >= 4); ASSERT (~(value >= 6)); ASSERT (value >= value);
	END Test.

positive: negation on short integers

	MODULE Test;
	VAR value: SHORTINT;
	BEGIN value := 5; ASSERT (-value = -5); ASSERT (-(-value) = 5); ASSERT (-(-value) = value)
	END Test.

positive: short integer as set element

	MODULE Test;
	VAR element: SHORTINT; set: SET;
	BEGIN
		element := MIN (SET); set := {element}; ASSERT (element IN set); ASSERT (set - {element} = {});
		element := MAX (SET); set := {element}; ASSERT (element IN set); ASSERT (set - {element} = {});
	END Test.

negative: short integer as too small set element

	MODULE Test;
	VAR element: SHORTINT; set: SET;
	BEGIN element := MIN (SET) - 1; set := {element};
	END Test.

negative: short integer as too large set element

	MODULE Test;
	VAR element: SHORTINT; set: SET;
	BEGIN element := MAX (SET) + 1; set := {element};
	END Test.

positive: absolute value of short integer

	MODULE Test;
	VAR value: SHORTINT;
	BEGIN
		value := 5; ASSERT (ABS (value) = 5); ASSERT (ABS (-value) = 5); ASSERT (ABS (value) = value); ASSERT (ABS (-value) = value);
		value := -5; ASSERT (ABS (value) = 5); ASSERT (ABS (-value) = 5); ASSERT (ABS (value) = -value); ASSERT (ABS (-value) = -value);
	END Test.

positive: odd test on short integer

	MODULE Test;
	VAR value: SHORTINT;
	BEGIN
		value := 0; ASSERT (~ODD (value)); ASSERT (ODD (value + 1));
		value := 5; ASSERT (ODD (value)); ASSERT (~ODD (value + 1));
		value := -5; ASSERT (ODD (value)); ASSERT (~ODD (value + 1));
	END Test.

positive: long on short integer

	MODULE Test;
	VAR value: SHORTINT;
	BEGIN value := 11H; ASSERT (LONG (value) = 11H); ASSERT (LONG (value) = LONG (11H));
	END Test.

positive: character value of short integer

	MODULE Test;
	VAR value: SHORTINT; c: CHAR;
	BEGIN
		value := ORD ('0'); ASSERT (CHR (value) = '0');
		value := ORD ('9'); ASSERT (CHR (value) = '9');
		value := ORD ('a'); ASSERT (CHR (value) = 'a');
		value := ORD ('z'); ASSERT (CHR (value) = 'z');
		value := ORD ('A'); ASSERT (CHR (value) = 'A');
		value := ORD ('Z'); ASSERT (CHR (value) = 'Z');
	END Test.

positive: relational operations on integers

	MODULE Test;
	VAR value: INTEGER;
	BEGIN
		value := 5;
		ASSERT (value = 5); ASSERT (~(value = 6)); ASSERT (value = value);
		ASSERT (value # 6); ASSERT (~(value # 5)); ASSERT (~(value # value));
		ASSERT (value < 6); ASSERT (~(value < 4)); ASSERT (~(value < value));
		ASSERT (value <= 6); ASSERT (~(value <= 4)); ASSERT (value <= value);
		ASSERT (value > 4); ASSERT (~(value > 6)); ASSERT (~(value > value));
		ASSERT (value >= 4); ASSERT (~(value >= 6)); ASSERT (value >= value);
	END Test.

positive: negation on integers

	MODULE Test;
	VAR value: INTEGER;
	BEGIN value := 5; ASSERT (-value = -5); ASSERT (-(-value) = 5); ASSERT (-(-value) = value)
	END Test.

positive: integer as set element

	MODULE Test;
	VAR element: INTEGER; set: SET;
	BEGIN
		element := MIN (SET); set := {element}; ASSERT (element IN set); ASSERT (set - {element} = {});
		element := MAX (SET); set := {element}; ASSERT (element IN set); ASSERT (set - {element} = {});
	END Test.

negative: integer as too small set element

	MODULE Test;
	VAR element: INTEGER; set: SET;
	BEGIN element := MIN (SET) - 1; set := {element};
	END Test.

negative: integer as too large set element

	MODULE Test;
	VAR element: INTEGER; set: SET;
	BEGIN element := MAX (SET) + 1; set := {element};
	END Test.

positive: absolute value of integer

	MODULE Test;
	VAR value: INTEGER;
	BEGIN
		value := 5; ASSERT (ABS (value) = 5); ASSERT (ABS (-value) = 5); ASSERT (ABS (value) = value); ASSERT (ABS (-value) = value);
		value := -5; ASSERT (ABS (value) = 5); ASSERT (ABS (-value) = 5); ASSERT (ABS (value) = -value); ASSERT (ABS (-value) = -value);
	END Test.

positive: odd test on integer

	MODULE Test;
	VAR value: INTEGER;
	BEGIN
		value := 0; ASSERT (~ODD (value)); ASSERT (ODD (value + 1));
		value := 5; ASSERT (ODD (value)); ASSERT (~ODD (value + 1));
		value := -5; ASSERT (ODD (value)); ASSERT (~ODD (value + 1));
	END Test.

positive: short on integer

	MODULE Test;
	VAR value: INTEGER;
	BEGIN value := 1122H; ASSERT (SHORT (value) = 22H); ASSERT (SHORT (value) = SHORT (1122H));
	END Test.

positive: long on integer

	MODULE Test;
	VAR value: INTEGER;
	BEGIN value := 1122H; ASSERT (LONG (value) = 1122H); ASSERT (LONG (value) = LONG (1122H));
	END Test.

positive: character value of integer

	MODULE Test;
	VAR value: INTEGER; c: CHAR;
	BEGIN
		value := ORD ('0'); ASSERT (CHR (value) = '0');
		value := ORD ('9'); ASSERT (CHR (value) = '9');
		value := ORD ('a'); ASSERT (CHR (value) = 'a');
		value := ORD ('z'); ASSERT (CHR (value) = 'z');
		value := ORD ('A'); ASSERT (CHR (value) = 'A');
		value := ORD ('Z'); ASSERT (CHR (value) = 'Z');
	END Test.

positive: relational operations on long integers

	MODULE Test;
	VAR value: LONGINT;
	BEGIN
		value := 5;
		ASSERT (value = 5); ASSERT (~(value = 6)); ASSERT (value = value);
		ASSERT (value # 6); ASSERT (~(value # 5)); ASSERT (~(value # value));
		ASSERT (value < 6); ASSERT (~(value < 4)); ASSERT (~(value < value));
		ASSERT (value <= 6); ASSERT (~(value <= 4)); ASSERT (value <= value);
		ASSERT (value > 4); ASSERT (~(value > 6)); ASSERT (~(value > value));
		ASSERT (value >= 4); ASSERT (~(value >= 6)); ASSERT (value >= value);
	END Test.

positive: negation on long integers

	MODULE Test;
	VAR value: LONGINT;
	BEGIN value := 5; ASSERT (-value = -5); ASSERT (-(-value) = 5); ASSERT (-(-value) = value)
	END Test.

positive: long integer as set element

	MODULE Test;
	VAR element: LONGINT; set: SET;
	BEGIN
		element := MIN (SET); set := {element}; ASSERT (element IN set); ASSERT (set - {element} = {});
		element := MAX (SET); set := {element}; ASSERT (element IN set); ASSERT (set - {element} = {});
	END Test.

negative: long integer as too small set element

	MODULE Test;
	VAR element: LONGINT; set: SET;
	BEGIN element := MIN (SET) - 1; set := {element};
	END Test.

negative: long integer as too large set element

	MODULE Test;
	VAR element: LONGINT; set: SET;
	BEGIN element := MAX (SET) + 1; set := {element};
	END Test.

positive: absolute value of long integer

	MODULE Test;
	VAR value: LONGINT;
	BEGIN
		value := 5; ASSERT (ABS (value) = 5); ASSERT (ABS (-value) = 5); ASSERT (ABS (value) = value); ASSERT (ABS (-value) = value);
		value := -5; ASSERT (ABS (value) = 5); ASSERT (ABS (-value) = 5); ASSERT (ABS (value) = -value); ASSERT (ABS (-value) = -value);
	END Test.

positive: odd test on long integer

	MODULE Test;
	VAR value: LONGINT;
	BEGIN
		value := 0; ASSERT (~ODD (value)); ASSERT (ODD (value + 1));
		value := 5; ASSERT (ODD (value)); ASSERT (~ODD (value + 1));
		value := -5; ASSERT (ODD (value)); ASSERT (~ODD (value + 1));
	END Test.

positive: short on long integer

	MODULE Test;
	VAR value: LONGINT;
	BEGIN value := 11223344H; ASSERT (SHORT (value) = 3344H); ASSERT (SHORT (value) = SHORT (11223344H));
	END Test.

positive: long on long integer

	MODULE Test;
	VAR value: LONGINT;
	BEGIN value := 11223344H; ASSERT (LONG (value) = 11223344H); ASSERT (LONG (value) = LONG (11223344H));
	END Test.

positive: character value of long integer

	MODULE Test;
	VAR value: LONGINT; c: CHAR;
	BEGIN
		value := ORD ('0'); ASSERT (CHR (value) = '0');
		value := ORD ('9'); ASSERT (CHR (value) = '9');
		value := ORD ('a'); ASSERT (CHR (value) = 'a');
		value := ORD ('z'); ASSERT (CHR (value) = 'z');
		value := ORD ('A'); ASSERT (CHR (value) = 'A');
		value := ORD ('Z'); ASSERT (CHR (value) = 'Z');
	END Test.

positive: relational operations on huge integers

	MODULE Test;
	VAR value: HUGEINT;
	BEGIN
		value := 5;
		ASSERT (value = 5); ASSERT (~(value = 6)); ASSERT (value = value);
		ASSERT (value # 6); ASSERT (~(value # 5)); ASSERT (~(value # value));
		ASSERT (value < 6); ASSERT (~(value < 4)); ASSERT (~(value < value));
		ASSERT (value <= 6); ASSERT (~(value <= 4)); ASSERT (value <= value);
		ASSERT (value > 4); ASSERT (~(value > 6)); ASSERT (~(value > value));
		ASSERT (value >= 4); ASSERT (~(value >= 6)); ASSERT (value >= value);
	END Test.

positive: negation on huge integers

	MODULE Test;
	VAR value: HUGEINT;
	BEGIN value := 5; ASSERT (-value = -5); ASSERT (-(-value) = 5); ASSERT (-(-value) = value)
	END Test.

positive: huge integer as set element

	MODULE Test;
	VAR element: HUGEINT; set: SET;
	BEGIN
		element := MIN (SET); set := {element}; ASSERT (element IN set); ASSERT (set - {element} = {});
		element := MAX (SET); set := {element}; ASSERT (element IN set); ASSERT (set - {element} = {});
	END Test.

negative: huge integer as too small set element

	MODULE Test;
	VAR element: HUGEINT; set: SET;
	BEGIN element := MIN (SET) - 1; set := {element};
	END Test.

negative: huge integer as too large set element

	MODULE Test;
	VAR element: HUGEINT; set: SET;
	BEGIN element := MAX (SET) + 1; set := {element};
	END Test.

positive: absolute value of huge integer

	MODULE Test;
	VAR value: HUGEINT;
	BEGIN
		value := 5; ASSERT (ABS (value) = 5); ASSERT (ABS (-value) = 5); ASSERT (ABS (value) = value); ASSERT (ABS (-value) = value);
		value := -5; ASSERT (ABS (value) = 5); ASSERT (ABS (-value) = 5); ASSERT (ABS (value) = -value); ASSERT (ABS (-value) = -value);
	END Test.

positive: odd test on huge integer

	MODULE Test;
	VAR value: HUGEINT;
	BEGIN
		value := 0; ASSERT (~ODD (value)); ASSERT (ODD (value + 1));
		value := 5; ASSERT (ODD (value)); ASSERT (~ODD (value + 1));
		value := -5; ASSERT (ODD (value)); ASSERT (~ODD (value + 1));
	END Test.

positive: short on huge integer

	MODULE Test;
	VAR value: HUGEINT;
	BEGIN value := 1122334455667788H; ASSERT (SHORT (value) = 55667788H); ASSERT (SHORT (value) = SHORT (1122334455667788H));
	END Test.

positive: character value of huge integer

	MODULE Test;
	VAR value: HUGEINT; c: CHAR;
	BEGIN
		value := ORD ('0'); ASSERT (CHR (value) = '0');
		value := ORD ('9'); ASSERT (CHR (value) = '9');
		value := ORD ('a'); ASSERT (CHR (value) = 'a');
		value := ORD ('z'); ASSERT (CHR (value) = 'z');
		value := ORD ('A'); ASSERT (CHR (value) = 'A');
		value := ORD ('Z'); ASSERT (CHR (value) = 'Z');
	END Test.

positive: relational operations on reals

	MODULE Test;
	VAR value: REAL;
	BEGIN
		value := 5;
		ASSERT (value = 5); ASSERT (~(value = 6)); ASSERT (value = value);
		ASSERT (value # 6); ASSERT (~(value # 5)); ASSERT (~(value # value));
		ASSERT (value < 6); ASSERT (~(value < 4)); ASSERT (~(value < value));
		ASSERT (value <= 6); ASSERT (~(value <= 4)); ASSERT (value <= value);
		ASSERT (value > 4); ASSERT (~(value > 6)); ASSERT (~(value > value));
		ASSERT (value >= 4); ASSERT (~(value >= 6)); ASSERT (value >= value);
	END Test.

positive: negation on reals

	MODULE Test;
	VAR value: REAL;
	BEGIN value := 5; ASSERT (-value = -5); ASSERT (-(-value) = 5); ASSERT (-(-value) = value)
	END Test.

positive: absolute value of real

	MODULE Test;
	VAR value: REAL;
	BEGIN
		value := 5; ASSERT (ABS (value) = 5); ASSERT (ABS (-value) = 5); ASSERT (ABS (value) = value); ASSERT (ABS (-value) = value);
		value := -5; ASSERT (ABS (value) = 5); ASSERT (ABS (-value) = 5); ASSERT (ABS (value) = -value); ASSERT (ABS (-value) = -value);
	END Test.

positive: relational operations on long reals

	MODULE Test;
	VAR value: LONGREAL;
	BEGIN
		value := 5;
		ASSERT (value = 5); ASSERT (~(value = 6)); ASSERT (value = value);
		ASSERT (value # 6); ASSERT (~(value # 5)); ASSERT (~(value # value));
		ASSERT (value < 6); ASSERT (~(value < 4)); ASSERT (~(value < value));
		ASSERT (value <= 6); ASSERT (~(value <= 4)); ASSERT (value <= value);
		ASSERT (value > 4); ASSERT (~(value > 6)); ASSERT (~(value > value));
		ASSERT (value >= 4); ASSERT (~(value >= 6)); ASSERT (value >= value);
	END Test.

positive: negation on long reals

	MODULE Test;
	VAR value: LONGREAL;
	BEGIN value := 5; ASSERT (-value = -5); ASSERT (-(-value) = 5); ASSERT (-(-value) = value)
	END Test.

positive: absolute value of long real

	MODULE Test;
	VAR value: LONGREAL;
	BEGIN
		value := 5; ASSERT (ABS (value) = 5); ASSERT (ABS (-value) = 5); ASSERT (ABS (value) = value); ASSERT (ABS (-value) = value);
		value := -5; ASSERT (ABS (value) = 5); ASSERT (ABS (-value) = 5); ASSERT (ABS (value) = -value); ASSERT (ABS (-value) = -value);
	END Test.

positive: relational operations on sets

	MODULE Test;
	VAR value: SET;
	BEGIN
		value := {1, 2};
		ASSERT (value = {1, 2}); ASSERT (~(value = {2})); ASSERT (value = value);
		ASSERT (value # {2}); ASSERT (~(value # {1, 2})); ASSERT (~(value # value));
		ASSERT (value < {1, 2, 3}); ASSERT (~(value < {2})); ASSERT (~(value < value));
		ASSERT (value <= {1, 2, 3}); ASSERT (~(value <= {2})); ASSERT (value <= value);
		ASSERT (value > {2}); ASSERT (~(value > {1, 2, 3})); ASSERT (~(value > value));
		ASSERT (value >= {2}); ASSERT (~(value >= {1, 2, 3})); ASSERT (value >= value);
	END Test.

positive: negation on sets

	MODULE Test;
	VAR value: SET;
	BEGIN value := {1, 2}; ASSERT (-value = {0, 3 .. MAX (SET)}); ASSERT (-(-value) = {1, 2}); ASSERT (-(-value) = value)
	END Test.

positive: relational operations on character arrays

	MODULE Test;
	VAR value: ARRAY 10 OF CHAR;
	BEGIN
		value := "text";
		ASSERT (value = "text"); ASSERT (~(value = "abc")); ASSERT (value = value);
		ASSERT (value # "abc"); ASSERT (~(value # "text")); ASSERT (~(value # value));
		ASSERT (value < "xyz"); ASSERT (~(value < "abc")); ASSERT (~(value < value));
		ASSERT (value <= "xyz"); ASSERT (~(value <= "abc")); ASSERT (value <= value);
		ASSERT (value > "abc"); ASSERT (~(value > "xyz")); ASSERT (~(value > value));
		ASSERT (value >= "abc"); ASSERT (~(value >= "xyz")); ASSERT (value >= value);
	END Test.


# programs

positive: Gaussian natural sum using arrays

	MODULE Test;
	CONST Count = 10000;
	VAR i, sum: LONGINT; a: ARRAY Count OF LONGINT;
	BEGIN
		i := 0;
		WHILE i < Count DO
			a[i] := i; INC (i);
		END;
		i := 0; sum := 0;
		WHILE i < Count DO
			INC (sum, a[i]); INC (i);
		END;
		ASSERT (sum = Count * (Count-1) DIV 2);
	END Test.
