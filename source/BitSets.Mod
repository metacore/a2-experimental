MODULE BitSets;	(** AUTHOR "negelef"; PURPOSE "generic bit container"; *)

CONST Elements = MAX (SET) - MIN (SET) + 1;

TYPE Data = POINTER TO ARRAY OF SET;

TYPE BitSet* = OBJECT
	VAR size: LONGINT;
	VAR data: Data;

	PROCEDURE & InitBitSet* (size: LONGINT);
	BEGIN SELF.size := size; Resize (size);
	END InitBitSet;

	PROCEDURE Resize* (size: LONGINT);
	VAR newData: Data; i: LONGINT;
	BEGIN
		ASSERT (size >= 0);
		SELF.size := size;
		size := MAX (size - 1, 0) DIV Elements + 1;
		IF data # NIL THEN
			IF size <= LEN (data) THEN RETURN; END;
			size := MAX (size, LEN (data) * 2);
		END;
		NEW (newData, size);
		IF data # NIL THEN
			FOR i := 0 TO LEN (data) - 1 DO newData[i] := data[i]; END;
		END;
		data := newData;
	END Resize;

	PROCEDURE GetSize* (): LONGINT;
	BEGIN RETURN size;
	END GetSize;

	PROCEDURE SetBit* (pos: LONGINT; value: BOOLEAN);
	BEGIN
		ASSERT (pos >= 0); ASSERT (pos < size);
		IF value THEN
			INCL (data[pos DIV Elements], pos MOD Elements);
		ELSE
			EXCL (data[pos DIV Elements], pos MOD Elements);
		END;
	END SetBit;

	PROCEDURE GetBit* (pos: LONGINT): BOOLEAN;
	BEGIN
		ASSERT (pos >= 0); ASSERT (pos < size);
		RETURN pos MOD Elements IN data[pos DIV Elements];
	END GetBit;

	PROCEDURE SetBits* (startPos, bits, value: LONGINT);
	BEGIN
		ASSERT (startPos >= 0); ASSERT (startPos+bits <= size);
		WHILE bits > 0 DO
			SetBit (startPos, ODD (value)); value := value DIV 2;
			INC(startPos); DEC(bits)
		END;
		WHILE bits < 0 DO
			SetBit (startPos, ODD (value)); value := value DIV 2;
			DEC(startPos); INC(bits)
		END;
	END SetBits;

	PROCEDURE GetBits* (startPos, bits: LONGINT): LONGINT;
	VAR value: LONGINT;
	BEGIN
		ASSERT (startPos >= 0); ASSERT (startPos+bits <= size);
		INC (startPos, bits); value := 0;
		WHILE bits > 0 DO
			value := value*2; DEC (startPos); DEC (bits);
			IF GetBit (startPos) THEN INC (value) END;
		END;
		WHILE bits < 0 DO
			value := value*2; INC (startPos); INC (bits);
			IF GetBit (startPos) THEN INC (value) END;
		END;
		RETURN value;
	END GetBits;

END BitSet;

PROCEDURE CopyBits* (source: BitSet; sourcePos: LONGINT; dest: BitSet; destPos, count: LONGINT);
BEGIN
	ASSERT (count >= 0);
	WHILE count # 0 DO
		dest.SetBit (destPos, source.GetBit (sourcePos));
		INC (sourcePos); INC (destPos); DEC (count);
	END;
END CopyBits;

END BitSets.

