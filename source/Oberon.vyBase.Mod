(** This file has been generated by SpotPP 0.2d2 at  26.07.1999 13:45:30
from   vy/src/Mpp/vyBase.Host.Mpp - Last modified at  26.07.1999 13:45:30
using flags: Base S3 S3R203
Do not change this file. Apply changes to the master file only.  *)

MODULE vyBase IN Oberon;      (*=    gs *)
(* Copyright notice:

This file is part of Voyager
Copyright (C) 1993-2002 Project Voyager, StatLab Heidelberg ; (C) 1993-2002 G. Sawitzki et al.

This library is free software; you can redistribute it and/or
modify it under the terms of the GNU Lesser General Public
License as published by the Free Software Foundation; either
version 2.1 of the License, or (at your option) any later version.

This library is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public
License along with this library; if not, write to the Free Software
Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

Copy of the GNU Lesser General Public License can be found in the file COPYING.TXT
Report any problems as soon as possible to voyager@statlab.uni-heidelberg.de
*)


(* changed ad hoc. Mpp needs adjustment  gs 17.4.00 *)
(* jb 2.7.01 - handle Objects.FindMsg now *)
(* jb 18.8.01 - SubscrBroadcastMsg *)

(****** Basic object management for Voyager *)

(*= The basic system has to guarantee overall stability and consistency of the Voyager system. It has three aspects: general object administration, user access, and storage management. Ideally these aspects are aligned and realized in one common implementation.
However a user cannot be obliged to follow the strategies which are optimal for storage, and storage may have other strategies than those appropriate for (long term) object management. As a consequence, object management, name space management, and storage management have been implemented as separate modules.
This module comprises object management. It is the common core module for the Voyager system. It defines interfaces for name and storage management. The implementation for name space and storage management may be exchanged, but it is assumed that these components are always instantiated.

To allow caching, abstract data types for name and storage are already included in this module.

Rules for this module:
Do not make any assumption about specific storage types or name space organization.
NO visible input/output in this module, except for debugging !!
NO user commands in this module.
Test commands:
VoyagerBase.Dump
VoyagerBase.Test

A number of compromises have been made in this module:

To allow caching, abstract data types for name and storage are already included in this module.
To avoid type casts at run time, some record fields are introduced here although the semantics will be defined only by extensions.
For efficiency of this core module, various implementations are rolled out here even if they represent general methods.
To allow a portable version, this module deliberately does not make use of facilities which may be available in one Oberon implementation or the other. Note that it is possible to replace this Voyager base by a system specific variant.
*)
IMPORT SYSTEM, Oberon, Texts, Files, vyLinks, vyOOPT := OPT,  Objects, Display,
	Attributes, Links,
	Display3, Gadgets, Fonts, BasicGadgets, vyHost, (* for CallWStringX*)vyHostTexts, Strings, vyHostStrings;

	(***** Iddentification and Version Maintenance *)
CONST
	(* may be maintained or changed by tools.  *)
	idversion* =

	"vy0.0a5";       	(* Used as magic token for Voyager files. Must be 7 chars. *)

	idname* = "VoyagerBase";
	cprofileversion* = 000001X;       	(* version and release of profile record. 00000X is reserved for extensions *)
	minVersion = 0;      maxVersion = 0;      (* file storage formats *)

	(*= These declarations are repeated in Host and Base to reduce module interdependence *)
	vy* = "vy";      	(* prefix for Voyager commands *)

	(***** Portability and Environment Specific Definitions *)
CONST
	(**** System Specific Constants: S3 Version **)
	charset* = "Oberon";
	TextElemCode* = 01CX;      	(*=  substitution character if non-character elements are represented as char*)
	precc* = 100;       	 (*= 100 <= trap < 110 : pre-condition	(/F: 20-59) *)
	postcc* = 120;       	(*= 120 <= trap < 130 : post-condition 	(/F:60-99)*)
	notyetcc* = 99;      	(*= HALT (for not yet implemeted) *)
	fatalcc* = 98;      	(*= HALT (fatal error condition) *)

TYPE
	(*** Numeric Types *)
	Index* = LONGINT;      	(*= default type for counts, indices of arrays, and related purposes *)
	Real* = LONGREAL;      	(*= default type for numerics and 2d/3d graphics *)

	(*** Access Types *)
	(*= -- must match declaration in vyHost.
	These types are introduced to avoid a design problem in BlackBox. BlackBox uses Oberon names, but with a differing semantics. *)
	Text* = Texts.Text;      	(*= the text data type *)
	(*! get better names *)
	TextElemBaseType* = Objects.Object;      	(*= base type for non-character elements supported by text system *)
	TextElemType* = Gadgets.FrameDesc;      	(*= type for non-character elements in text used by Voyager.
	Possibly an extension of TextElemBaseType*)
	TextsWriter* = Texts.Writer;
	TextsReader* = Texts.Reader;
	TextsScanner* = Texts.Scanner;

	FilesReader* = Files.Rider;
	FilesWriter* = Files.Rider;

	(***** Oberon Abstractions *)
CONST
	(** Mouse keys **)
	rightKey* = 0;
	middleKey* = 1;
	leftKey* = 2;

	cnonumber* = 1;      (* nan code for no number on input *)

	(***** Oberon Data Abstractions *)
CONST
	(**** constants from OPT *)
	(*! move from compilers based type identification to OPT based identification. *)
	(* object modes *)
	Var* = 1;        VarPar* = 2;        Con* = 3;        Fld* = 4;        Typ* = 5;        LProc* = 6;        XProc* = 7;
	SProc* = 8;        CProc* = 9;        Mod* = 11;        Head* = 12;        TProc* = 13;        Alias* = 14;

	(**** Structure Forms *)
	cUndef* = 0;        cByte* = 1;        cBool* = 2;        cChar* = 3;        cSInt* = 4;        cInt* = 5;        cLInt* = 6;
	cReal* = 7;        cLReal* = 8;        cSet* = 9;        cString* = 10;        cNilTyp* = 11;        cNoTyp* = 12;
	cPointer* = 13;        cProcTyp* = 14;        cComp* = 15;

	(* composite structure forms *)
	Basic* = 1;        Array* = 2;        DynArr* = 3;        Record* = 4;

TYPE
	(** Structure data types --  *)
	OPTConst* = vyOOPT.Const;
	OPTModule* = vyOOPT.Module;
	OPTNode* = vyOOPT.Node;
	OPTObject* = vyOOPT.Object;
	OPTStruct* = vyOOPT.Struct;

VAR
	(*= basic types, copied from OPT. A generic module will not need to access OPT, but can use these copies *)
	undftyp* , bytetyp* , booltyp* , chartyp* , sinttyp* , inttyp* , linttyp* ,
	realtyp* , lrltyp* , settyp* , stringtyp* , niltyp* , notyp* ,  ptrtyp* : OPTStruct;
	dynboolarray* , dynintarray* , dynlintarray* , dynrealarray* , dynlrlarray* : OPTStruct;

	(***** Voyager Abstractions *)
CONST
	(**** Constants Used as Status Indicators *)
	cNotYetImplemented* = 0;     (*= operation not defined or implemented for this type *)
	cBadType* = 1;      	(*= operation not defined or implemented for this type *)
	cBadLen* = 2;      	(*= length not matching for this type *)
	cOK* = {};

	(**** State  Dispositions *)
	cpurgable = 1;

TYPE
	(** S3 glue **)

	TickMsg* = RECORD (Display.FrameMsg) END;     	(*! move to Action type *)

	(*** Text data types *)
	(** S3 glue **)


	(**** Messages*)
	(*= Messages are used as common base to allow the same slota to hold messages or objects, as appropriate *)
	(*=
	S3: Using a common base type for messages and objects was introduced for pragmatic reasons. We wanted to allow
	extensive caching, while avoiding aboundant type checks or type castings. So we allowed messages in the same slots as objects,
	with the implicit rule that messages would only carry relative references. If an absolute reference was contained, it would be
	ignored upon any load/store action.
	It is easy to separate Voyager messages from Voyager items or objects, although it would need to introduce a pile of type checks,
	*)
	(*tMessagePtr = POINTER TO tMessage;*)
	(*	tMessage * = RECORD (Objects.ObjMsg) END;  (*? could be Objects.ObjMsg for S3, but compiler crashes in vyPorts *)*)
	(*tMessage * = Objects.ObjMsg(*Objects.ObjMsg*);*)
	RecursiveMsg = RECORD (Objects.ObjMsg) END;

	(**** Basic types *)
	(*= The basic type hierachy is
	Objects <- Data
	Objects and extensions thereof may have names. *)

	(**Names and Keys *)
	(*= Names. Objects and extensions thereof may have names. Names are used for command level identification of objects, and for feedback.
	No assumption about the name space is made at this level. In particular, Names need not be unique, if a user controlled arbitration is supported. Names may be qualified by preceding names. A reference to the Name is included in the objed descritpon as a mere convenience to avoid an extra search during Object->Name translation. The implementation of the name space is in a separate module.
	*)
	tName* = POINTER TO tNameDesc;
	(*= Voyager does not enforce consistency. But to allow for some data security, a key system is supported. Key management is implemented in a separate module. *)
	tKey* = Objects.Object;
	tKeyDesc* = Objects.ObjDesc;

	(** Actions*)
	(*= Basic Operations. Used for deferred iteratiors or times tasks.
	Actions are alway chained to required pre-actions, if necessary.
	Action generally use a private protocol to coordinate operations with pre-actions.*)
	tAction* = POINTER TO tActionDesc;
	tActionProc* = PROCEDURE (action: tAction;     VAR failed: BOOLEAN);
	tActionDesc* = RECORD
		(Oberon.TaskDesc)
		Do*: tActionProc;
		failed-: BOOLEAN;              (*= If a pre-action failed, abort action chain and bail out.
		Use Output for explicit status *)
		todoCount-: LONGINT;
		preAction-: tAction;     		(* NIL, or an action which must be done, before this one can be invoked *)
		TickDelta: LONGINT;     	(* NIL, or an action which must be done, before this one can be invoked *)
		termination: tAction;

		(*= These fields are unused. They are recommended fields for application use *)
		Input*, Output*: vyLinks.Link;
		ControlPar*: vyLinks.Link;     	(*= to be used for variables that are persistent during invocations, e.g. control parameters *)
		(*= These fields are controlles by vyBase.  *)
	END;

	(** Voyager Objects*)
	(*= Any entity needing consistency management or identification should be a Voyager object.
	Objects may be: Vars, sets of cases, transformations, modules, formats ... The object information should not be
	duplicated. Multiple access can be achieved by duplicating the reference to an object. *)
	(*=
	S3: we use a LONGINT identification. Typically, about 2000 objects are built up during one analysis session.
	So it is not a problem to renumber/rescale on load/store operations.
	*)

TYPE
	tCache* = POINTER TO tCacheDesc;
	tCacheDesc* = RECORD
		nextcache* : tCache
	END;

	Object* = POINTER TO ObjDesc;
	ObjDesc* =  RECORD
		(Gadgets.ObjDesc)
		(*    *)	ObjectId-: LONGINT;
		(*01*)	Name-	: tName;      			(* a storage id. Objects should be identified as Object *)
		(*    *)	createdT-, createdD-: LONGINT;
		(*D: 7bit yr, 4bit mon 5bit day; T: 5bit hr, 6bit min 6bit s *)
		(*    *)	modifiedT-, modifiedD-: LONGINT;
		(*02*)	key: tKey;
		(*03*)	struct- : OPTStruct;      	(* structure description. This need not correspond to physical storage *)
		(*    *)	disposition- : SET;      			(* object disposition flags *)
		(*! implement purge: remove all objects with purgeable set *)
		(*04*)	cache* : tCache;      	(* statistics cache. Usually not stored *)
		(* queue for object book-keeping *)
		(*05*)	users*,
		(*= Forward list for internal messages, in particular update messages.
		Not stored. Entries must be objects.*)
		(*06*)	sources*: vyLinks.Link
		(*= Reverse list for internal messages, in particular update messages.
		Usually an inverse list to "users". Entries must be objects.
		Sources are comparable to Models in a Models-Views-Controllers architecture. *)
	END;

	(* base type for name and object management *)

	(*= messages for all objects. Messages are used to signal events, or to communicate statistics. In particular, some statistiscs may be cached in a message. *)

	(** Messages *)
	(*? use flag an Objects.UpdateMsg? *)
	UpdateMessage* = RECORD (* A precondition has become invalid. Maybe an update is needed *)
		(Objects.ObjMsg)
	END;
	SubscrBroadcastMsg* = RECORD (Objects.ObjMsg) END;   	(* jb 18.8.01 *)
	NewSimMsg* = RECORD (SubscrBroadcastMsg) END;   	(*? should that be defined here? - jb 18.8.01 *)

	(*	FileMsg* = Objects.FileMsg;
	AttrMsg* = Objects.AttrMsg;
	DisplayMsg* = Display.DisplayMsg;
	CopyMsg* = Objects.CopyMsg;*)

	ReadMessage* = RECORD (* Read an object from input *)
		(Objects.ObjMsg)
	END;
	DumpMessage* = RECORD (* Dump an object to output *)
		(Objects.ObjMsg)
	END;

	(** Abstract data types *)
	(*= Data are objects which allow operations, such as arithmetic or logical operations. These operations should be supported by the handler. The handler should operate quietly, leaving error reports to explicit inspections. *)
	tStatus* = SET;
	(*	tFormat= SET;
	tType=INTEGER;*)
	tData* = POINTER TO tDataDesc;
	tDataDesc* = RECORD (ObjDesc)
		status* : tStatus;
		type* : OPTStruct;       (*!  access type -- defunct*)
		storagetype* : OPTStruct;    (*!  access type -- support is needed*)
		cacheHighlight*: Object
	END;
	(*= Operators in procedural form. By convention, results are the first operator.
	Any extension to tData should implement an adapted version of iterators for these operators.
	Templates are given below. *)
	tOp1* = PROCEDURE (VAR arg: tData);
	(*=     Op1(arg). Example: arg:=-arg *)
	tOp2* = PROCEDURE (VAR arg1, arg2: tData);
	(*=     Op2(arg1,arg2) Example: arg1:=-arg2;	arg1:=arg1*arg2 *)
	tOp3* = PROCEDURE (VAR arg1, arg2, arg3: tData);
	(*=     Op2(arg1,arg2) Example: arg1:=arg2+arg3; 	arg1:=arg3[0]+arg2*arg3[1] *)

	(** Storage types and descriptors **)
	(*= A buffer contains a run of element, nominally of the same type. Storage formats may be private,
	eg. ARRAYS, FILES, run length encoded data etc.
	Each implementation however needs several access methods:
	Get and Set by element
	Optionally:
	Get and Set as array
	*)

	tBuf* = POINTER TO tBufDesc;
	tBufDesc* = RECORD
		str* : OPTStruct;
		len* : LONGINT;       (*= Nr of entries allocated to a chunk. aka  LEN. This is the buffer capacity. *)
		usedentries* : LONGINT;       (*= Nr of used entries in a chunk. >=0  *)
		aux* : tBuf;       (*= auxiliary pointer, to hold case nrs for indexed sort *)
		cache* : tCache;       (*= cached information, such as min, max *)
		next* : tBuf
	END;

	tSBLProc* = PROCEDURE (buf1, buf2: tBuf): BOOLEAN;     (* true, if buf1<= buf2 *)

	(*= The basic data elements are vectors.
	A vector may be used to hold higher dimensional data, either following Oberon
	conventions, or transposed, following FORTRAN conventions *)
	(*= tLayout will be changed to use OPTStruct. *)
	tLenArray* = POINTER TO tLenArrayDesc;
	tLenArrayDesc = ARRAY OF LONGINT;
	tLayout* = POINTER TO tLayoutDesc;
	tLayoutDesc* = RECORD
		(*! defunct. replace by type struct *)
		dim*: INTEGER;
		transposed*: BOOLEAN
	END;
	(* abstract layouts *)
	(*! defunct. replace by type struct *)
	tArray* = POINTER TO tArrayDesc;
	tArrayDesc* = RECORD (tLayoutDesc)
		(*! defunct. replace by type struct *)
		lens*: tLenArray
	END;

	(*= Storage format need not be homogeneous for vectors.
	storage need not be consecutive, i.e. a vector may be composed of various buffers, possibly making use of compression
	scemes or on the fly  data generation. *)
	tVector* = POINTER TO tVectorDesc;
	tVectorDesc* = RECORD (tDataDesc)
		Layout*: tLayout;      	(* NIL = vector *)
		nrData*: LONGINT;
		buf*: tBuf
	END;

	(*= Transformations. Transformations should be objects. Only in exceptional cases, temporary transformations
	should be implemented on item level. This definition is given here for reference only to fix naming conventions. *)
	(*? defunct??	LinkTransformation = POINTER TO LinkTransDesc;
	LinkTransDesc= RECORD
	(LinkDesc)	(* administrative links *)
	(* do: recommended name if a procedure record entry is used *)
	(* the following fields are caches only. use of handlers is recommended *)
	input:Link;	(* may be a queue *)
	output:Link;	(* may be a queue *)
	controlpars:Link;	(* may be used as parametrization *)
	END;

	(*= state information for persistent storage *)
	tProfile = RECORD
	magic: ARRAY 8 OF CHAR;
	profileversion: LONGINT;
	END; (* may be saved *)
	*)

	(*= Voyager threads. Objects are arranged in threads. Threads are special objects used for grouping. A typical arrangement may be data sets represented by threads, with variables in a data set represented by elementary Voyager objects. An object may belong to at most one thread.
	Threads are organizational units. If a group of iobjects is worth to be controlled by Voyager, it may be collected in a thread.

	Threads may be replaced by generic queues in next release!!!
	*)
	tThread = POINTER TO tThreadDesc;
	(*! Will be replaced by generic queues ?*)
	(*! Maybe these objects may vanish in a general queue *)
	(* Threads are queus and objects and have an identity. *)
	tThreadDesc = RECORD
		(ObjDesc)
		lastObject: vyLinks.Link	(* last object in thread *)
	END;


	(*? avoid generation of circular update message paths ! *)


	(*! Time stamps should be sticky, i.e. use oldest time unless change needed *)
	(* Oberon.Time gives a 1/300s timer. Guaranteed? Needed ? *)

	(** Transformations *)
	(*=This data type may be replaced by actions in a subsequent release.*)
	(*! replace by action *)
	tTransformation* = POINTER TO tTransDesc;
	tTransDesc* = RECORD
		(ObjDesc)	(* administrative links *)
		(* do: recommended name if a procedure record entry is used *)
		(* the following fields are caches only. use of handlers is recommended *)
		input-: vyLinks.Link;      	(* may be a queue *)
		output-: vyLinks.Link;      	(* may be a queue *)
		controlpars-: vyLinks.Link 	(* may be used as parameterization *)
	END;

	(**Names*)
	(*=Names are introduced as abstract objects to allow various name space implementations.*)
	tNameDesc* = Gadgets.ObjDesc;
	TickProc* = PROCEDURE;     	(*! move to Action type *)

	ProcQPtr = POINTER TO ProcQElem;      	(*! move to Action type *)
	ProcQElem = RECORD(*! move to Action type *)
		Proc: 	TickProc;
		TickDelta: 	LONGINT;      (* time delta, in ticks. 0: always *)
		NextTime: 	LONGINT;
		next: ProcQPtr
	END;

	(*** Displays & Visualization *)
	(*= General definitions only. Implementation should be postponed to a special module to allow for "faceless" systems, or systems with remote display servers. *)

	Frame* = POINTER TO FrameDesc;
	FrameObject = POINTER TO FrameObjDesc;
	(*= auxiliary data type to fake multiple inheritance *)
	FrameObjDesc = RECORD (ObjDesc)
		gadget: Frame	(*= back link. obj.gadget.vyobj= obj *)(*? not used ?*)(*? frame?*)
	END;
	FrameDesc* = RECORD (Gadgets.FrameDesc) (*? or use Gadgets.View ? *)
		(*		defunctx*, defuncty* : INTEGER;       (* cached absolute location, is updated by frame's handler. defunct. use messages *) *)
		borderW* : INTEGER;
		hotupdate* : BOOLEAN;

		vyobj: FrameObject;     (*= 	allow inheritance form Objjects.
		Used if Voyager object stamp is needed.
		This is an auxiliary object used for fake multiple inheritance only. *)
		vylinks*: vyLinks.Link;     (*= entry type may be restricted,
		eg. Frames only link to Pictures,  Pictures only link to Layers *)
	END;

	(*
	Picture*=POINTER TO PictureDesc;
	PictureDesc*=RECORD (Gadgets.FrameDesc)
	vyobj*:Object;
	layers*: vyLinks.Link; 	(* first layer is a dummy layer! keep separate from link: all entries here are layers *)
	END;

	Layer*=POINTER TO LayerDesc;
	LayerDesc*=RECORD (Objects.ObjDesc) (*= preferably a Voyager object *)
	END;
	*)
	(***** Variables *)

	(*** Global Variables *)
VAR
	hd: ARRAY 17 OF CHAR;
	Context-: 	tThread;      	(* start searches in this thread. Must not be NIL! *)
	currentThread-: 	tThread;      	(* add objects to this thread. Must not be NIL! *)
	lastThread-: 	tThread;      	(* add threads here. Must not be NIL!  *)
	Trash-: 	tThread;      	(* defunct objects - cleaned by GC *)
	objcount-: 	LONGINT;         (* for unique id *)
	objecthandle*: 	Objects.Handler;      	(* may be used if no handler is installed.
	Default:objecthandle := ObjectHandler;  *)
	framehandle*: Objects.Handler;   (* may be used if no handler is installed.
	Default: framehandle := FrameHandler; *)

	w* : 	TextsWriter;      	(*= a general writer. Output goes to Log *)
	werr* : 	TextsWriter;      (* =a writer for exception messages. Output goes to Log *)
	Log* : Text;      (*= a persistent text. May be mapped to Oberon.Log *)
	slow*: INTEGER;     	(*= slow motion factor. All deltas are multiplied by this factor *)
	lastmsg-: Objects.ObjMsg;
	ProcToCall: ProcQPtr;
	countTask: Oberon.Task;
	ticks-: LONGINT;

	(* global buffer used for PROCEDURE Show *)
	showParameter* : vyLinks.Link;
	parameterCount* : INTEGER;

	recurse: BOOLEAN;

	Register*: PROCEDURE (ob: Object);
	DeRegister*: PROCEDURE (ob: Object);

	(*** Utilities **)
PROCEDURE AppendToLog* (VAR w: TextsWriter);
BEGIN Texts.Append(Log, w.buf)
END AppendToLog;



(*** Base Procedures *)
PROCEDURE NextIdCount (): LONGINT;
BEGIN INC(objcount);       RETURN objcount
END NextIdCount;

(** General item related procedures *)
(*
PROCEDURE ForItemsDo* (start: Link;  proc: tProcedure);
BEGIN WHILE start # NIL DO proc(start);  start := start.next END
END ForItemsDo;
*)
PROCEDURE DoHandle* (o: vyLinks.Link;       VAR (*msg*)m: Objects.ObjMsg);        (*vs 0.1d0 gs *)
BEGIN IF o.obj.handle # NIL THEN o.obj.handle(o.obj, m) ELSIF
	o.obj IS Frame THEN framehandle(o.obj, m)  ELSE objecthandle(o.obj, m) END;
	(*! support default handler *)
END DoHandle;
(*
PROCEDURE ForItemsHandle* (start: Link;  VAR m: Objects.ObjMsg);
BEGIN WHILE start # NIL DO DoHandle(start, m);  start := start.next END
END ForItemsHandle;

(** General queue related procedures   *)

PROCEDURE ForItemsAndQueuesHandle* (queue: tQueue;  VAR m: Objects.ObjMsg);
(*= send message to all items in queue. If an item is of type tQueue, walk down queue starting
at this item*)
VAR start: Link;
BEGIN IF queue # NIL THEN start := queue.first;
WHILE start # NIL DO DoHandle(start, m);
IF start IS tQueue THEN ForItemsAndQueuesHandle(start(tQueue), m) END;
start := start.next END
END
END ForItemsAndQueuesHandle;
*)



(** Base object access *)

PROCEDURE DumpItem* (item: vyLinks.Link);
	(*VAR w:TextsWriter; *)
(* BEGIN *)
	(*! provide portable version of DumpItem - disabled for now *)
	(*	Texts.OpenWriter(w);
	IF item=NIL THEN Texts.WriteString(w," _ NIL _") ELSE
	Texts.WriteHex(w,SYSTEM.VAL(LONGINT,item));
	(*Texts.WriteString(w," [");
	Texts.WriteHex(w,SYSTEM.VAL(LONGINT,ob.handle));
	Texts.WriteString(w,"] ");
	*)
	Texts.WriteString(w," _>");
	Texts.WriteHex(w,SYSTEM.VAL(LONGINT,item.next));
	END;
	Texts.WriteLn(w);
	vyHost.AppendToLog(w); (* DumpItem *)
	*)
END DumpItem;
(** Action procedures*)


(** Object procedures*)

PROCEDURE Write* (VAR w: TextsWriter;      ob: Object);
	VAR s: ARRAY 64 OF CHAR;    link: vyLinks.Link;
BEGIN IF ob = NIL THEN Texts.WriteString(w, '<NIL>')
	ELSE
		Texts.Write(w, '[');       Texts.WriteHex(w, ob.ObjectId);      Texts.Write(w, ']');
		IF ob IS tThread THEN Texts.Write(w, '*') ELSE Texts.Write(w, ' ') END;
		Texts.WriteHex(w, vyHost.Addr(ob));   Texts.WriteString(w, 'H ');
		Texts.WriteDate(w, ob.createdT, ob.createdD);
		IF 	(ob.createdT # ob.modifiedT) OR	(ob.createdD # ob.modifiedD) THEN
			Texts.WriteDate(w, ob.modifiedT, ob.modifiedD)
		END;
		Attributes.GetString(ob, 'Gen', s);   Texts.Write(w, ' ');   Texts.WriteString(w, s);
		Texts.Write(w, ' ');    Attributes.GetString(ob, 'Name', s);   Texts.WriteString(w, s);   Texts.WriteLn(w);
		Texts.Write(w, 09X);   Texts.WriteString(w, 'users:');
		link := ob.users;    WHILE link # NIL DO
			IF  link.obj IS Object THEN
				Texts.Write(w, '[');       Texts.WriteHex(w, link.obj(Object).ObjectId);      Texts.Write(w, ']')
			END;
			Texts.WriteHex(w, vyHost.Addr(link.obj));   Texts.WriteString(w, 'H ');
			link := link.link
		END;   Texts.WriteLn(w);
		Texts.Write(w, 09X);   Texts.WriteString(w, 'sources:');

		link := ob.sources;    WHILE link # NIL DO
			IF  link.obj IS Object THEN
				Texts.Write(w, '[');       Texts.WriteHex(w, link.obj(Object).ObjectId);      Texts.Write(w, ']')
			END;
			Texts.WriteHex(w, vyHost.Addr(link.obj));   Texts.WriteString(w, 'H ');
			link := link.link
		END;   Texts.WriteLn(w)
	END
END Write;
PROCEDURE DebugDump* (VAR w: TextsWriter;      ob: Object);
BEGIN Write(w, ob);
	(*! add more debug info *)
END DebugDump;

PROCEDURE Purge* (ob: Object);        (*vs 0.1d1 *)
BEGIN	INCL(ob.disposition, cpurgable)	END Purge;

PROCEDURE Update* (ob: Objects.Object);        (*vs 0.1d1 *)
	VAR u: vyLinks.Link;       msg: UpdateMessage;     oo: Object;
BEGIN
	(* vyHostTexts.MsgSHex('vyBase.Updating',ADDRESSOF(ob^));*)
	IF (ob IS Frame) & (ob(Frame).vyobj # NIL) THEN oo := ob(Frame).vyobj
	ELSIF ob IS Object THEN oo := ob(Object)
	ELSE oo := NIL  END;

	IF oo # NIL THEN
		Oberon.GetClock(oo.modifiedT, oo.modifiedD);
		oo.cache := NIL;      	(* invalidate statistics *)
		u := oo.users;
		msg.dlink := oo;    (*msg.res:=-1;*)Objects.Stamp(msg);
		WHILE u # NIL DO
			DoHandle(u, msg);
			u := u.link
		END
	END;

	Gadgets.Update(ob)

END Update;

PROCEDURE ForUsersHandle* (ob: Object;      VAR msg: Objects.ObjMsg);
	VAR u: vyLinks.Link;
BEGIN
	u := ob.users;
	WHILE u # NIL DO
		DoHandle(u, msg);
		u := u.link
	END
END ForUsersHandle;

(** Key management **)
PROCEDURE GetKey* (ob: Object): tKey;
BEGIN RETURN ob.key
END GetKey;

PROCEDURE SetKey* (ob: Object;      key: tKey);
BEGIN
	ob.key := key
END SetKey;

(* Insert/Remove from queue *)
PROCEDURE register* (ob: Object);       (*vs 0.1d1 set id, create and update time stamp *)
	(*! decouple update *)
	VAR l: vyLinks.Link;
BEGIN ASSERT(ob # NIL);
	(*vyHost.StackFrame('Register');*)
	ob.ObjectId := NextIdCount();
	ob.Name := NIL;
	ob.cache := NIL;
	Update(ob);
	ob.createdT := ob.modifiedT;
	ob.createdD := ob.modifiedD;
	NEW(l);     l.obj := ob;      l.link := currentThread.lastObject;     currentThread.lastObject := l
END register;

(* fof: need this procedure in ants *)
PROCEDURE GetLastInThread* (t: tThread): vyLinks.Link;
BEGIN
	RETURN t.lastObject
END GetLastInThread;


(*
PROCEDURE Move* (ob:Object; newThread:tThread); (*vs 0.1d1 move object  *)
VAR o:Object;
BEGIN ASSERT(ob#NIL); ASSERT(newThread#NIL);
IF newThread#ob.thread THEN
o:=ob.thread.lastObject;
IF o=ob THEN ob.thread.lastObject:=ob.link(Object)
ELSE
WHILE o.link#ob DO
ASSERT(o.link#NIL);
o:=o.link(Object);
END;
o.link:=ob.link;
END;
o.link:=newThread.lastObject;newThread.lastObject:=o;Update(newThread);
END;(*newThread#ob.thread *)
END Move;
*)
PROCEDURE deRegister* (ob: Object);       (*vs 0.1d0 remove  object *)
BEGIN ASSERT(ob # NIL);
	(*! Dummy *)
END deRegister;

PROCEDURE Name* (ob: Object;       VAR name: tName);       (*vs 0.1d1 set or get id *)
BEGIN ASSERT(ob # NIL);
	IF name = NIL THEN
		name := ob.Name
	ELSE
		ob.Name := name
	END
END Name;

PROCEDURE RegisterNamed* (ob: Object;        name: tName);
	(*vs 0.1d1 register and set id *)
BEGIN ASSERT(ob # NIL);   Register(ob);
	Name(ob, name)
END RegisterNamed;
(** User list **)

PROCEDURE EffObject (o: Objects.Object): Object;
BEGIN
	IF o = NIL THEN RETURN NIL
	ELSIF o IS Object THEN RETURN o(Object)
	ELSIF (o IS Frame)  THEN RETURN o(Frame).vyobj
		(*ELSIF (o IS Picture)  THEN RETURN o(Picture).vyobj*)
	ELSE RETURN NIL END
END EffObject;

(* --- Recursion checking --- *)

PROCEDURE RecursiveHandler (obj: Objects.Object;    VAR M: Objects.ObjMsg);
BEGIN (* IF ~(M IS Display3.UpdateMaskMsg) THEN *)recurse := TRUE   (*END;*)
END RecursiveHandler;

(** Check if a message loop would be created should newchild be inserted in the container parent. Sends a dummy message behind the scenes. *)
PROCEDURE Recursive* (parent, newchild: Objects.Object): BOOLEAN;
	VAR old: Objects.Handler;    M: RecursiveMsg;
BEGIN
	old := parent.handle;    M.dlink := NIL;
	parent.handle := RecursiveHandler;    recurse := FALSE;
	newchild.handle(newchild, M);
	parent.handle := old;
	RETURN recurse
END Recursive;

PROCEDURE Subscribe* (o: Objects.Object;     subscriber: Objects.Object);
	(*= subscribe as user of object o *)
	(*Template:
	vyBase.Subscribe ((*for messages from source*) o: Objects.Object;  (*to subscriber*) subscriber: Objects.Object)
	*)

	VAR s, n: vyLinks.Link;     oo, ss: Object;
BEGIN ASSERT(o # NIL, 100);      	ASSERT(subscriber # NIL, 101);
	oo := EffObject(o);
	IF oo = NIL THEN (* NOOP *)RETURN END;
	(* add to user queue of source *)
	NEW(s);      s.obj := subscriber;       s.link := NIL;       (*s.prev:=NIL;*)
	IF oo.users = NIL THEN oo.users := s
	ELSE
		s.link := oo.users;
		n := oo.users;
		WHILE n # NIL DO
			IF n.obj = subscriber THEN (* NOOP *)RETURN ELSE
				n := n.link
			END  (* no duplicates *)
		END;       (* WHILE *)
		oo.users := s
	END;

	ASSERT( ~Recursive(oo, subscriber), 102);    	(*! avoid circular references, eg. require newer subscribes to older *)

	(* add to own source queue*)
	ss := EffObject(subscriber);
	IF ss = NIL THEN RETURN END;
	(* add to user queue of source *)
	NEW(s);      s.obj := o;       s.link := NIL;       (*s.prev:=NIL;*)
	IF ss.sources = NIL THEN ss.sources := s
	ELSE
		s.link := ss.sources;
		n := ss.sources;
		WHILE n # NIL DO
			IF n.obj = o THEN RETURN ELSE
				n := n.link
			END  (* no duplicates *)
		END;       (* WHILE *)
		ss.sources := s
	END
END Subscribe;

PROCEDURE UnSubscribe* (o, subscriber: Objects.Object);
	(*= cancel subscription as user of object o *)
	VAR n, nprev: vyLinks.Link;    oo, ss: Object;
BEGIN
	oo := EffObject(o);   	IF oo = NIL THEN RETURN END;
	n := oo.users;      nprev := NIL;
	WHILE n # NIL DO
		IF n.obj = subscriber THEN
			(*IF n.link # NIL THEN n.link(ObjectRef).prev:= n.prev END;*)
			IF nprev # NIL THEN nprev.link := n.link ELSE oo.users := n.link END;
			RETURN
		ELSE
			nprev := n;    n := n.link
		END  (* n.obj = subscriber *)
	END;

	(* remove from own source queue *)
	ss := EffObject(subscriber);   	IF ss = NIL THEN RETURN END;
	n := ss.sources;      nprev := NIL;
	WHILE n # NIL DO
		IF n.obj = o THEN
			(*IF n.link # NIL THEN n.link(ObjectRef).prev:= n.prev END;*)
			IF nprev # NIL THEN nprev.link := n.link ELSE ss.sources := n.link END;
			RETURN
		ELSE
			nprev := n;   		n := n.link
		END  (* n.obj = o *)
	END
END UnSubscribe;

(** Misc **)
PROCEDURE StoreObject0* (ob: Object;        VAR M: Objects.FileMsg);
BEGIN	ASSERT(ob # NIL);        (*! dummy *)
	Files.WriteLInt(M.R, maxVersion);
	Files.WriteLInt(M.R, ob.ObjectId);
	Gadgets.WriteRef(M.R, ob.lib, ob.Name);
	(*IF ob.Name=NIL THEN  Files.Write(M.R,0X) ELSE Files.Write(M.R,01X);  ob.Name.handle(ob.Name,M) END;*)
	Files.WriteLInt(M.R, ob.createdT);       Files.WriteLInt(M.R, ob.createdD);
	Files.WriteLInt(M.R, ob.modifiedT);       Files.WriteLInt(M.R, ob.modifiedD);
	Gadgets.WriteRef(M.R, ob.lib, ob.key);
	Files.Write(M.R, 1X);      (* sync placeholder: struct *)
	Files.WriteSet(M.R, ob.disposition);
	Files.Write(M.R, 2X);      (* sync placeholder: cache *)
	(*
	Files.Write(M.R, 3X);  (* placeholder: users *)
	u := ob.users;   WHILE u # NIL DO
	Files.Write(M.R, 06X); Gadgets.WriteRef(M.R, ob.lib, u.obj);
	u := u.link
	END;
	Files.Write(M.R, 04X);
	*)
	(*?	vyLinks.StoreLinks(M.R, ob.lib, ob.users);*)
	vyLinks.StoreLinks(M.R, ob.lib, ob.sources);
	Files.WriteLInt(M.R, 05678H)  (* terminates *)
END StoreObject0;

PROCEDURE LoadObject0* (ob: Object;        VAR M: Objects.FileMsg);
	VAR version, uid: LONGINT;       ch: CHAR;       obsub: Objects.Object;    name: tName;    list: vyLinks.Link;
BEGIN	ASSERT(ob # NIL);        	(*! dummy *)
	Files.ReadLInt(M.R, version);
	ASSERT((version >= minVersion) &  (version <= maxVersion), precc);
	Files.ReadLInt(M.R, ob.ObjectId);
	Gadgets.ReadRef(M.R, ob.lib, obsub);
	IF (obsub # NIL) & (obsub IS tName) THEN
		IF (obsub.dlink # NIL) & (obsub.dlink IS tName) THEN
			name := obsub(tName).dlink(tName)
		ELSE
			name := obsub(tName);    (*Name(ob, name);*)
		END;

		RegisterNamed(ob, name);
		Links.SetLink(name, 'Object', ob)
	ELSE Register(ob)
	END;
	Files.ReadLInt(M.R, ob.createdT);       Files.ReadLInt(M.R, ob.createdD);
	Files.ReadLInt(M.R, ob.modifiedT);       Files.ReadLInt(M.R, ob.modifiedD);
	Gadgets.ReadRef(M.R, ob.lib, ob.key);
	Files.Read(M.R, ch);     (* placeholder: struct *)ASSERT(ch = 1X, precc + 1);
	Files.ReadSet(M.R, ob.disposition);
	Files.Read(M.R, ch);      (* placeholder: cache *)ASSERT(ch = 2X, precc + 2);
	(*	Files.Read(M.R, ch);  (* placeholder: users *)ASSERT(ch = 3X, precc + 3);
	Files.Read(M.R, ch);
	WHILE ch = 06X DO
	Gadgets.ReadRef(M.R, ob.lib, obsub) ;
	IF  (obsub # NIL) & (obsub IS Object) THEN Subscribe ((*for messages from source*) ob, obsub(Object)) END;
	Files.Read(M.R, ch)
	END;
	ASSERT(ch = 04X, precc + 4);*)
	(*?	vyLinks.LoadLinks(M.R, ob.lib, ob.users); *)
	vyLinks.LoadLinks(M.R, ob.lib, ob.sources);    (*! may need an explicit subscribe *)
	list := ob.sources;
	WHILE list # NIL DO		Subscribe ((*for messages from source*)list.obj, ob);    list := list.link END;
	Files.ReadLInt(M.R, uid);       ASSERT(uid = 05678H, precc + 5)
END LoadObject0;

PROCEDURE CopyObject* (VAR M: Objects.CopyMsg;     src, dest: Object);      (*vs 0.0d0 gs. mode 0:shallow, 1 deep *)
	(*! check shallow, deep *)
	VAR list: vyLinks.Link;
BEGIN
	dest := src;
	Gadgets.CopyObject(M, src, dest);
	dest.ObjectId := NextIdCount();
	IF M.id = Objects.deep THEN
		dest.cache := NIL;
		(*! add more if appropriate *)
	END;
	list := src.sources;     dest.sources := NIL;
	WHILE list # NIL DO Subscribe ((*for messages from source*)list.obj, dest);    list := list.link END
END CopyObject;

PROCEDURE SetCurrentThread* (thread: tThread);
BEGIN currentThread := thread END SetCurrentThread;

PROCEDURE GetCurrentThread* (): tThread;
BEGIN RETURN currentThread END GetCurrentThread;
(*

(* object queue level. This thread and all contained threads *)
PROCEDURE ForObInThreadDo (thread: tThread;  P: Objects.Handler; VAR m: Objects.ObjMsg);
VAR o: Object;
BEGIN IF thread # NIL THEN
o := thread.lastObject;
WHILE o # NIL DO
P(o, m);
IF o IS tThread THEN ForObInThreadDo(o(tThread), P, m) END;
IF o.link = NIL THEN o := NIL ELSE
o := o.link(Object) END  END
END
END ForObInThreadDo;

PROCEDURE ForObInThreadDoStd (thread: tThread;  VAR m: Objects.ObjMsg);
VAR o: Object;
BEGIN IF thread # NIL THEN
o := thread.lastObject;
WHILE o # NIL DO
o.handle(o, m);
IF o IS tThread THEN ForObInThreadDoStd(o(tThread), m) END;
IF o.link = NIL THEN o := NIL ELSE
o := o.link(Object) END
END
END
END ForObInThreadDoStd;

(* thread queue. This thread and all previous threads. *)
(*? defunct?? *)
PROCEDURE ForObInAllThreadsDo (thread: tThread;  P: Objects.Handler; VAR m: Objects.ObjMsg);
BEGIN WHILE thread # NIL DO
ForObInThreadDo(thread, P, m);
ASSERT(thread.link IS tThread);
thread := thread.link(tThread)
END
END ForObInAllThreadsDo;
*)
(** Misc *)
PROCEDURE Report* (VAR w: TextsWriter);       (*vs 0.1d0 *)
	(*! use iterators *)
	(* gs 05.12.94 added check for lastThread=NIL *)
	VAR ob: vyLinks.Link;
BEGIN ASSERT ( lastThread # NIL );
	ob := lastThread.lastObject;
	WHILE ob # NIL DO
		Write(w, ob.obj(Object));
		Texts.WriteLn(w);
		ob := ob.link
	END
END Report;

PROCEDURE WriteVS* (VAR w: TextsWriter ;      name, vs: ARRAY OF CHAR);
	VAR D, T: LONGINT;
BEGIN Oberon.GetClock(T, D);
	Texts.WriteString(w, name);      Texts.Write(w, " ");      Texts.WriteString(w, vs);
	Texts.WriteDate(w, T, D);
	Texts.WriteLn(w)
END WriteVS;

PROCEDURE Dump*;       (*vs 0.1d0 Dump info for debugging *)
	VAR w: TextsWriter;
BEGIN Texts.OpenWriter(w);
	WriteVS(w, idname, idversion);
	Report(w);
	AppendToLog(w)  (* Dump *)
END Dump;

PROCEDURE GetUsers* (o: Object): vyLinks.Link;
BEGIN RETURN o.users
END GetUsers;

PROCEDURE GetSources* (o: Object): vyLinks.Link;
BEGIN RETURN o.sources
END GetSources;

PROCEDURE Test*;       (*vs 0.1d0 Test for debugging *)
	VAR ob: Object;
BEGIN NEW(ob);
	Register(ob);
	Dump;
	Update(ob);
	Dump
END Test;
(*
(** Basic Objects: Items *)
PROCEDURE HandleItemAttributes (obj: vyLinks.Link; VAR M: Objects.AttrMsg);
VAR b: Attributes.BoolAttr; c: Attributes.CharAttr; i: Attributes.IntAttr; r: Attributes.RealAttr;
s: Attributes.StringAttr; a, f: Attributes.Attr;
BEGIN
IF M.id = Objects.get THEN
IF M.name = "Gen" THEN
COPY('vyBase.NewItem',M.s);M.class := Objects.String; M.res := 0
ELSE
Gadgets.objecthandle(obj,M)
END
ELSE
Gadgets.objecthandle(obj,M)
END
END HandleItemAttributes;

PROCEDURE LoadItem* (ob: vyLinks.Link; VAR M:Objects.FileMsg);
VAR version,uid: LONGINT;
BEGIN	(*ASSERT(ob # NIL); 	(*! dummy *)
Files.ReadLInt(M.R,version);
ASSERT((version>=minVersion) &  (version<=maxVersion));
Files.ReadLInt(M.R, ob.ObjectId);
Files.ReadLInt(M.R, ob.createdT); Files.ReadLInt(M.R, ob.createdD);
Files.ReadLInt(M.R, ob.modifiedT); Files.ReadLInt(M.R, ob.modifiedD);
(*! support inverse user list
REPEAT
Files.ReadLInt(M.R, uid);  (*! write to temporary list & patch back!*)
UNTIL uid = 0 *)
*)
END LoadItem;

PROCEDURE StoreItem* (ob: vyLinks.Link; VAR M:Objects.FileMsg);
VAR u: vyLinks.Link;
BEGIN (*	ASSERT(ob # NIL); (*! dummy *)
Files.WriteLInt(M.R,maxVersion);
Files.WriteLInt(M.R, ob.ObjectId);
Files.WriteLInt(M.R, ob.createdT); Files.WriteLInt(M.R, ob.createdD);
Files.WriteLInt(M.R, ob.modifiedT); Files.WriteLInt(M.R, ob.modifiedD);
(*! support inverse user list
u := ob.users;  WHILE u # NIL DO
IF u IS vyLinks.Link THEN Files.WriteLInt(M.R, u(vyLinks.Link).ObjectId) END;
u := u.link
END;
Files.WriteLInt(M.R, 0)  (* terminates use list *) *) *)
END StoreItem;

PROCEDURE CopyItem* (VAR M:Objects.CopyMsg;src, dest: vyLinks.Link); (*vs 0.0d0 gs. mode 0:shallow, 1 deep *)
BEGIN
dest := src;
Gadgets.CopyObject(M,src,dest);
(*	dest.ObjectId := NextIdCount();
IF M.id = vyHost.cDeep THEN
dest.cache := NIL;
(*! add more if appropriate *)
END*)
END CopyItem;

PROCEDURE ItemHandler* (obj: Objects.Object;     VAR M: Objects.ObjMsg);
VAR newobj:vyLinks.Link;    ch:CHAR;
BEGIN
ASSERT(obj IS vyLinks.Link, 100);
IF obj IS vyLinks.Link THEN
WITH obj:Object DO
IF M IS Objects.FileMsg THEN WITH M:Objects.FileMsg DO
IF M.id=Objects.load THEN
LoadItem(obj,M);
Gadgets.objecthandle(obj,M)
ELSIF M.id=Objects.store THEN
StoreItem(obj,M);
(*! handle key& id *)
(*IF  obj.key=NIL THEN Files.Write(M.R,01X) ELSE
Files.Write(M.R,02X); obj.key.handle(obj.key,M);
END;*)

Gadgets.objecthandle(obj,M)
ELSE HALT(100)
END
END (*WITH M:Objects.FileMsg *)
ELSIF M IS Objects.AttrMsg THEN WITH M: Objects.AttrMsg DO
HandleItemAttributes(obj, M) END
ELSIF M IS Objects.CopyMsg THEN WITH M:Objects.CopyMsg DO
IF M.stamp=obj.stamp THEN M.obj:=obj.dlink
ELSE NEW(newobj);    (*! init*)obj.stamp:=M.stamp;    obj.dlink:=newobj;
CopyItem(M,obj,newobj);
M.obj:=newobj;
END
END(*WITH M:Objects.CopyMsg*)
ELSE Gadgets.objecthandle(obj,M)
END;
(*	ELSIF o IS vyLinks.Link THEN
WITH o:vyLinks.Link DO
Gadgets.objecthandle(obj,M)
END; *)
ELSE Gadgets.objecthandle(obj,M)
END
ELSE
Gadgets.objecthandle(obj,M)
END
END ItemHandler;

PROCEDURE InivyLinks.Link (obj:Object);
BEGIN
obj.handle:=ItemHandler;
END InivyLinks.Link;

PROCEDURE NewItem*;
VAR newobj:Object;
BEGIN
NEW(newobj);InivyLinks.Link(newobj);Objects.NewObj:=newobj
END NewItem;
*)


(** Basic Objects: Gadget Support *)
PROCEDURE DateTimeString (d, t: LONGINT;     VAR s: ARRAY OF CHAR);
	VAR ts: ARRAY 64 OF CHAR;
BEGIN
	Strings.DateToStr(d, s);     Strings.Append(s, ' ');    Strings.TimeToStr(t, ts);    Strings.Append(s, ts)
END DateTimeString;

PROCEDURE HandleObjectAttributes (obj: Object;      VAR M: Objects.AttrMsg);
	VAR CreString, ModString: ARRAY 64 OF CHAR;
BEGIN
	IF M.id = Objects.get THEN
		IF M.name = "Gen"THEN
			COPY('vyBase.NewObj', M.s);     M.class := Objects.String;      M.res := 0
		ELSIF M.name = "ObjectId"THEN
			M.i := obj.ObjectId;     M.class := Objects.Int;      M.res := 0
		ELSIF M.name = "TimeStamp"THEN
			DateTimeString(obj.createdD, obj.createdT, CreString);
			DateTimeString(obj.modifiedD, obj.modifiedT, ModString);
			M.s := 'First: ';    Strings.Append(M.s, CreString);
			Strings.Append(M.s, ' Last:');   Strings.Append(M.s, ModString);   M.class := Objects.String;      M.res := 0
		ELSIF M.name = "Name"THEN IF obj.Name # NIL THEN obj.Name.handle(obj.Name, M)
			ELSE Gadgets.objecthandle (obj, M) (* jb 3.8.01 *)
			END

		ELSIF M.name = "Key"THEN IF obj.key # NIL THEN obj.key.handle(obj.key, M) END
		ELSIF M.name = "Disposition"THEN Strings.SetToStr(obj.disposition, M.s);    M.class := Objects.String;      M.res := 0
		ELSIF M.name = "Users"THEN M.i := vyLinks.LinkCount(obj.users);    M.class := Objects.Int;      M.res := 0
		ELSIF M.name = "Sources"THEN M.i := vyLinks.LinkCount(obj.sources);    M.class := Objects.Int;      M.res := 0
		ELSE
			Gadgets.objecthandle(obj, M)
		END

	ELSIF M.id = Objects.set THEN
		IF (M.name = "Name") & (obj.Name # NIL) THEN obj.Name.handle(obj.Name, M) ELSE Gadgets.objecthandle(obj, M) END

	ELSIF M.id = Objects.enum THEN M.Enum("ObjectId");
		M.Enum("Name");    M.Enum("TimeStamp");
		M.Enum("Key");
		M.Enum("Structure");
		M.Enum("Disposition");
		M.Enum("Users");
		M.Enum("Sources");

		Gadgets.objecthandle(obj, M)
	ELSE
		Gadgets.objecthandle(obj, M)
	END
END HandleObjectAttributes;

PROCEDURE HandleObjectLinks (obj: Object;      VAR M: Objects.LinkMsg);
	VAR seqnr: LONGINT;   stub: ARRAY 32 OF CHAR;
BEGIN
	IF M.id = Objects.enum THEN
		IF M.res < 0 THEN
			IF obj.sources # NIL THEN vyLinks.DoHandleLinks(obj.sources, 'Source', M) END;
			IF obj.users # NIL THEN vyLinks.DoHandleLinks(obj.users, 'User', M) END
		END;
		Gadgets.objecthandle(obj, M)
	ELSIF M.id = Objects.get THEN
		vyLinks.DoHandleLinks(obj.sources, 'Source', M);
		IF M.res < 0 THEN vyLinks.DoHandleLinks(obj.users, 'User', M) END;
		IF M.res < 0 THEN Gadgets.objecthandle(obj, M) END
	ELSIF M.id = Objects.set THEN
		vyLinks.NameToSeq(M.name, ' ', stub, seqnr);
		IF stub = 'Source'THEN vyLinks.DoHandleLinks(obj.sources, 'Source', M)
		ELSIF stub = 'User'THEN vyLinks.DoHandleLinks(obj.users, 'User', M)
		END;
		IF M.res < 0 THEN  Gadgets.objecthandle(obj, M)
		END
	ELSE (*! provide special case to set sources/users link *)
		Gadgets.objecthandle(obj, M)
	END
END HandleObjectLinks;

PROCEDURE HandleObjectFind (obj: Object;    VAR M: Objects.FindMsg);   	(* jb 2.7.01 *)
VAR
	name: Objects.Name;
BEGIN
	ASSERT (M.obj = NIL, 100);
	Gadgets.GetObjName (obj, name);
	IF name = M.name THEN M.obj := obj ELSE vyLinks.FindLinks (obj.sources, M) END
END HandleObjectFind;


PROCEDURE ObjectHandler* (obj: Objects.Object;          VAR M: Objects.ObjMsg);
VAR newobj: Object;     tempM: Objects.ObjMsg;
BEGIN
	tempM := M;
	IF obj IS Object THEN
		WITH obj: Object DO
			IF M IS Objects.FileMsg THEN WITH M: Objects.FileMsg DO
					IF M.id = Objects.load THEN
						LoadObject0(obj, M);       Gadgets.objecthandle(obj, M)
					ELSIF M.id = Objects.store THEN
						StoreObject0(obj, M);        Gadgets.objecthandle(obj, M)
					ELSE HALT(100)
					END
				END (*WITH M:Objects.FileMsg *)
			ELSIF M IS Objects.FindMsg THEN WITH M: Objects.FindMsg DO (* jb 2.7.01 *)
					ASSERT (M.obj = NIL, 100);
					Gadgets.objecthandle (obj, M);
					IF M.obj = NIL THEN HandleObjectFind (obj, M) END
				END

			ELSIF M IS SubscrBroadcastMsg THEN	(* jb 18.8.01 *)
				vyLinks.ForwardMsgToLinks (obj.users, M)

			ELSIF M IS Objects.AttrMsg THEN WITH M: Objects.AttrMsg DO
				HandleObjectAttributes(obj, M) END
			ELSIF M IS Objects.BindMsg THEN WITH M: Objects.BindMsg DO
					IF obj.lib # M.lib THEN  (* fof 010427, to prevent from multiple bind (recursion)*)
						Gadgets.objecthandle(obj, M);
						IF obj.Name # NIL THEN Gadgets.BindObj(obj.Name, M.lib) END;
						IF obj.key # NIL THEN Gadgets.BindObj(obj.key, M.lib) END;
						IF obj.sources # NIL THEN vyLinks.BindLinks(obj.sources, M) END  (* handle sources like models *)
					END;
					(*? avoid cyclic messages	IF obj.users # NIL THEN vyLinks.BindLinks(obj.users, M) END *)
				END (*WITH M IS Objects.BindMsg*)
			ELSIF M IS Objects.CopyMsg THEN WITH M: Objects.CopyMsg DO
					IF M.stamp = obj.stamp THEN M.obj := obj.dlink
					ELSE NEW(newobj);         (*! init*)obj.stamp := M.stamp;         obj.dlink := newobj;
						CopyObject(M, obj, newobj);
						M.obj := newobj
					END
				END(*WITH M:Objects.CopyMsg*)

			ELSIF M IS Objects.LinkMsg THEN WITH M: Objects.LinkMsg DO
					IF (*M.res<0*)TRUE THEN HandleObjectLinks(obj, M) END  (* fof 020624:  Enum Msg misspecified in many modules, M.res <0 cannot be guaranteed *)
				END (*WITH M:Objects.LinkMsg DO*)
			ELSIF M IS UpdateMessage THEN
				Update(obj);     (*!!! fof 011129, update must reach all dependent objects, doesn't it ? *)
			ELSE Gadgets.objecthandle(obj, M)
			END
			(*	ELSIF o IS Link THEN
			WITH o:Link DO
			Gadgets.objecthandle(obj,M)
			END; *)
		(* ELSE Gadgets.objecthandle(obj, M)*)
		END
	ELSE
		IF obj IS Gadgets.Object THEN
			Gadgets.objecthandle(obj, M)
		ELSE HALT(100)
		END
	END
END ObjectHandler;

PROCEDURE InitObj (obj: Object);
BEGIN
	obj.handle := objecthandle
END InitObj;

PROCEDURE NewObj*;
	VAR newobj: Object;
BEGIN
	NEW(newobj);     InitObj(newobj);     Objects.NewObj := newobj
END NewObj;

(** Frame handling *)
(*= The Gadgets system extends Objects.Object and Display.Frame. Oberon does not allow multiple inheritance. To overcome this restriction, fields and code are duplicated. We have to follow this and use different handlers for Frames and Objects *)

PROCEDURE HandleFrameAttributes (obj: Frame;      VAR M: Objects.AttrMsg);
BEGIN
	IF M.id = Objects.get THEN
		IF M.name = "Gen"THEN
			COPY('vyBase.NewFrame', M.s);     M.class := Objects.String;      M.res := 0
		ELSIF M.name = "borderW"THEN			M.class := Objects.Int;           M. i := obj.borderW;           M.res := 0
		ELSIF M.name = "hotupdate"THEN M.class := Objects.Bool;            M.b := ~obj.hotupdate;            M.res := 0

		ELSE (* obj is handled as imbedded *)
			IF obj.vyobj # NIL THEN objecthandle(obj.vyobj, M)
			ELSE (* generic *)
				Gadgets.framehandle(obj, M)
			END
		END
		(* END get *)

	ELSIF M.id = Objects.set THEN
		IF M.name = "border"THEN
			IF M.class = Objects.Int THEN  obj.borderW := SHORT(M.i);           M.res := 0;    Gadgets.Update(obj) END
		ELSIF M.name = "hotupdate"THEN obj.hotupdate := ~M.b;            M.res := 0

		ELSE Gadgets.framehandle(obj, M) END
		(* END set *)
	ELSIF M.id = Objects.enum THEN IF (obj.vyobj # NIL) THEN (*M.Enum("ObjectId")*)obj.vyobj.handle(obj.vyobj, M) END;
		M.Enum("Name");   				M.Enum("borderW");   			M.Enum("hotupdate");
		Gadgets.framehandle(obj, M)
	ELSE
		IF obj.vyobj # NIL THEN objecthandle(obj.vyobj, M) END;
		Gadgets.framehandle(obj, M)
	END
END HandleFrameAttributes;

PROCEDURE HandleFrameFileMsg (obj: Frame;    VAR M: Objects.FileMsg);
	VAR tempobj: Objects.Object;

BEGIN
	IF M.id = Objects.load THEN
		Gadgets.framehandle(obj, M);
		(*	Files.ReadInt(M.R, obj.defunctx);       Files.ReadInt(M.R, obj.defuncty);    *)
		Files.ReadInt(M.R, obj.borderW);
		Files.ReadBool(M.R, obj.hotupdate);
		vyLinks.CacheErrors;
		vyLinks.LoadLinkObj(M.R, obj.lib, tempobj);
		vyLinks.HaltErrors;
		IF tempobj # NIL THEN obj.vyobj := tempobj(FrameObject);     obj.vyobj.gadget := obj
		ELSE obj.vyobj := NIL END;
		vyLinks.CacheErrors;    (*debug*)

		vyLinks.LoadLinks(M.R, obj.lib, obj.vylinks)
	ELSIF M.id = Objects.store THEN
		Gadgets.framehandle(obj, M);
		(*	Files.WriteInt(M.R, obj.defunctx);       Files.WriteInt(M.R, obj.defuncty);*)
		Files.WriteInt(M.R, obj.borderW);
		Files.WriteBool(M.R, obj.hotupdate);

		vyLinks.CacheErrors;
		vyLinks.StoreLinkObj(M.R, obj.lib, obj.vyobj);
		vyLinks.HaltErrors;
		vyLinks.StoreLinks(M.R, obj.lib, obj.vylinks)

	ELSE HALT(100)
	END

END HandleFrameFileMsg;

PROCEDURE CopyFrame* (VAR M: Objects.CopyMsg;     src, dest: Frame);
BEGIN
	dest := src;
	IF src.vyobj # NIL THEN
		NEW(dest.vyobj);    CopyObject(M, src.vyobj, dest.vyobj);   dest.vyobj.gadget := dest
	END;
	IF M.id = Objects.deep THEN
		(*! add more if appropriate *)
		(*! copy vylinks *)
	END
END CopyFrame;

PROCEDURE FrameHandler* (obj: Objects.Object;          VAR M: Objects.ObjMsg);
VAR newobj: Frame;     tempM: Objects.ObjMsg;
BEGIN
	tempM := M;
	IF obj IS Frame THEN
		WITH obj: Frame DO
			IF M IS Objects.FileMsg THEN WITH M: Objects.FileMsg DO HandleFrameFileMsg(obj, M) END
			ELSIF M IS Objects.FindMsg THEN WITH M: Objects.FindMsg DO	(* jb 2.7.01 *)
					ASSERT (M.obj = NIL, 100);
					Gadgets.framehandle (obj, M);
					IF M.obj = NIL THEN vyLinks.FindLinks (obj.vylinks, M) END
				END
			ELSIF M IS Objects.BindMsg THEN
				WITH M: Objects.BindMsg DO
					Gadgets.framehandle(obj, M);
					vyLinks.BindLinks(obj.vylinks, M)
				END
			ELSIF M IS Objects.AttrMsg THEN WITH M: Objects.AttrMsg DO
				HandleFrameAttributes(obj, M) END
			ELSIF M IS Objects.BindMsg THEN WITH M: Objects.BindMsg DO
					Gadgets.framehandle(obj, M);
					IF obj.vyobj # NIL THEN Gadgets.BindObj(obj.vyobj, M.lib) END;
					vyLinks.BindLinks(obj.vylinks, M)
				END
			ELSIF M IS Objects.CopyMsg THEN WITH M: Objects.CopyMsg DO
					IF M.stamp = obj.stamp THEN M.obj := obj.dlink
					ELSE NEW(newobj);         (*! init*)obj.stamp := M.stamp;         obj.dlink := newobj;
						CopyFrame(M, obj, newobj);
						M.obj := newobj
					END
				END(*WITH M:Objects.CopyMsg*)
			ELSE Gadgets.framehandle(obj, M)
			END
		(* ELSE
			Gadgets.framehandle(obj, M)*)
		END
	ELSE
		IF obj IS Gadgets.Frame THEN
			Gadgets.framehandle(obj, M)
		ELSE HALT(101)
		END
	END
END FrameHandler;

PROCEDURE FrameObjHandler* (obj: Objects.Object;          VAR M: Objects.ObjMsg);
BEGIN
	WITH obj: FrameObject DO
		lastmsg := M;
		ASSERT(obj # NIL, 100)
	END;
END FrameObjHandler;

PROCEDURE InitFrameObj (obj: FrameObject);
BEGIN
	obj.handle := framehandle
END InitFrameObj;

PROCEDURE NewFrameObj*;
	VAR newobj: FrameObject;
BEGIN
	NEW(newobj);     InitFrameObj(newobj);     Objects.NewObj := newobj
END NewFrameObj;

PROCEDURE NewFrame*;
	(* System.Free vyBase* ~ Gadgets.Insert vyBase.NewFrame ~ *)
	VAR newobj: Frame;
BEGIN
	NEW(newobj);   newobj.W := 10;    newobj.H := 10;   newobj.handle := framehandle;   Objects.NewObj := newobj
END NewFrame;

(*! add generator for Frame if necessary *)


PROCEDURE DebugObjectHandler* (o: Objects.Object;       VAR M: Objects.ObjMsg);
BEGIN	(*! write diagnostic messages*)
	ASSERT(o IS Object, 100);

	ObjectHandler(o, M)
END DebugObjectHandler;


(** Data types **)
(** Data Objects: Gadget Support *)
PROCEDURE HandleDataAttributes (obj: Object;      VAR M: Objects.AttrMsg);
BEGIN
	IF M.id = Objects.get THEN
		IF M.name = "Gen"THEN
			COPY('vyBase.NewData', M.s);     M.class := Objects.String;      M.res := 0
		ELSE
			objecthandle(obj, M)
		END
	ELSE
		objecthandle(obj, M)
	END
END HandleDataAttributes;

PROCEDURE DataHandler* (obj: Objects.Object;          VAR M: Objects.ObjMsg);
BEGIN
	WITH obj: tData DO
		IF M IS Objects.AttrMsg THEN WITH M: Objects.AttrMsg DO
			HandleDataAttributes(obj, M)  END
		ELSE
			objecthandle(obj, M)
		END
	END;
END DataHandler;

PROCEDURE InitData (obj: Object);
BEGIN InitObj(obj);     obj.handle := DataHandler
END InitData;

PROCEDURE NewData*;
	VAR newobj: tData;
BEGIN
	NEW(newobj);     InitData(newobj);     Objects.NewObj := newobj
END NewData;

(** Vector Objects: Gadget Support *)
PROCEDURE HandleVectorAttributes (obj: tVector;      VAR M: Objects.AttrMsg);
BEGIN
	WITH obj: tVector DO
		IF M.id = Objects.get THEN
			IF M.name = "Gen"THEN
				COPY('vyBase.NewVec', M.s);     M.class := Objects.String;      M.res := 0
			ELSIF M.name = "nrData"THEN  M.i := obj.nrData;    M.class := Objects.Int;      M.res := 0

			ELSE
				DataHandler(obj, M)
			END
		ELSIF M.id = Objects.set THEN DataHandler(obj, M)
		ELSIF M.id = Objects.enum THEN M.Enum("Layout");
			M.Enum("nrData");
			M.Enum("Data");
			DataHandler(obj, M)
		ELSE
			DataHandler(obj, M)
		END
	END
END HandleVectorAttributes;

PROCEDURE VectorHandler* (obj: Objects.Object;          VAR M: Objects.ObjMsg);
BEGIN
	WITH obj: tVector DO
		IF M IS Objects.AttrMsg THEN
			WITH M: Objects.AttrMsg DO
			HandleVectorAttributes(obj, M) END
		ELSE
			DataHandler(obj, M)
		END
	END
END VectorHandler;

PROCEDURE InitVector (obj: Object);
BEGIN InitObj(obj);     obj.handle := DataHandler
END InitVector;

PROCEDURE NewVec*;
	VAR newobj: tVector;
BEGIN
	NEW(newobj);     InitVector(newobj);     Objects.NewObj := newobj
END NewVec;

(** Low level buffer routines for chunked data *)
PROCEDURE FindAllocLen* (v: tVector;      VAR l, freetrail: LONGINT;      VAR firstfree: tBuf);
	(* find total allocated len and number of trailing free entries. firstfree is the first chunk containing trailing free entries*)
	VAR chunk: tBuf;
BEGIN l := 0;      freetrail := 0;      firstfree := NIL;
	IF (v.buf = NIL) THEN RETURN END;
	chunk := v.buf;      firstfree := chunk;
	WHILE chunk # NIL DO l := l + chunk.len;
		IF chunk.usedentries # 0 THEN firstfree := chunk;       freetrail := 0
		ELSE INC(freetrail, chunk.len)  END;       chunk := chunk.next
	END;
	(* now l is len, firstfree is last used buf *)
	IF firstfree.usedentries = firstfree.len THEN firstfree := firstfree.next END;
	chunk := firstfree;
	WHILE chunk # NIL DO INC(freetrail, (chunk.len - chunk.usedentries));      chunk := chunk.next END
END FindAllocLen;

(*?usedentries needs strict control. *)
PROCEDURE MarkUsed* (count: LONGINT;      v: tVector);
	(*= risky mark routine. only sets the used counts. no fields are updated *)
	VAR last: tBuf;      l, free, needed, get: LONGINT;
BEGIN
	IF v.nrData < 0 THEN v.nrData := 0 END;
	IF count <= v.nrData THEN needed := 0;      v.nrData := count;
		last := v.buf;
		WHILE last # NIL DO
			IF last.usedentries > count THEN
			last.usedentries := count END;      DEC(count, last.usedentries);
			last := last.next
		END
	ELSE
		(*	ASSERT(i<=Len(v,0),100); *)ASSERT((v.buf # NIL), 101);
		FindAllocLen(v, l, free, last);      needed := count - v.nrData;
		ASSERT(free >= needed, 102);
		IF free >= needed THEN
			WHILE (needed > 0) & (last # NIL) DO
				get := (last.len - last.usedentries);       IF get > needed THEN get := needed END;
				INC(last.usedentries, get);
				INC(v.nrData, get);
				needed := needed - get;
				last := last.next
			END
		END
	END
END MarkUsed;

PROCEDURE Loc* (i: LONGINT;       v:  tVector;       VAR chunk: tBuf;       VAR loc: LONGINT);
	(*= (external world) pos i to internal storage chunk location loc. If space is allocated for element i, chunk reference and location are returned.
	If i is beyond allocation, the last chunk reference is returned with loc<0; -loc more elements needed *)
PROCEDURE getChunkLoc (pos: LONGINT;       chunkstart: LONGINT;       VAR chunk: tBuf;       VAR loc: LONGINT);
BEGIN 	loc := pos - chunkstart;
	WHILE (chunk # NIL) & (loc >= chunk.usedentries) DO
		IF chunk.next # NIL THEN
			DEC(loc, chunk.usedentries);      chunk := chunk.next
		ELSE IF loc >= chunk.len THEN
				DEC(loc, chunk.len);      loc := - (loc + 1)
			END;
			RETURN
		END
	END;      (*WHILE*)
END getChunkLoc;

BEGIN	ASSERT((v # NIL) & (v.buf # NIL) );    (* gs 20001118 *)
	chunk := v.buf ;
	getChunkLoc(i, 0, chunk, loc)
END Loc;

PROCEDURE Pos* (v:  tVector;        chunk: tBuf;        loc: LONGINT): LONGINT;
	(*= internal storage chunk location to (external world) pos*)
PROCEDURE getPos (chunkstart: LONGINT;      curchunk: tBuf;      chunk: tBuf;       loc: LONGINT): LONGINT;
	VAR pos: LONGINT;
BEGIN 	pos := chunkstart;
	WHILE (chunk # curchunk) &  (curchunk.next # NIL)  DO
	INC(pos, curchunk.usedentries);       curchunk := curchunk.next END;
	pos := pos + loc;       RETURN pos
END getPos;
BEGIN
	ASSERT((v # NIL) & (v.buf # NIL) );    (* gs 20001118 *)
	RETURN(getPos(0, v.buf, chunk, loc))
END Pos;

(** Abstract variable types *)

(** Enquiry Routines *)
PROCEDURE Len* (v: tData;      dim: INTEGER): LONGINT;
	(*! should work for any data structure which has a matrix representation *)
BEGIN
	IF v IS tVector THEN WITH
		v: tVector DO
		IF v.Layout = NIL THEN
			IF dim = 0 THEN RETURN v.nrData ELSE RETURN 0 END
		ELSIF
			(dim > v.Layout.dim) OR ~(v.Layout IS tArray) THEN RETURN 0
		ELSE
			RETURN v.Layout(tArray).lens[dim]
		END
		END
	ELSE RETURN 0
	END
END Len;

PROCEDURE CloneLayout* (model: tData): tLayout;
	(*= Allocate a new layout, and fill from model layout *)
	VAR layout: tLayout;      array: tArray;
BEGIN
	ASSERT((model # NIL) & (model IS tVector), 100);
	IF model(tVector).Layout = NIL THEN RETURN NIL END;
	WITH model: tVector DO
		IF model.Layout IS tArray THEN NEW(array);      array := model.Layout(tArray);      RETURN array
		ELSIF model.Layout IS tLayout THEN NEW(layout);      layout := model.Layout;      RETURN layout
		ELSE ASSERT(model.Layout IS tLayout, 120) END
	END
	(*
	WITH (model(tVector)^.Layout): tArray DO (*NEW(array); array:=model.Layout; RETURN array*)
	| model.Layout:tLayout DO NEW(layout); layout:=model.Layout; RETURN layout
	END;*)
END CloneLayout;


(*! This procedure must already be available in the compiler.
PROCEDURE SequentialPos* (layout:tLayout; indices: ARRAY OF Index):Index;
(*= Calculate sequential offset for indices, taking dimensions and transposed from layout*)
VAR i:LONGINT;tempindex,prevsize:LONGINT;
BEGIN
ASSERT(LEN(indices)>=layout.dim,100);i:=layout.dim-1;
prevsize.len[i]:=layout.; tempindex:=indices[i];
WHILE i>0 DO DEC(i); tempindex:=tempindex+
END SequentialPos;
*)
(** Index calculation - linear storage for matrices *)
PROCEDURE VecIndex* (VAR lens, indices: ARRAY OF Index): Index;
	(*! check *)
	VAR i: LONGINT;     tempindex: Index;     prevsize: LONGINT;
BEGIN
	tempindex := indices[0];      prevsize := lens[0];
	FOR i := 1 TO LEN(lens) - 1 DO
		tempindex := tempindex * prevsize + indices[i];      prevsize := lens[i]
	END;
	RETURN tempindex
END VecIndex;

PROCEDURE VecIndexT* (VAR lens, indices: ARRAY OF Index): Index;
	(*! check *)
	VAR i: LONGINT;     tempindex: Index;     l, prevsize: LONGINT;
BEGIN l := LEN(lens) - 1;
	tempindex := indices[l];      prevsize := lens[l];
	FOR i := l TO 0 BY - 1 DO
		tempindex := tempindex * prevsize + indices[i];      prevsize := lens[i]
	END;
	RETURN tempindex
END VecIndexT;

PROCEDURE VecIndex2* (len0, len1, index0, index1: Index): Index;
	(*! check *)
BEGIN
	RETURN len0 * index0 + index1
END VecIndex2;

PROCEDURE VecIndex2T* (len0, len1, index0, index1: Index): Index;
	(*! check *)
BEGIN
	RETURN len1 * index1 + index0
END VecIndex2T;

(** Housekeeping - used internally only *)

PROCEDURE GC* (count: LONGINT;       v: tData;       pos: LONGINT);
	(*= Do internal garbage collection on v. Do not destroy any valid data. *)
	(*! interface to be specified *)
	VAR oldchunk, chunk:  tBuf;
BEGIN
	IF v IS tVector THEN
	WITH v:  tVector DO
		ASSERT((v.buf # NIL) , 100);
		WHILE (v.buf # NIL) & (v.buf( tBuf).usedentries = 0) DO v.buf := v.buf( tBuf).next END;
		oldchunk := v.buf( tBuf);
		IF v.buf # NIL THEN chunk := v.buf( tBuf).next ELSE chunk := NIL END;
		WHILE chunk # NIL DO
			IF chunk.usedentries = 0 THEN oldchunk.next := chunk.next ELSE oldchunk := oldchunk.next END;
			chunk := chunk.next
		END
	END;
	END
END GC;

(** Chunk Support *)
(*= Use these procedures with care. They are intended as internal support for Voyager modules below Common Ground *)
PROCEDURE FlushCaches* (data: tData);
	VAR  chunk:  tBuf;
BEGIN
	WITH data: tVector DO
		chunk := data.buf;
		WHILE chunk # NIL DO chunk.cache := NIL;       chunk := chunk.next
		END
	END
END FlushCaches;

PROCEDURE DoToAllChunks* (src: tData;       action: PROCEDURE (VAR buf: tBuf));
	(*= Iterate an action through all chunks of a vector. *)
	VAR  chunk:  tBuf;
BEGIN WITH src: tVector DO
		chunk := src.buf;
		WHILE chunk # NIL DO action(chunk);       chunk := chunk.next
		END
	END
END DoToAllChunks;

PROCEDURE Piece* (VAR count: LONGINT;
src: tVector;      srcpos: LONGINT;
dest: tVector;      destpos: LONGINT;
VAR piececount: LONGINT;
VAR srcchunk: tBuf;      VAR srcloc: LONGINT;
VAR destchunk: tBuf;      VAR destloc: LONGINT);
	(*= Find intersection of requested count that fits into src and dest *)
BEGIN
	Loc(srcpos, src, srcchunk, srcloc);      ASSERT(srcloc >= 0);
	Loc(destpos, dest, destchunk, destloc);      ASSERT(destloc >= 0);
	piececount := count;
	IF (srcchunk.usedentries - srcloc + 1) < piececount THEN piececount := (srcchunk.usedentries - srcloc ) END;    (*fof 010315 changed srcloc+1 => scrloc *)
	IF (destchunk.usedentries - destloc + 1) < piececount THEN piececount := (destchunk.usedentries - destloc ) END;    (*fof 010315 changed destloc+1 => scrloc *)

	count := count - piececount
END Piece;

PROCEDURE DoToAllPieces* (src, dest: tData;       action: PROCEDURE (VAR piececount: LONGINT;
VAR srcchunk: tBuf;      VAR srcloc: LONGINT;
VAR destchunk: tBuf;      VAR destloc: LONGINT));
	(*= Iterate an action through all pieces of two vectors. Vectors must be of same size *)
	VAR  srcchunk, destchunk:  tBuf;      oldcount, piececount, count, offs, srcoffs, destoffs: LONGINT;
BEGIN WITH src: tVector DO WITH dest: tVector DO
			ASSERT(src.nrData = dest.nrData, 100);       offs := 0;      count := dest.nrData;
			WHILE count > 0 DO oldcount := count;
				Piece(count, src, offs, dest, offs, piececount, srcchunk, srcoffs, destchunk, destoffs);
				ASSERT(count < oldcount);
				action(piececount, srcchunk, srcoffs, destchunk, destoffs)
			END  END
	END
END DoToAllPieces;

PROCEDURE ApndChunks* (chunk: tBuf;      o: tVector);
	VAR temp: tBuf;       count: LONGINT;
BEGIN 	count := 0;       temp := chunk;
	WHILE temp # NIL DO count := count + temp.usedentries;       temp := temp.next   END;
	IF o.buf = NIL THEN o.buf := chunk;      o.nrData := count
	ELSE ASSERT(o.buf IS  tBuf);       temp := o.buf( tBuf);
		WHILE temp.next # NIL DO temp := temp.next  END;
		temp.next := chunk;       o.nrData := o.nrData + count
	END
END ApndChunks;

PROCEDURE SortBufferList* (VAR chunk: tBuf;      ordered: tSBLProc);
	(*= sort buffers in list using a natural merge sort. Does  n o t  sort within buffers.
	ordered should be a less-or-equal test to give a stable sort.*)
	VAR rest, left, leftlast, right, rightlast: tBuf;
PROCEDURE Merge;       (*Merge sorted runs*)
	VAR newleft: tBuf;
BEGIN
	IF ordered(left, right) THEN newleft := left;        left := left.next ELSE newleft := right;       right := right.next END;       leftlast := newleft;
	WHILE (left # NIL) & (right # NIL) DO
		IF ordered(left, right) THEN leftlast.next := left;       left := left.next ELSE leftlast.next := right;       right := right.next END;
		leftlast := leftlast.next
	END;
	IF left # NIL THEN leftlast.next := left ELSE leftlast.next := right END;
	WHILE leftlast.next # NIL DO leftlast := leftlast.next END;
	left := newleft
END Merge;

BEGIN IF (chunk = NIL) OR (chunk.next = NIL) THEN RETURN END;
	left := chunk;      leftlast := chunk;
	REPEAT
		(* precondition: rest queue is appended to leftlast *)
		WHILE (leftlast.next # NIL) & ordered(leftlast, leftlast.next) DO leftlast := leftlast.next END;
		right := leftlast.next;       leftlast.next := NIL;       (* split off rest *)
		IF right = NIL THEN rest := NIL
		ELSE rightlast := right;
			WHILE (rightlast.next # NIL) & ordered(rightlast, rightlast.next) DO rightlast := rightlast.next END;
			rest := rightlast.next;      rightlast.next := NIL;      (* split off rest *)
			Merge;
			IF rest # NIL THEN leftlast.next := rest END
		END
	UNTIL rest = NIL;
	chunk := left
END SortBufferList;

(** Abstract variable types: Iterated operators *)
(*=  Dummy implementation templates *)
PROCEDURE HandletOp1* (VAR arg: tData;      t: tOp1);
BEGIN
	ASSERT(arg # NIL);      INCL(arg.status, cNotYetImplemented)
END HandletOp1;

PROCEDURE HandletOp2* (VAR arg1, arg2: tData;      t: tOp1);
BEGIN
	ASSERT(arg1 # NIL);
	IF arg2 # NIL THEN arg1.status := arg1.status + arg2.status END;
	INCL(arg1.status, cNotYetImplemented)
END HandletOp2;

PROCEDURE HandletOp3* (VAR arg1, arg2, arg3: tData;      t: tOp1);
BEGIN
	ASSERT(arg1 # NIL);
	IF arg2 # NIL THEN arg1.status := arg1.status + arg2.status END;
	IF arg3 # NIL THEN arg1.status := arg1.status + arg3.status END;
	INCL(arg1.status, cNotYetImplemented)
END HandletOp3;

PROCEDURE GenericCatBuf* (ch: tBuf;       len: LONGINT;       VAR size: LONGINT;        VAR first, last: tBuf);
BEGIN
	ch.usedentries := 0;        ch.len := len;        ch.next := NIL;        size := size - len;
	IF first = NIL THEN first := ch;        last := ch ELSE last.next := ch;        last := ch END
END GenericCatBuf;

PROCEDURE NextBuf* (c: tBuf): tBuf;
BEGIN
	IF c = NIL THEN RETURN NIL ELSE RETURN c.next END
END NextBuf;

PROCEDURE GetUsedEntries* (c: tBuf): LONGINT ;
	VAR len: LONGINT;
BEGIN len := 0;        WHILE(c # NIL) DO INC(len, c.usedentries);        c := NextBuf(c)   END;        RETURN len
END GetUsedEntries;

PROCEDURE MatrixLayout* (rows, columns: LONGINT): tArray;
	VAR l: tArray;
BEGIN NEW(l);       l.dim := 2;       l.transposed := FALSE;       l.lens[0] := rows;       l.lens[1] := columns;        RETURN l
END MatrixLayout;

PROCEDURE SetArrayLayout* (sizes: ARRAY OF LONGINT;       v: tVector;       VAR total: LONGINT);
	VAR l: tArray;       i, dim: INTEGER;
BEGIN
	NEW(l);       i := 0;        WHILE ( i < LEN(sizes)) & (sizes[i] # 0) DO INC(i) END;
	(*ASSERT(i <= vyHost.maxdims);*)
	l.dim := i;       l.transposed := FALSE;
	IF i = 0 THEN total := 0 ELSE total := 1 END;
	FOR dim := 0 TO i - 1 DO l.lens[dim] := sizes[dim];       total := total * sizes[dim]    END;
	v.Layout := l
END SetArrayLayout;

PROCEDURE Clear* (v: tData);
	VAR chunk: tBuf;
BEGIN
	WITH
		v: tVector DO
		v.nrData := 0;
		chunk := v.buf;
		WHILE chunk # NIL DO chunk.usedentries := 0;        chunk := chunk.next    END
	END
END Clear;
(*
PROCEDURE HexToStr (pre:ARRAY OF CHAR;i: LONGINT; VAR s: ARRAY OF CHAR);
VAR k, j, c: INTEGER; a: ARRAY 10 OF CHAR;
BEGIN
j := 0;
WHILE pre[j]#0X DO s[j]:=pre[j]; INC(j) END;
k:=j+7;
s[k+1]:='H';s[k+2]:=0X;
c:=0; REPEAT	s[k] := hd[i MOD 16]; i := i DIV 16; DEC(k); INC(c)	UNTIL (i = 0) OR (c=8);
WHILE k>=j DO  s[k] := '0'; DEC(k);END
END HexToStr;

*)
PROCEDURE HexToStr (pre: ARRAY OF CHAR;     i: LONGINT;      VAR s: ARRAY OF CHAR);
	VAR k, j, c: INTEGER;      a: ARRAY 10 OF CHAR;
BEGIN
	j := 0;
	WHILE pre[j] # 0X DO s[j] := pre[j];      INC(j) END;
	k := 0;      c := 0;      REPEAT	a[k] := hd[i MOD 16];      i := i DIV 16;      INC(k);      INC(c)	UNTIL (i = 0) OR (c = 8);
	REPEAT DEC(k);      s[j] := a[k];      INC(j)  UNTIL k = 0;      s[j] := "H";      s[j + 1] := 0X
END HexToStr;

PROCEDURE StringSize (s: ARRAY OF CHAR;      VAR w, h: INTEGER);
	VAR r: Objects.Object;      p: INTEGER;
BEGIN
	w := 6;      h := 0;
	p := 0;
	WHILE s[p] # 0X DO
		Fonts.Default.GetObj(Fonts.Default, ORD(s[p]), r);
		INC(w, r(Fonts.Char).dx);
		INC(p)
	END;
	h := Fonts.Default.height + 2
END StringSize;
(*
(** Icons *)
PROCEDURE IconHandler* (F: Objects.Object; VAR M: Objects.ObjMsg);
VAR objadr:LONGINT;VAR w, h: INTEGER;
BEGIN WITH F:Icons.Icon DO
IF M IS Objects.LinkMsg THEN WITH M: Objects.LinkMsg DO
IF (M.id = Objects.set) & (M.name = "Model") & (M.obj#NIL) THEN
F.obj:=M.obj;
IF F.obj IS Object THEN
F.col:=Display3.blue;
END;
objadr:=ADDRESSOF(F.obj);
HexToStr('@ ',objadr,F.caption);
StringSize(F.caption,w,h);
IF w+2>F.W THEN F.W:=w+2 END;
M.res:=0;

ELSE
Icons.IconHandler(F,M)
END
END
ELSE
Icons.IconHandler(F,M)
END
END
END IconHandler;

PROCEDURE InitIcon (F:Objects.Object);
BEGIN F.handle:= IconHandler;
END InitIcon;

PROCEDURE NewIcon*;
BEGIN
Icons.NewIcon; InitIcon(Objects.NewObj);
END NewIcon;
*)
(** Buttons *)
PROCEDURE ButtonHandler* (F: Objects.Object;      VAR M: Objects.ObjMsg);
	VAR objadr: ADDRESS;     VAR w, h: INTEGER;
BEGIN WITH F: BasicGadgets.Button DO
		IF M IS Objects.LinkMsg THEN WITH M: Objects.LinkMsg DO
				IF (M.id = Objects.set) & (M.name = "Model") & (M.obj # NIL) THEN
					F.obj := M.obj;
					F.popout := TRUE;
					IF F.obj IS Object THEN
						F.ledcol := Display3.blue
					END;
					objadr := ADDRESSOF(F.obj);
					HexToStr('@ ', LONGINT(objadr), F.caption);
					StringSize(F.caption, w, h);
					IF w + 2 > F.W THEN F.W := w + 2 END;
					M.res := 0

				ELSE
					BasicGadgets.ButtonHandler(F, M)
				END
			END
		ELSE
			BasicGadgets.ButtonHandler(F, M)
		END
	END
END ButtonHandler;

PROCEDURE InitButton (F: Objects.Object);
BEGIN F.handle := ButtonHandler
END InitButton;

PROCEDURE NewButton*;
BEGIN
	BasicGadgets.NewButton;      InitButton(Objects.NewObj)
END NewButton;

(*** Tick counter and time controlled actions ***)
PROCEDURE Slow*;      BEGIN slow := slow * 2 END Slow;
PROCEDURE ActionReset*;      BEGIN slow := 1 END ActionReset;

PROCEDURE Stop*;
BEGIN	Oberon.Remove(countTask);      countTask := NIL
END Stop;

PROCEDURE Step*;
	VAR M: TickMsg;     t: LONGINT;      pq: ProcQPtr;
BEGIN
	IF countTask = NIL THEN Stop END;

	t := Oberon.Time();
	pq := ProcToCall;
	WHILE pq # NIL DO
		pq.Proc;      pq.NextTime := t + pq.TickDelta * slow;
		pq := pq.next
	END;

	(*	IF	t#ticks	THEN 		ticks:=t; Viewers.Broadcast(M)	END 	END Tick; *)
	ticks := t;

	Display.Broadcast(M)

END Step;

PROCEDURE ActionRegister* (p: TickProc;     delta: LONGINT);      (*vs 0.1d0 gs *)
	(*! avoid double entries *)
	VAR pq: ProcQPtr;
BEGIN
	NEW(pq);
	pq.Proc := p;     pq.TickDelta := delta;     pq.NextTime := Oberon.Time();
	pq.next := ProcToCall;
	ProcToCall := pq
END ActionRegister;

PROCEDURE ActionDeRegister* (p: TickProc);
	VAR prevpq, pq: ProcQPtr;
BEGIN IF ProcToCall.Proc = p THEN ProcToCall := ProcToCall.next ELSE
		prevpq := ProcToCall;     pq := ProcToCall.next;
		WHILE pq # NIL DO
			IF pq.Proc = p THEN prevpq.next := pq.next;      RETURN END;
			pq := pq.next
		END
	END
END ActionDeRegister;

PROCEDURE Tick (me: Oberon.Task);     	(* vs S3 *)(* Installed as an Oberon Task *)

VAR t: LONGINT;      pq: ProcQPtr;      mintime: LONGINT;
BEGIN	t := Oberon.Time();      pq := ProcToCall;       mintime := MAX(LONGINT);      (*? wrap around *)
	IF pq # NIL THEN
		WHILE pq # NIL DO
			IF pq.NextTime <= t THEN pq.Proc;      pq.NextTime := t + pq.TickDelta * slow;
				IF pq.NextTime < mintime THEN mintime := pq.NextTime END
			ELSE
				IF pq.NextTime < mintime THEN mintime := pq.NextTime  END
			END;
			pq := pq.next
		END;
		me.time := mintime
	END;     	(*pq#NIL*)
END Tick;


PROCEDURE NewCountTask (VAR T: Oberon.Task);
BEGIN	NEW(T);      T.safe := FALSE;      T.handle := Tick;      T.time := Oberon.Time(); Oberon.Install(T)
END NewCountTask;

PROCEDURE Run*;
BEGIN
	IF	countTask = NIL	THEN	NewCountTask(countTask)	END
END Run;

(** Action **)
PROCEDURE AppendAction* (newaction, prevaction: tAction);
	(*= Append new action to an action list. Prevaction will be executed before new action is done. *)
BEGIN
	IF newaction = NIL THEN RETURN END;
	newaction.preAction := prevaction;     newaction.todoCount := 0
END AppendAction;

PROCEDURE DoAction* (action: tAction);
	(*= Use with care. DoAction escapes the general message mechanism and may block the machine. *)
BEGIN
	action.failed := FALSE;
	IF action.preAction # NIL THEN DoAction(action.preAction);      action.failed := action.preAction.failed END;
	IF ~action.failed THEN action.Do(action, action.failed);
		IF action.todoCount > 0 THEN DEC(action.todoCount) END
	END
END DoAction;

PROCEDURE TerminateAction* (action: tAction);
BEGIN Oberon.Remove(action);
	IF action.termination # NIL THEN action.termination.Do(action, action.termination.failed) END
END TerminateAction;

PROCEDURE Suspend* (action: tAction);
BEGIN Oberon.Remove(action)
END Suspend;

PROCEDURE Resume* (action: tAction);
	VAR t: LONGINT;
BEGIN t := Oberon.Time();     action.time := t;     Oberon.Install(action)
END Resume;

PROCEDURE DoRunAction (action: Oberon.Task);
(*= Internal version of DoAction, to be used with timer. *)
VAR t: LONGINT;
BEGIN
	WITH action: tAction DO
		action.failed := FALSE;
		IF action.preAction # NIL THEN DoAction(action.preAction);      action.failed := action.preAction.failed END;
		IF ~action.failed THEN
			t := Oberon.Time();
			action.time := t + action.TickDelta * slow;
			action.Do(action, action.failed);
			IF action.todoCount > 0 THEN DEC(action.todoCount) END;
			IF action.todoCount = 0 THEN TerminateAction(action) END
		END
	END;
END DoRunAction;
PROCEDURE RunAction* (action: tAction;      requcount: LONGINT;      delay: LONGINT;      termination: tAction);
	(*= Install an action as background task, and run it repeatedly. If reqcount>0, stop after reqcount runs and call termination.
	Use delay between successive calls. Update events must be supported by the Do action if required.
	*)
	VAR t: LONGINT;
BEGIN 	t := Oberon.Time();         (*? wrap around *)
	IF action = NIL THEN RETURN  END;
	IF requcount < 1 THEN action.todoCount := - 1 ELSE action.todoCount := requcount END;
	action.termination := termination;      IF termination # NIL THEN termination.preAction := action END;
	action.TickDelta := delay;
	action.handle := DoRunAction;      action.safe := FALSE;
	action.time := t;
	Oberon.Install(action)
END RunAction;

(** for module SYSTEM **)
(*= tentatively fail safe and efficient copy routines. *)


PROCEDURE COPYB* (VAR src: ARRAY OF BOOLEAN;      srcoffs, len: LONGINT;
VAR dest: ARRAY OF BOOLEAN;     destoffs: LONGINT);
CONST sz = SIZEOF(BOOLEAN);
BEGIN	ASSERT(LEN(src) >= len, 100);     	ASSERT(LEN(dest) >= len, 101);
	ASSERT((len >= 0) & (len < (MAX(LONGINT) DIV sz)), 102);
	SYSTEM.MOVE(ADDRESSOF(src[srcoffs]), ADDRESSOF(dest[destoffs]), len * sz)
END COPYB;

PROCEDURE COPYCHAR* (VAR src: ARRAY OF CHAR;      srcoffs, len: LONGINT;
VAR dest: ARRAY OF CHAR;     destoffs: LONGINT);
CONST sz = SIZEOF(CHAR);
BEGIN	ASSERT(LEN(src) >= len, 100);     	ASSERT(LEN(dest) >= len, 101);
	ASSERT((len >= 0) & (len < (MAX(LONGINT) DIV sz)), 102);
	SYSTEM.MOVE(ADDRESSOF(src[srcoffs]), ADDRESSOF(dest[destoffs]), len * sz)
END COPYCHAR;

PROCEDURE COPYSHORT* (VAR src: ARRAY OF SHORTINT;      srcoffs, len: LONGINT;
VAR dest: ARRAY OF SHORTINT;     destoffs: LONGINT);
CONST sz = SIZEOF(SHORTINT);
BEGIN	ASSERT(LEN(src) >= len, 100);     	ASSERT(LEN(dest) >= len, 101);
	ASSERT((len >= 0) & (len < (MAX(LONGINT) DIV sz)), 102);
	SYSTEM.MOVE(ADDRESSOF(src[srcoffs]), ADDRESSOF(dest[destoffs]), len * sz)
END COPYSHORT;

PROCEDURE COPYI* (VAR src: ARRAY OF INTEGER;      srcoffs, len: LONGINT;
VAR dest: ARRAY OF INTEGER;     destoffs: LONGINT);
CONST sz = SIZEOF(INTEGER);
BEGIN	ASSERT(LEN(src) >= len, 100);     	ASSERT(LEN(dest) >= len, 101);
	ASSERT((len >= 0) & (len < (MAX(LONGINT) DIV sz)), 102);
	SYSTEM.MOVE(ADDRESSOF(src[srcoffs]), ADDRESSOF(dest[destoffs]), len * sz)
END COPYI;

PROCEDURE COPYL* (VAR src: ARRAY OF LONGINT;      srcoffs, len: LONGINT;
VAR dest: ARRAY OF LONGINT;     destoffs: LONGINT);
CONST sz = SIZEOF(LONGINT);
BEGIN	ASSERT(LEN(src) >= len, 100);     	ASSERT(LEN(dest) >= len, 101);
	ASSERT((len >= 0) & (len < (MAX(LONGINT) DIV sz)), 102);
	SYSTEM.MOVE(ADDRESSOF(src[srcoffs]), ADDRESSOF(dest[destoffs]), len * sz)
END COPYL;

PROCEDURE COPYR* (VAR src: ARRAY OF REAL;      srcoffs, len: LONGINT;
VAR dest: ARRAY OF REAL;     destoffs: LONGINT);
CONST sz = SIZEOF(REAL);
BEGIN	ASSERT(LEN(src) >= len, 100);     	ASSERT(LEN(dest) >= len, 101);
	ASSERT((len >= 0) & (len < (MAX(LONGINT) DIV sz)), 102);
	SYSTEM.MOVE(ADDRESSOF(src[srcoffs]), ADDRESSOF(dest[destoffs]), len * sz)
END COPYR;

PROCEDURE COPYX* (VAR src: ARRAY OF LONGREAL;      srcoffs, len: LONGINT;
VAR dest: ARRAY OF LONGREAL;     destoffs: LONGINT);
CONST sz = SIZEOF(LONGREAL);
BEGIN	ASSERT(LEN(src) >= len, 100);     	ASSERT(LEN(dest) >= len, 101);
	ASSERT((len >= 0) & (len < (MAX(LONGINT) DIV sz)), 102);
	SYSTEM.MOVE(ADDRESSOF(src[srcoffs]), ADDRESSOF(dest[destoffs]), len * sz)
END COPYX;

PROCEDURE COPYSET* (VAR src: ARRAY OF SET;      srcoffs, len: LONGINT;
VAR dest: ARRAY OF SET;     destoffs: LONGINT);
CONST sz = SIZEOF(SET);
BEGIN	ASSERT(LEN(src) >= len, 100);     	ASSERT(LEN(dest) >= len, 101);
	ASSERT((len >= 0) & (len < (MAX(LONGINT) DIV sz)), 102);
	SYSTEM.MOVE(ADDRESSOF(src[srcoffs]), ADDRESSOF(dest[destoffs]), len * sz)
END COPYSET;
PROCEDURE CallWString* (caller, name, pars: ARRAY OF CHAR;    new: BOOLEAN;    VAR res: INTEGER);
BEGIN
	(*IF pre[0]=0X THEN vyHost.CallWString(name,pars,new, res);
	ELSE*)	 vyHost.CallWStringX(name, vy, pars, new, res);
	(*	END;*)
	IF res # 0 THEN
		vyHostTexts.NoteSSS (vyHostTexts.cAlert, caller, " could not call ", name);
		CASE res OF
			1: vyHostTexts.Note (vyHostTexts.cWarning, ". File not found")
		|2: vyHostTexts.Note (vyHostTexts.cWarning, ". Not an object file")
		|3: 	vyHostTexts.Note(vyHostTexts.cWarning, ". Not up-to-date: imports  modules with bad key")
		|4: vyHostTexts.Note (vyHostTexts.cWarning, ". Not enough memory")
		|5: vyHostTexts.Note (vyHostTexts.cWarning, ". Module not found")
		|6: 	vyHostTexts.Note (vyHostTexts.cWarning, ". Command not found")
		ELSE
			vyHostTexts.NoteSI (vyHostTexts.cWarning, ". Error code = ", res)
		END  (* CASE *)
	END
END CallWString;

PROCEDURE GetVFromObj* (obj: Objects.Object): tVector;
BEGIN  IF obj = NIL THEN RETURN NIL END;
	IF ~(obj IS tVector) THEN RETURN NIL
	ELSE RETURN  obj(tVector) END
END GetVFromObj;


PROCEDURE Show* (list: vyLinks.Link;    obCount: INTEGER;    as: ARRAY OF CHAR);
	(*vs 0.0a1	md  05.07.94 *)
	VAR res: INTEGER;    asCmd: ARRAY 255 OF CHAR;
BEGIN
	showParameter := list;    parameterCount := obCount;
	(*debug $IF debug THEN *)
	res := 0;    WHILE list # NIL DO INC(res);    list := list.link END;
	ASSERT(res = obCount, 100);
	(*$END debug *)
	COPY (as, asCmd);    vyHostStrings.Append (asCmd, ".");
	vyHostStrings.Append (asCmd, "ShowP");    (* show, with parsed parameters *)
	(* vyHostTexts.NoteSS(vyHostTexts.cWarning, 'asCmdX', asCmd); *)
	(*! Std2dLayer mechanism (with BaseDraw) as alternative ?
	try to call Std2dLayer.Show with <as> as parameter,
	so that Std2dLayer.Show can call vyQuickDraw.<as>.
	For very quick graphic implementation without interactive features.*)
	CallWString(idversion, asCmd, "", FALSE, res);    (* caution: Do NOT set new=TRUE, that inititates new modules any time show is called -> unknown PC adress for the old handlers ! *)
	showParameter := NIL;    parameterCount := 0
END Show;

PROCEDURE NextParObj* (): Objects.Object;
	VAR ob: Objects.Object;
BEGIN
	IF showParameter = NIL THEN ASSERT(parameterCount = 0, 100);    RETURN NIL
	ELSE
		ob := showParameter.obj;    showParameter := showParameter.link;    DEC(parameterCount);    RETURN ob
	END
END NextParObj;


BEGIN
	Log := Oberon.Log;
	Texts.OpenWriter(w);      Texts.OpenWriter(werr);
	Register := register;    DeRegister := deRegister;
	ActionReset;     	(*= Tick counter and time controlled actions ***)

	hd := "0123456789ABCDEF";     objcount := 0;       objecthandle := ObjectHandler;     framehandle := FrameHandler;
	NEW(lastThread);
	lastThread.lastObject := NIL;
	currentThread := lastThread;
	Context := lastThread;

	NEW(Trash);
	Trash.lastObject := NIL;
	(* types support *)
	(* from OOPT *)
	undftyp := vyOOPT.undftyp;        bytetyp := vyOOPT.bytetyp;        booltyp := vyOOPT.booltyp;        chartyp := vyOOPT.chartyp;
	sinttyp := vyOOPT.sinttyp;        inttyp := vyOOPT.inttyp;        linttyp := vyOOPT.linttyp;
	realtyp := vyOOPT.realtyp;        lrltyp := vyOOPT.lrltyp;        settyp := vyOOPT.settyp;        stringtyp := vyOOPT.stringtyp;
	niltyp := vyOOPT.niltyp;        notyp := vyOOPT.notyp;

	ptrtyp := vyOOPT.ptrtyp;

	NEW(dynboolarray);       dynboolarray.form := cComp;       dynboolarray.comp := DynArr;
	dynboolarray.BaseTyp := booltyp;
	NEW(dynintarray);       dynintarray.form := cComp;       dynintarray.comp := DynArr;
	dynintarray.BaseTyp := inttyp;
	NEW(dynlintarray);       dynlintarray.form := cComp;       dynlintarray.comp := DynArr;
	dynlintarray.BaseTyp := linttyp;
	NEW(dynrealarray);       dynrealarray.form := cComp;       dynrealarray.comp := DynArr;
	dynrealarray.BaseTyp := realtyp;
	NEW(dynlrlarray);       dynlrlarray.form := cComp;       dynlrlarray.comp := DynArr;
	dynlrlarray.BaseTyp := lrltyp

END  vyBase.


System.Free vyBase *  ~
 # Gadgets.Insert vyBase.NewIcon CurrentLoad   ~
 # Gadgets.Insert vyBase.NewButton CurrentLoad   ~
Gadgets.Insert vyBase.NewButton vyBase.NewObj   ~

