MODULE vyName IN Oberon;
(* Copyright notice:

This file is part of Voyager
Copyright (C) 1993-2002 Project Voyager, StatLab Heidelberg ; (C) 1993-2002 G. Sawitzki et al.

This library is free software; you can redistribute it and/or
modify it under the terms of the GNU Lesser General Public
License as published by the Free Software Foundation; either
version 2.1 of the License, or (at your option) any later version.

This library is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public
License along with this library; if not, write to the Free Software
Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

Copy of the GNU Lesser General Public License can be found in the file COPYING.TXT
Report any problems as soon as possible to voyager@statlab.uni-heidelberg.de
*)


(* 	(c) Project Voyager, StatLab Heidelberg *)
(*
gs 17.07.99 moved to Gadgets base to use load/store.
!	implement as a ligtht-weight object
gs  15.08.94 added queue for objects sharing a name.
!	check with base register
!	allow selective find and deregister
vyName.v0r1d3
gs 07.08.94 added assertion to catch multiple registrations *)
(* 	Contents	name management.
Task: support a unified name space for Voyager.
All user-visible names should be arbitrated by the name broker.

Names may be needed for various objects
Data sets, e.g. Data stored in a file, or generated by a random number generator
Representations of data sets, e.g. state space or frequency
Variables, or transformations of variables
Styles or formats of representation
Names are used only in connection with voyager objects. There is no free floating name. Objects however may be anonymous.
Names may have scopes. For example, the same variable name may be used in various data sets. The name broker must resolve name conflicts.

A name may have different views:
UserName	a user name of restricted syntax; not necessarily unique
e.g "speed".
IndexedName	a system defined name, e.g. "VAR[4]".
The name management should not impose any unnecessary restriction on the user's naming convention.

The implementation of the name space should be self-contained.

No user commands in this module.
Test commands:
vyName.Dump
vyName.Test
*)
(*! support qualified name as qualifier.name *)
(*! support duplicate names and resolution *)
(*! support generic system defined names *)
(*! support generation and detection of names for copies etc. *)

IMPORT	 Objects, Files, vyBase,  vyHostStrings, Gadgets, Texts, vyHostTexts, vyLinks;  	(* basic data types *)
CONST
	idversion* = "vyName 0.0a5";  	(* may be maintained or changed by tools *)
	cNameLength = 32;
	(*	cQualifiedNameLength=255; *)

TYPE
	tNameArray* = ARRAY cNameLength OF CHAR;
	(*	tQNameArray=ARRAY cQualifiedNameLength OF CHAR; *)

	(*
	tNQueue = POINTER TO tNQueueDesc;
	tNQueueDesc = RECORD
	(Gadgets.ObjDesc)
	Object*: vyBase.Object;
	id: LONGINT;
	prev: tNQueue
	END;
	*)


	tName* = POINTER TO tNameDesc;
	tNameDesc = RECORD
		(Gadgets.ObjDesc)
		Object*: vyBase.Object;
		Name: tNameArray;
		id: LONGINT;
		highid: LONGINT;  (* do not re-use id numbers*)
		(* multi: tNQueue; (* if name is re-used *) *)(* fof 010410, binary tree sorted by < and >= now *)
		prev, next: tName
	END;

	VAR	NameBase*: tName;
	(* general voyager support *)

	(*
	(*! hack to place into name list *)
	PROCEDURE InsertMult (VAR name: tName);
	VAR n: tNQueue;
	BEGIN
	(*
	NEW(n); n.prev := name.multi; n.Object := name.Object; n.id := name.id;
	name.multi := n;
	INC(name.highid); name.id := name.highid; (* name.Object := ob;*)
	(* vyBase.InsertNamed(ob, name) *)
	*)
	END InsertMult;
	*)

PROCEDURE DoInsert (VAR NameBase: tName;  VAR temp: tName);
	(* hack to  avoid recursive overhead  *)
	VAR (*temp: tName; *)duplicate: BOOLEAN;
BEGIN
	(*NEW(temp); Init(temp);
	temp.Name := Name;
	temp.Object := ob;*)
	temp.prev := NIL;  temp.next := NIL;
	temp.id := 1;  temp.highid := 1;  (* temp.multi := NIL; *)duplicate := FALSE;  (*for notification only *)
	(* find the place to add name *)
	IF NameBase = NIL THEN
		NameBase := temp;
		(*vyBase.RegisterNamed(ob, temp)*)
	ELSIF temp.Name < NameBase.Name THEN DoInsert(NameBase.prev, temp)
	ELSIF temp.Name > NameBase.Name THEN DoInsert(NameBase.next, temp)
	ELSE
		temp.next := NameBase;
		temp.prev := NameBase.prev;  NameBase.prev := NIL;
		NameBase := temp
		(*
		(* duplicate key *)
		duplicate := TRUE;
		(*	ASSERT(~duplicate); *)(*notification only *)
		InsertMult(NameBase);
		temp.dlink := NameBase; (* fof, File message should give back NameBase for LinkMsg from vyBase *)
		(*! allow duplicate names. Last entry returned first *)
		*)
	END
END DoInsert;

PROCEDURE DoInsert2 (VAR NameBase: tName;  VAR temp: tName);  (* Insert SubTree in Tree *)
	(* caution: only to be used when consitency given: temp.prev < temp.next for all nodes *)
BEGIN
	IF temp = NIL THEN RETURN END;
	(* find the place to add name *)
	IF NameBase = NIL THEN
		NameBase := temp;
		(*vyBase.RegisterNamed(ob, temp)*)
	ELSIF temp.Name < NameBase.Name THEN DoInsert2(NameBase.prev, temp)
	ELSIF temp.Name > NameBase.Name THEN DoInsert2(NameBase.next, temp)
	ELSE (* duplicate key *)
		temp.next := NameBase;
		temp.prev := NameBase.prev;  NameBase.prev := NIL;
		NameBase := temp
	END
END DoInsert2;

PROCEDURE GetFather (NameBase: tName;  VAR temp: tName;  VAR left: BOOLEAN): BOOLEAN;  (* TRUE if temp in Tree *)
	VAR last: tName;
BEGIN
	last := NIL;
	IF NameBase = temp THEN temp := NIL;  RETURN TRUE END;
	WHILE (NameBase # temp)  DO
		last := NameBase;
		IF NameBase = NIL THEN temp := NIL;  RETURN FALSE
		ELSIF  temp.Name < NameBase.Name THEN
			NameBase := NameBase.prev;  left := TRUE
		ELSIF temp.Name >= NameBase.Name THEN
			NameBase := NameBase.next;  left := FALSE
		END
	END;
	temp := last;
	RETURN TRUE
END GetFather;

PROCEDURE Rebuild (VAR NameBase: tName;  VAR this: tName);
	VAR prev, next: tName;
BEGIN
	prev := this.prev;  next := this.next;
	this.prev := NIL;  this.next := NIL;
	IF prev # NIL THEN  Rebuild(NameBase, prev) END;
	IF next # NIL THEN  Rebuild(NameBase, next) END;
	IF prev # NIL THEN
		DoInsert(NameBase, prev)
	END;
	IF next # NIL THEN
		DoInsert(NameBase, next)
	END
END Rebuild;

PROCEDURE Rename (VAR NameBase: tName;  VAR temp: tName;  name: ARRAY OF CHAR);
	(* fof 010409, used when name has changed, NameBase is invariant. *)
	VAR father: tName;  left: BOOLEAN;   prev, next: tName;
BEGIN
	father := temp;
	IF ~GetFather(NameBase, father, left) THEN RETURN END;
	COPY(name, temp.Name);
	IF father = NIL THEN
		temp := NameBase;
		Rebuild(NameBase, temp)
		(* rebuild tree because top has changed2 *)
	ELSE
		prev := temp.prev;  next := temp.next;   (* delete node temp and reinsert *)
		IF left THEN
			father.prev :=  next ;   DoInsert2(father, prev)
		ELSE
			father.next := prev ;  DoInsert2(father, next)
		END;
		DoInsert(NameBase, temp)
	END
END Rename;

PROCEDURE Attributes (obj: tName;  VAR M: Objects.AttrMsg);
BEGIN
	IF (M.id = Objects.get)
		THEN
		IF (M.name = "Gen") THEN COPY('vyName.New', M.s);  M.class := Objects.String

		ELSIF (M.name =  'Name') OR (M.name =  'ObjName') THEN
			COPY(obj.Name, M.s);  M.class := Objects.String;  M.res := 0
		ELSE
			Gadgets.objecthandle(obj, M)
		END
	ELSIF (M.id = Objects.set) THEN
		IF ((M.name =  'ObjName') OR (M.name =  'Name')) & (M.class = Objects.String) THEN
			Rename(NameBase, obj, M.s);   M.res := 0
			(*! fof: Works only if NameBase is NameBase of obj, better idea ?? *)
		ELSE Gadgets.objecthandle(obj, M)
		END
	ELSIF (M.id = Objects.enum) THEN M.Enum('ObjName');  Gadgets.objecthandle(obj, M)
	ELSE Gadgets.objecthandle(obj, M)
	END
END Attributes;

PROCEDURE StoreName0 (obj: tName;  VAR M: Objects.FileMsg);
BEGIN
	Files.WriteString(M.R, obj.Name);
	Files.WriteLInt(M.R, obj.id);
	Files.WriteLInt(M.R, obj.highid)
END StoreName0;

PROCEDURE LoadName0 (obj: tName;  VAR M: Objects.FileMsg);
BEGIN
	Files.ReadString(M.R, obj.Name);
	Files.ReadLInt(M.R, obj.id);
	Files.ReadLInt(M.R, obj.highid);
	DoInsert(NameBase, obj)
END LoadName0;

PROCEDURE Links (obj: tName;    VAR M: Objects.LinkMsg);
BEGIN
	IF M.id = Objects.enum THEN
		M.Enum('Object');
		Gadgets.objecthandle(obj, M)
	ELSIF M.id = Objects.get THEN
		IF (M.res < 0) & (M.name = 'Object')  THEN  M.obj :=  obj.Object;  M.res := 0 END;
		IF M.res < 0 THEN Gadgets.objecthandle(obj, M) END
	ELSIF M.id = Objects.set THEN
		IF (M.res < 0) & (M.name = 'Object') & (M.obj # NIL) & (M.obj IS vyBase.Object)
		THEN  obj.Object := M.obj (vyBase.Object);  M.res := 0 END;
		IF M.res < 0 THEN Gadgets.objecthandle(obj, M) END
	ELSE
		Gadgets.objecthandle(obj, M)
	END
END Links;

PROCEDURE Handle* (obj: Objects.Object;  VAR M: Objects.ObjMsg);
	VAR newob: tName;
BEGIN
	WITH obj: tName DO
		IF M IS Objects.AttrMsg THEN
			WITH M: Objects.AttrMsg DO  Attributes(obj, M) END
		ELSIF M IS Objects.LinkMsg THEN

			WITH M: Objects.LinkMsg DO Links(obj, M) END

		ELSIF M IS Objects.CopyMsg THEN
			WITH M: Objects.CopyMsg DO
				IF M.stamp = obj.stamp THEN M.obj := obj.dlink
				ELSE
					NEW(newob);  obj.stamp := M.stamp;  obj.dlink := newob;
					newob.handle := obj.handle;
					COPY(obj.Name, newob.Name);  newob.Object := obj.Object;
					newob.id := obj.id;  newob.highid := obj.highid;
					(* newob.multi := obj.multi;*)
					M.obj := newob
				END
			END
		ELSIF M IS Objects.FileMsg THEN
			WITH M: Objects.FileMsg DO
				IF M.id = Objects.load THEN (*Files.ReadString(M.R, obj.Name)*)
					LoadName0(obj, M);  Gadgets.objecthandle(obj, M)
				ELSIF M.id = Objects.store THEN (*Files.WriteString(M.R, obj.Name)*)
					StoreName0(obj, M);  Gadgets.objecthandle(obj, M)
				ELSE
					Gadgets.objecthandle(obj, M)
				END
			END (*WITH*)
		ELSE
			Gadgets.objecthandle(obj, M) (* not understood *)
		END
	END
END Handle;

PROCEDURE Init* (name: tName);
BEGIN name.Name := '';  name.id := 0;  name.highid := 0;  name.handle := Handle
END Init;

PROCEDURE New*;
	VAR name: tName;
BEGIN NEW(name);  Init(name);  Objects.NewObj := name
END New;

(*
PROCEDURE RegisterMult (VAR name: tName; ob: vyBase.Object);
VAR n: tNQueue;
BEGIN
NEW(n); n.prev := name.multi; n.Object := name.Object; n.id := name.id;
name.multi := n;
INC(name.highid); name.id := name.highid; name.Object := ob;
vyBase.RegisterNamed(ob, name)
END RegisterMult;
*)

PROCEDURE DoRegister (VAR NameBase: tName;  ob: vyBase.Object;  VAR Name: tNameArray);
	(* hack to  avoid recursive overhead  *)
	VAR temp: tName;  duplicate: BOOLEAN;
BEGIN
	NEW(temp);  Init(temp);
	temp.Name := Name;
	temp.Object := ob;
	temp.prev := NIL;  temp.next := NIL;
	temp.id := 1;  temp.highid := 1;  (* temp.multi := NIL; *)duplicate := FALSE;  (*for notification only *)
	(* find the place to add name *)
	IF NameBase = NIL THEN
		NameBase := temp;
		vyBase.RegisterNamed(ob, temp)
	ELSIF Name < NameBase.Name THEN DoRegister(NameBase.prev, ob, Name)
	ELSIF Name > NameBase.Name THEN DoRegister(NameBase.next, ob, Name)
	ELSE (* duplicate key *)
		temp.next := NameBase;
		temp.prev := NameBase.prev;  NameBase.prev := NIL;
		NameBase := temp;
		vyBase.RegisterNamed(ob, temp)
		(*
		duplicate := TRUE;
		(*	ASSERT(~duplicate); *)(*notification only *)
		RegisterMult(NameBase, ob);
		(*! allow duplicate names. Last entry returned first *)
		*)
	END
END DoRegister;

PROCEDURE Register* (VAR NameBase: tName;  ob: vyBase.Object;  Name: ARRAY OF CHAR);
	(*vs 0.1d1 register a name to name space *)
	VAR name: tNameArray;
BEGIN ASSERT(vyHostStrings.Length(Name) < LEN(name));
	COPY(Name, name);
DoRegister(NameBase, ob, name)   END Register;

PROCEDURE RegisterNamed* (ob: vyBase.Object;  Name: ARRAY OF CHAR);
	VAR name: tNameArray;
BEGIN
	ASSERT(vyHostStrings.Length(Name) < LEN(name));
	COPY(Name, name);
	Register(NameBase, ob, name)
END RegisterNamed;

PROCEDURE Find* (NameBase: tName;  Name: tNameArray): vyBase.Object;
	(*vs 0.1d1 find an object by name. return NIL if not found *)
	(*VAR	w: vyHost.TextsWriter; *)
BEGIN
	(*	Texts.OpenWriter(w);
	Texts.WriteString(w,Name); Texts.WriteLn(w);
	vyHost.AppendToLog(w);
	*)
	WHILE (NameBase # NIL) & (NameBase.Name # Name) DO
		(*	Texts.WriteString(w,NameBase.Name); Texts.WriteLn(w);
		vyHost.AppendToLog(w);
		*)
		IF Name < NameBase.Name THEN NameBase := NameBase.prev
		ELSE NameBase := NameBase.next
		END
	END;
	IF NameBase # NIL THEN
	RETURN NameBase.Object ELSE RETURN NIL END
END Find;

PROCEDURE FindObj* (name: ARRAY OF CHAR): vyBase.Object;
	VAR tempname: tNameArray;
BEGIN  COPY(name, tempname);   RETURN Find(NameBase, tempname)
END FindObj;

PROCEDURE FindMult* (NameBase: tName;  Name: tNameArray): vyLinks.Link;  (* fof 020625 *)
	VAR link: vyLinks.Link;
BEGIN
	link := NIL;
	WHILE (NameBase # NIL) & (NameBase.Name # Name) DO
		(*	Texts.WriteString(w,NameBase.Name); Texts.WriteLn(w);
		vyHost.AppendToLog(w);
		*)
		IF Name < NameBase.Name THEN NameBase := NameBase.prev
		ELSE NameBase := NameBase.next
		END
	END;
	WHILE(NameBase # NIL) DO
		vyLinks.InsertObj(link, NameBase.Object);
		NameBase := NameBase.next;
		IF NameBase # NIL THEN
			IF NameBase.Name # Name THEN NameBase := NIL END
		END
	END;
	RETURN link
END FindMult;

PROCEDURE FindMultObj* (name: ARRAY OF CHAR): vyLinks.Link; (* fof 020625 *)
	VAR tempname: tNameArray;
BEGIN
	COPY(name, tempname);   RETURN FindMult(NameBase, tempname)
END FindMultObj;


PROCEDURE GetName* (NameBase: tName;  VAR Name: ARRAY OF CHAR );
	(*vs 0.1d1 get name string of current entry *)
BEGIN
	IF NameBase = NIL THEN Name[0] := 0X
	ELSE COPY(NameBase.Name, Name)
	END
END GetName;

PROCEDURE ExtName* (stub: tNameArray;  ext: tNameArray;  extnum: LONGINT;  VAR name: tNameArray);  (*vs 0.0d0 gs *)
	(* generate a generic name based on ext. Format: <stub><ext><extnum>
	where extnum is numeric and positive  *)
BEGIN
	COPY(stub, name);  vyHostStrings.Append(name, ext);  vyHostStrings.AppendInt(extnum, 0, name)
END ExtName;

(*PROCEDURE FixupObj* (ob: vyBase.Object);
VAR temp: tName; duplicate: BOOLEAN;Name: tNameArray;
BEGIN
IF (ob.Name=NIL) OR ~ (ob.Name IS tName) THEN RETURN END;
temp:=ob.Name(tName); GetName(temp,Name);
temp.id := 1; temp.highid := 1; temp.multi := NIL; duplicate := FALSE; (*for notification only *)
(* find the place to add name *)
IF NameBase = NIL THEN
NameBase := temp;
vyBase.RegisterNamed(ob, temp)
ELSIF Name < NameBase.Name THEN DoRegister(NameBase.prev, ob, Name)
ELSIF Name > NameBase.Name THEN DoRegister(NameBase.next, ob, Name)
ELSE (* duplicate key *)
duplicate := TRUE;
(*	ASSERT(~duplicate); *)(*notification only *)
RegisterMult(NameBase, ob);
(*! allow duplicate names. Last entry returned first *)
END
END FixupObj;
*)
PROCEDURE IsExtName* (VAR name: tNameArray;  ext: tNameArray;  VAR stub: tNameArray;  VAR extnum: LONGINT): BOOLEAN;  (*vs 0.0d0 gs *)
	(* test  whether name is a generic name based on ext. Format: <stub><ext><extnum>
	where extnum is numeric or empty. Empty is interpreted as 0  *)
	VAR pos, l: LONGINT;
BEGIN
	pos := vyHostStrings.Pos(ext, name, 0);
	IF pos < 0 THEN stub := name;  extnum := 0;  RETURN FALSE
	ELSE
		vyHostStrings.Extract(name, 0, pos, stub);
		extnum := 0;
		l := vyHostStrings.Length(name);
		pos := pos + vyHostStrings.Length(ext);
		WHILE pos < l DO
			IF (name[pos] >= '0') &  (name[pos] <= '9')
				THEN extnum := extnum * 10 + ORD(name[pos]) - ORD('0')
			ELSE RETURN FALSE END;
			INC(pos)
		END;
		RETURN TRUE
	END
END IsExtName;

PROCEDURE UniqueExtName* (NameBase: tName;  stub: tNameArray;  ext: tNameArray;  VAR newname: tNameArray);  (*vs 0.0d0 gs *)
	(* generate a unique new name based on stub and ext. Additional extension should be numeric *)
	VAR extnum: LONGINT;
BEGIN
	extnum := 0;
	REPEAT
		INC(extnum);  ExtName(stub, ext, extnum, newname)
	UNTIL Find(NameBase, newname) = NIL
END UniqueExtName;
(*
PROCEDURE Next (VAR NameBase:tName );
(*vs 0.1d1 advance entry. Return NIL if done. Used to walk throught graph. *)
BEGIN
(*! implement walk through *)
END Next;
*)

PROCEDURE Dump*;  (*vs 0.1d2 List name space. Debug version.*)
VAR
	w: vyBase.TextsWriter;
PROCEDURE SSHOW (VAR NameB: tName);
	(* VAR n: tNQueue; *)
BEGIN
	IF NameB.prev # NIL THEN SSHOW(NameB.prev) END;
	Texts.WriteString(w, NameB.Name);
	IF NameB.highid > 1 THEN Texts.WriteString(w, " [ ");
		Texts.WriteInt(w, NameB.id, 3);  Texts.WriteString(w, " of ");
		Texts.WriteInt(w, NameB.highid, 3);  Texts.WriteString(w, " ] ")
	END;
	IF NameB.Object # NIL THEN vyBase.Write(w, NameB.Object) END;
	Texts.WriteLn(w);
	(* n := NameB.multi;
	WHILE n # NIL DO Texts.WriteString(w, " [ ");
	Texts.WriteInt(w, n.id, 3); Texts.WriteString(w, " ] ");
	vyBase.Write(w, n.Object); n := n.prev;
	Texts.WriteLn(w)
	END;
	*)
	vyHostTexts.AppendToLog(w);
	IF NameB.next # NIL THEN SSHOW(NameB.next) END
END SSHOW;

BEGIN
	Texts.OpenWriter(w);
	vyBase.WriteVS(w, '', idversion);
	Texts.WriteString(w, 'Named entries:');  Texts.WriteLn(w);
	vyHostTexts.AppendToLog(w);
	IF NameBase = NIL THEN Texts.WriteString(w, ' - none - ');
		Texts.WriteLn(w)
	ELSE
		SSHOW(NameBase)
	END;
	vyHostTexts.AppendToLog(w)
END Dump;

PROCEDURE GetObjId* (o: vyBase.Object;  VAR id: ARRAY OF CHAR);
	(*= Returns 0X on error *)
	VAR vyname: vyBase.tName;  name: tName;
BEGIN
	IF o = NIL THEN id[0] := 0X;  RETURN END;
	vyname := NIL;  vyBase.Name (o, vyname);
	IF vyname = NIL THEN  id[0] := 0X
	ELSIF vyname IS tName THEN name := vyname(tName);  GetName (name, id)
	ELSE COPY("undef",id);  END
END GetObjId;

PROCEDURE AppendObjId* (o: vyBase.Object;  VAR id: ARRAY OF CHAR);
	VAR name: tNameArray;
BEGIN	GetObjId (o, name);  vyHostStrings.Append(id, name)	END AppendObjId;

BEGIN
	NameBase := NIL;
END vyName.

System.Free vyName * vyBase * ~
Gadgets.Insert vyBase.NewButton vyName.New ~
kiki