 (* This file has been generated by SpotPP 0.2d2 at  22.11.2000 14:37:01
from   vy/src/vyReal.Mpp - Last modified at  22.11.2000 14:37:01
using flags: Real
Do not change this file. Apply changes to the master file only.  *)



MODULE vyReal IN Oberon;
(* Copyright notice:

This file is part of Voyager
Copyright (C) 1993-2002 Project Voyager, StatLab Heidelberg ; (C) 1993-2002 G. Sawitzki et al.

This library is free software; you can redistribute it and/or
modify it under the terms of the GNU Lesser General Public
License as published by the Free Software Foundation; either
version 2.1 of the License, or (at your option) any later version.

This library is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public
License along with this library; if not, write to the Free Software
Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

Copy of the GNU Lesser General Public License can be found in the file COPYING.TXT
Report any problems as soon as possible to voyager@statlab.uni-heidelberg.de
*)




(** real number arrays, including linear algebra and matrices *)
(*! all procedures should include gentle support for NaNs, eg. report nr of NaNs *)

(*base model.  Including  BLAS machar.
Generate INTEGER, LONGINT, LONGREAL, BOOLEAN from this module
Automatic.Do
Edit.Open 	:vy:vyBoolean.v0r0a2.Mod
Edit.Open 	:vy:vyBits.v0r0a2.Mod
Edit.Open	:vy:vySets.v0r0a2.Mod
Edit.Open 	:vy:vyLongreal.v0r0a2.Mod
Edit.Open 	:vy:vyInteger.v0r0a2.Mod
Edit.Open 	:vy:vyLongint.v0r0a2.Mod
~
resp
Edit.Open 	vy/vyBoolean.v0r0a2.Mod
Edit.Open 	vy/vyBits.v0r0a2.Mod
Edit.Open	vy/vySets.v0r0a2.Mod
Edit.Open 	vy/vyLongreal.v0r0a2.Mod
Edit.Open 	vy/vyInteger.v0r0a2.Mod
Edit.Open 	vy/vyLongint.v0r0a2.Mod
~
COPY procedures are prepared in :vy:vyHost.v0r0a2.Mod
*)
IMPORT Files, Reals IN A2, vyBase;
CONST idversion* = ' v0r0a3x';

	(*= start and len parameters are passed as explicit parameters, to allow for incomplete buffers,
	or simulated higher dim arrays. *)
	(* strategies: pre-check array bounds *)
	(*? limit counts at 0 or 1 ? 0 may need exception anyhow, so 1 is ok *)
	(* NaN respected in sorts. Stabilize ?? *)
	(* Assertion models: single array
	(len:index; VAR x: ARRAY OF real; start: index; .....)
	ASSERT(start>=0,100);ASSERT(len>=0,101);
	ASSERT(start<=LEN(x)-len,102);

	single array with step size
	(len:index; VAR x: ARRAY OF real; start, step: index; .....)
	ASSERT(start>=0,100);ASSERT(len>=0,101);
	ASSERT(start+len<=LEN(x),102);	ASSERT(step>0,103);

	*)
	(*= storage formats *)
	fmtany* = 0;   (*= never in stored format. fmtany in storage signals termination*)
	fmtend* = 0;  (*= termination*)
	fmtplain* = 1;
	fmtpacked* = 2;

	(*> BLAS machar interface >*)
TYPE

	real = REAL; (* technical convenience, to avoid duplicate code for REAL and LONGREAL *)


	index = LONGINT;
	tOp1* = PROCEDURE (VAR arg: real);
	tOp2* = PROCEDURE (VAR arg1: real;  arg2: real);
	tOp3* = PROCEDURE (VAR arg1: real;  arg2, arg3: real);

	(* Machine translated from FORTRAN to Oberon by defor 0.1d1 (C) G. Sawitzki 30.Jul.94*)
	(* modified 07.12.94 gs *)
	(*
	SUBROUTINE MACHAR(IBETA,IT,IRND,NGRD,MACHEP,NEGEP,IEXP,MINEXP,;
	MAXEXP,EPS,EPSNEG,XMIN,XMAX);
	*)

	(*-----------------------------------------------------------------------
	This Fortran 77 subroutine is intended to determine the parameters
	of the floating-point arithmetic system specified below.  The
	determination of the first three uses an extension of an algorithm
	due to M. Malcolm, CACM 15 (1972), pp. 949-951, incorporating some,
	but not all, of the improvements suggested by M. Gentleman and S.
	Marovich, CACM 17 (1974), pp. 276-277.  An earlier version of this
	program was published in the book Software Manual for the
	Elementary Functions by W. J. Cody and W. Waite, Prentice-Hall,
	Englewood Cliffs, NJ, 1980.  The present version is documented in
	W. J. Cody, "MACHAR: A subroutine to dynamically determine machine
	parameters," TOMS 14, December, 1988.

	The program as given here must be modified before compiling.  If
	a single (double) precision version is desired, change all
	occurrences of CS (CD) in columns 1 and 2 to blanks.

	Parameter values reported are as follows:
	*)
	(** Global variables*)
	(*= These variables are calculated when the module is loaded.*)
	(*=
	IBETA   - the radix for the floating-point representation
	IT      - the number of base IBETA digits in the floating-point
	significand
	IRND    - 0 if floating-point addition chops
	1 if floating-point addition rounds, but not in the
	IEEE style
	2 if floating-point addition rounds in the IEEE style
	3 if floating-point addition chops, and there is
	partial underflow
	4 if floating-point addition rounds, but not in the
	IEEE style, and there is partial underflow
	5 if floating-point addition rounds in the IEEE style,
	and there is partial underflow
	NGRD    - the number of guard digits for multiplication with
	truncating arithmetic.  It is
	0 if floating-point arithmetic rounds, or if it
	truncates and only  IT  base  IBETA digits
	participate in the post-normalization shift of the
	floating-point significand in multiplication;
	1 if floating-point arithmetic truncates and more
	than  IT  base  IBETA  digits participate in the
	post-normalization shift of the floating-point
	significand in multiplication.
	MACHEP  - the largest negative integer such that
	1.0+FLOAT(IBETA)**MACHEP .NE. 1.0, except that
	MACHEP is bounded below by  -(IT+3)
	NEGEPS  - the largest negative integer such that
	1.0-FLOAT(IBETA)**NEGEPS .NE. 1.0, except that
	NEGEPS is bounded below by  -(IT+3)
	IEXP    - the number of bits (decimal places if IBETA = 10)
	reserved for the representation of the exponent
	(including the bias or sign) of a floating-point
	number
	MINEXP  - the largest in magnitude negative integer such that
	FLOAT(IBETA)**MINEXP is positive and normalized
	MAXEXP  - the smallest positive power of  BETA  that overflows
	EPS     - the smallest positive floating-point number such
	that  1.0+EPS .NE. 1.0. In particular, if either
	IBETA = 2  or  IRND = 0, EPS = FLOAT(IBETA)**MACHEP.
	Otherwise,  EPS = (FLOAT(IBETA)**MACHEP)/2
	EPSNEG  - A small positive floating-point number such that
	1.0-EPSNEG .NE. 1.0. In particular, if IBETA = 2
	or  IRND = 0, EPSNEG = FLOAT(IBETA)**NEGEPS.
	Otherwise,  EPSNEG = (IBETA**NEGEPS)/2.  Because
	NEGEPS is bounded below by -(IT+3), EPSNEG may not
	be the smallest number that can alter 1.0 by
	subtraction.
	XMIN    - the smallest non-vanishing normalized floating-point
	power of the radix, i.e.,  XMIN = FLOAT(IBETA)**MINEXP
	XMAX    - the largest finite floating-point number.  In
	particular  XMAX = (1.0-EPSNEG)*FLOAT(IBETA)**MAXEXP
	Note - on some machines  XMAX  will be only the
	second, or perhaps third, largest number, being
	too small by 1 or 2 units in the last digit of
	the significand.

	*)
	(*     Latest revision - December 4, 1987

	Author - W. J. Cody
	Argonne National Laboratory

	-----------------------------------------------------------------------*)
	VAR IBETA-, IEXP-, IRND-, IT-
	, MACHEP-, MAXEXP-,
	MINEXP-, NEGEP-, NGRD-: INTEGER;
	(*S    REAL D    DOUBLE PRECISION*)
	(*CONV,*)EPS-,
	EPSNEG-, XMAX-, XMIN-: real;


PROCEDURE Machar;
	VAR I, J, K, ITEMP, IZ,
	MX, NXRES: INTEGER;
	(*S    REAL D    DOUBLE PRECISION*)
	A, B, BETA, BETAIN, BETAH, ONE, T, TEMP, TEMPA,
	TEMP1, TWO, Y, Z, ZERO: real;
	(*-----------------------------------------------------------------------
	S    CONV(I) = REAL(I)
	D    CONV(I) = DBLE(I)*)
	(*-----------------------------------------------------------------------
	S    CONV(I) = REAL(I)
	D    CONV(I) = DBLE(I)*)

PROCEDURE CONV (i: INTEGER): real;
BEGIN
	RETURN i
END CONV;

PROCEDURE INT (r: real): INTEGER;
BEGIN
	RETURN SHORT(ENTIER(r));  (*! check FORTRAN INT. Watfor uses INT(r)=0 for |r|<1 *)
END INT;

BEGIN
	ONE := CONV(1);
	TWO := ONE + ONE;
	ZERO := ONE - ONE;
	(*-----------------------------------------------------------------------
	Determine IBETA, BETA ala Malcolm.
	-----------------------------------------------------------------------*)
	A := ONE;
	(*10*)REPEAT
		A := A + A;
		TEMP := A + ONE;
		TEMP1 := TEMP - A;
		(*IF (TEMP1-ONE = ZERO) THEN GOTO 10; END;*)(* If Block *)
	UNTIL  (TEMP1 - ONE # ZERO);

	B := ONE;
	(*20*)REPEAT
		B := B + B;
		TEMP := A + B;
		ITEMP := INT(TEMP - A);
		(* IF (ITEMP = 0) THEN GOTO 20; END;*)(* If Block *)
	UNTIL (ITEMP # 0);
	IBETA := ITEMP;
	BETA := CONV(IBETA);
	(*-----------------------------------------------------------------------
	Determine IT, IRND.
	-----------------------------------------------------------------------*)
	IT := 0;
	B := ONE;
	(*100*)REPEAT IT := IT + 1;
		B := B * BETA;
		TEMP := B + ONE;
		TEMP1 := TEMP - B;
		(* IF (TEMP1-ONE = ZERO) THEN GOTO 100; END; *)(* If Block *)
	UNTIL  (TEMP1 - ONE # ZERO);
	IRND := 0;
	BETAH := BETA / TWO;
	TEMP := A + BETAH;
	IF (TEMP - A # ZERO) THEN  IRND := 1 END;
	TEMPA := A + BETA;
	TEMP := TEMPA + BETAH;
	IF ((IRND = 0) & (TEMP - TEMPA # ZERO)) THEN  IRND := 2 END;
	(*-----------------------------------------------------------------------
	Determine NEGEP, EPSNEG.
	-----------------------------------------------------------------------*)
	NEGEP := IT + 3;
	BETAIN := ONE / BETA;
	A := ONE;
	FOR  I  :=  1 TO  NEGEP DO A := A * BETAIN;
		(*200*)END;
		(* * CONTINUE * *)
		B := A;
		(*210*)TEMP := ONE - A;
		(* IF (TEMP-ONE # ZERO) THEN GOTO 220; END; *)(* If Block *)
		WHILE  (TEMP - ONE = ZERO) DO
			A := A * BETA;
			NEGEP := NEGEP - 1;
			TEMP := ONE - A
		END;  (*GOTO 210;*)
		(*220*)NEGEP := - NEGEP;
		EPSNEG := A;
		(*-----------------------------------------------------------------------
		Determine MACHEP, EPS.
		-----------------------------------------------------------------------*)
		MACHEP := - IT - 3;
		A := B;
		(*300*)TEMP := ONE + A;
		(* IF (TEMP-ONE # ZERO) THEN GOTO 320; END; *)(* If Block *)
		WHILE (TEMP - ONE = ZERO) DO
			A := A * BETA;
			MACHEP := MACHEP + 1;
			TEMP := ONE + A

		END;  (* GOTO 300;*)
		(*320*)EPS := A;
		(*-----------------------------------------------------------------------
		Determine NGRD.
		-----------------------------------------------------------------------*)
		NGRD := 0;
		TEMP := ONE + EPS;
		IF ((IRND = 0) & (TEMP * ONE - ONE # ZERO)) THEN  NGRD := 1 END;
		(*-----------------------------------------------------------------------
		Determine IEXP, MINEXP, XMIN.

		Loop to determine largest I and K = 2**I such that
		(1/BETA) ** (2**(I))
		does not underflow.
		Exit from loop is signaled by an underflow.
		-----------------------------------------------------------------------*)
		I := 0;
		K := 1;
		Z := BETAIN;
		T := ONE + EPS;
		NXRES := 0;
		(*400*)
		LOOP
			Y := Z;
			Z := Y * Y;
			(*-----------------------------------------------------------------------
			Check for underflow here.
			-----------------------------------------------------------------------*)
			A := Z * ONE;
			TEMP := Z * T;
			IF ((A + A = ZERO) OR (ABS(Z) >= Y)) THEN EXIT END;  (* If Block *)
			TEMP1 := TEMP * BETAIN;
			IF (TEMP1 * BETA = Z) THEN EXIT END;  (* If Block *)
			I := I + 1;
			K := K + K
		END;  (*GOTO 400;*)
		(*410*)
		IF (IBETA = 10) THEN (*GOTO 420;*)
			(*-----------------------------------------------------------------------
			This segment is for decimal machines only.
			-----------------------------------------------------------------------*)
			(*420*)IEXP := 2;
			IZ := IBETA;
			(*430*)LOOP IF (K < IZ) THEN EXIT END;  (* If Block *)
				IZ := IZ * IBETA;
				IEXP := IEXP + 1;
				(*GOTO 430;*)
				(*440*)END;
				MX := IZ + IZ - 1
			ELSE
				IEXP := I + 1;
				MX := K + K
			END;  (*GOTO 450;*)
			(*-----------------------------------------------------------------------
			Loop to determine MINEXP, XMIN.
			Exit from loop is signaled by an underflow.
			-----------------------------------------------------------------------*)
			(*450*)LOOP
				XMIN := Y;
				Y := Y * BETAIN;
				(*-----------------------------------------------------------------------
				Check for underflow here.
				-----------------------------------------------------------------------*)
				A := Y * ONE;
				TEMP := Y * T;
				IF (((A + A) = ZERO) OR (ABS(Y) >= XMIN)) THEN  EXIT END;  (* If Block *)
				K := K + 1;
				TEMP1 := TEMP * BETAIN;
				IF ((TEMP1 * BETA # Y) OR (TEMP = Y)) THEN (* If Block *)
					(* GOTO 450; *)
				ELSE
					NXRES := 3;
					XMIN := Y;  EXIT
				END (*IF*)
			END;  (*LOOP 460*)MINEXP := - K;
			(*-----------------------------------------------------------------------
			Determine MAXEXP, XMAX.
			-----------------------------------------------------------------------*)
			IF ((MX > K + K - 3) OR (IBETA = 10)) THEN (*GOTO 500; END; *)(* If Block *)
			ELSE MX := MX + MX;
			IEXP := IEXP + 1 END;
			(*500*)MAXEXP := MX + MINEXP;
			(*-----------------------------------------------------------------
			Adjust IRND to reflect partial underflow.
			-----------------------------------------------------------------*)
			IRND := IRND + NXRES;
			(*-----------------------------------------------------------------
			Adjust for IEEE-style machines.
			-----------------------------------------------------------------*)
			IF (IRND >= 2) THEN  MAXEXP := MAXEXP - 2 END;
			(*-----------------------------------------------------------------
			Adjust for machines with implicit leading bit in binary
			significand, and machines with radix point at extreme
			right of significand.
			-----------------------------------------------------------------*)
			I := MAXEXP + MINEXP;
			IF ((IBETA = 2) & (I = 0)) THEN  MAXEXP := MAXEXP - 1 END;
			IF (I > 20) THEN  MAXEXP := MAXEXP - 1 END;
			IF (A # Y) THEN  MAXEXP := MAXEXP - 2 END;
			XMAX := ONE - EPSNEG;
			IF (XMAX * ONE # XMAX) THEN  XMAX := ONE - BETA * EPSNEG END;
			XMAX := XMAX / (BETA * BETA * BETA * XMIN);
			I := MAXEXP + MINEXP + 3;
			IF (I > 0) THEN FOR  J  :=  1 TO  I DO (*510*)
					IF (IBETA = 2) THEN  XMAX := XMAX + XMAX END;
					IF (IBETA # 2) THEN  XMAX := XMAX * BETA END
				END;  (*510*)(* * CONTINUE * *)
				(*520*)END
			END Machar;

			(*< BLAS machar interface end <*)

			(** File storage *)
			PROCEDURE Write* (VAR R: Files.Rider;  count: index;  VAR x: ARRAY OF real;  start: index);
			BEGIN
				ASSERT(start >= 0, 100);  ASSERT(count >= 0, 101);
				ASSERT(start <= LEN(x) - count, 102);
				count := start + count;

				WHILE start < count DO Files.WriteReal(R, x[start]); INC(start) END

			END Write;

		PROCEDURE Read* (VAR R: Files.Rider;  count: index;  VAR x: ARRAY OF real;  start: index);
		BEGIN
			ASSERT(start >= 0, 100);  ASSERT(count >= 0, 101);
			ASSERT(start <= LEN(x) - count, 102);
			count := start + count;

			WHILE start < count DO Files.ReadReal(R, x[start]); INC(start) END

		END Read;


		(*= Formatted write, eg. packed, sparse... *)
		(*! add implementations *)
		(*= file is a series of packages of structure
		<formatkey>: LONGINT
		0: terminate. No further information in this record
		1: plain
		2: repeat packing
		<start><count> : LONGINT
		<privat packing data>
		*)
		(*= packed format.
		formatkey=1
		count: total number of entries
		<default>: real. Gaps between packages are filled with this value, eg. 0 or NaN
		[<packcount>   <packstart>	<packval> ] terminates on packcount 0
		*)
		(*! check add implementations *)
	PROCEDURE WriteFmt* (prefform: LONGINT; VAR R: Files.Rider;  count: index;  VAR x: ARRAY OF real;  start: index);
		(*= prefform is the preferred storage format, but the internal algorithm may choose a different one *)
	BEGIN
		(*! add implementations for non plain. form ignored so far *)
		Files.WriteLInt(R, fmtplain);
		Files.WriteLInt(R, start);
		Files.WriteLInt(R, count);
		Write(R, count, x, start);
		Files.WriteLInt(R, fmtend)
	END WriteFmt;

PROCEDURE ReadFmt* (VAR form: LONGINT; VAR R: Files.Rider;  count: index;  VAR x: ARRAY OF real;  start: index);
	VAR stop: LONGINT;
BEGIN
	(*! add implementations for non plain. form ignored so far *)
	Files.ReadLInt(R, form);
	Files.ReadLInt(R, start);
	Files.ReadLInt(R, count);
	Read(R, count, x, start);
	Files.ReadLInt(R, stop);  ASSERT(stop = fmtend, 100)
END ReadFmt;

(** Basic **)


PROCEDURE Fill* (len: index;  VAR x: ARRAY OF real;  start: index;  val: real);
BEGIN
	ASSERT(start >= 0, 100);  ASSERT(len >= 0, 101);
	ASSERT(start <= LEN(x) - len, 102);
	len := start + len;  (* used as top *)
	WHILE start < len DO x[start] := val;  INC(start) END
END Fill;

PROCEDURE FillPat* (count: index;  VAR x: ARRAY OF real;  start, step: index;  	val: real);
BEGIN ASSERT(start >= 0, 100);  ASSERT(count >= 0, 101);
	ASSERT((count - 1) * step <= LEN(x) - start - 1, 102);  	(* cw 21.8.98 *)
	ASSERT(step > 0, 103);
	count := start + count * step;  (* used as top *)
	WHILE start < count DO x[start] := val;  INC(start, step) END
END FillPat;

PROCEDURE Copy* (len: index;
VAR (*IN*)src: ARRAY OF real;  srcstart: index;
	VAR dest: ARRAY OF real;  deststart: index );
BEGIN
	ASSERT(len > 0, 100);
	ASSERT(srcstart <= LEN(src) - len + 1, 101);
	ASSERT(deststart <= LEN(dest) - len + 1, 102);

	vyBase.COPYR(src, srcstart, len, dest, deststart)

END Copy;

PROCEDURE CopyPat* (count: index;  VAR (*IN*)src: ARRAY OF real;  start, step: index;  VAR dest: ARRAY OF real;  deststart, deststep: index);
	VAR i, j, top: index;
BEGIN
	ASSERT((start >= 0) & (deststart >= 0), 100);  ASSERT(count >= 0, 101);
	ASSERT((step > 0) & (deststep > 0), 103);
	ASSERT((start + count * step <= LEN(src))
	 & (deststart + count * deststep <= LEN(dest)), 102);
	i := start;  j := deststart;  top := start + count * step;
	WHILE i < top DO dest[j] := src[i];  INC(i, step);  INC(j, deststep) END
END CopyPat;

PROCEDURE Min* (len: index;  VAR (*IN*)x: ARRAY OF real;  start: index;  VAR minpos: index): real;
	VAR min: real;
BEGIN
	ASSERT(start >= 0, 100);  ASSERT(len >= 0, 101);
	ASSERT(start <= LEN(x) - len, 102);
	min := MAX(real);  minpos := - 1;  len := start + len;
	WHILE start < len DO
		IF x[start] < min THEN min := x[start];  minpos := start END;
	INC(start) END;
	RETURN min
END Min;

PROCEDURE Max* (len: index;  VAR (*IN*)x: ARRAY OF real;  start: index;  VAR maxpos: index): real;
	VAR max: real;
BEGIN
	ASSERT(start >= 0, 100);  ASSERT(len >= 0, 101);
	ASSERT(start <= LEN(x) - len, 102);
	max := MIN(real);  maxpos := - 1;  len := start + len;
	WHILE start < len DO
		IF x[start] > max THEN max := x[start];  maxpos := start END;
	INC(start) END;
	RETURN max
END Max;

PROCEDURE MinMax* (len: index;  VAR (*IN*)x: ARRAY OF real;  start: index;
	VAR min: real;  VAR minpos: index;  VAR max: real;  VAR maxpos: index;  VAR nans: index);
	(*! improve NaN handling *)
BEGIN
	ASSERT(start >= 0, 100);  ASSERT(len >= 0, 101);
	ASSERT(start <= LEN(x) - len, 102);
	nans := 0;  (*! not yet implemented *)

	IF ODD(len) THEN

		IF Reals.IsNaN(x[start]) THEN INC(nans) END;

		max := x[start];  min := max;  minpos := start;  maxpos := start;
		len := len + start;  INC(start)
	ELSE	max := MIN(real);  min := MAX(real);
		minpos := - 1;  maxpos := - 1;  len := len + start
	END;
	WHILE start < len DO
		IF x[start] > x[start + 1] THEN
			IF x[start] > max THEN max := x[start];  maxpos := start END;

			IF Reals.IsNaN(x[start]) THEN INC(nans) END;

			INC(start);
			IF x[start] < min THEN min := x[start];  minpos := start END
		ELSE
			IF x[start] < min THEN min := x[start];  minpos := start END;

			IF Reals.IsNaN(x[start]) THEN INC(nans) END;

			INC(start);
			IF x[start] > max THEN max := x[start];  maxpos := start END
		END;

		IF Reals.IsNaN(x[start]) THEN INC(nans) END;

	INC(start) END
END MinMax;

(* test site to look for high speed low count exchanges *)
PROCEDURE sort5* (VAR data: ARRAY OF real;  start: index);
	(*= Procedure only for test functions *)
BEGIN
	Sort(5, data, start)
END sort5;

PROCEDURE Sort5* (VAR data: ARRAY OF real;  start: index);
BEGIN
	ASSERT(start >= 0, 100);
	ASSERT(start <= LEN(data) - 5, 102);
	sort5(data, start)
END Sort5;

PROCEDURE bt (x1, x2: real): BOOLEAN;
BEGIN

	IF Reals.IsNaN(x1) & ~Reals.IsNaN(x2) THEN RETURN TRUE

	ELSE RETURN (x1 > x2) END
END bt;

PROCEDURE Sort* (count: index;  VAR x: ARRAY OF real;  start: index);  (* vs 0.1d0 gs *)
	(*= Quicksort ist used for normal sorting *)
PROCEDURE LocSort (lo, hi: index);  (* Quicksort *)
	VAR i, j, m: index;  temp: real;
BEGIN
	IF lo < hi THEN i := lo;  j := hi;  m := (lo + hi) DIV 2;
		REPEAT
			WHILE (bt(x[m], x[i]))  DO INC(i) END;
			WHILE (bt(x[ j], x[ m]))  DO DEC(j) END;

			IF i <= j THEN
				IF m = i THEN m := j ELSIF m = j THEN m := i END;
				temp := x[i];  x[i] := x[j];  x[j] := temp;  (*Swap(data, i, j); *)
				(* 970919 fof inserted temp for windows compatibilty (~"too many registers")*)
				INC(i);  DEC(j)
			END
		UNTIL i > j;
		LocSort(lo, j);  LocSort(i, hi)
	END
END LocSort;
BEGIN
	ASSERT(count >= 0, 100);  ASSERT(start >= 0, 101);  	ASSERT(start + count <= LEN(x), 102);
	IF count < 2 THEN RETURN END;
	LocSort(start, start + count - 1)
END Sort;

(*? Is it useful to have two general sorting algorithms? *)
PROCEDURE MergeSort* (count: index;  VAR x: ARRAY OF real;  start: index);  (* Natural Mergesort for normal sorting *)
	(* 	Contact	M. Fuchs <fuchs@statlab.uni-heidelberg.de> *)
PROCEDURE NMerge (lo, hi: index);  (* Natural Mergesort *)
PROCEDURE Merge (l, m, r: index);  	(* Mixing the preorderd Runs *)
	VAR hx : POINTER TO ARRAY OF real;  	(* Arrays to store the datas temporary *)
	h, i, j, k : index;
BEGIN
	NEW(hx, r - l + 1);  	(*Allocation of store *)
	i := l;  j := m + 1;  k := 0;
	WHILE (i <= m) & (j <= r) DO
		IF x[i] <= x[j] THEN
			hx[k] := x[i];  	(* store in the temporary array *)
			INC(i)
		ELSE
			hx[k] := x[j];  	(* store in the temporary array *)
			INC(j)
		END;
		INC(k)
	END;
	IF i > m THEN
		FOR h := j TO r DO
			hx[k + h - j] := x[h] 	(* store the rest of the nonempty run in the temporary array *)
		END
	ELSE
		FOR h := i TO m DO
			hx[k + h - i] := x[h] 	(* store the rest of the nonempty run in the temporary array *)
		END
	END;
	FOR h := l TO r DO
		x[h] := hx[h - l] 	(* restore the sorted run *)
	END
END Merge;

PROCEDURE NMS (l, r: index);  	(* Searching of preorderd runs and merge them *)
	VAR rr, ll, mm: index;
BEGIN
	REPEAT
		rr := l - 1;
		WHILE rr < r DO
			ll := rr + 1;  mm := ll;
			WHILE ((mm < r) & (x[mm] <= x[mm + 1])) DO (* determination of the left run *)
				INC(mm)
			END;
			IF mm < r THEN
				rr := mm + 1;
				WHILE ((rr < r) & (x[rr] <= x[rr + 1])) DO (* determination of the next run *)
					INC(rr)
				END;
				Merge(ll, mm, rr)	(* Mix the preorderd runs *)
			ELSE
				rr := mm
			END
		END
	UNTIL ll = l
END NMS;
BEGIN
	NMS(lo, hi)
END NMerge;
BEGIN
	ASSERT(count >= 0, 100);  ASSERT(start >= 0, 101);  	ASSERT(start + count <= LEN(x), 102);
	IF count < 2 THEN RETURN END;
	NMerge(start, start + count - 1)
END MergeSort;



PROCEDURE SortIndexed* (count: index;  VAR data: ARRAY OF real;  start: index;  VAR Index: ARRAY OF index);
	(*= Natural Mergesort is used for indexed sorting *)
	(*! PROCEDURE should be excluded, because there is a high risk of using it in a wrong way. SortTwoDepArrays could be used instead*)
PROCEDURE NMergeIndexed (lo, hi: index);  (* Natural Mergesort *)
PROCEDURE MergeIndexed (l, m, r: index);  	(* Mixing the preorderd Runs *)
	VAR hdata : POINTER TO ARRAY OF real;
	hindex : POINTER TO ARRAY OF index;  	(* Arrays to store the datas temporary *)
	h, i, j, k : index;
BEGIN
	NEW(hdata, r - l + 1);  NEW(hindex, r - l + 1);  	(*Allocation of store *)
	i := l;  j := m + 1;  k := 0;
	WHILE (i <= m) & (j <= r) DO
		(*IF data[i]<=data[j] THEN*)IF ~bt(data[i], data[j]) THEN
		hdata[k] := data[i];  hindex[k] := Index[i];  (* store in the temporary array *)
		INC(i)
	ELSE
		hdata[k] := data[j];  hindex[k] := Index[j];  (* store in the temporary array *)
		INC(j)
	END;
	INC(k)
END;
IF i > m THEN
	FOR h := j TO r DO
		hdata[k + h - j] := data[h];  hindex[k + h - j] := Index[h] 	(* store the rest of the nonempty run in the temporary array *)
	END
ELSE
	FOR h := i TO m DO
		hdata[k + h - i] := data[h];  hindex[k + h - i] := Index[h] 	(* store the rest of the nonempty run in the temporary array *)
	END
END;
FOR h := l TO r DO
	data[h] := hdata[h - l];  Index[h] := hindex[h - l] 	(* restore the sorted run *)
END
END MergeIndexed;

PROCEDURE NMSIndexed (l, r: index);  	(* Searching of preorderd runs and merge them *)
	VAR rr, ll, mm: index;
BEGIN
	REPEAT
		rr := l - 1;
		WHILE rr < r DO
			ll := rr + 1;  mm := ll;
			(*WHILE ((mm<r) & (data[mm]<=data[mm+1])) DO *)WHILE ((mm < r) & ~bt(data[mm], data[mm + 1])) DO (* determination of the left run *)
			INC(mm)
		END;
		IF mm < r THEN
			rr := mm + 1;
			(*WHILE ((rr<r) & (data[rr]<=data[rr+1])) DO*)WHILE ((rr < r) & ~bt(data[rr], data[rr + 1])) DO (* determination of the next run *)
			INC(rr)
		END;
		MergeIndexed(ll, mm, rr)	(* Mix the preorderd runs *)
	ELSE
		rr := mm
	END
END
UNTIL ll = l
END NMSIndexed;
BEGIN
	NMSIndexed(lo, hi)
END NMergeIndexed;
BEGIN
	ASSERT(count >= 0, 100);  ASSERT(start >= 0, 101);  ASSERT(start + count <= LEN(data), 102);
	ASSERT(LEN(Index) = LEN(data), 103);
	IF count < 2 THEN RETURN END;
	NMergeIndexed(start, start + count - 1)
END SortIndexed;

(*! add procedure based sorts if necessary *)
PROCEDURE SortTwoDepArrays* (VAR reg, resp: ARRAY OF real);
	VAR help: POINTER TO ARRAY OF real;
	indicator: POINTER TO ARRAY OF index;
	i, len: index;
BEGIN
	len := LEN(reg);
	NEW(indicator, len); NEW(help, len);
	FOR i := 0 TO len - 1 DO
		indicator[i] := i;
		help[i] := resp[i]
	END;
	SortIndexed(len, reg, 0, indicator^);
	FOR i := 0 TO len - 1 DO
		resp[i] := help[indicator[i]]
	END
END SortTwoDepArrays;

PROCEDURE Order* (count: index;  x: ARRAY OF real;  start: index;  ith: index): real;
PROCEDURE LocSort (lo, hi: index;  order: index): real;
	(* Quicksort *)
	VAR i, j, m, k: index;  temp: real;
BEGIN
	IF lo >= hi THEN RETURN x[lo] END;
	(*! partititon. return by randomized partition lo hi *)
	IF lo < hi THEN i := lo;  j := hi;  m := (lo + hi) DIV 2;
		REPEAT
			WHILE (x[i] < x[m]) DO INC(i) END;
			WHILE (x[ m] < x[ j]) DO DEC(j) END;
			IF i <= j THEN
				IF m = i THEN m := j ELSIF m = j THEN m := i END;
				temp := x[i];  x[i] := x[j];  x[j] := temp;  (*Swap(data, i, j); *)
				(* 970919 fof inserted temp for windows compatibilty (~"too many registers")*)
				INC(i);  DEC(j)
			END
		UNTIL i > j;
		(* end randomized partition *)
		IF j < lo THEN	INC(j)	END;  	(*	Gruss von Lutz 20.3.96	*)
		k := j - lo + 1;
		IF order <= k THEN RETURN LocSort(lo, j, order)
		ELSE
			RETURN LocSort(j + 1, hi, order - k)
		END
	END END LocSort;

BEGIN
	(*Corman et al. Algorithms., 10.2 *)
	ASSERT(count >= 0, 100);  ASSERT(start >= 0, 101);  	ASSERT(start + count <= LEN(x), 102);
	IF count < 2 THEN RETURN x[start] END; 	(*	Gruss von Lutz 20.3.96	*)
	RETURN LocSort(start, start + count - 1, ith)
END Order;

PROCEDURE Summary* (len: index;  VAR x: ARRAY OF real;  start: index;  VAR min, max, mean, ssq: LONGREAL);  (* vs 0.1d0 gs *)
	(* One pass summary *)
	(*! unroll to use pairs *)
	VAR i, top: index;  Xdiff: LONGREAL;  xx: real;
BEGIN
	min := MAX(real);  max := MIN(real);  mean := 0;  ssq := 0;
	i := start;  top := start + len;
	WHILE i < top DO xx := x[i];
		IF xx > max THEN max := xx END;
		IF xx < min THEN min := xx END;
		(* Provisional means *)
		Xdiff := xx - mean;
		mean := mean + Xdiff / (i + 1 - start);
		ssq := ssq + Xdiff * (xx - mean);
	INC(i) END
END Summary;

PROCEDURE MeanSSq* (len: index;  VAR x: ARRAY OF real;  start: index;  VAR mean, ssq: LONGREAL; VAR nans: index);
	VAR i, top: index;  Xdiff: LONGREAL;  xx: real;
BEGIN
	nans := 0;  (*! not yet supported *)
	mean := 0;  ssq := 0;
	i := start;  top := start + len;
	WHILE i < top DO xx := x[i];
		(* Provisional means *)
		Xdiff := xx - mean;
		mean := mean + Xdiff / (i + 1 - start);
		ssq := ssq + Xdiff * (xx - mean);
	INC(i) END
END MeanSSq;

(** Predeclared functions *)
PROCEDURE Abs* (len: index;  VAR x: ARRAY OF real;  start: index);
	VAR i, top: index;
BEGIN ASSERT(start >= 0, 100);  ASSERT(len >= 0, 101);
	ASSERT(start + len <= LEN(x), 102);
	i := start;  top := start + len;
	WHILE i < top DO x[i] := ABS(x[i]);  INC(i) END
END Abs;

(** Vector-Scalar operations *)
PROCEDURE AddConst* (len: index;  VAR x: ARRAY OF real;  start: index;  	y: real);
	VAR i, top: index;
BEGIN ASSERT(start >= 0, 100);  ASSERT(len >= 0, 101);
	ASSERT(start + len <= LEN(x), 102);
	i := start;  top := start + len;
	WHILE i < top DO x[i] := x[i] + y;  INC(i) END
END AddConst;

PROCEDURE AddConstPat* (count: index;  VAR x: ARRAY OF real;  start, step: index;  	y: real);
	(*! test this procedure *)
	(*! klären, ob ASSERT 102 als bedingung nicht start+count*step<=LEN(x) braucht (so wie in CopyPat bzw. FillPat) *)
	VAR i, top: index;
BEGIN ASSERT(start >= 0, 100);  ASSERT(count >= 0, 101);
	ASSERT(start + (count - 1) * step + 1 <= LEN(x), 102);
	ASSERT(step > 0, 103);
	i := start;  top := start + count * step;
	WHILE i < top DO x[i] := x[i] + y;  INC(i, step) END
END AddConstPat;

PROCEDURE SubConst* (len: index;  VAR x: ARRAY OF real;  start: index;  	y: real);
BEGIN
	AddConst(len, x, start, (- 1) * y)
END SubConst;

PROCEDURE SubConstPat* (count: index;  VAR x: ARRAY OF real;  start, step: index;  y: real);
BEGIN
	AddConstPat(count, x, start, step, (- 1) * y)
END SubConstPat;

PROCEDURE MulConst* (len: index;  VAR x: ARRAY OF real;  start: index;  fact: real );
	VAR i, top: index;
BEGIN ASSERT(start >= 0, 100);  ASSERT(len >= 0, 101);
	ASSERT(start + len <= LEN(x), 102);
	i := start;  top := start + len;
	WHILE i < top DO x[i] := x[i] * fact;  INC(i) END
END MulConst;

PROCEDURE MulConstPat* (count: index;  VAR x: ARRAY OF real;  start, step: index;  fact: real );
	(*! ASSERT 102 klären, siehe AddConstPat *)
	(*! test this procedure *)
	VAR i, top: index;
BEGIN ASSERT(start >= 0, 100);  ASSERT(count >= 0, 101);
	ASSERT(start + (count - 1) * step + 1 <= LEN(x), 102);
	ASSERT(step > 0, 103);
	i := start;  top := start + count * step;
	WHILE i < top DO x[i] := x[i] * fact;  INC(i, step) END
END MulConstPat;

PROCEDURE DivConst* (len: index;  VAR x: ARRAY OF real;  start: index;  divisor: real );
BEGIN
	MulConst(len, x, start, 1 / divisor)
END DivConst;

PROCEDURE DivConstPat* (count: index;  VAR x: ARRAY OF real;  start, step: index;  divisor: real);
BEGIN
	MulConstPat(count, x, start, step, 1 / divisor)
END DivConstPat;

PROCEDURE Scale* (len: index;  VAR x: ARRAY OF real;  start: index;  offs, factor: real );
	(*= x[ ]:=x[ ]*factor+offs *)
	VAR i, top: index;
BEGIN
	IF factor = 1 THEN AddConst(len, x, start, offs)
	ELSIF
		offs = 0 THEN MulConst(len, x, start, factor)
	ELSE
		ASSERT(start >= 0, 100);  ASSERT(len >= 0, 101);  ASSERT(start + len <= LEN(x), 102);
		i := start;  top := start + len;
		WHILE i < top DO x[i] := x[i] * factor + offs;  INC(i) END
	END
END Scale;

PROCEDURE ScalePat* (count: index;  VAR x: ARRAY OF real;  start, step: index;  offs, factor: real );
	(*! ASSERT 102 klären, siehe AddConstPat *)
	(*! test This procedure *)
	(*= x[ ]:=x[ ]*factor+offs *)
	VAR i, top: index;
BEGIN
	IF factor = 1 THEN AddConstPat(count, x, start, step, offs)
	ELSIF
		offs = 0 THEN MulConstPat(count, x, start, step, factor)
	ELSE
		ASSERT(start >= 0, 100);  ASSERT(count >= 0, 101);  ASSERT(start + (count - 1) * step + 1 <= LEN(x), 102);
		i := start;  top := start + count * step;
		WHILE i < top DO x[i] := x[i] * factor + offs;  INC(i, step) END
	END
END ScalePat;

(** Vector-Vector operations, assuming equivalent vectors. Interface may change!!! *)
(*= assuming equivalent vectors. Interface may change!!! *)


PROCEDURE Add* (VAR (*IN*)x, (*IN*)y: ARRAY OF real;  VAR z: ARRAY OF real;  len: index );
	VAR i: index;  temp: real;
BEGIN
	i := 0;  WHILE i < len DO temp := x[i] + y[i];  z[i] := temp;  INC(i) END
	(* 970919 fof inserted temp for windows compatibilty (~"too many registers")*)
END Add;

PROCEDURE Sub* (VAR (*IN*)x, (*IN*)y: ARRAY OF real;  VAR z: ARRAY OF real;  len: index );
	VAR i: index;  temp: real;
BEGIN
	i := 0;  WHILE i < len DO temp := x[i] - y[i];  z[i] := temp;   INC(i) END
	(* 970919 fof inserted temp for windows compatibilty (~"too many registers")*)
END Sub;

PROCEDURE Mul* (VAR (*IN*)x, (*IN*)y: ARRAY OF real;  VAR z: ARRAY OF real;  len: index );
	VAR i: index;  temp: real;
BEGIN
	i := 0;  WHILE i < len DO temp := x[i] * y[i];  z[i] := temp;  INC(i) END
	(* 970919 fof inserted temp for windows compatibilty (~"too many registers")*)
END Mul;

PROCEDURE Div* (VAR (*IN*)x, (*IN*)y: ARRAY OF real;  VAR z: ARRAY OF real;  len: index );
	VAR i: index;  temp: real;
BEGIN
	i := 0;  WHILE i < len DO temp := x[i] / y[i];  z[i] := temp;  INC(i) END
	(* 970919 fof inserted temp for windows compatibilty (~"too many registers")*)
END Div;

PROCEDURE SSQxy* (VAR (*IN*)x, (*IN*)y: ARRAY OF real;
	mx, my: LONGREAL;
	len: index): LONGREAL;  (* vs 0.1d0 gs *)
	VAR i: index;  s: LONGREAL;
BEGIN
	s := 0;  i := 0;  WHILE i < len DO s := s + (x[i] - mx) * (y[i] - my);  INC(i) END;
	RETURN s
END SSQxy;

(** 2D support *)
PROCEDURE Get2d* (VAR (*IN*)x: ARRAY OF real;  rows, row, column: index): real;
BEGIN
	ASSERT(rows >= row);
	RETURN x[row * rows + column]
END Get2d;

PROCEDURE Set2d* (VAR x: ARRAY OF real;  rows, row, column: index;  val: real);
BEGIN
	ASSERT(rows >= row);
	x[row * rows + column] := val
END Set2d;

PROCEDURE Get2dM* (VAR (*IN*)x: ARRAY OF real;
	rowoffset, coloffset, nrrows, nrcolumns: index;  VAR dest: ARRAY OF ARRAY OF real);
	(*= Copy a 1-dim array as nrrows,nrcolumns submatrix into dest *)
	VAR i, j, k: index;
BEGIN	k := 0;
	FOR i := rowoffset TO rowoffset + nrrows DO
		FOR j := coloffset TO coloffset + nrcolumns DO dest[i, j] := x[k];  INC(k)
		END
	END
END Get2dM;

PROCEDURE Set2dM* (VAR x: ARRAY OF real;
rowoffset, coloffset, nrrows, nrcolumns: index;  VAR (*IN*)src: ARRAY OF ARRAY OF real);
	(*= Set a 1-dim array as nrrows,nrcolumns submatrix from src *)
	VAR i, j, k: index;
BEGIN 	k := 0;
	FOR i := rowoffset TO rowoffset + nrrows DO
		FOR j := coloffset TO coloffset + nrcolumns DO x[k] := src[i, j];  INC(k)
		END
	END
END Set2dM;

(*? 2D support - FORTRAN-like. Are these needed ?*)
PROCEDURE Get2dF* (VAR (*IN*)x: ARRAY OF real;  columns, row, column: index): real;
BEGIN
	ASSERT(columns >= column);
	RETURN x[row + column * columns]
END Get2dF;

PROCEDURE Set2dF* (VAR x: ARRAY OF real;  columns, row, column: index;  val: real);
BEGIN
	ASSERT(columns >= column);
	x[row + column * columns] := val
END Set2dF;

(*PROCEDURE SkalProd* (len: index; VAR (*IN*) x: ARRAY OF real; xstart: index;
VAR (*IN*) y: ARRAY OF real; ystart: index): LONGREAL;
(*! replace by BLAS1.SDOT*)
(*=  scalar product <x,y> *)
VAR prod: LONGREAL;
BEGIN
ASSERT(xstart >= 0, 100); ASSERT(ystart >= 0, 101); ASSERT(len >= 0, 102);
ASSERT(xstart + len <= LEN(x), 103); ASSERT(ystart + len <= LEN(y), 104);
prod := 0;
WHILE len > 0 DO prod := prod + x[xstart] * y[ystart]; INC(xstart); INC(ystart); DEC(len) END;
RETURN prod
END SkalProd;
*)
PROCEDURE SkalProd* (len: index;  VAR (* IN *)x: ARRAY OF real;  xstart: index;
	VAR (* IN *)y: ARRAY OF real;  ystart: index): LONGREAL;

	(* cw 23.8.98 algorithm taken from BLAS1D and split up into
	SkalProd and SkalProdPat; xstart, ystart added
	the following variable names have been changed :
	N -> count;	DX -> x;	DY -> y;	INCX -> xstep;	INCY -> ystep
	DTEMP -> temp;	I -> i;	M -> m;
	if you call this procedure with len<0 the program will be stopped by an ASSERT	*)

	(*=     forms the dot product of two vectors.
	uses unrolled loops for increments equal to one.
	jack dongarra, linpack, 3/11/78.
	modified 12/3/93, array(1) declarations changed to array( * )*)

	VAR temp: LONGREAL; 	i, m: index;
BEGIN
	ASSERT(xstart >= 0, 100); 	ASSERT(ystart >= 0, 101); 	ASSERT(len >= 0, 102);
	ASSERT(xstart + len <= LEN(x), 103); 	ASSERT(ystart + len <= LEN(y), 104);
	temp := 0.0D0;
	(*        code for unequal increments or equal increments
	not equal to 1*)
	IF len = 0 THEN RETURN temp END;
	m := len MOD 5;
	IF m # 0 THEN
		FOR i := xstart TO xstart + m - 1 DO
			temp := temp + x[i] * y[i]
		END;  (* FOR CONTINUE *)
		IF len < 5 THEN RETURN temp END
	END;
	FOR i := m + xstart TO xstart + len - 1 BY 5 DO
		temp := temp + x[i] * y[i] + x[i + 1] * y[i + 1] + x[i + 2] * y[i + 2] + x[i + 3] * y[i + 3] +
		x[i + 4] * y[i + 4]
	END;  (* FOR CONTINUE *)
	RETURN temp
END SkalProd;

PROCEDURE SkalProdPat* (count: index; VAR x: ARRAY OF real;  xstart, xstep: index;
VAR y: ARRAY OF real;  ystart, ystep: index): LONGREAL;

	(* cw 23.8.98 algorithm taken from BLAS1D and split up into
	SkalProd and SkalProdPat; xstart, ystart added
	the following variable names have been changed:
	N -> count;	DX -> x;	DY -> y;	INCX -> xstep;	INCY -> ystep
	DTEMP -> temp;	I -> i;	IX -> xstart;	IY -> ystart;	M -> m;
	another change to BLAS1D: xstep<=0 and ystep<=0 is not supported
	a call to this procedure with len<0 stops the program by an ASSERT	*)

	(*=     forms the dot product of two vectors.
	uses unrolled loops for increments equal to one.
	jack dongarra, linpack, 3/11/78.
	modified 12/3/93, array(1) declarations changed to array( * )*)

	VAR temp: LONGREAL;
	VAR i: index;

BEGIN
	ASSERT(xstart >= 0, 100); 	ASSERT(ystart >= 0, 101); 	ASSERT(count >= 0, 102);
	ASSERT(xstep > 0, 103); 	ASSERT(ystep > 0, 104);
	ASSERT(xstart + (count - 1) * xstep + 1 <= LEN(x), 105);
	ASSERT(ystart + (count - 1) * ystep + 1 <= LEN(y), 106);
	temp := 0.0D0;
	IF count = 0 THEN RETURN temp END;
	(*        code for unequal increments or equal increments
	not equal to 1*)
	FOR i := 1 TO count DO
		temp := temp + x[xstart] * y[ystart];
		INC(xstart, xstep);  INC(ystart, ystep)
	END;  (* FOR CONTINUE *)
	RETURN temp
END SkalProdPat;
(*
PROCEDURE Norm2Sq* (len: index; VAR (*IN*) x: ARRAY OF real; xstart: index): LONGREAL;
(*! replace by BLAS1.SNORM2*)
(*= Square of L2-Norm of x *)
VAR prod: LONGREAL;
BEGIN
ASSERT(xstart >= 0, 100); ASSERT(len >= 0, 101);
ASSERT(xstart + len <= LEN(x), 102);
prod := 0;
WHILE len > 0 DO prod := prod + x[xstart] * x[xstart]; INC(xstart); DEC(len) END;
RETURN prod
END Norm2Sq;

PROCEDURE Dist2Sq* (len: index; VAR (*IN*) x: ARRAY OF real; xstart: index; VAR (*IN*) y: ARRAY OF real; ystart: index): LONGREAL;
(*! replace by BLAS1.SNORM2 modified*)
(*= Square of L2-Norm of x-y *)
VAR prod, delta: LONGREAL;
BEGIN
ASSERT(xstart >= 0, 100); ASSERT(ystart >= 0, 101); ASSERT(len >= 0, 102);
ASSERT(xstart + len <= LEN(x), 103); ASSERT(ystart + len <= LEN(y), 104);
prod := 0;
WHILE len > 0 DO delta := x[xstart] - y[ystart];
prod := prod + delta * delta; INC(xstart); INC(ystart); DEC(len) END;
RETURN prod
END Dist2Sq;
*)
PROCEDURE Norm2Sq* (len: index;  VAR (* IN *)x: ARRAY OF real;  xstart: index): LONGREAL;

	(* cw 24.8.98 algorithm DNRM2 taken from BLAS1D
	changes:	increment = 1 and #1 -> two distinct procedures
	variables: N _> len; X _> x; IX -> i;	ABSXI -> absx;	capital letters -> small letters
	xstart new;	returns no longer the euclidean norm but its square
	if the procedure is called with len<0 the program will be stopped by an ASSERT	*)

	(*=  DNRM2 returns the euclidean norm of a vector via the function name, so that
	DNRM2 := sqrt( x'*x )
	-- This version written on 25-October-1982.
	Modified on 14-October-1993 to inline the call to DLASSQ.
	Sven Hammarling, Nag Ltd.
	.. Parameters ..*)
CONST ONE = 1.0D0;
	ZERO = 0.0D0;
	(*     .. Local Scalars ..*)
	VAR absx, end, scale, ssq, temp: LONGREAL;
	(*     ..    Executable Statements ..*)
BEGIN
	ASSERT(xstart >= 0, 100); 	ASSERT(len >= 0, 101); 	end :=  xstart + len ; 	ASSERT(end <= LEN(x), 102);
	IF len = 0 THEN RETURN ZERO END;
	IF len = 1 THEN
		RETURN x[xstart] * x[xstart]
	ELSE
		scale := ZERO;
		ssq := ONE;
		(*        The following loop is equivalent to this call to the LAPACK
		auxiliary routine:
		CALL DLASSQ(len, x, 1, scale, ssq ) (1=xstep)*)
		(* changes to the BLAS1D routine : I _> xstart; WHILE I<=end
		-> WHILE xtsart < end *)
		WHILE xstart < end DO
			IF x[xstart] # ZERO THEN
				absx := ABS(x[xstart]);
				IF scale < absx THEN
					temp := 1 / absx;
					ssq := ONE + ssq * (scale * temp) * (scale * temp);
					scale := absx
				ELSE
					ssq := ssq + (absx * temp) * (absx * temp)
				END (* IF*)
			END (* IF*);
			INC(xstart)
		END;  (* FOR CONTINUE *)
		RETURN scale * scale * ssq
	END;  (* IF*)
	(*     End of DNRM2.*)
END Norm2Sq;

PROCEDURE Norm2SqPat* (count: index;  VAR (* IN *)x: ARRAY OF real;  xstart, xstep: index): LONGREAL;

	(* cw 25.8.98 algorithm DNRM2 taken from BLAS1D and separated into a
	"normal" and a pattern version
	variables: N _> count; X _> x; IX -> i;	ABSXI -> absx;	XINC -> xstep;	capital letters -> small letters
	xstart added; returns no longer the euclidean Norm but its square
	xstep<=0 and ystep <=0 are no longer supported; count<0 is also forbidden	*)

	(*=  DNRM2 returns the euclidean norm of a vector via the function  name, so that
	DNRM2 := sqrt( x'*x )
	-- This version written on 25-October-1982.
	Modified on 14-October-1993 to inline the call to DLASSQ.
	Sven Hammarling, Nag Ltd.
	.. Parameters ..*)
CONST ONE = 1.0D0;
	ZERO = 0.0D0;
	(*     .. Local Scalars ..*)
	VAR absx, end, scale, ssq, temp: LONGREAL;
	(*     ..
	.. Executable Statements ..*)
BEGIN
	ASSERT(xstart >= 0, 100); 	ASSERT(count >= 0, 101); 	ASSERT(xstep > 0, 103);
	end := xstart + (count - 1) * xstep + 1; 	ASSERT(end <= LEN(x), 102);
	IF count = 0 THEN RETURN ZERO END;
	IF count = 1 THEN
		RETURN x[xstart] * x[xstart]
	ELSE
		scale := ZERO;
		ssq := ONE;
		(*        The following loop is equivalent to this call to the LAPACK
		auxiliary routine:
		CALL DLASSQ(count, x, xstep, scale, ssq )*)
		WHILE xstart < end DO
			IF x[xstart] # ZERO THEN
				absx := ABS(x[xstart]);
				IF scale < absx THEN
					temp := 1 / absx;
					ssq := ONE + ssq * (scale * temp) * (scale * temp);
					scale := absx
				ELSE
					ssq := ssq + (absx * temp) * (absx * temp)
				END (* IF*)
			END (* IF*);
			INC(xstart, xstep)
		END;  (* FOR CONTINUE *)
		RETURN scale * scale * ssq
	END;  (* IF*)
	(*     End of DNRM2.*)
END Norm2SqPat;

PROCEDURE Dist2Sq* (len: index;  VAR (* IN *)x: ARRAY OF real;  xstart: index;
	VAR (* IN *)y: ARRAY OF real;  ystart: index): LONGREAL;

	(* cw 28.8.98 algorithm DNRM2 taken from BLAS1D and modified for euclidean distance
	changes:	increment = 1 and #1 -> two distinct procedures
	variables: N _> len; X _> x; IX -> i;	ABSXI -> absx;	capital characters -> characters
	xstart,ystart new;	returns no longer the euclidean distance but its square
	len<0 is forbidden	*)

	(*=  DNRM2 returns the euclidean norm of a vector via the function
	name, so that
	DNRM2 := sqrt( x'*x )

	-- This version written on 25-October-1982.
	Modified on 14-October-1993 to inline the call to DLASSQ.
	Sven Hammarling, Nag Ltd.
	.. Parameters ..*)
CONST ONE = 1.0D0;
	ZERO = 0.0D0;
	(*     .. Local Scalars ..*)
	VAR absx, end, scale, ssq, temp, temp1: LONGREAL;
	(*     ..
	.. Executable Statements ..*)
BEGIN
	ASSERT(xstart >= 0, 100); 	ASSERT(len >= 0, 102); 	end :=  xstart + len ; 	ASSERT(end <= LEN(x), 103);
	ASSERT(ystart >= 0, 101); 	ASSERT(ystart + len <= LEN(x), 104);
	IF len = 0 THEN RETURN ZERO END;
	IF len = 1 THEN
		RETURN (x[xstart] - y[ystart]) * (x[xstart] - y[ystart])
	ELSE
		scale := ZERO;
		ssq := ONE;
		(*        The following loop is equivalent to this call to the LAPACK
		auxiliary routine:
		CALL DLASSQ(len, x, 1, scale, ssq ) (1=xstep)*)
		(* changes to the BLAS1D routine : I _> xstart; WHILE I<=end
		-> WHILE xtsart < end *)
		WHILE xstart < end DO
			temp1 := x[xstart] - y[ystart];
			IF temp1 # ZERO THEN
				absx := ABS(temp1);
				IF scale < absx THEN
					temp := 1 / absx;
					ssq := ONE + ssq * (scale * temp) * (scale * temp);
					scale := absx
				ELSE
					ssq := ssq + (absx * temp) * (absx * temp)
				END (* IF*)
			END (* IF*);
			INC(xstart);  INC(ystart)
		END;  (* FOR CONTINUE *)
		RETURN scale * scale * ssq
	END;  (* IF*)
	(*     End of DNRM2.*)
END Dist2Sq;

PROCEDURE Dist2SqPat* (count: index;  VAR (* IN *)x: ARRAY OF real;  xstart, xstep: index;
	VAR (* IN *)y: ARRAY OF real;  ystart, ystep: index): LONGREAL;

	(* cw 28.8.98 algorithm DNRM2 taken from BLAS1D and separated into
	a "INCX=INCY=1" (i. e. xstep=ystep=1) and a "Pat" (i. e. Pattern) version
	variables: N _> count; X _> x; IX -> i;	ABSXI -> absx;	XINC -> xstep;	capital latters -> small letters
	xstart,ystart added; returns not the euclidean distance, but its square
	xstep or ystep<=0 is no longer supported; count<0 is also forbidden	*)

	(*=  DNRM2 returns the euclidean norm of a vector via the function
	name, so that
	DNRM2 := sqrt( x'*x )
	-- This version written on 25-October-1982.
	Modified on 14-October-1993 to inline the call to DLASSQ.
	Sven Hammarling, Nag Ltd.
	.. Parameters ..*)
CONST ONE = 1.0D0;
	ZERO = 0.0D0;
	(*     .. Local Scalars ..*)
	VAR absx, end, scale, ssq, temp, temp1: LONGREAL;
	(*     ..
	.. Executable Statements ..*)
BEGIN
	ASSERT(xstart >= 0, 100); 	ASSERT(ystart >= 0, 101); 	ASSERT(count >= 0, 102); 	ASSERT(xstep > 0, 103);
	ASSERT(ystep > 0, 104); 	end := xstart + (count - 1) * xstep + 1;
	ASSERT(end <= LEN(x), 105); 	ASSERT(ystart + (count - 1) * ystep + 1 <= LEN(y), 106);
	IF count = 0 THEN RETURN ZERO END;
	IF count = 1 THEN
		RETURN (x[xstart] - y[ystart]) * (x[xstart] - y[ystart])
	ELSE
		scale := ZERO;
		ssq := ONE;
		(*        The following loop is equivalent to this call to the LAPACK
		auxiliary routine:
		CALL DLASSQ(count, x, xstep, scale, ssq )*)
		WHILE xstart < end DO
			temp1 := x[xstart] - y[ystart];
			IF temp1 # ZERO THEN
				absx := ABS(temp1);
				IF scale < absx THEN
					temp := 1 / absx;
					ssq := ONE + ssq * (scale * temp) * (scale * temp);
					scale := absx
				ELSE
					ssq := ssq + (absx * temp) * (absx * temp)
				END (* IF*)
			END (* IF*);
			INC(xstart, xstep);  INC(ystart, ystep)
		END;  (* FOR CONTINUE *)
		RETURN scale * scale * ssq
	END;  (* IF*)
	(*     End of DNRM2.*)
END Dist2SqPat;

PROCEDURE Norm1* (len: index;  VAR (*IN*)x: ARRAY OF real;  xstart: index): LONGREAL;
	(*= L1-Norm of x *)
	VAR prod: LONGREAL; 	top: 	index;
BEGIN
	ASSERT(xstart >= 0, 100);  ASSERT(len >= 0, 101);
	top := xstart + len;
	ASSERT(top <= LEN(x), 102);
	prod := 0;
	WHILE top > xstart DO prod := prod + ABS(x[xstart]);  INC(xstart) END;
	RETURN prod
END Norm1;
PROCEDURE Norm1Pat* (count: index;  VAR (*IN*)x: ARRAY OF real;  xstart, xstep: index): LONGREAL;
	(*= L1-Norm of x *)
	VAR prod: LONGREAL;
	top: 	index;
BEGIN
	ASSERT(xstart >= 0, 100); 	ASSERT(count >= 0, 101); 	ASSERT(xstep > 0, 102);
	top := xstart + (count - 1) * xstep + 1;
	ASSERT(top <= LEN(x), 103);
	prod := 0;
	WHILE top > xstart DO prod := prod + ABS(x[xstart]);  INC(xstart, xstep)  END;
	RETURN prod
END Norm1Pat;

PROCEDURE Dist1* (len: index;  VAR (*IN*)x: ARRAY OF real;  xstart: index;  VAR (*IN*)y: ARRAY OF real;  ystart: index): LONGREAL;
	(*= L1-Norm of x-y *)
	VAR dist: LONGREAL; 	top: 	index;
BEGIN
	ASSERT(xstart >= 0, 100);  ASSERT(ystart >= 0, 101);  ASSERT(len >= 0, 102); top := xstart + len;
	ASSERT(top <= LEN(x), 103);  ASSERT(ystart + len <= LEN(y), 104);
	dist := 0;
	WHILE top > xstart DO
	dist := dist + ABS(x[xstart] - y[ystart]);  INC(xstart);  INC(ystart) END;
	RETURN dist
END Dist1;
PROCEDURE Dist1Pat* (count: index;  VAR (*IN*)x: ARRAY OF real;  xstart, xstep: index;
	VAR (*IN*)y: ARRAY OF real;  ystart, ystep: index): real;
	(*= L1-Norm of x-y *)
	(* cw 2.9.98 *)
	VAR dist: real;
	top: 	index;
BEGIN
	ASSERT(xstart >= 0, 100); 	ASSERT(ystart >= 0, 101); 	ASSERT(count >= 0, 102);
	ASSERT(xstep > 0, 103); 	ASSERT(ystep > 0, 104); 	top := xstart + (count - 1) * xstep + 1;
	ASSERT(top <= LEN(x), 105);  ASSERT(ystart + (count - 1) * ystep + 1 <= LEN(y), 104);
	dist := 0;
	WHILE top > xstart DO
	dist := dist + ABS(x[xstart] - y[ystart]);  INC(xstart, xstep);  INC(ystart, ystep)  END;
	RETURN dist
END Dist1Pat;

PROCEDURE NormSup* (len: index;  VAR (*IN*)x: ARRAY OF real;  xstart: index;  VAR mindist: LONGREAL): LONGREAL;
	(*! Find out, if ASSERT- trap codes may be changed (102 -> 101; 103 -> 102)*)
	(*= supNorm of x; min absolute dist is reported as additional result *)

	VAR dist, maxdist: LONGREAL;
	top: 	index;
BEGIN
	ASSERT(xstart >= 0, 100); 	ASSERT(len >= 0, 102);
	top := xstart + len;
	ASSERT(top <= LEN(x), 103);
	maxdist := 0; 	mindist := MAX(LONGREAL);
	WHILE top > xstart DO
		dist := ABS(x[xstart]);
		IF dist < mindist THEN mindist := dist END;  IF dist > maxdist THEN maxdist := dist END;
		INC(xstart)
	END;
	RETURN maxdist
END NormSup;

PROCEDURE NormSupPat* (count: index;  VAR (*IN*)x: ARRAY OF real;  xstart, xstep: index;  VAR mindist: real): real;
	(*= supNorm of x; min absolute dist is reported as additional result *)
	(* cw 2.9.98 *)
	VAR dist, maxdist: real;
	top: 	index;
BEGIN
	ASSERT(xstart >= 0, 100); 	ASSERT(count >= 0, 101); 	ASSERT(xstep > 0, 102);
	top := xstart + (count - 1) * xstep + 1;
	ASSERT(top <= LEN(x), 103);
	maxdist := 0; 	mindist := MAX(real);
	WHILE top > xstart DO
		dist := ABS(x[xstart]);
		IF dist < mindist THEN mindist := dist END;  IF dist > maxdist THEN maxdist := dist END;
		INC(xstart, xstep)
	END;
	RETURN maxdist
END NormSupPat;

PROCEDURE DistSup* (len: index;  VAR (*IN*)x: ARRAY OF real;  xstart: index;  VAR (*IN*)y: ARRAY OF real;  ystart: index;
	VAR mindist: LONGREAL): LONGREAL;
	(*= supNorm of x-y; min absolute dist is reported as additional result *)
	VAR dist, maxdist: LONGREAL; 	top: 	index;
BEGIN
	ASSERT(xstart >= 0, 100);  ASSERT(ystart >= 0, 101);  ASSERT(len >= 0, 102);
	top := xstart + len;
	ASSERT(top <= LEN(x), 103);  ASSERT(ystart + len <= LEN(y), 104);
	maxdist := 0; mindist := MAX(LONGREAL);
	WHILE top > xstart  DO
		dist := ABS(x[xstart] - y[ystart]);
		IF dist < mindist THEN mindist := dist END;  IF dist > maxdist THEN maxdist := dist END;
		INC(xstart); 	INC(ystart)
	END;
	RETURN maxdist
END DistSup;
PROCEDURE DistSupPat* (count: index;  VAR (*IN*)x: ARRAY OF real;  xstart, xstep: index;
	VAR (*IN*)y: ARRAY OF real;  ystart, ystep: index;
	VAR mindist: LONGREAL): LONGREAL;
	(*= supNorm of x-y; min absolute dist is reported as additional result *)
	(* cw 2.9.98 *)
	VAR dist, maxdist: LONGREAL;
	top: 	index;
BEGIN
	ASSERT(xstart >= 0, 100);  ASSERT(ystart >= 0, 101);  ASSERT(count >= 0, 102);
	ASSERT(xstep > 0, 103); 	ASSERT(ystep > 0, 104); 	top := xstart + (count - 1) * xstep + 1;
	ASSERT(top <= LEN(x), 105); 	ASSERT(ystart + (count - 1) * ystep + 1 <= LEN(y), 104);
	maxdist := 0; 	mindist := MAX(LONGREAL);
	WHILE top > xstart DO
		dist := ABS(x[xstart] - y[ystart]);
		IF dist < mindist THEN mindist := dist END;  IF dist > maxdist THEN maxdist := dist END;
		INC(xstart, xstep); 	INC(ystart, ystep)
	END;
	RETURN maxdist
END DistSupPat;

PROCEDURE Entier* (len: index;  VAR x: ARRAY OF real;  start: index;  offs, factor: real;  VAR result: ARRAY OF index);
	(*=  result[ ]:=ENTIER(offs+x[ ]*factor) *)
	VAR end: index;
BEGIN
	ASSERT(start >= 0, 100);  ASSERT(len >= 0, 101);
	IF len = 0 THEN RETURN END;
	end := start + len;
	IF offs = 0 THEN
		IF factor = 1 THEN WHILE start < end DO result[start] := ENTIER(x[start]);  INC(start) END
		ELSE WHILE start < end DO result[start] := ENTIER(x[start] * factor);  INC(start) END
		END
	ELSIF factor = 1 THEN WHILE start < end DO result[start] := ENTIER(offs + x[start]);  INC(start) END
	ELSE  WHILE start < end DO result[start] := ENTIER(offs + x[start] * factor);  INC(start) END
	END
END Entier;



PROCEDURE Short* (len: index;  VAR x: ARRAY OF real;  start: index;  VAR result: ARRAY OF REAL);
	(*=  result[ ]:=SHORT(x[ ]) , or x[ ]*)
	VAR end: index;
BEGIN
	ASSERT(start >= 0, 100);  ASSERT(len >= 0, 101);
	IF len = 0 THEN RETURN END;
	end := start + len;
	WHILE start < end DO result[start] := x[start];  INC(start) END
END Short;



PROCEDURE Long* (len: index;  VAR x: ARRAY OF REAL;  start: index;  VAR result: ARRAY OF real);
	(*=  result[ ]:=LONG(x[ ]) *)
	VAR end: index;
BEGIN
	ASSERT(start >= 0, 100);  ASSERT(len >= 0, 101);
	IF len = 0 THEN RETURN END;
	end := start + len;
	WHILE start < end DO result[start] := x[start];  INC(start) END
END Long;

PROCEDURE Convolution* (len, start: index;  VAR src, dest, kernel: ARRAY OF real;  kernelw: index);
	(* RAW convolution: 0 based Kernel,  blurred upper bound in dest  *)
	VAR i, j: index;  temp: real;
BEGIN
	FOR i := 0 TO len + kernelw - 1 DO dest[i] := 0 END;
	FOR i := start TO start + len - 1 DO (* src *)
		FOR j := 0 TO kernelw - 1 DO  temp := dest[i + j];  temp := temp + src[i] * kernel[j];  dest[i + j] :=  temp
		END
	END
END Convolution;

BEGIN
	Machar

END vyReal.
