MODULE FoxActiveCells; (** AUTHOR "fof"; PURPOSE "hardware library for the ActiveCells compiler"; *)

IMPORT SyntaxTree := FoxSyntaxTree, Basic := FoxBasic, Files, Streams, D := Debugging, Diagnostics, Strings, Commands, GenericLinker, StaticLinker;

CONST
	In*= SyntaxTree.InPort; Out*= SyntaxTree.OutPort;
	defaultInstructionMemorySize*=0;
	defaultDataMemorySize *=2;
	defaultPortWidth *=32; (* bits *)
	defaultFifoSize *=32; (* "words" of port width size *)
	defaultChannelWidth* = 32;
	CodeFileExtension*="code";
	DataFileExtension*="data";
	SpecificationFileExtension*="spec";
	ObjectFileExtension*="Gof";

	TraceError=FALSE;

TYPE

	PortInstance*=RECORD
		instance-: Instance; port-: Port
	END;

	(* base type of all ingredients of the specification graph *)
	Symbol*=OBJECT
	VAR name-: SyntaxTree.String;
		scope-: Scope;

		PROCEDURE InitSymbol(CONST name: ARRAY OF CHAR; scope: Scope);
		BEGIN
			COPY(name,SELF.name);
			SELF.scope := scope;
		END InitSymbol;
	END Symbol;

	SymbolList*= OBJECT(Basic.List)

		PROCEDURE GetSymbol*(i: LONGINT): Symbol;
		VAR a: ANY;
		BEGIN
			a := Get(i); IF a = NIL THEN RETURN NIL ELSE RETURN a(Symbol) END
		END GetSymbol;

		PROCEDURE AddSymbol(a: Symbol);
		BEGIN Add(a);
		END AddSymbol;

		PROCEDURE ByName*(CONST name: ARRAY OF CHAR): Symbol;
		VAR a: Symbol; i: LONGINT;
		BEGIN
			FOR i := 0 TO Length()-1 DO
				a := GetSymbol(i);
				IF (a # NIL) & (a.name = name) THEN RETURN a END;
			END;
			RETURN NIL
		END ByName;
	END SymbolList;

	(* representation of a connection point
		- represented as STREAM parameter in the language
		- endpoint of FIFOs in hardware
	*)
	Port*= OBJECT (Symbol)
	VAR
		direction-: LONGINT;
		adr-: LONGINT;
		width-: LONGINT;
		delegate-: PortInstance;
		index-: LONGINT;

		PROCEDURE &InitPort*(CONST name: ARRAY OF CHAR; scope: Scope; direction: LONGINT; adr: LONGINT);
		BEGIN
			InitSymbol(name,scope);
			SELF.direction := direction;
			SELF.adr := adr;
			width := defaultPortWidth;
			delegate.instance := NIL;
			index := -1;
		END InitPort;

		PROCEDURE SetWidth*(widthInBits: LONGINT);
		BEGIN width := widthInBits
		END SetWidth;


		PROCEDURE Delegate*(instance: Instance; port: Port);
		BEGIN
			delegate.instance := instance; delegate.port := port
		END Delegate;

		PROCEDURE Write*(w: Streams.Writer; indent: LONGINT);
		BEGIN
			Indent(w,indent);
			w.Int(index,1);
			w.String(" name="); w.String(name);
			w.String(" direction=");
			IF direction = In THEN w.String("in ");
			ELSIF direction=Out THEN w.String("out ");
			END;
			w.String(" adr="); w.Int(adr,1);
			w.String(" width="); w.Int(width,1);
			w.String(" delegateInstance=");
			IF delegate.instance = NIL THEN
				w.String("none")
			ELSE
				w.String(delegate.instance.name);
				w.String(" delegatePort="); w.String(delegate.port.name);
			END;
			w.Ln;
			w.Update;
		END Write;

		PROCEDURE Read*(r: Streams.Reader): BOOLEAN;
		VAR s: SyntaxTree.String; index: LONGINT;
		BEGIN
			IF ~r.GetInteger(index,FALSE) OR (index # SELF.index) OR ~CheckItem(r,"name") OR ~GetString(r,name)
			OR ~CheckItem(r,"direction") OR ~GetString(r,s)
			THEN IF TraceError THEN HALT(100) ELSE RETURN FALSE END END;
			IF s = "in" THEN direction := In
			ELSIF s="out" THEN direction := Out
			END;
			IF ~CheckItem(r,"adr") OR ~r.GetInteger(adr,FALSE) OR
			~CheckItem(r,"width") OR ~r.GetInteger(width,FALSE) OR
			~CheckItem(r,"delegateInstance") OR ~GetString(r,s)
			THEN IF TraceError THEN HALT(100) ELSE RETURN FALSE END END;

			IF s = "none" THEN delegate.instance := NIL
			ELSE
				delegate.instance := scope.instances.ByName(s);
				ASSERT(delegate.instance # NIL);
				IF ~CheckItem(r,"delegatePort") OR ~GetString(r,s) THEN IF TraceError THEN HALT(100) ELSE RETURN FALSE END END;
				delegate.port := delegate.instance.type.ports.ByName(s);
			END;
			RETURN TRUE
		END Read;

	END Port;

	PortList*= OBJECT(Basic.List)

		PROCEDURE GetPort*(i: LONGINT): Port;
		VAR a: ANY;
		BEGIN
			a := Get(i); IF a = NIL THEN RETURN NIL ELSE RETURN a(Port) END
		END GetPort;

		PROCEDURE AddPort(a: Port);
		BEGIN a.index := Length(); Add(a);
		END AddPort;

		PROCEDURE ByName*(CONST name: ARRAY OF CHAR): Port;
		VAR a: Port; i: LONGINT;
		BEGIN
			FOR i := 0 TO Length()-1 DO
				a := GetPort(i);
				IF (a # NIL) & (a.name = name) THEN RETURN a END;
			END;
			RETURN NIL
		END ByName;

	END PortList;

	(* devices are additional components that can be attached to processors
		- implicitly represented as imported module and used interface in the language
		- represented as components attached to processor in hardware
	*)
	Device*= OBJECT (Symbol)
	VAR
		adr-: LONGINT;
		index-: LONGINT;

		PROCEDURE &InitDevice*(CONST name: ARRAY OF CHAR; scope: Scope; adr: LONGINT);
		BEGIN
			InitSymbol(name,scope);
			SELF.adr := adr;
			index := -1;
		END InitDevice;

		PROCEDURE Write*(w:Streams.Writer; indent: LONGINT);
		BEGIN
			Indent(w,indent);
			w.Int(index,1);
			w.String(" name="); w.String(name); w.String(" adr="); w.Int(adr,1); w.Ln;
			w.Update;
		END Write;

		PROCEDURE Read*(r: Streams.Reader): BOOLEAN;
		VAR i: LONGINT;
		BEGIN
			RETURN r.GetInteger(i,FALSE) & (i=index) &
			CheckItem(r,"name") & GetString(r,name) &
			CheckItem(r,"adr") & r.GetInteger(adr,FALSE);
		END Read;

	END Device;

	DeviceList*= OBJECT(Basic.List)

		PROCEDURE GetDevice*(i: LONGINT): Device;
		VAR a: ANY;
		BEGIN
			a := Get(i); IF a = NIL THEN RETURN NIL ELSE RETURN a(Device) END
		END GetDevice;

		PROCEDURE AddDevice(p: Device);
		BEGIN p.index := Length(); Add(p);
		END AddDevice;

		PROCEDURE ByName*(CONST name: ARRAY OF CHAR): Device;
		VAR a: Device; i: LONGINT;
		BEGIN
			FOR i := 0 TO Length()-1 DO
				a := GetDevice(i);
				IF (a # NIL) & (a.name = name) THEN RETURN a END;
			END;
			RETURN NIL
		END ByName;

	END DeviceList;

	(*
		a module is a collection of actors
		- represented as IMPORT in source code
		- has no representation in hardware
	*)
	Module*=OBJECT (Symbol)
	VAR
		fileName*: Files.FileName; (* preparation for separate compilation (optimization) *)
		index-: LONGINT;

		PROCEDURE & InitModule(CONST name: ARRAY OF CHAR; scope: Scope; CONST fileName: ARRAY OF CHAR);
		BEGIN
			InitSymbol(name,scope);
			COPY(name, SELF.name);
			COPY(fileName, SELF.fileName);
			index := -1;
		END InitModule;

		PROCEDURE Write*(w:Streams.Writer; indent: LONGINT);
		BEGIN
			Indent(w,indent);
			w.Int(index,1);
			w.String(" name="); w.String(name);
			w.String(" filename="); w.String("'"); w.String(fileName); w.String("'");
			w.Ln;
			w.Update;
		END Write;

		PROCEDURE Read*(r: Streams.Reader): BOOLEAN;
		VAR i: LONGINT;
		BEGIN
			RETURN r.GetInteger(i,FALSE) & (i=index) & CheckItem(r,"name") & GetString(r,name)
				&CheckItem(r,"filename") & GetString(r,name);
		END Read;

	END Module;

	ModuleList*= OBJECT(Basic.List)

		PROCEDURE GetModule*(i: LONGINT): Module;
		VAR a: ANY;
		BEGIN
			a := Get(i); IF a = NIL THEN RETURN NIL ELSE RETURN a(Module) END
		END GetModule;

		PROCEDURE AddModule(a: Module);
		BEGIN a.index := Length(); Add(a);
		END AddModule;

		PROCEDURE ByName*(CONST name: ARRAY OF CHAR): Module;
		VAR a: Module; i: LONGINT;
		BEGIN
			FOR i := 0 TO Length()-1 DO
				a := GetModule(i);
				IF (a # NIL) & (a.name = name) THEN RETURN a END;
			END;
			RETURN NIL
		END ByName;

	END ModuleList;

	(*
		instances are variables in networks pointing to a type
		- represented as VAR ... in assemblies (networks)
		- when instantiated the instance represents the instance of a processor in hardware
	*)
	Instance*=OBJECT (Symbol)
	VAR
		type-: Type; (* instance type *)
		index-: LONGINT;

		PROCEDURE &Init(CONST name: ARRAY OF CHAR; scope: Scope; c: Type);
		BEGIN
			InitSymbol(name,scope);
			type := c;
			index := -1; SELF.scope := scope;
			ASSERT(scope # NIL);
		END Init;

		PROCEDURE Write(w: Streams.Writer; indent: LONGINT);
		VAR typeName: SyntaxTree.String;
		BEGIN
			Indent(w,indent);
			w.Int(index,1);
			w.String(" name="); w.String(name);
			type.GetFullName(typeName,scope);

			w.String(" type="); w.String(typeName); w.Ln;
		END Write;

		PROCEDURE Read(r: Streams.Reader): BOOLEAN;
		VAR index: LONGINT; s: SyntaxTree.String; symbol: Symbol;
		BEGIN
			IF r.GetInteger(index,FALSE) & CheckItem(r,"name") & GetString(r,name) &
			CheckItem(r,"type") & GetString(r,s)
			THEN
				symbol := GetSymbol(scope,s);
				type := symbol(Type);
				RETURN TRUE
			ELSE IF TraceError THEN HALT(100) ELSE RETURN FALSE END
			END;
		END Read;

	END Instance;

	InstanceList*= OBJECT(Basic.List)

		PROCEDURE GetInstance*(i: LONGINT): Instance;
		VAR a: ANY;
		BEGIN
			a := Get(i); IF a = NIL THEN RETURN NIL ELSE RETURN a(Instance) END
		END GetInstance;

		PROCEDURE AddInstance(a: Instance);
		BEGIN a.index := Length(); Add(a);
		END AddInstance;

		PROCEDURE ByName*(CONST name: ARRAY OF CHAR): Instance;
		VAR a: Instance; i: LONGINT;
		BEGIN
			FOR i := 0 TO Length()-1 DO
				a := GetInstance(i);
				IF (a # NIL) & (a.name = name) THEN RETURN a END;
			END;
			RETURN NIL
		END ByName;
	END InstanceList;

	Scope*=OBJECT (Symbol)
	VAR
		symbols-: SymbolList;
		instances-: InstanceList;
		channels-: ChannelList;
		types-: TypeList;
		ports-: PortList;
		index-: LONGINT;
		specification-: Specification;

		PROCEDURE &InitScope(CONST name: ARRAY OF CHAR; scope: Scope; specification: Specification);
		BEGIN
			COPY(name,SELF.name); SELF.specification := specification;
			NEW(instances); NEW(channels);
			NEW(ports); NEW(types);
			NEW(symbols);
			index := -1;
		END InitScope;

		PROCEDURE FindSymbol(CONST name: ARRAY OF CHAR; traverse: BOOLEAN): Symbol;
		VAR symbol: Symbol;
		BEGIN
			symbol := symbols.ByName(name);
			IF (symbol = NIL) & (scope # NIL) & traverse THEN RETURN scope.FindSymbol(name,TRUE)
			ELSE RETURN symbol;
			END;
		END FindSymbol;

		PROCEDURE GetFullName*(VAR name: ARRAY OF CHAR; in: Scope);

			PROCEDURE InScope(this,in : Scope): BOOLEAN;
			BEGIN
				WHILE (this # NIL) & (this # in) DO
					this := this.scope;
				END;
				RETURN this # NIL
			END InScope;

		BEGIN
			IF (SELF.scope # NIL) & ~InScope(in,SELF.scope) THEN
				SELF.scope.GetFullName(name,in);
				Strings.Append(name,".");
				Strings.Append(name,SELF.name);
			ELSE
				COPY(SELF.name,name)
			END;
		END GetFullName;

		PROCEDURE NewInstance*(CONST name: ARRAY OF CHAR; type: Type): Instance;
		VAR instance: Instance;
		BEGIN
			NEW(instance, name, SELF, type);
			instances.AddInstance(instance);
			symbols.AddSymbol(instance);
			RETURN instance
		END NewInstance;

		(* generate a new channel, may be overwritten by implementations if a non-default channel object has to be installed *)
		PROCEDURE NewChannel*(CONST name: ARRAY OF CHAR): Channel;
		VAR channel: Channel;
		BEGIN
			NEW(channel,name,SELF);
			channels.AddChannel(channel);
			symbols.AddSymbol(channel);
			RETURN channel;
		END NewChannel;

		(* generate a new port, may be overwritten by implementations if a non-default port object has to be installed *)
		PROCEDURE NewPort*(CONST name: ARRAY OF CHAR; direction: LONGINT; adr: LONGINT): Port;
		VAR port: Port;
		BEGIN
			NEW(port, name,SELF, direction,adr);
			ports.AddPort(port);
			symbols.AddSymbol(port);
			RETURN port
		END NewPort;

		(* generate a new type, may be overwritten by implementations if a non-default type object has to be installed *)
		PROCEDURE NewType*(CONST name: ARRAY OF CHAR): Type;
		VAR type: Type;
		BEGIN
			NEW(type,name,SELF);
			types.AddType(type);
			symbols.AddSymbol(type);
			 RETURN type
		END NewType;

		PROCEDURE Link*(diagnostics: Diagnostics.Diagnostics; verbose: BOOLEAN): BOOLEAN;
		VAR type: Type; i: LONGINT;
		BEGIN
			FOR i := 0 TO types.Length()-1 DO
				type := types.GetType(i);
				IF type.instances.Length()=0 THEN
					IF ~type.LinkType(diagnostics,verbose) THEN IF TraceError THEN HALT(100) ELSE RETURN FALSE END END;
				ELSE
					type.SetDataMemorySize(0);
				END;
				IF ~type.Link(diagnostics, verbose) THEN RETURN FALSE END; (* subtypes ? *)
			END;
			RETURN TRUE
		END Link;

	END Scope;

	(*
		definition of a (virtual) computing node (processor)
		- represented by ACTOR or ASSEMBLY (-> virtual) in source code
		- represented as processor (if ACTOR) and as network or processors (if ASSEMBLY) in hardware
	*)

	Type*=OBJECT (Scope)
	VAR

		devices-: DeviceList;
		modules-: ModuleList; (* for linking / compiling *)
		instructionMemorySize-, dataMemorySize-: LONGINT;


		PROCEDURE & InitType*(CONST name: ARRAY OF CHAR; scope: Scope);
		BEGIN
			InitScope(name,scope,scope.specification);
			ASSERT(specification # NIL);
			instructionMemorySize := defaultInstructionMemorySize;
			dataMemorySize := defaultDataMemorySize;
			NEW(devices);
			NEW(modules);
			SELF.scope := scope
		END InitType;

		PROCEDURE SetInstructionMemorySize*(value: LONGINT);
		BEGIN instructionMemorySize := value
		END SetInstructionMemorySize;

		PROCEDURE SetDataMemorySize*(value: LONGINT);
		BEGIN dataMemorySize := value
		END SetDataMemorySize;

		(* generate a new device, may be overwritten by implementations if a non-default device object has to be installed *)
		PROCEDURE NewDevice*(CONST name: ARRAY OF CHAR; adr: LONGINT): Device;
		VAR device: Device;
		BEGIN
			NEW(device,name,SELF, adr);
			devices.AddDevice(device);
			symbols.AddSymbol(device);
			RETURN device;
		END NewDevice;

		PROCEDURE NewModule*(CONST moduleName, fileName: ARRAY OF CHAR): Module;
		VAR module: Module;
		BEGIN
			NEW(module, moduleName, SELF, fileName);
			modules.AddModule(module);
			symbols.AddSymbol(module);
			RETURN module;
		END NewModule;



		(*
		PROCEDURE ThisPort(CONST name: ARRAY OF CHAR): Port;
		VAR type: Type; port:Port; i: LONGINT;
		BEGIN
			(*! suboptimal, replace by two-staged version *)
			FOR i := 0 TO subTypes.Length()-1 DO
				type := subTypes.GetType(i);
				port := type.ports.ByName(name);
				IF port # NIL THEN RETURN port END;
			END;
			RETURN NIL
		END ThisPort;
		*)

		PROCEDURE LinkType*(diagnostics: Diagnostics.Diagnostics; verbose: BOOLEAN): BOOLEAN;
		VAR
			fileName, codeFileName, dataFileName: Files.FileName;
			code, data: StaticLinker.Arrangement; linker: GenericLinker.Linker;
			module: Module;
			msg: ARRAY 256 OF CHAR;
			linkRoot: SyntaxTree.String;
			i: LONGINT;
		BEGIN
			NEW (code, 0);
			NEW (data, 0);
			NEW (linker, diagnostics, verbose, FALSE (* useAll *), FALSE (* stripInitCodes *), code, data);
			GetFullName(linkRoot,NIL);
			Strings.Append(linkRoot,".$$BODYSTUB");
			linker.SetLinkRoot(linkRoot);
			FOR i := 0 TO modules.Length()-1 DO
				module := modules.GetModule(i);
				StaticLinker.ReadObjectFile(module.name, "",ObjectFileExtension,linker);
			END;

			(* do linking after having read in all blocks to account for potential constraints *)
			IF ~linker.error THEN linker.Link; END;

			instructionMemorySize := 1+ code.SizeInBits() DIV 36 DIV 1024 ;

			GetFullName(fileName,NIL);
			Files.JoinExtension(fileName,CodeFileExtension,codeFileName);
			Files.JoinExtension(fileName,DataFileExtension,dataFileName);

			IF ~linker.error THEN
				StaticLinker.WriteOutputFile (code, codeFileName, linker, StaticLinker.WriteTRMCodeFile);
				StaticLinker.WriteOutputFile (data, dataFileName, linker, StaticLinker.WriteTRMDataFile);
				GetFullName(msg,NIL); Strings.Append(msg," successfully linked");
				diagnostics.Information("",Diagnostics.Invalid, Diagnostics.Invalid,msg);
			ELSE
				msg := "could not link ";
				Strings.Append(msg,linkRoot);
				 FOR i := 0 TO modules.Length()-1 DO
				 	module := modules.GetModule(i);
				 	Strings.Append(msg," "); Strings.Append(msg,module.name);
				 END;
				 diagnostics.Error("",Diagnostics.Invalid, Diagnostics.Invalid, msg);
			END;
			RETURN ~linker.error
		END LinkType;

		PROCEDURE Read(r: Streams.Reader): BOOLEAN;
		VAR port: Port; module: Module; device: Device; i,number: LONGINT;
			channel: Channel; instance: Instance; type: Type;
		BEGIN
			IF ~r.GetInteger(i,FALSE) OR (index # i) OR
				~CheckItem(r,"name") OR  ~GetString(r,name) OR
			~CheckItem(r,"instructionMemorySize") OR ~r.GetInteger(instructionMemorySize,FALSE) OR
			~CheckItem(r,"dataMemorySize") OR ~r.GetInteger(dataMemorySize,FALSE) THEN IF TraceError THEN HALT(100) ELSE RETURN FALSE END END;
			IF ~CheckItem(r,"types") OR ~r.GetInteger(number,FALSE) THEN IF TraceError THEN HALT(100) ELSE RETURN FALSE END END;
			FOR i := 0 TO number-1 DO
				type := NewType("");
				IF ~type.Read(r) THEN IF TraceError THEN HALT(100) ELSE RETURN FALSE END END;
			END;
			IF ~CheckItem(r,"instances") OR ~r.GetInteger(number,FALSE)
			THEN IF TraceError THEN HALT(100) ELSE RETURN FALSE END
			END;
			FOR i := 0 TO number-1 DO
				instance := NewInstance("",NIL);
				IF ~instance.Read(r) THEN IF TraceError THEN HALT(100) ELSE RETURN FALSE END END;
			END;
			IF ~CheckItem(r,"ports")OR ~ r.GetInteger(number,FALSE) THEN IF TraceError THEN HALT(100) ELSE RETURN FALSE END END;
			FOR i := 0 TO number-1 DO
				port := NewPort("",0,0);
				IF ~port.Read(r) THEN IF TraceError THEN HALT(100) ELSE RETURN FALSE END END;
			END;
			IF ~CheckItem(r,"modules")OR ~ r.GetInteger(number,FALSE) THEN IF TraceError THEN HALT(100) ELSE RETURN FALSE END END;
			FOR i := 0 TO number-1 DO
				module := NewModule("","");
				IF ~module.Read(r) THEN IF TraceError THEN HALT(100) ELSE RETURN FALSE END END;
			END;
			IF ~CheckItem(r,"devices")OR ~ r.GetInteger(number,FALSE) THEN IF TraceError THEN HALT(100) ELSE RETURN FALSE END END;
			FOR i := 0 TO number-1 DO
				device := NewDevice("",0);
				IF ~device.Read(r) THEN IF TraceError THEN HALT(100) ELSE RETURN FALSE END END;
			END;
			IF ~CheckItem(r,"channels")OR ~ r.GetInteger(number,FALSE) THEN IF TraceError THEN HALT(100) ELSE RETURN FALSE END END;
			FOR i := 0 TO number-1 DO
				channel := NewChannel("");
				IF ~channel.Read(r) THEN IF TraceError THEN HALT(100) ELSE RETURN FALSE END END;
			END;
			RETURN TRUE
		END Read;

		PROCEDURE Write*(w: Streams.Writer; indent: LONGINT);
		VAR port: Port; device: Device; module: Module; instance: Instance; channel: Channel; type: Type; i: LONGINT;
		BEGIN
			Indent(w,indent); INC(indent);
			w.Int(index,1);
			w.String(" name="); w.String(name);
			w.String(" instructionMemorySize="); w.Int(instructionMemorySize,1);
			w.String(" dataMemorySize="); w.Int(dataMemorySize,1);
			w.Ln;
			(* sub types first because of potential delegates on ports *)
			Indent(w,indent); w.String("types=");w.Int(types.Length(),1); w.Ln;
			FOR i := 0 TO types.Length()-1 DO
				type := types.GetType(i);
				type.Write(w,indent+1);
			END;
			Indent(w,indent);
			w.String("instances=");w.Int(instances.Length(),1); w.Ln;
			FOR i := 0 TO instances.Length()-1 DO
				instance := instances.GetInstance(i);
				instance.Write(w,indent+1);
			END;
			Indent(w,indent);
			w.String("ports=");w.Int(ports.Length(),1); w.Ln;
			FOR i := 0 TO ports.Length()-1 DO
				port := ports.GetPort(i);
				port.Write(w,indent+1);
			END;
			Indent(w,indent);
			w.String("modules="); w.Int(modules.Length(),1);  w.Ln;
			FOR i := 0 TO modules.Length()-1 DO
				module := modules.GetModule(i);
				module.Write(w,indent+1);
			END;
			Indent(w,indent);
			w.String("devices="); w.Int(devices.Length(),1); w.Ln;
			FOR i := 0 TO devices.Length()-1 DO
				device := devices.GetDevice(i);
				device.Write(w,indent+1);
			END;
			Indent(w,indent);
			w.String("channels=");w.Int(channels.Length(),1); w.Ln;
			FOR i := 0 TO channels.Length()-1 DO
				channel := channels.GetChannel(i);
				channel.Write(w,indent+1);
			END;
			w.Update;
		END Write;

	END Type;

	TypeList*= OBJECT(Basic.List)

		PROCEDURE GetType*(i: LONGINT): Type;
		VAR a: ANY;
		BEGIN
			a := Get(i); IF a = NIL THEN RETURN NIL ELSE RETURN a(Type) END
		END GetType;

		PROCEDURE AddType(a: Type);
		BEGIN a.index := Length(); Add(a);
		END AddType;

		PROCEDURE ByName*(CONST name: ARRAY OF CHAR): Type;
		VAR a: Type; i: LONGINT;
		BEGIN
			FOR i := 0 TO Length()-1 DO
				a := GetType(i);
				IF (a # NIL) & (a.name = name) THEN RETURN a END;
			END;
			RETURN NIL
		END ByName;

	END TypeList;

	(*
		channel defines the connection between ports
		- defined by CONNECT in source code
		- represented as FIFO in hardware
	*)
	Channel*=OBJECT (Symbol)
	VAR
		in-, out-: PortInstance;
		fifoSize-: LONGINT;
		widthInBits-: LONGINT;
		index-: LONGINT; (* useful for implementations that emulate channels (simulator) *)

		PROCEDURE & InitChannel(CONST name: ARRAY OF CHAR; scope: Scope);
		BEGIN
			InitSymbol(name,scope);
			fifoSize := defaultFifoSize;
			widthInBits := defaultChannelWidth;
			in.port := NIL; in.instance := NIL;
			out.port := NIL; out.instance := NIL;
			SELF.index := -1;
		END InitChannel;

		PROCEDURE ConnectIn*(instance: Instance; port: Port);
		BEGIN in.port := port; in.instance := instance;
		END ConnectIn;

		PROCEDURE ConnectOut*(instance: Instance; port: Port);
		BEGIN out.port := port; out.instance := instance;
		END ConnectOut;

		PROCEDURE SetFifoSize*(size: LONGINT);
		BEGIN fifoSize := size
		END SetFifoSize;

		PROCEDURE SetWidth*(width: LONGINT);
		BEGIN widthInBits := width
		END SetWidth;

		PROCEDURE Read(r: Streams.Reader): BOOLEAN;
		VAR s: SyntaxTree.String; i: LONGINT;
		BEGIN
			IF ~r.GetInteger(i,FALSE) OR (i#index) OR
			~CheckItem(r,"name") OR ~GetString(r,name) OR
			~CheckItem(r,"outInstance") OR ~ GetString(r,s) THEN IF TraceError THEN HALT(100) ELSE RETURN FALSE END END;
			IF s#"NIL" THEN out.instance := scope.instances.ByName(s) END;
			IF ~CheckItem(r,"outPort") OR ~GetString(r,s) THEN IF TraceError THEN HALT(100) ELSE RETURN FALSE END END;
			IF s#"NIL" THEN out.port := out.instance.type.ports.ByName(s) END;
			IF ~CheckItem(r,"inInstance") OR ~ GetString(r,s) THEN IF TraceError THEN HALT(100) ELSE RETURN FALSE END END;
			IF s#"NIL" THEN in.instance := scope.instances.ByName(s) END;
			IF ~CheckItem(r,"inPort")OR ~GetString(r,s) THEN IF TraceError THEN HALT(100) ELSE RETURN FALSE END END;
			IF s#"NIL" THEN	in.port := in.instance.type.ports.ByName(s) END;
			IF ~CheckItem(r,"size")OR ~r.GetInteger(i,FALSE) THEN IF TraceError THEN HALT(100) ELSE RETURN FALSE END END;
			fifoSize := i;
			IF ~CheckItem(r,"width")OR ~r.GetInteger(i,FALSE) THEN IF TraceError THEN HALT(100) ELSE RETURN FALSE END END;
			widthInBits := i;
			RETURN TRUE
		END Read;

		PROCEDURE Write*(w: Streams.Writer; indent: LONGINT);
		BEGIN
			Indent(w,indent);
			w.Int(index,1);
			w.String(" name="); w.String(name);
			w.String(" outInstance="); IF out.instance = NIL THEN w.String("NIL") ELSE w.String(out.instance.name) END;
			w.String(" outPort="); IF out.port = NIL THEN w.String("NIL") ELSE w.String(out.port.name) END;
			w.String(" inInstance="); IF in.instance = NIL THEN w.String("NIL") ELSE w.String(in.instance.name) END;
			w.String(" inPort="); IF in.port = NIL THEN w.String("NIL") ELSE w.String(in.port.name) END;
			w.String(" size="); w.Int(fifoSize,1);
			w.String(" width="); w.Int(widthInBits,1);
			w.Ln;w.Update;
		END Write;

	END Channel;

	ChannelList*= OBJECT(Basic.List)

		PROCEDURE GetChannel*(i: LONGINT): Channel;
		VAR a: ANY;
		BEGIN
			a := Get(i); IF a = NIL THEN RETURN NIL ELSE RETURN a(Channel) END
		END GetChannel;

		PROCEDURE AddChannel*(a: Channel);
		BEGIN a.index := Length(); Add(a);
		END AddChannel;

		PROCEDURE ByName*(CONST name: ARRAY OF CHAR): Channel;
		VAR a: Channel; i: LONGINT;
		BEGIN
			FOR i := 0 TO Length()-1 DO
				a := GetChannel(i);
				IF (a # NIL) & (a.name = name)  THEN RETURN a END;
			END;
			RETURN NIL
		END ByName;

		PROCEDURE ByPort*(port: Port): Channel;
		VAR a: Channel; i: LONGINT;
		BEGIN
			FOR i := 0 TO Length()-1 DO
				a := GetChannel(i);
				IF (a # NIL) & (a.in.port = port) OR (a.out.port=port) THEN RETURN a END;
			END;
			RETURN NIL
		END ByPort;

	END ChannelList;

	(*
		a specification is a collection of actors together with factory procedures to build hardware
		- represented as IMPORT in source code
		- to build hardware scripts generating hardware
	*)
	Specification*=OBJECT (Scope) (* specification object including hardware factory *)
	VAR
		instructionSet-: SyntaxTree.String;

		diagnostics-: Diagnostics.Diagnostics;
		supportedDevices-: DeviceList;
		imports-: SymbolList;

		PROCEDURE & Init*(CONST name: ARRAY OF CHAR; diagnostics: Diagnostics.Diagnostics);
		VAR device: Device;
		BEGIN
			InitScope(name,NIL,SELF);
			instructionSet := "UNDEFINED";
			NEW(supportedDevices);
			SELF.diagnostics := diagnostics;
			NEW(device,"DDR",SELF, 0FFCAH); supportedDevices.AddDevice(device);
			NEW(device,"RS232",SELF,LONGINT(0FFFFFFC4H)); supportedDevices.AddDevice(device);
			NEW(device,"LCD",SELF,0FFC9H); supportedDevices.AddDevice(device);
			NEW(device,"CF",SELF,0); supportedDevices.AddDevice(device);
			NEW(device,"LED",SELF,0); supportedDevices.AddDevice(device);
			NEW(device,"TIMER",SELF,0FFC6H); supportedDevices.AddDevice(device);
			NEW(device,"PORT",SELF,0FF10H); supportedDevices.AddDevice(device);
			NEW(device,"Switch",SELF,0FFFFH); supportedDevices.AddDevice(device);
			NEW(device,"Motor",SELF,LONGINT(0FFFFFFCEH)); supportedDevices.AddDevice(device);
			NEW(imports);
		END Init;

		PROCEDURE AddImport*(CONST name: ARRAY OF CHAR);
		VAR import: Specification;
		BEGIN
			IF imports.ByName(name) = NIL THEN
				import := LoadSpecification(name);
				IF import # NIL THEN imports.Add(import); symbols.Add(import) END;
			END;
		END AddImport;

		PROCEDURE SetInstructionSet*(CONST instructionSet: ARRAY OF CHAR);
		BEGIN
			COPY(instructionSet,SELF.instructionSet);
		END SetInstructionSet;

		PROCEDURE Write*(w: Streams.Writer; indent: LONGINT);
		VAR type: Type; channel: Channel; i: LONGINT; instance: Instance;port: Port; import: Symbol;
		BEGIN
			Indent(w,indent);w.String("name="); w.String(name); w.Ln;
			INC(indent);
			Indent(w,indent); w.String("instructionSet="); w.String(instructionSet); w.Ln;
			Indent(w,indent); w.String("imports="); w.Int(imports.Length(),1); w.Ln;
			FOR i := 0 TO imports.Length()-1 DO
				import := imports.GetSymbol(i);
				Indent(w,indent+1); w.String(import.name); w.Ln;
			END;
			Indent(w,indent); w.String("types=");w.Int(types.Length(),1); w.Ln;
			FOR i := 0 TO types.Length()-1 DO
				type := types.GetType(i);
				type.Write(w,indent+1);
			END;
			(* sub types first because of potential delegates on ports *)
			Indent(w,indent); w.String("instances=");w.Int(instances.Length(),1); w.Ln;
			FOR i := 0 TO instances.Length()-1 DO
				instance := instances.GetInstance(i);
				instance.Write(w,indent+1);
			END;
			Indent(w,indent); w.String("ports=");w.Int(ports.Length(),1); w.Ln;
			FOR i := 0 TO ports.Length()-1 DO
				port := ports.GetPort(i);
				port.Write(w,indent+1);
			END;
			Indent(w,indent); w.String("channels=");w.Int(channels.Length(),1); w.Ln;
			FOR i := 0 TO channels.Length()-1 DO
				channel := channels.GetChannel(i);
				channel.Write(w,indent+1);
			END;
			w.Update;
		END Write;

		PROCEDURE Read*(r: Streams.Reader): BOOLEAN;
		VAR i, number: LONGINT; type: Type;
			instance: Instance; port: Port; channel: Channel; importName: SyntaxTree.String;
		BEGIN
			IF ~	CheckItem(r,"name") OR ~GetString(r,name) OR
			~CheckItem(r,"instructionSet") OR ~GetString(r,instructionSet) OR
			~CheckItem(r,"imports") OR ~r.GetInteger(number,FALSE) THEN IF TraceError THEN HALT(100) ELSE RETURN FALSE END END;
			FOR i := 0 TO number-1 DO
				IF ~GetString(r,importName) THEN IF TraceError THEN HALT(100) ELSE RETURN FALSE END END;
				AddImport(importName);
			END;
			IF ~CheckItem(r,"types") OR ~r.GetInteger(number,FALSE) THEN IF TraceError THEN HALT(100) ELSE RETURN FALSE END END;
			FOR i := 0 TO number-1 DO
				type := NewType("");
				IF ~type.Read(r) THEN IF TraceError THEN HALT(100) ELSE RETURN FALSE END END;
			END;
			IF ~CheckItem(r,"instances") OR ~r.GetInteger(number,FALSE) THEN IF TraceError THEN HALT(100) ELSE RETURN FALSE END END;
			FOR i := 0 TO number-1 DO
				instance := NewInstance("",NIL);
				IF ~instance.Read(r) THEN IF TraceError THEN HALT(100) ELSE RETURN FALSE END END;
			END;
			IF ~CheckItem(r,"ports")OR ~r.GetInteger(number,FALSE) THEN IF TraceError THEN HALT(100) ELSE RETURN FALSE END END;
			FOR i := 0 TO number-1 DO
				port := NewPort("",0,0);
				IF ~port.Read(r) THEN IF TraceError THEN HALT(100) ELSE RETURN FALSE END END;
			END;
			IF ~CheckItem(r,"channels") OR ~r.GetInteger(number,FALSE) THEN IF TraceError THEN HALT(100) ELSE RETURN FALSE END END;
			FOR i := 0 TO number-1 DO
				channel := NewChannel("");
				IF ~channel.Read(r) THEN IF TraceError THEN HALT(100) ELSE RETURN FALSE END END;
			END;
			RETURN TRUE
		END Read;

		PROCEDURE GetPortAddress*(number: LONGINT): LONGINT;
		BEGIN
			RETURN LONGINT(0FFFFFFD0H)+2*number;
		END GetPortAddress;

		PROCEDURE Emit*(): BOOLEAN; (* to be overwritten by implementers *)
		VAR w: Files.Writer; f: Files.File; fileName: Files.FileName; msg: SyntaxTree.String;
		BEGIN
			(* D.Ln; D.String("before resolving ");Write(D.Log,1); D.Update;*)
			FlattenNetwork(SELF);
			(* D.Ln; D.String("after resolving "); Write(D.Log,1); D.Update; *)
			Files.JoinExtension(SELF.name,SpecificationFileExtension,fileName);
			f := Files.New(fileName);
			IF f # NIL THEN
				NEW(w,f,0);
				Write(w,0);
				w.Update;
				Files.Register(f);

				msg := "Wrote Active Cells specification to file "; Strings.Append(msg, fileName);
				diagnostics.Information("",Diagnostics.Invalid, Diagnostics.Invalid, msg);
				RETURN TRUE
			ELSE
				diagnostics.Error(fileName,Diagnostics.Invalid, Diagnostics.Invalid,"could not generate file");
				IF TraceError THEN HALT(100) ELSE RETURN FALSE END
			END;
		END Emit;



	END Specification;

	PROCEDURE Indent(w: Streams.Writer; indent: LONGINT);
	BEGIN
		WHILE indent > 0 DO
			w.String("  ");
			DEC(indent);
		END;
	END Indent;

	PROCEDURE CheckItem(VAR r: Streams.Reader; CONST name: ARRAY OF CHAR): BOOLEAN;
	VAR i: LONGINT; ch: CHAR; b: BOOLEAN;
	BEGIN
		i := 0;
		b := r.GetChar(ch);
		WHILE (r.res=Streams.Ok) & (ch # "=") DO
			IF name[i] # ch THEN IF TraceError THEN HALT(100) ELSE RETURN FALSE END END;
			INC(i);
			r.Char(ch);
		END;
		RETURN TRUE
	END CheckItem;

	PROCEDURE GetString(VAR r: Streams.Reader; VAR name: ARRAY OF CHAR): BOOLEAN;
	VAR c: CHAR;
	BEGIN
		c := r.Peek();
		IF r.GetString(name) THEN RETURN TRUE
		ELSE RETURN (name[0]=0X) & (c="'") OR (c='"')
		END;
	END GetString;

	PROCEDURE ReadSpecification*(context: Commands.Context);
	VAR fileName: Files.FileName; r: Files.Reader; specification: Specification;f : Files.File; b: BOOLEAN;
	BEGIN
		b := context.arg.GetString(fileName);
		NEW(specification,"",NIL);
		f := Files.Old(fileName);
		NEW(r,f,0);
		IF specification.Read(r) THEN
			specification.Write(D.Log,0);
		END;
	END ReadSpecification;

	PROCEDURE LoadSpecification(CONST name: ARRAY OF CHAR): Specification;
	VAR fileName: Files.FileName; r:Files.Reader;  specification: Specification;f : Files.File;
	BEGIN
		specification := NIL;
		COPY(name,fileName); Strings.Append(fileName,".spec");
		f := Files.Old(fileName);
		IF f # NIL THEN NEW(r,f,0); NEW(specification,"",NIL);
			IF ~specification.Read(r) THEN specification := NIL END;
		END;
		RETURN specification
	END LoadSpecification;


	PROCEDURE GetSymbol*(scope: Scope; CONST name: ARRAY OF CHAR): Symbol;
	VAR scopeName: SyntaxTree.String; i,j: LONGINT; symbol: Symbol; first: BOOLEAN;
	BEGIN
		i := 0; first := TRUE;
		WHILE (scope # NIL) & (name[i] # 0X) DO
			j := 0;
			WHILE (name[i] # 0X) & (name[i] # ".") DO
				scopeName[j] := name[i];
				INC(i); INC(j);
			END;
			scopeName[j] := 0X; INC(i);
			(*
			D.String("find symbol : "); D.String(scopeName); D.Ln;
			*)
			symbol := scope.FindSymbol(scopeName, first); first := FALSE;
			IF (symbol # NIL) & (symbol IS Scope) THEN scope := symbol(Scope)
			ELSE scope := NIL
			END;
		END;
		IF name[i] # 0X THEN RETURN NIL ELSE RETURN symbol END;
	END GetSymbol;


	PROCEDURE FlattenNetwork*(scope: Scope);
	VAR instance,subInstance,newInstance: Instance; oldChannel,channel: Channel;
		 instances: InstanceList; channels: ChannelList;
		 i,j: LONGINT; name: SyntaxTree.String;
		 port: Port;

		 PROCEDURE FlattenPortInstance(VAR pi: PortInstance);
		 VAR name: SyntaxTree.String; port, prevPort: Port; instance: Instance;
		 BEGIN
		 	IF pi.port # NIL THEN
			 	port := pi.port.delegate.port;
			 	IF port # NIL THEN
				 	instance := pi.port.delegate.instance;
				 	ASSERT(instance # NIL);
			 		COPY(pi.instance.name,name);
			 		(* iteratively resolve port delegation and build local instance name *)
			 		WHILE  port # NIL DO
			 			prevPort := port;
			 			ASSERT(instance # NIL);
				 		Strings.Append(name,"."); Strings.Append(name,instance.name);
				 		instance := port.delegate.instance;
				 		port := port.delegate.port;
				 	END;
				 	port := prevPort;
				 	instance := instances.ByName(name);
				 	ASSERT(port # NIL);
				 	ASSERT(instance # NIL);
				 	pi.instance := instance;
				 	pi.port := port;
			 	END;
			 END;
		 END FlattenPortInstance;

		 PROCEDURE EmbedInstance(instance: Instance; VAR subInstance: Instance): Instance;
		 VAR name: SyntaxTree.String; newInstance: Instance;
		 BEGIN
		 	COPY(instance.name, name); Strings.Append(name,"."); Strings.Append(name,subInstance.name);
		 	newInstance := instances.ByName(name);
		 	IF newInstance = NIL THEN
		 		NEW(newInstance, name, scope, subInstance.type);
		 	END;
		 	RETURN newInstance
		 END EmbedInstance;

	BEGIN
		IF scope.instances.Length()=0 THEN RETURN END;
		NEW(instances); NEW(channels);
		FOR i := 0 TO scope.channels.Length()-1 DO
			oldChannel := scope.channels.GetChannel(i);
			COPY(oldChannel.name, name);
			NEW(channel,name,scope);
			channel.ConnectIn(oldChannel.in.instance, oldChannel.in.port);
			channel.ConnectOut(oldChannel.out.instance, oldChannel.out.port);
			channel.SetFifoSize(oldChannel.fifoSize);
			channel.SetWidth(oldChannel.fifoSize);
			channels.AddChannel(channel);
		END;
		FOR i := 0 TO scope.instances.Length()-1 DO
			instance := scope.instances.GetInstance(i);
			IF instance.type.instances.Length() # 0 THEN
				FlattenNetwork(instance.type);
				FOR j := 0 TO instance.type.instances.Length()-1 DO
					subInstance := instance.type.instances.GetInstance(j);
					newInstance := EmbedInstance(instance, subInstance);
					instances.AddInstance(newInstance)
				END;
				FOR j := 0 TO instance.type.channels.Length()-1 DO
					oldChannel := instance.type.channels.GetChannel(j);
					COPY(oldChannel.name,name);
					NEW(channel,name,scope);
					channel.ConnectIn(oldChannel.in.instance, oldChannel.in.port);
					channel.ConnectOut(oldChannel.out.instance, oldChannel.out.port);

					channel.SetFifoSize(oldChannel.fifoSize);
					channel.SetWidth(oldChannel.fifoSize);
					channel.in.instance := EmbedInstance(instance, channel.in.instance);
					channel.out.instance := EmbedInstance(instance, channel.out.instance);
					channels.AddChannel(channel);
				END;
			ELSE
				instances.AddInstance(instance);
			END;
		END;
		FOR i := 0 TO channels.Length()-1 DO
			channel := channels.GetChannel(i);
			FlattenPortInstance(channel.in);
			FlattenPortInstance(channel.out);
		END;
		FOR i := 0 TO scope.ports.Length()-1 DO
			port := scope.ports.GetPort(i);
			FlattenPortInstance(port.delegate);
		END;
		scope.instances := instances;
		scope.channels := channels;
	END FlattenNetwork;


END FoxActiveCells.

FoxActiveCells.ReadSpecification Test.spec ~
