 (* This file has been generated by SpotPP 0.2d2 at  26.07.1999 13:45:39
from   vy/src/Mpp/vyHost.Mpp - Last modified at  26.07.1999 13:45:39
using flags: Host S3
Do not change this file. Apply changes to the master file only.
Add hoc changes applied 24.9.2000
*)


MODULE vyHost IN Oberon;   (*   gs 	*)
(* Copyright notice:

This file is part of Voyager
Copyright (C) 1993-2002 Project Voyager, StatLab Heidelberg ; (C) 1993-2002 G. Sawitzki et al.

This library is free software; you can redistribute it and/or
modify it under the terms of the GNU Lesser General Public
License as published by the Free Software Foundation; either
version 2.1 of the License, or (at your option) any later version.

This library is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public
License along with this library; if not, write to the Free Software
Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

Copy of the GNU Lesser General Public License can be found in the file COPYING.TXT
Report any problems as soon as possible to voyager@statlab.uni-heidelberg.de
*)


(* 	(c) Project Voyager, StatLab Heidelberg  *)

(***** Glue module to unify various Oberon variants *****)
(*=
Oberon systems come in variants which may implement comparable functionality
in different ways. For example, the original Oberon system does not specify how non-
character elements are represented in texts. The V4 implementation uses escaped
sequences, while S3 systems use a generalisation of the Fonts system to imbed
more general graphical elements.
This module serves to give a unified basis.
If the unification affects many Voyager modules, it should be concentrated here.
If it affects only a very small set of modules, it may be implemented as module
variants.

Main problems:
- Some implementors/designers change the interface of corresponding procedures.
A recommended way out would be to introduce new procedures, keeping the original
interfaces intact. If an obsolete interface is encountered, a note is tolerable.

- There is no common base for persistent objects.
- V4 and S3 keep explicit buffers -although the buffer structure is not exporterd-, while
/F is hiding buffers in the implementation.

*)

IMPORT SYSTEM, Oberon, Texts,  Viewers, Display, TextFrames,Objects,Links (*, Examiner *);



CONST idversion* = "vyHost Oberon S3 0.1d3";   (* may be maintained or changed by tools *)

	(**** general constants and definitions for Voyager ****)
	(* 	Do not place entries here without necessity. If information is shared between modules,
	it should be places at the lowest common node.
	Information may be placed here for two reasons:
	- if it is used in several unrelated places
	- if debugging and analyzing is simplified.
	Recommended usage:
	take local copies so that names are short, while consistency can still be checked.
	eg.
	CONST
	CR=vyConst.CR;
	*)
	(*	vy* ="vy"; 	(* prefix for Voyager commands *)
	(* copy modes *)
	cShallow*=0; cDeep*=1;
	(** Mouse keys **)
	rightKey* = 0;
	middleKey* = 1;
	leftKey* = 2;

	cnonumber=1; (* nan code for no number on input *) *)

	(** system specific constants: S3 version **)
	charset* = "Oberon";
	TextElemCode* = 01CX;  	(*=  substitution character if non-character elements are represented as char*)



	precc* = 100;   	 (*= 100 <= trap < 110 : pre-condition	(/F: 20-59) *)
	postcc* = 120;   	(*= 120 <= trap < 130 : post-condition 	(/F:60-99)*)
	notyetcc* = 99;  	(*= HALT (for not yet implemeted) *)
	fatalcc* = 98;  	(*= HALT (fatal error condition) *)


	(*	(*= constants from OPT *)
	(*! move from compilers based type identification to OPT based identification. *)
	(* object modes *)
	Var* = 1;    VarPar* = 2;    Con* = 3;    Fld* = 4;    Typ* = 5;    LProc* = 6;    XProc* = 7;
	SProc* = 8;    CProc* = 9;    Mod* = 11;    Head* = 12;    TProc* = 13;    Alias* =14;

	(* structure forms *)
	Undef* = 0;    Byte* = 1;    Bool* = 2;    Char* = 3;    SInt* = 4;    Int* = 5;    LInt* = 6;
	Real* = 7;    LReal* = 8;    Set* = 9;    String* = 10;    NilTyp* = 11;    NoTyp* = 12;
	Pointer* = 13;    ProcTyp* = 14;    Comp* = 15;

	(* composite structure forms *)
	Basic* = 1;    Array* = 2;    DynArr* = 3;    Record* = 4;
	*)
TYPE
	(** voyager specific **)
	Index* = SIGNED32;  	(*= index type for open arrays *)
	(*	Coordinate*=SIGNED16; 	(*= type used for output coordinates *)
	Color*= SIGNED16;
	RealNumber*=FLOAT64;  (*= base type for numerics and 2d coordinates*)

	FilesReader*=Files.Rider;
	FilesWriter*=Files.Rider;
	*)
	Viewer* = Viewers.Viewer;  	(*= base type for all views *)
	Frame* = Display.Frame;  	(*= port mapper for views *)
	(*
	(** basic graphic types *)
	tCoordinate* = POINTER TO tCoordinateDesc;
	tCoordinateDesc* = RECORD
	x0*, y0*,w0*,h0*: SIGNED16
	END;
	tRegion2d* = POINTER TO tRegion2dDesc;
	tRegion2dDesc* = RECORD
	x*, y*, w*, h*: RealNumber;
	prev*: tRegion2d;
	END;

	tCoordinate2d* = POINTER TO tCoordinate2dDesc;
	tCoordinate2dDesc* = RECORD (tCoordinateDesc)
	x*, y*, w*, h*: SIGNED16; 			(* screen region *)
	x2d*, y2d*, w2d*, h2d*: RealNumber; 	(* real world region *)
	xFact*, yFact*: RealNumber;
	x02d*, y02d*: SIGNED16;
	zoomCache*: tRegion2d;
	END;
	*)
	(*** Tick counter and time controlled actions ***)
CONST
	second* = 300;  	(*= time units per second *)
	slides* = 150;  		(*= recommended frame rate for slides: 2 slides per second *)
	movie* = 15;  		(*= recommended frame rate for continuous: 20 frames per second *)
	maxdims* = 10;  	(* max dimension of arrays supported. not needed for Oberon-2 *)

TYPE
	(*	TypeObject*=vyOOPT.Object;
	Struct*=vyOOPT.Struct;

	TickMsg*=RECORD (Display.FrameMsg) END; 	(*! move to Action type *)

	*)
	(*
	TickProc*= PROCEDURE; 	(*! move to Action type *)

	ProcQPtr=POINTER TO ProcQElem;  	(*! move to Action type *)
	ProcQElem=RECORD(*! move to Action type *)
	Proc:	TickProc;
	TickDelta:	SIGNED32;  (* time delta, in ticks. 0: always *)
	NextTime:	SIGNED32;
	next:ProcQPtr
	END; *)
	(*
	tAction* = POINTER TO tActionDesc;
	tActionProc*=PROCEDURE (action:tAction; VAR failed:BOOLEAN);
	tActionDesc* = RECORD (Oberon.TaskDesc)
	Do*: tActionProc;
	failed-:BOOLEAN;          (*= If a pre-action failed, abort action chain and bail out.
	Use Output for explicit status *)
	todoCount-:SIGNED32;
	preAction-:tAction; 		(* NIL, or an action which must be done, before this one can be invoked *)
	TickDelta: SIGNED32; 	(* NIL, or an action which must be done, before this one can be invoked *)
	termination: tAction;
	END;
	*)
VAR
	(*	ProcToCall:ProcQPtr;
	countTask: Oberon.Task; *)
	(*	slow*: SIGNED16; 	(*= slow motion factor. All deltas are multiplied by this factor *) *)
	ticks-: SIGNED32;
	w: Texts.Writer;
	(*	(*= basic types, copied from OPT. A generic module will not need to access OPT, but can use these copies *)
	undftyp*, bytetyp*, booltyp*, chartyp*, sinttyp*, inttyp*, linttyp*,
	realtyp*, lrltyp*, settyp*, stringtyp*, niltyp*, notyp*, sysptrtyp*, ptrtyp*: Struct;

	dynboolarray*,dynintarray*,dynlintarray*,dynrealarray*,dynlrlarray*:Struct;   	*)
	(***** ** PROCEDURE section **  ****)
PROCEDURE Addr* (p: ANY): ADDRESS;
BEGIN
	RETURN SYSTEM.VAL(ADDRESS, p)
END Addr;

(** Texts **)
(*
PROCEDURE AppendToLog* (VAR w:Texts.Writer); (* vyHost.AppendToLog(w); *)
BEGIN Texts.Append(Oberon.Log,w.buf);
END AppendToLog;

PROCEDURE AppendToText* (VAR t:Text; VAR w:Texts.Writer);
BEGIN Texts.Append(t,w.buf);
END AppendToText;
*)
(*** Display system and global state access ***)

(** Caret mark. Default output position **)

PROCEDURE GetCaret* (VAR F: Frame;   VAR text: Texts.Text;   VAR pos: SIGNED32);
	(*= get viewer and text of current insertion caret. *)
	VAR Cmsg: Oberon.CaretMsg;
BEGIN
	F := NIL;   text := NIL;
	Cmsg.id := Oberon.get;   Cmsg.car := NIL;   Cmsg.text := NIL;   Cmsg.F := NIL;   Cmsg.res := - 1;
	Display.Broadcast(Cmsg);
	IF Cmsg.res < 0  THEN text := NIL END;
	ASSERT(Cmsg.car # NIL, 100);
	F := Cmsg.car;   text := Cmsg.text;   pos := Cmsg.pos
END GetCaret;

(** Latest selection **)

PROCEDURE GetSelectionText* (VAR text: Texts.Text;  VAR beg, end: SIGNED32);
	(*= get recent selection. *)

	VAR time: SIGNED32;
BEGIN
	Oberon.GetSelection(text, beg, end, time);
	IF time < 0 THEN text := NIL END
END GetSelectionText;

(** Textual parameters **)

PROCEDURE GetPar*;
	(*= get parameters. *)
BEGIN
	HALT(100)
END GetPar;

PROCEDURE GetParText* (VAR text: Texts.Text;  VAR pos: SIGNED32);  	(*= get parameters text. *)
BEGIN
	text := Oberon.Par.text;  pos := Oberon.Par.pos
END GetParText;

(** Marked viewer. Target for actions **)
PROCEDURE GetMarkedViewer*;
	(*= get viewer marked as target for actions. *)
END GetMarkedViewer;

PROCEDURE GetMarkedText* (VAR text: Texts.Text);
	VAR V: Viewer;gadget: Objects.Object;
BEGIN
	V := Oberon.MarkedViewer();
	IF (V # NIL) & (V.dsc # NIL) & (V.dsc.next # NIL)
		 & (V.dsc.next IS TextFrames.Frame) THEN
		text := V.dsc.next(TextFrames.Frame).text
	ELSIF (V # NIL) THEN
		Links.GetLink(V,"Model",gadget);
		WHILE(gadget # NIL) DO
			IF gadget IS Texts.Text THEN
				text := gadget(Texts.Text); RETURN;
			END;
			Links.GetLink(gadget,"Model",gadget);
		END;
	ELSE text := NIL
	END
END GetMarkedText;

(** Access by name **)
PROCEDURE GetNamedText* (name: ARRAY OF CHAR;   VAR text: Texts.Text);
BEGIN
	text := TextFrames.Text(name)
END GetNamedText;

PROCEDURE GetVisibleOutput (VAR F: Frame;  VAR text: Texts.Text);
	(*= Get a guaranteed text output path. If no text is accessible, or the text
	cannot be made visible, an error is occured *)
	VAR pos: SIGNED32;
BEGIN
	GetCaret(F, text, pos);
	IF (F = NIL) OR (text = NIL) THEN HALT(fatalcc) END;
	(*! support fall back paths*)
	(*! move to output position if possible *)
END GetVisibleOutput;


(*** String routines needed for conversion etc. ***)
(*= These are only the most simple routines used for name generation and
similar purposes. They MUST be aligned with the corresponding output routines.
*)
PROCEDURE StringLength* (s: ARRAY OF CHAR): Index;
	VAR i: Index;
BEGIN
	i := 0;   WHILE (i < LEN(s)) & (s[i] # 0X) DO INC(i) END;
	RETURN i
END StringLength;

PROCEDURE StringAppend* (extra: ARRAY OF CHAR;  start: Index;   VAR dest: ARRAY OF CHAR;  VAR pos: Index);
	(*= Append extra to dest. Always adds a stopping 0X *)
BEGIN
	WHILE extra[start] # 0X   DO dest[pos] := extra[start];   INC(start);   INC(pos) END;
	dest[pos] := 0X
END StringAppend;


PROCEDURE StringAppendInt* (x, n: SIGNED32;  VAR dest: ARRAY OF CHAR;  VAR pos: Index);
	(*= SIGNED32 to character string.
	append x as string at pos of dest; if n>0, fill with leading spaces;
	pos is moved to new end *)
	VAR i: SIGNED16;   x0: SIGNED32;
	a: ARRAY 11 OF CHAR;
BEGIN
	i := 0;   (* FOF changed *)
	IF x < 0 THEN
		IF x = MIN(SIGNED32) THEN StringAppend(" -2147483648", 0, dest, pos);   RETURN
		ELSE DEC(n);   x0 := - x
		END
	ELSE x0 := x
	END;
	REPEAT
		a[i] := CHR(x0 MOD 10 + 30H);   x0 := x0 DIV 10;   INC(i)
	UNTIL x0 = 0;
	WHILE n > i DO dest[pos] := " ";   DEC(n);  INC(pos) END;
	IF x < 0 THEN dest[pos] := "-";  INC(pos)  END;
	REPEAT DEC(i);   dest[pos] := a[i];  INC(pos) UNTIL i = 0;
	dest[pos] := 0X
END StringAppendInt;

PROCEDURE StringAppendHex* (x: SIGNED32;  VAR dest: ARRAY OF CHAR;   VAR pos: Index);
	(* no leading space used *)
	VAR i: SIGNED16;   y: SIGNED32;
	a: ARRAY 10 OF CHAR;
BEGIN
	i := 0;
	REPEAT y := x MOD 10H;
		IF y < 10 THEN a[i] := CHR(y + 30H) ELSE a[i] := CHR(y + 37H) END;
		x := x DIV 10H;   INC(i)
	UNTIL i = 8;
	REPEAT DEC(i);   dest[pos] := a[i];   INC(pos) UNTIL i = 0;
	dest[pos] := 0X
END  StringAppendHex;

PROCEDURE StringAppendDate* (t, d: SIGNED32;  VAR dest: ARRAY OF CHAR;   VAR pos: Index);

PROCEDURE StringAppendPair (ch: CHAR;   x: SIGNED32);
BEGIN dest[pos] := ch;   INC(pos);
	dest[pos] := CHR(x DIV 10 + 30H);   INC(pos);
	dest[pos] := CHR(x MOD 10 + 30H);   INC(pos)
END StringAppendPair;

BEGIN
	StringAppendPair(" ", d MOD 32);   StringAppendPair(".", d DIV 32 MOD 16);   StringAppendPair(".", d DIV 512 MOD 128);
	StringAppendPair(" ", t DIV 4096 MOD 32);   StringAppendPair(":", t DIV 64 MOD 64);
	StringAppendPair(":", t MOD 64);
	dest[pos] := 0X
END StringAppendDate;


(*
(*** Tick counter and time controlled actions ***)
PROCEDURE Slow*;  BEGIN slow:=slow*2 END Slow;
PROCEDURE Reset*;  BEGIN slow:=1 END Reset;

PROCEDURE Stop*;
BEGIN	Oberon.Remove(countTask);  countTask:=NIL
END Stop;

PROCEDURE Step*;
VAR M: TickMsg; t: SIGNED32;  pq:ProcQPtr;
BEGIN
IF countTask=NIL THEN Stop END;

t:=Oberon.Time();
pq:=ProcToCall;
WHILE pq#NIL DO
pq.Proc;  pq.NextTime:=t+pq.TickDelta*slow;
pq:=pq.next;
END;

(*	IF	t#ticks	THEN 		ticks:=t; Viewers.Broadcast(M)	END 	END Tick; *)
ticks:=t;

Display.Broadcast(M);

END Step;

PROCEDURE Register* (p:TickProc; delta:SIGNED32);  (*vs 0.1d0 gs *)
(*! avoid double entries *)
VAR pq:ProcQPtr;
BEGIN
NEW(pq);
pq.Proc:=p; pq.TickDelta:=delta; pq.NextTime:=Oberon.Time();
pq.next:=ProcToCall;
ProcToCall:=pq;
END Register;

PROCEDURE DeRegister* (p:TickProc);
VAR prevpq,pq:ProcQPtr;
BEGIN IF ProcToCall.Proc=p THEN ProcToCall:=ProcToCall.next ELSE
prevpq:= ProcToCall; pq:=ProcToCall.next;
WHILE pq#NIL DO
IF pq.Proc=p THEN prevpq.next:=pq.next;  RETURN END;
pq:=pq.next;
END;
END ;
END DeRegister;


PROCEDURE Tick (me:Oberon.Task); 	(* vs S3 *)(* Installed as an Oberon Task *)

VAR t: SIGNED32;  pq:ProcQPtr;  mintime:SIGNED32;
BEGIN	t:=Oberon.Time();  pq:=ProcToCall;   mintime:=MAX(SIGNED32);  (*? wrap around *)
IF pq#NIL THEN
WHILE pq#NIL DO
IF pq.NextTime<=t THEN pq.Proc;  pq.NextTime:=t+pq.TickDelta*slow;
IF pq.NextTime<mintime THEN mintime:= pq.NextTime END;
ELSE
IF pq.NextTime<mintime THEN mintime:=pq.NextTime;  END;
END;
pq:=pq.next;
END;
me.time:=mintime;
END; 	(*pq#NIL*)
END Tick;


PROCEDURE NewCountTask (VAR T: Oberon.Task);
BEGIN	NEW(T);  T.safe:=FALSE;  T.handle:=Tick;  Oberon.Install(T)
END NewCountTask;

PROCEDURE Run*;
BEGIN
IF	countTask=NIL	THEN	NewCountTask(countTask)	END;
END Run;
*)

(*** Command execution ***)

(** For module Oberon **)

PROCEDURE CallWString* (name: ARRAY OF CHAR;   pars: ARRAY OF CHAR;   new: BOOLEAN;   VAR res: SIGNED16);
	(*= call an Oberon command with parameters passed as a string *)
	VAR par: Oberon.ParList;  	w: Texts.Writer;
BEGIN Texts.OpenWriter(w);
	(*	Texts.WriteString(w, ' CallWString ');Texts.Write(w,'>');
	Texts.WriteString(w, pars);Texts.Write(w,'<');Texts.WriteLn(w);
	Texts.StringAppend(Oberon.Log, w.buf);*)
	(* *)
	NEW(par);  par.vwr := Oberon.Par.vwr;  par.frame := Oberon.Par.frame;  par.text := TextFrames.Text("");  par.pos := 0;
	(*	par:=Oberon.Par; (* ? some fail-safe values for the frame field are needed *)
	par.text := TextFrames.Text(""); Texts.WriteString(w, pars);
	Texts.StringAppend(par.text, w.buf); par.pos := 0;
	*)
	Texts.WriteString(w, pars);
	IF w.buf.len > 0 THEN Texts.Append(par.text, w.buf)  END;
	Oberon.Call(name, par, new, res)
END CallWString;

PROCEDURE CallWStringX* (name, pre: ARRAY OF CHAR;   pars: ARRAY OF CHAR;   new: BOOLEAN;   VAR res: SIGNED16);
	(*= call an Oberon command with parameters passed as a string.
	If res is FALSE,add prefix  and try again *)
	VAR 	name2: ARRAY 32 OF CHAR;
	i, j: SIGNED16;
BEGIN CallWString(name, pars, new, res);   IF res = 0 THEN RETURN END;
	i := 0;   j := 0;   WHILE pre[i] # 0X DO name2[i] := pre[i];   INC(i) END;
	j := 0;   WHILE name[j] # 0X DO  name2[i] := name[j];   INC(i);   INC(j) END;
	name2[i] := 0X;
	CallWString(name2, pars, new, res)
END CallWStringX;


(*=
Motto:
Make it as simple as possible, but not simpler.
Contents	Tools and hacks for Oberon
*)


(** For module Math **)
(*
(*! defunct. Use NaN support of module Reals.
Remove calls to these functions *)
PROCEDURE IsNaN* (x: FLOAT64): BOOLEAN;
BEGIN
RETURN (Reals.IsNaNL(x))
END IsNaN;

PROCEDURE NaNCode* (x: FLOAT64): SIGNED16;
VAR h, l: SIGNED32;
BEGIN
Reals.NaNCodeL(x, h, l);
RETURN  SHORT(l)	(*! code high part not yet supported *)
END NaNCode;

PROCEDURE NaN* (code: SIGNED16): FLOAT64;
VAR x: FLOAT64;
BEGIN
RETURN Reals.NaN(code) (*! hack: Reals.NaNL not yet supported in MacOberon 2.3 *)
END NaN;
*)
(*PROCEDURE NoNumberNaN* ():FLOAT64;
VAR x:FLOAT64;
BEGIN
RETURN Reals.NaN(cnonumber);(*! hack: Reals.NaNL not yet supported in MacOberon 2.3 *)
END NoNumberNaN;

*)

PROCEDURE XpwrI* (x: FLOAT32;   i: SIGNED16): FLOAT32;
	VAR z: FLOAT32;
BEGIN IF i < 0 THEN  x := 1 / x;  i := - i END;
	z := 1;
	WHILE i > 0 DO
		(* z*u**e=x**i, e>0 *)
		WHILE ~ODD(i) DO i := i DIV 2;   x := x * x END;
		DEC(i);   z := z * x
	END;
	RETURN z
END XpwrI;

PROCEDURE XLpwrIL* (x: FLOAT64;   i: SIGNED32): FLOAT64;
	VAR z: FLOAT64;
BEGIN IF i < 0 THEN  x := 1 / x;  i := - i END;
	z := 1;
	WHILE i > 0 DO
		(* z*u**e=x**i, e>0 *)
		WHILE ~ODD(i) DO i := i DIV 2;   x := x * x END;
		DEC(i);   z := z * x
	END;
	RETURN z
END XLpwrIL;

PROCEDURE Ten* (i: SIGNED16): FLOAT32;
	(* special case of XpwrI(10.0,i) -- optimize ! Use Reals.Ten*)
	VAR x, z: FLOAT32;
BEGIN
	IF i < 0 THEN x := 0.1  ELSE x := 10.0  END;
	z := 1;
	WHILE i > 0 DO (* z*u**e=x**i, e>0 *)
		WHILE ~ODD(i) DO i := i DIV 2;   x := x * x END;
		DEC(i);   z := z * x
	END;
	RETURN z

END Ten;

PROCEDURE TenL* (i: SIGNED32): FLOAT64;
	(* special case of XpwrI(10.0,i) -- optimize ! Use Reals.Ten*)
	VAR x, z: FLOAT64;
BEGIN IF i < 0 THEN x := 0.1  ELSE x := 10.0  END;
	z := 1;
	WHILE i > 0 DO (* z*u**e=x**i, e>0 *)
		WHILE ~ODD(i) DO i := i DIV 2;   x := x * x END;
		DEC(i);   z := z * x
	END;
	RETURN z
END TenL;

(** For module texts **)
(*= support for scanner components to get information of known type from text.

These are high risk routines. They expect that all position and sizes are valid, and the
text segment is of expected type*)

PROCEDURE GetString*
 (VAR text: Texts.Text;  pos: SIGNED32;   len: SIGNED16;   VAR s: ARRAY OF CHAR): BOOLEAN;
	VAR i: SIGNED16;   r: Texts.Reader;  temp: BOOLEAN;
BEGIN Texts.OpenReader(r, text, pos);
	IF len >= LEN(s) THEN len := SIGNED16(LEN(s)) - 1;   temp := FALSE
	ELSE temp := TRUE END;
	i := 0;   WHILE i < len DO Texts.Read(r, s[i]);   INC(i) END;
	s[i] := 0X;
	RETURN temp
END GetString;

PROCEDURE GetLInt* (VAR text: Texts.Text;  pos: SIGNED32;   len: SIGNED16;  VAR x: SIGNED32): BOOLEAN;
	VAR i: SIGNED16;   r: Texts.Reader;   neg, res: BOOLEAN;  c: CHAR;
BEGIN IF (text = NIL) OR ((pos < 0) OR (len <= 0)) THEN x := 0;   RETURN FALSE END;

	(*! add error check and perform proper test *)
	Texts.OpenReader(r, text, pos);
	x := 0;  res := TRUE;  neg := FALSE;
	Texts.Read(r, c);  IF ("0" <= c) & (c <= "9") THEN x := (ORD(c) - 30H)
	ELSIF (c = "+") THEN IF len = 1 THEN RETURN FALSE END
	ELSIF (c = "-") THEN neg := TRUE;   IF len = 1 THEN RETURN FALSE END
	ELSE RETURN FALSE END;

	i := 1;   WHILE i < len DO Texts.Read(r, c);   INC(i);
		IF ("0" <= c) & (c <= "9") THEN x := x * 10 + (ORD(c) - 30H);  	ASSERT(x >= 0, 101)
		ELSE res := FALSE;   i := len  END
	END;   (* WHILE *)
	IF neg THEN x := - x  END;
	RETURN res
END GetLInt;

PROCEDURE GetInt* (VAR text: Texts.Text;  pos: SIGNED32;   len: SIGNED16;  VAR x: SIGNED16): BOOLEAN;
	VAR res: BOOLEAN;  xl: SIGNED32;
BEGIN res := GetLInt(text, pos, len, xl);
	IF res THEN 	(*! Add range check *)
		x := SHORT(xl);   RETURN TRUE
	ELSE RETURN FALSE END
END GetInt;

PROCEDURE GetSInt* (VAR text: Texts.Text;  pos: SIGNED32;   len: SIGNED16;  VAR x: SIGNED8): BOOLEAN;
	VAR res: BOOLEAN;  xl: SIGNED32;
BEGIN res := GetLInt(text, pos, len, xl);
	IF res THEN 	(*! Add range check *)
		x := SHORT(SHORT(xl));   RETURN TRUE
	ELSE RETURN FALSE END
END GetSInt;

PROCEDURE GetLReal* (VAR text: Texts.Text;  pos: SIGNED32;   len: SIGNED16;
VAR x: FLOAT64): BOOLEAN;
	VAR i: SIGNED16;   r: Texts.Reader;   more, res, negex: BOOLEAN;  c: CHAR;  pre, post, exp, pow: SIGNED32;
	(*xx:ARRAY 2 OF CHAR; *)neg: BOOLEAN;
BEGIN IF (text = NIL) OR ((pos < 0) OR (len <= 0)) THEN x := 0;   RETURN FALSE END;
	Texts.OpenReader(r, text, pos);  (*xx[1]:=0X;*)
	x := 0;  res := TRUE;  pre := 0;  post := 0;  exp := 0;   more := TRUE;  pow := 1;  negex := FALSE;   neg := FALSE;  (* gs 29.3.97 *)
	(*vyHostTexts.MsgSISI('GetReal* scan from pos ',pos,'for len ',len);*)
	(* pre *)
	Texts.Read(r, c);  IF ("0" <= c) & (c <= "9") THEN pre := (ORD(c) - 30H)
	ELSIF (c = "+") THEN IF len = 1 THEN RETURN FALSE END
	ELSIF (c = "-") THEN neg := TRUE;   IF len = 1 THEN RETURN FALSE END
	ELSE more := FALSE;   res := FALSE END;
	i := 1;   WHILE (i < len) & more DO Texts.Read(r, c);   INC(i);
		(*xx[0]:=c; vyHostTexts.MsgSI(xx,i);*)

		IF ("0" <= c) & (c <= "9") THEN pre := pre * 10 + (ORD(c) - 30H);  	ASSERT(pre >= 0, 101)
		ELSE more := FALSE;     res := (c = ".")
		(* ; xx[0]:=c; vyHostTexts.MsgStS(xx,' is stopping char')  *)END
	END;  (* WHILE *)
	(* IF res THEN vyHostTexts.MsgSI('pre:',pre) ELSE vyHostTexts.MsgSI('~pre:',pre) END; *)
	(* post *)
	IF res THEN
		more := TRUE;  WHILE (i < len) & more DO Texts.Read(r, c);   INC(i);
			IF ("0" <= c) & (c <= "9") THEN post := post * 10 + (ORD(c) - 30H);  pow := pow * 10;
				ASSERT(pre >= 0, 102);  ASSERT(pow >= 0, 103)
			ELSE more := FALSE;    res := (c = "E") END
		END  (* WHILE *)
	END;
	(* IF res THEN vyHostTexts.MsgSI('post:',post) ELSE vyHostTexts.MsgSI('~post:',post) END;
	vyHostTexts.MsgSI('pow',pow);*)
	(*exp*)
	IF res THEN
		more := TRUE;   IF (i < len) THEN Texts.Read(r, c);   INC(i);   negex := ( c = "-");
			IF (c = "+") OR (c = "-") THEN
				IF (i < len) THEN Texts.Read(r, c);   INC(i) ELSE res := FALSE END (* at least one digit is needed *)
			END;   (*(c='+') OR (c='-') *)
			IF ("0" <= c) & (c <= "9") THEN exp := (ORD(c) - 30H) ELSE res := FALSE  END;
			IF res THEN
				WHILE (i < len) & more DO Texts.Read(r, c);   INC(i);
					IF ("0" = c) & (c <= "9") THEN exp := exp * 10 + (ORD(c) - 30H);  	ASSERT(exp >= 0, 101)
					ELSE  res := FALSE END
				END  (* WHILE *)
			END
		END;   (* exponent*)

		(* IF res THEN vyHostTexts.MsgSI('exp:',exp) ELSE vyHostTexts.MsgSI('~exp:',exp) END; *)

		IF res THEN x := (pre + (post / pow) ) END;
		IF res THEN IF negex THEN x := (x / TenL(exp))
			ELSE  x := (x * TenL(exp)) END
		END;  (*res*)END;
		IF neg THEN x := - x END;   (* gs 29.3.97 *)
		(*! handle/note real underflow or overflow *)
		RETURN res;   (**! dummy *)
	END GetLReal;

	PROCEDURE GetReal* (VAR text: Texts.Text;  pos: SIGNED32;   len: SIGNED16;
VAR x: FLOAT32): BOOLEAN;
	VAR xl: FLOAT64;   res: BOOLEAN;
BEGIN res := GetLReal(text, pos, len, xl);
	IF res THEN	(*! Add range check *)
		x := SHORT(xl);   RETURN TRUE
	ELSE RETURN FALSE END
END GetReal;

PROCEDURE ShowId*;
	VAR F: Frame;   VAR text: Texts.Text;
BEGIN
	GetVisibleOutput(F, text);
	Texts.WriteString(w, idversion);  Texts.WriteLn(w);
	Texts.Append(text, w.buf);
	(*!show logo*)
END ShowId;

PROCEDURE DisplayNewPattern* ( x, y: SIGNED16;   VAR img: ARRAY OF SET): ADDRESS;
BEGIN
	RETURN Display.NewPattern(x, y, img)
END  DisplayNewPattern;

(*
PROCEDURE LoadCoordinate2d* (VAR r: FilesReader; c: tCoordinate2d);
(** vs 0.0d0	md  01.06.94 08:46:53 *)
BEGIN
Files.ReadInt (r, c.x); Files.ReadInt (r, c.y); Files.ReadInt (r, c.w); Files.ReadInt (r, c.h);
Files.ReadLReal (r, c.x2d); Files.ReadLReal (r, c.y2d);
Files.ReadLReal (r, c.w2d); Files.ReadLReal (r, c.h2d);
Files.ReadLReal (r, c.xFact); Files.ReadLReal (r, c.yFact);
Files.ReadInt (r, c.x0); Files.ReadInt (r, c.y0);
c.zoomCache := NIL;
END LoadCoordinate2d;

PROCEDURE StoreCoordinate2d* (VAR r: FilesWriter; c: tCoordinate2d);
(** vs 0.0d0	md  01.06.94 08:47:27 *)
BEGIN
Files.WriteInt (r, c.x); Files.WriteInt (r, c.y); Files.WriteInt (r, c.w); Files.WriteInt (r, c.h);
Files.WriteLReal (r, c.x2d); Files.WriteLReal (r, c.y2d);
Files.WriteLReal (r, c.w2d); Files.WriteLReal (r, c.h2d);
Files.WriteLReal (r, c.xFact); Files.WriteLReal (r, c.yFact);
Files.WriteInt (r, c.x0); Files.WriteInt (r, c.y0);
END StoreCoordinate2d;
*)
(*
PROCEDURE LoadCoordinate2d* (VAR r: FilesReader; c: tCoordinate2d);
(** vs 0.0d0	md  01.06.94 08:46:53 *)
BEGIN
Files.ReadInt (r, c.x); Files.ReadInt (r, c.y); Files.ReadInt (r, c.w); Files.ReadInt (r, c.h);
Files.ReadReal (r, c.x2d); Files.ReadReal (r, c.y2d);
Files.ReadReal (r, c.w2d); Files.ReadReal (r, c.h2d);
Files.ReadReal (r, c.xFact); Files.ReadReal (r, c.yFact);
Files.ReadInt (r, c.x0); Files.ReadInt (r, c.y0);
c.zoomCache := NIL
END LoadCoordinate2d;

PROCEDURE StoreCoordinate2d* (VAR r: FilesWriter; c: tCoordinate2d);
(** vs 0.0d0	md  01.06.94 08:47:27 *)
BEGIN
Files.WriteInt (r, c.x); Files.WriteInt (r, c.y); Files.WriteInt (r, c.w); Files.WriteInt (r, c.h);
Files.WriteReal (r, c.x2d); Files.WriteReal (r, c.y2d);
Files.WriteReal (r, c.w2d); Files.WriteReal (r, c.h2d);
Files.WriteReal (r, c.xFact); Files.WriteReal (r, c.yFact);
Files.WriteInt (r, c.x0); Files.WriteInt (r, c.y0)
END StoreCoordinate2d;
*)
(*PROCEDURE CopyCoordinate2d* (sc, dc: tCoordinate2d);
(* md	 05.04.94 14:17:57 *)
BEGIN
dc.x := sc.x;  dc.y := sc.y;  dc.w := sc.w;  dc.h := sc.h;
dc.x2d := sc.x2d;  dc.y2d := sc.y2d;  dc.w2d := sc.w2d;  dc.h2d := sc.h2d;
dc.x0 := sc.x0;  dc.y0 := sc.y0;  dc.xFact := sc.xFact;  dc.yFact := sc.yFact;
dc.zoomCache := NIL;
END CopyCoordinate2d; 	*)

(* PROCEDURE AppendAction* (newaction,prevaction:tAction);
(*= Append new action to an action list. Prevaction will be executed before new action is done. *)
BEGIN
IF newaction=NIL THEN RETURN END;
newaction.preAction:=prevaction; newaction.todoCount:=0;
END AppendAction;

PROCEDURE DoAction* (action:tAction);
(*= Use with care. DoAction escapes the general message mechanism and may block the machine. *)
BEGIN
action.failed:=FALSE;
IF action.preAction#NIL THEN DoAction(action.preAction);  action.failed:=action.preAction.failed END;
IF ~action.failed THEN action.Do(action,action.failed);
IF action.todoCount>0 THEN DEC(action.todoCount) END
END;
END DoAction;

PROCEDURE TerminateAction* (action:tAction);
BEGIN Oberon.Remove(action);
IF action.termination # NIL THEN action.termination.Do(action,action.termination.failed) END;
END TerminateAction;

PROCEDURE Suspend* (action:tAction);
BEGIN Oberon.Remove(action)
END Suspend;

PROCEDURE Resume* (action:tAction);
VAR t: SIGNED32;
BEGIN t:=Oberon.Time();action.time:=t;Oberon.Install(action)
END Resume;

PROCEDURE DoRunAction (action:Oberon.Task);
(*= Internal version of DoAction, to be used with timer. *)
VAR t: SIGNED32;
BEGIN
WITH action:tAction DO
action.failed:=FALSE;
IF action.preAction#NIL THEN DoAction(action.preAction);  action.failed:=action.preAction.failed END;
IF ~action.failed THEN
t:=Oberon.Time();
action.time:=t+action.TickDelta*slow;
action.Do(action,action.failed);
IF action.todoCount>0 THEN DEC(action.todoCount) END;
IF action.todoCount=0 THEN TerminateAction(action) END
END;
END;
END DoRunAction;

PROCEDURE RunAction* (action:tAction;  requcount:SIGNED32;  delay:SIGNED32;  termination:tAction);
(*= Install an action as background task, and run it repeatedly. If reqcount>0, stop after reqcount runs and call termination.
Use delay between successive calls. Update events must be supported by the Do action if required.
*)
VAR t: SIGNED32;
BEGIN 	t:=Oberon.Time();     (*? wrap around *)
IF action=NIL THEN RETURN  END;
IF requcount<1 THEN action.todoCount:=-1 ELSE action.todoCount:=requcount END;
action.termination:=termination;  IF termination#NIL THEN termination.preAction:=action END;
action.TickDelta:=delay;
action.handle:=DoRunAction;  action.safe:=FALSE;
action.time:=t;
Oberon.Install(action);
END RunAction;
*)
(*PROCEDURE RealToCoord* (r: RealNumber): Coordinate;
BEGIN
RETURN SHORT(ENTIER(r))
END RealToCoord;
*)

PROCEDURE StackFrame* (msg: ARRAY OF CHAR);
(* BEGIN Examiner.StackFrame(msg)*)
END StackFrame;


BEGIN

	Texts.OpenWriter(w)
	(*
	ProcToCall:=NIL; 	Reset; 	(*= Tick counter and time controlled actions ***)
	(* from OOPT *)
	undftyp:=vyOOPT.undftyp;    bytetyp:=vyOOPT.bytetyp;    booltyp:=vyOOPT.booltyp;    chartyp:=vyOOPT.chartyp;
	sinttyp:=vyOOPT.sinttyp;    inttyp:=vyOOPT.inttyp;    linttyp:=vyOOPT.linttyp;
	realtyp:=vyOOPT.realtyp;    lrltyp:=vyOOPT.lrltyp;    settyp:=vyOOPT.settyp;    stringtyp:=vyOOPT.stringtyp;
	niltyp:=vyOOPT.niltyp;    notyp:=vyOOPT.notyp;    sysptrtyp:=vyOOPT.sysptrtyp;

	ptrtyp:=vyOOPT.ptrtyp;

	NEW(dynboolarray);   dynboolarray.form:=Comp;   dynboolarray.comp:=DynArr;   dynboolarray.BaseTyp:=booltyp;
	NEW(dynintarray);   dynintarray.form:=Comp;   dynintarray.comp:=DynArr;   dynintarray.BaseTyp:=inttyp;
	NEW(dynlintarray);   dynlintarray.form:=Comp;   dynlintarray.comp:=DynArr;   dynlintarray.BaseTyp:=linttyp;
	NEW(dynrealarray);   dynrealarray.form:=Comp;   dynrealarray.comp:=DynArr;   dynrealarray.BaseTyp:=realtyp;
	NEW(dynlrlarray);   dynlrlarray.form:=Comp;   dynlrlarray.comp:=DynArr;   dynlrlarray.BaseTyp:=lrltyp
*)END vyHost.
