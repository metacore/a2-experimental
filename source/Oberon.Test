# Oberon language test and validation suite


# Syntax tests
# =====================================


# plain modules

negative: missing module name

	MODULE END.

negative: unmatched module name

	MODULE Test; END tseT.

negative: missing semicolon in module definition

	MODULE Test END Test.

negative: missing END in module definition

	MODULE Test; Test.

negative: missing concluding dot

	MODULE Test; END Test

positive: empty module

	MODULE Test; END Test.


# identifiers

negative: number as identifier

	MODULE 007;
	END 007.

negative: keyword as identifier

	MODULE THEN;
	END THEN.

negative: string as identifier

	MODULE "Test";
	END "Test".

positive: single character identifier

	MODULE T;
	END T.

positive: long identifiers

	MODULE IncrediblyLongModuleNameLikeSupercalifragilisticexpialidocious;
	END IncrediblyLongModuleNameLikeSupercalifragilisticexpialidocious.

positive: underscore in identifier

	MODULE Test_Module;
	END Test_Module.


# comments

negative: comment only

	(* MODULE *)

positive: comment in front of module definition

	(* comment *)
	MODULE Test; END Test.

positive: comment within module definition

	MODULE Test;
	(* comment *)
	END Test.

positive: comment after module definition

	MODULE Test;
	END Test.
	(* comment *)

positive: plain text after module definition

	MODULE Test;
	END Test.

	plain text

negative: invalid closing of comment

	MODULE Test; *) END Test.

negative: missing closing of comment

	MODULE Test; (* END Test.

positive: comment spanning several lines

	MODULE Test;
	(*
	   this comment spans
	   several text lines
	*)
	END Test.

positive: comment as whitespace

	MODULE(*whitespace*)Test;END(*whitespace*)Test.


# nested comments

positive: nested comment

	(* (* nested comment *) *)
	MODULE Test; END Test.

negative: invalid closing of nested comment

	(* nested comment *) *)
	MODULE Test; END Test.

negative: missing closing of nested comment

	(* (* nested comment *)
	MODULE Test; END Test.

positive: double nested comments

	(* (* extremely (* nested comment *) *) *)
	MODULE Test; END Test.

positive: multiple nested comments

	MODULE Test;
	(* (* multiple *) nested (* comments (* over (* four *) levels *) *) *)
	END Test.

negative: invalid multiple nested comments

	MODULE Test;
	(* invalid (* multiple *) nested (* comments (* over *) (* four *) levels *) *) *)
	END Test.


# import section

positive: dummy module for import section tests

	MODULE A; END A.

negative: empty import list

	MODULE Test;
	IMPORT;
	END Test.

negative: single module import without concluding semicolon

	MODULE Test;
	IMPORT A
	END Test.

positive: single module import

	MODULE Test;
	IMPORT A;
	END Test.

positive: single module import with alias

	MODULE Test;
	IMPORT B := A;
	END Test.

negative: double module import missing second module name

	MODULE Test;
	IMPORT A, ;
	END Test.

negative: double module import without separating comma

	MODULE Test;
	IMPORT B := A C := A;
	END Test.

negative: double module import with separating semicolon

	MODULE Test;
	IMPORT B := A; C := A;
	END Test.

negative: double module import without concluding semicolon

	MODULE Test;
	IMPORT B := A, C := A
	END Test.

positive: double module import

	MODULE Test;
	IMPORT B := A, C := A;
	END Test.

positive: multiple module import

	MODULE Test;
	IMPORT B := A, C := A, D := A, E := A;
	END Test.

negative: multiple import lists

	MODULE Test;
	IMPORT B := A;
	IMPORT C := A;
	END Test.


# const section

positive: empty const section

	MODULE Test;
	CONST
	END Test.

positive: const section without declarations

	MODULE Test;
	CONST ;;;;
	END Test.

positive: repeated empty const sections

	MODULE Test;
	CONST CONST CONST
	CONST ; CONST ; CONST
	END Test.

negative: single constant declaration missing equal sign

	MODULE Test;
	CONST Constant 5;
	END Test.

negative: single constant declaration missing value

	MODULE Test;
	CONST Constant =
	END Test.

positive: single constant declaration

	MODULE Test;
	CONST Constant = 5
	END Test.

negative: double constant declaration without separating semicolon

	MODULE Test;
	CONST A = 5 B = 10
	END Test.

positive: double constant declaration

	MODULE Test;
	CONST A = 5; B = 10
	END Test.


# literals

positive: boolean literal FALSE

	MODULE Test;
	CONST Boolean = TRUE
	END Test.

positive: boolean literal TRUE

	MODULE Test;
	CONST Boolean = FALSE
	END Test.

# legacy behaviour
positive: character literal using '

	MODULE Test;
	CONST Character = 'a'
	END Test.

# legacy behaviour
positive: character literal using "

	MODULE Test;
	CONST Character = "b"
	END Test.

negative: unclosed character literal

	MODULE Test;
	CONST Character = 't
	END Test.

positive: uppercase hexadecimal character literal

	MODULE Test;
	CONST Character = 0ABX
	END Test.

negative: lowercase hexadecimal character literal

	MODULE Test;
	CONST Character = 0efX
	END Test.

negative: hexadecimal character literal beginning with letter

	MODULE Test;
	CONST Character = CDX
	END Test.

negative: hexadecimal character literal missing concluding X

	MODULE Test;
	CONST Character = 9A
	END Test.

negative: hexadecimal character literal with concluding x

	MODULE Test;
	CONST Character = CAx
	END Test.

positive: integer literal

	MODULE Test;
	CONST Integer = 25
	END Test.

positive: uppercase hexadecimal integer literal

	MODULE Test;
	CONST Integer = 1EDH
	END Test.

negative: lowercase hexadecimal integer literal

	MODULE Test;
	CONST Integer = 4faH
	END Test.

negative: hexadecimal integer literal beginning with letter

	MODULE Test;
	CONST Integer = EFH
	END Test.

negative: hexadecimal integer literal missing concluding H

	MODULE Test;
	CONST Integer = 42F
	END Test.

negative: hexadecimal integer literal with concluding h

	MODULE Test;
	CONST Integer = 89h
	END Test.

positive: real literal

	MODULE Test;
	CONST Real = 25.3
	END Test.

positive: real literal with concluding dot

	MODULE Test;
	CONST Real = 7.
	END Test.

negative: real literal beginning with dot

	MODULE Test;
	CONST Real = .4
	END Test.

negative: real literal with comma instead of dot

	MODULE Test;
	CONST Real = 12,1
	END Test.

positive: real literal with scale factor

	MODULE Test;
	CONST Real = 1.2E5
	END Test.

positive: real literal with positive scale factor

	MODULE Test;
	CONST Real = 0.3E+8
	END Test.

positive: real literal with negative scale factor

	MODULE Test;
	CONST Real = 0.E-54
	END Test.

negative: real literal with scale factor without number

	MODULE Test;
	CONST Real = 6354.9E+
	END Test.

negative: real literal with scale factor without number and sign

	MODULE Test;
	CONST Real = 9.1E
	END Test.

negative: real literal with lowercase scale factor

	MODULE Test;
	CONST Real = 24.e97
	END Test.

negative: real literal with hexadecimal scale factor

	MODULE Test;
	CONST Real = 1.97E1AB
	END Test.

negative: real literal with whitespace sepatared scale factor

	MODULE Test;
	CONST Real = 12.3 E-4
	END Test.

negative: real literal with scale factor with whitespace sepatared number

	MODULE Test;
	CONST Real = 0.1E 2
	END Test.

negative: real literal with scale factor without decimal point

	MODULE Test;
	CONST Real = 5E+2
	END Test.

positive: long real literal with scale factor

	MODULE Test;
	CONST Real = 0.77D24
	END Test.

positive: long real literal with positive scale factor

	MODULE Test;
	CONST Real = 0.1D+9
	END Test.

positive: long real literal with negative scale factor

	MODULE Test;
	CONST Real = 1.D-14
	END Test.

negative: long real literal with lowercase scale factor

	MODULE Test;
	CONST Real = 24.d97
	END Test.

positive: set literal

	MODULE Test;
	CONST Set = {}
	END Test.

negative: unclosed set literal

	MODULE Test;
	CONST Set = {
	END Test.

negative: unopened set literal

	MODULE Test;
	CONST Set = }
	END Test.

# legacy behaviour
positive: string literal using '

	MODULE Test;
	CONST String = 'abc'
	END Test.

# legacy behaviour
positive: string literal using "

	MODULE Test;
	CONST String = "ABC"
	END Test.

negative: unclosed string literal

	MODULE Test;
	CONST Character = "string
	END Test.


# type section

positive: empty type section

	MODULE Test;
	TYPE
	END Test.

positive: type section without declarations

	MODULE Test;
	TYPE ;;;;
	END Test.

positive: repeated empty type sections

	MODULE Test;
	TYPE TYPE TYPE
	TYPE ; TYPE ; TYPE
	END Test.

negative: single type declaration missing equal sign

	MODULE Test;
	TYPE Type RECORD END;
	END Test.

negative: single type declaration missing type

	MODULE Test;
	TYPE Type =
	END Test.

positive: single type declaration

	MODULE Test;
	TYPE Type = OBJECT;
	END Test.

negative: double type declaration without separating semicolon

	MODULE Test;
	TYPE A = RECORD END B = OBJECT;
	END Test.

positive: double type declaration

	MODULE Test;
	TYPE A = OBJECT; B = RECORD END
	END Test.


# types

negative: array without of

	MODULE Test;
	TYPE Array = ARRAY 10 OBJECT;
	END Test.

negative: array without base type

	MODULE Test;
	TYPE Array = ARRAY 15 OF;
	END Test.

positive: basic array of objects

	MODULE Test;
	TYPE Array = ARRAY 5 OF OBJECT;
	END Test.

negative: record without end

	MODULE Test;
	TYPE Record = RECORD;
	END Test.

positive: simple record

	MODULE Test;
	TYPE Record = RECORD END;
	END Test.

negative: record with empty parent record

	MODULE Test;
	TYPE Record = RECORD () END;
	END Test.

negative: record with explicitly defined parent record

	MODULE Test;
	TYPE Record = RECORD (RECORD END) END;
	END Test.

negative: record with variable declaration

	MODULE Test;
	TYPE Record = RECORD VAR f: OBJECT; END;
	END Test.

negative: pointer missing pointer keyword

	MODULE Test;
	TYPE Pointer = TO RECORD END;
	END Test.

negative: pointer missing to

	MODULE Test;
	TYPE Pointer = POINTER RECORD END;
	END Test.

negative: pointer missing base type

	MODULE Test;
	TYPE Pointer = POINTER TO;
	END Test.


# var section

positive: empty var section

	MODULE Test;
	VAR
	END Test.

positive: var section without declarations

	MODULE Test;
	VAR ;;;;
	END Test.

positive: repeated empty var sections

	MODULE Test;
	VAR VAR VAR
	VAR ; VAR ; VAR
	END Test.

negative: single variable declaration missing colon

	MODULE Test;
	VAR variable RECORD END;
	END Test.

negative: single variable declaration missing type

	MODULE Test;
	VAR variable: ;
	END Test.

positive: single variable declaration

	MODULE Test;
	VAR variable: RECORD END;
	END Test.

negative: double variable declaration without separating semicolon

	MODULE Test;
	VAR a: RECORD END b: OBJECT;
	END Test.

positive: double variable declaration

	MODULE Test;
	VAR a: ARRAY 10 OF CHAR; b: RECORD END;
	END Test.


# Semantic tests
# =====================================


# imports

positive: dummy module

	MODULE A; END A.

positive: single import

	MODULE Test;
	IMPORT A;
	END Test.

positive: single import with different alias

	MODULE Test;
	IMPORT B := A;
	END Test.

positive: single import with same alias

	MODULE Test;
	IMPORT A := A;
	END Test.

negative: duplicated import

	MODULE Test;
	IMPORT A, A;
	END Test.

positive: duplicated import with different alias

	MODULE Test;
	IMPORT B := A, C := A;
	END Test.

negative: duplicated import with same alias

	MODULE Test;
	IMPORT B := A, B := A;
	END Test.

# constants

positive: constant marked as exported

	MODULE Test;
	CONST Constant* = 54;
	END Test.

negative: constant marked as read-only

	MODULE Test;
	CONST Constant- = TRUE;
	END Test.

positive: backwards referencing constant

	MODULE Test;
	CONST A = 0; B = A;
	END Test.

positive: forwards referencing constant

	MODULE Test;
	CONST A = B; B = 0;
	END Test.

negative: cyclic referencing constants

	MODULE Test;
	CONST A = B; B = A;
	END Test.

negative: self referencing constant

	MODULE Test;
	CONST A = A;
	END Test.


# constant booleans

negative: arithmetic negation on constant boolean

	MODULE Test;
	CONST Result = -TRUE;
	END Test.

positive: logical negation on constant boolean

	MODULE Test;
	CONST Result = ~FALSE;
	END Test.

positive: multiple logical negations on constant boolean

	MODULE Test;
	CONST Result = ~~~~FALSE;
	END Test.

negative: addition on constant booleans

	MODULE Test;
	CONST Result = TRUE + FALSE;
	END Test.

negative: subtraction on constant booleans

	MODULE Test;
	CONST Result = FALSE - TRUE
	END Test.

negative: multiplication on constant booleans

	MODULE Test;
	CONST Result = FALSE * TRUE
	END Test.

negative: integer division on constant booleans

	MODULE Test;
	CONST Result = TRUE DIV TRUE
	END Test.

negative: real division on constant booleans

	MODULE Test;
	CONST Result = TRUE / FALSE
	END Test.

negative: modulo on constant booleans

	MODULE Test;
	CONST Result = FALSE MOD TRUE
	END Test.

positive: equal relation on constant booleans

	MODULE Test;
	CONST Result = TRUE = FALSE
	END Test.

positive: unequal relation on constant booleans

	MODULE Test;
	CONST Result = TRUE # TRUE
	END Test.

negative: less relation on constant booleans

	MODULE Test;
	CONST Result = TRUE < FALSE
	END Test.

negative: less or equal relation on constant booleans

	MODULE Test;
	CONST Result = FALSE <= FALSE
	END Test.

negative: greater relation on constant booleans

	MODULE Test;
	CONST Result = FALSE > TRUE
	END Test.

negative: greater or equal relation on constant booleans

	MODULE Test;
	CONST Result = FALSE >= TRUE
	END Test.

negative: set membership on constant booleans

	MODULE Test;
	CONST Result = TRUE IN FALSE
	END Test.

negative: type test on constant booleans

	MODULE Test;
	CONST Result = TRUE IS FALSE
	END Test.

positive: logical and on constant booleans

	MODULE Test;
	CONST Result = TRUE & FALSE
	END Test.

positive: logical or on constant booleans

	MODULE Test;
	CONST Result = TRUE OR TRUE
	END Test.


# constant characters

negative: constant character exceeding valid range

	MODULE Test;
	CONST Result = 1234X;
	END Test.

negative: arithmetic negation on constant character

	MODULE Test;
	CONST Result = -'a';
	END Test.

negative: logical negation on constant character

	MODULE Test;
	CONST Result = ~5X;
	END Test.

negative: addition on constant characters

	MODULE Test;
	CONST Result = 45X + 'r';
	END Test.

negative: subtraction on constant characters

	MODULE Test;
	CONST Result = '3' - 'a'
	END Test.

negative: multiplication on constant characters

	MODULE Test;
	CONST Result = '9' * 4FX
	END Test.

negative: integer division on constant characters

	MODULE Test;
	CONST Result = '@' DIV 'g'
	END Test.

negative: real division on constant characters

	MODULE Test;
	CONST Result = 'a' / 'b'
	END Test.

negative: modulo on constant characters

	MODULE Test;
	CONST Result = 8X MOD 2X
	END Test.

positive: equal relation on constant characters

	MODULE Test;
	CONST Result = 'r' = 'l'
	END Test.

positive: unequal relation on constant characters

	MODULE Test;
	CONST Result = 4AX # 'z'
	END Test.

negative: less relation on constant characters

	MODULE Test;
	CONST Result = 's' < 64X
	END Test.

negative: less or equal relation on constant characters

	MODULE Test;
	CONST Result = 'e' <= 9X
	END Test.

negative: greater relation on constant characters

	MODULE Test;
	CONST Result = 'r' > 'a'
	END Test.

negative: greater or equal relation on constant characters

	MODULE Test;
	CONST Result = 'h' >= 9DX
	END Test.

negative: set membership on constant characters

	MODULE Test;
	CONST Result = 1DX IN 'z'
	END Test.

negative: type test on constant characters

	MODULE Test;
	CONST Result = '0' IS 0X
	END Test.

negative: logical and on constant characters

	MODULE Test;
	CONST Result = 'A' & 't'
	END Test.

negative: logical or on constant characters

	MODULE Test;
	CONST Result = 0X OR 1X
	END Test.


# constant integers

negative: constant integer exceeding valid range

	MODULE Test;
	CONST Result = 123456789012345678901234567890;
	END Test.

positive: arithmetic negation on constant integer

	MODULE Test;
	CONST Result = -5;
	END Test.

positive: multiple arithmetic negations on constant integer

	MODULE Test;
	CONST Result = -(-(-9));
	END Test.

negative: logical negation on constant integer

	MODULE Test;
	CONST Result = ~788;
	END Test.

positive: addition on constant integers

	MODULE Test;
	CONST Result = 1 + 057H;
	END Test.

positive: subtraction on constant integers

	MODULE Test;
	CONST Result = 0 - 1
	END Test.

positive: multiplication on constant integers

	MODULE Test;
	CONST Result = 1AH * 10
	END Test.

positive: integer division on constant integers

	MODULE Test;
	CONST Result = 9 DIV 6
	END Test.

negative: integer division on constant integers by zero

	MODULE Test;
	CONST Result = 10 DIV 0
	END Test.

positive: real division on constant integers

	MODULE Test;
	CONST Result = 688 / 87
	END Test.

negative: real division on constant integers by zero

	MODULE Test;
	CONST Result = 1ACH / 0
	END Test.

positive: modulo on constant integers

	MODULE Test;
	CONST Result = 20 MOD 4
	END Test.

negative: modulo on constant integers by zero

	MODULE Test;
	CONST Result = 15H MOD 0
	END Test.

positive: equal relation on constant integers

	MODULE Test;
	CONST Result = 54 = 8
	END Test.

positive: unequal relation on constant integers

	MODULE Test;
	CONST Result = 0 # 9
	END Test.

positive: less relation on constant integers

	MODULE Test;
	CONST Result = 5 < 687H
	END Test.

positive: less or equal relation on constant integers

	MODULE Test;
	CONST Result = 0 <= 1321
	END Test.

positive: greater relation on constant integers

	MODULE Test;
	CONST Result = 0EFH > 54
	END Test.

positive: greater or equal relation on constant integers

	MODULE Test;
	CONST Result = 131 >= 9
	END Test.

negative: set membership on constant integers

	MODULE Test;
	CONST Result = 5 IN 9
	END Test.

negative: type test on constant integers

	MODULE Test;
	CONST Result = 4 IS 0
	END Test.

negative: logical and on constant integers

	MODULE Test;
	CONST Result = 123 & 3AH
	END Test.

negative: logical or on constant integers

	MODULE Test;
	CONST Result = 0 OR 685
	END Test.


# constant reals

negative: constant real exceeding valid range

	MODULE Test;
	CONST Result = 1.E500;
	END Test.

positive: arithmetic negation on constant real

	MODULE Test;
	CONST Result = -1.0;
	END Test.

positive: multiple arithmetic negations on constant real

	MODULE Test;
	CONST Result = -(-(-1.0));
	END Test.

negative: logical negation on constant real

	MODULE Test;
	CONST Result = ~1.D4;
	END Test.

positive: addition on constant reals

	MODULE Test;
	CONST Result = 1.9 + 87.1;
	END Test.

positive: subtraction on constant reals

	MODULE Test;
	CONST Result = 4.E-8 - 0.44
	END Test.

positive: multiplication on constant reals

	MODULE Test;
	CONST Result = 15.1 * 3.14
	END Test.

negative: integer division on constant reals

	MODULE Test;
	CONST Result = 3.E9 DIV 1.
	END Test.

positive: real division on constant reals

	MODULE Test;
	CONST Result = 54.5 / 4.1
	END Test.

negative: modulo on constant reals

	MODULE Test;
	CONST Result = 8.9 MOD 7.1
	END Test.

positive: equal relation on constant reals

	MODULE Test;
	CONST Result = 1.0 = 5.E89
	END Test.

positive: unequal relation on constant reals

	MODULE Test;
	CONST Result = 0.001 # 9.
	END Test.

positive: less relation on constant reals

	MODULE Test;
	CONST Result = 1.0 < 97.4
	END Test.

positive: less or equal relation on constant reals

	MODULE Test;
	CONST Result = 464.1 <= 9.E+7
	END Test.

positive: greater relation on constant reals

	MODULE Test;
	CONST Result = 0.1 > 1.54
	END Test.

positive: greater or equal relation on constant reals

	MODULE Test;
	CONST Result = 9.E9 >= 0.0
	END Test.

negative: set membership on constant reals

	MODULE Test;
	CONST Result = 9.1 IN 1.0
	END Test.

negative: type test on constant reals

	MODULE Test;
	CONST Result = 4.E9 IS 1.
	END Test.

negative: logical and on constant reals

	MODULE Test;
	CONST Result = 9.D54 & 1.974D+9
	END Test.

negative: logical or on constant reals

	MODULE Test;
	CONST Result = 0.4 OR 0.
	END Test.


# constant set

positive: empty constant set

	MODULE Test;
	CONST Result = {};
	END Test.

negative: constant boolean as set element

	MODULE Test;
	CONST Result = {FALSE};
	END Test.

negative: constant character as set element

	MODULE Test;
	CONST Result = {'a'};
	END Test.

positive: constant integer constant as set element

	MODULE Test;
	CONST Result = {10};
	END Test.

negative: constant real as set element

	MODULE Test;
	CONST Result = {45.4};
	END Test.

negative: constant set as set element

	MODULE Test;
	CONST Result = {{}};
	END Test.

negative: constant string as set element

	MODULE Test;
	CONST Result = {"string"};
	END Test.

negative: constant set element exceeding valid range

	MODULE Test;
	CONST Result = {100};
	END Test.

negative: negative constant set element

	MODULE Test;
	CONST Result = {-1};
	END Test.

positive: several equal constant set elements

	MODULE Test;
	CONST Result = {0, 0, 0};
	END Test.

positive: several different constant set elements

	MODULE Test;
	CONST Result = {0, 1, 2};
	END Test.

positive: constant set element range

	MODULE Test;
	CONST Result = {5..6};
	END Test.

positive: constant set element range with single element

	MODULE Test;
	CONST Result = {6..6};
	END Test.

positive: empty constant set element range

	MODULE Test;
	CONST Result = {3..2};
	END Test.

negative: empty constant set element range with negative start element

	MODULE Test;
	CONST Result = {-1..2};
	END Test.

negative: empty constant set element range with negative end element

	MODULE Test;
	CONST Result = {3..-4};
	END Test.

positive: complement on constant set

	MODULE Test;
	CONST Result = -{4, 9};
	END Test.

positive: multiple complements on constant set

	MODULE Test;
	CONST Result = -(-(-{5}));
	END Test.

negative: logical negation on constant set

	MODULE Test;
	CONST Result = ~{};
	END Test.

positive: union on constant sets

	MODULE Test;
	CONST Result = {4, 6} + {9};
	END Test.

positive: difference on constant sets

	MODULE Test;
	CONST Result = {7, 2} - {2..1}
	END Test.

positive: intersection on constant sets

	MODULE Test;
	CONST Result = {9} * {6..7}
	END Test.

negative: integer division on constant sets

	MODULE Test;
	CONST Result = {8} DIV {}
	END Test.

positive: symmetric difference on constant sets

	MODULE Test;
	CONST Result = {4..9} / {5,4,3,2,1}
	END Test.

negative: modulo on constant sets

	MODULE Test;
	CONST Result = {7} MOD {0}
	END Test.

positive: equal relation on constant sets

	MODULE Test;
	CONST Result = {4} = {}
	END Test.

positive: unequal relation on constant sets

	MODULE Test;
	CONST Result = {9, 5} # {0..5}
	END Test.

negative: less relation on constant sets

	MODULE Test;
	CONST Result = {9} < {7}
	END Test.

negative: less or equal relation on constant sets

	MODULE Test;
	CONST Result = {} <= {8}
	END Test.

negative: greater relation on constant sets

	MODULE Test;
	CONST Result = {9} > {0..2}
	END Test.

negative: greater or equal relation on constant sets

	MODULE Test;
	CONST Result = {4} >= {}
	END Test.

negative: set membership on constant sets

	MODULE Test;
	CONST Result = {9} IN {1}
	END Test.

positive: set membership on integer and constant set

	MODULE Test;
	CONST Result = 3 IN {2}
	END Test.

negative: type test on constant sets

	MODULE Test;
	CONST Result = {7} IS {}
	END Test.

negative: logical and on constant sets

	MODULE Test;
	CONST Result = {0..7} & {7}
	END Test.

negative: logical or on constant sets

	MODULE Test;
	CONST Result = {8} OR {}
	END Test.


# constant strings

positive: empty constant string

	MODULE Test;
	CONST Result = "";
	END Test.

negative: arithmetic negation on constant string

	MODULE Test;
	CONST Result = -"123";
	END Test.

negative: logical negation on constant string

	MODULE Test;
	CONST Result = ~"invalid";
	END Test.

negative: addition on constant strings

	MODULE Test;
	CONST Result = "hello" + "world";
	END Test.

negative: subtraction on constant strings

	MODULE Test;
	CONST Result = "nice" - "try"
	END Test.

negative: multiplication on constant strings

	MODULE Test;
	CONST Result = "multiplication" * "disallowed"
	END Test.

negative: integer division on constant strings

	MODULE Test;
	CONST Result = "abc" DIV "ABC"
	END Test.

negative: real division on constant strings

	MODULE Test;
	CONST Result = "007" / "008"
	END Test.

negative: modulo on constant strings

	MODULE Test;
	CONST Result = "one" MOD "two"
	END Test.

positive: equal relation on constant strings

	MODULE Test;
	CONST Result = "string" = "gnirts"
	END Test.

positive: unequal relation on constant strings

	MODULE Test;
	CONST Result = "qwerty" # "ytrewq"
	END Test.

positive: less relation on constant strings

	MODULE Test;
	CONST Result = "av" < "bv"
	END Test.

positive: less or equal relation on constant strings

	MODULE Test;
	CONST Result = "word1" <= "word2"
	END Test.

positive: greater relation on constant strings

	MODULE Test;
	CONST Result = "lower" > "UPPER"
	END Test.

positive: greater or equal relation on constant strings

	MODULE Test;
	CONST Result = "number" >= "text"
	END Test.

negative: set membership on constant strings

	MODULE Test;
	CONST Result = "name" IN "ninety"
	END Test.

negative: type test on constant strings

	MODULE Test;
	CONST Result = "not" IS "supported"
	END Test.

negative: logical and on constant strings

	MODULE Test;
	CONST Result = "oh" & "dear"
	END Test.

negative: logical or on constant strings

	MODULE Test;
	CONST Result = "last" OR "one"
	END Test.


# implicit const conversions

positive: implicit const short to integer conversion

	MODULE Test;
	CONST Result = 10H + 1000H
	END Test.

positive: implicit const short to long integer conversion

	MODULE Test;
	CONST Result = 10H * 100000H
	END Test.

positive: implicit const short to huge integer conversion

	MODULE Test;
	CONST Result = 10H DIV 100000000H
	END Test.

positive: implicit const default to long integer conversion

	MODULE Test;
	CONST Result = 1000H - 100000H
	END Test.

positive: implicit const default to huge integer conversion

	MODULE Test;
	CONST Result = 1000H * 100000000H
	END Test.

positive: implicit const long to huge integer conversion

	MODULE Test;
	CONST Result = 100000H + 100000000H
	END Test.

positive: implicit const integer to real conversion

	MODULE Test;
	CONST Result = 4 + 5.0
	END Test.

positive: implicit const integer to long real conversion

	MODULE Test;
	CONST Result = 4.5D127 / 54
	END Test.

positive: implicit const real to long real conversion

	MODULE Test;
	CONST Result = 1.2 * 1.7D247
	END Test.

negative: implicit conversion between const boolean and character

	MODULE Test;
	CONST Result = TRUE = 's'
	END Test.

negative: implicit conversion between const boolean and integer

	MODULE Test;
	CONST Result = TRUE # 5
	END Test.

negative: implicit conversion between const boolean and real

	MODULE Test;
	CONST Result = FALSE = 1.0E4
	END Test.

negative: implicit conversion between const boolean and set

	MODULE Test;
	CONST Result = TRUE = {3}
	END Test.

negative: implicit conversion between const boolean and string

	MODULE Test;
	CONST Result = TRUE = "adsf"
	END Test.

negative: implicit conversion between const character and integer

	MODULE Test;
	CONST Result = 's' # 2
	END Test.

negative: implicit conversion between const character and real

	MODULE Test;
	CONST Result = 't' # 1.0
	END Test.

negative: implicit conversion between const character and set

	MODULE Test;
	CONST Result = 0X = {}
	END Test.

negative: implicit conversion between const character and string

	MODULE Test;
	CONST Result = 'A' # "string"
	END Test.

positive: implicit conversion between const integer and real

	MODULE Test;
	CONST Result = 54 # 2.0
	END Test.

negative: implicit conversion between const integer and set

	MODULE Test;
	CONST Result = 0 = {5}
	END Test.

negative: implicit conversion between const integer and string

	MODULE Test;
	CONST Result = 9 # "text"
	END Test.

negative: implicit conversion between const real and set

	MODULE Test;
	CONST Result = 54.1 = {0..4}
	END Test.

negative: implicit conversion between const real and string

	MODULE Test;
	CONST Result = 0.0 = "zero"
	END Test.

negative: implicit conversion between const set and string

	MODULE Test;
	CONST Result = {9} # "value"
	END Test.


# types

positive: type marked as exported

	MODULE Test;
	TYPE Type* = RECORD END;
	END Test.

negative: type marked as read-only

	MODULE Test;
	TYPE type- = OBJECT;
	END Test.

positive: backwards referencing type

	MODULE Test;
	TYPE A = RECORD END; B = A;
	END Test.

positive: forwards referencing type

	MODULE Test;
	TYPE A = B; B = RECORD END;
	END Test.

negative: cyclic referencing types

	MODULE Test;
	TYPE A = B; B = A;
	END Test.

negative: self referencing type

	MODULE Test;
	TYPE A = A;
	END Test.


# basic types

positive: predefined basic character type

	MODULE Test;
	TYPE BasicType = CHAR;
	END Test.

positive: predefined basic boolean type

	MODULE Test;
	TYPE BasicType = BOOLEAN;
	END Test.

positive: predefined basic short integer type

	MODULE Test;
	TYPE BasicType = SHORTINT;
	END Test.

positive: predefined basic integer type

	MODULE Test;
	TYPE BasicType = INTEGER;
	END Test.

positive: predefined basic long integer type

	MODULE Test;
	TYPE BasicType = LONGINT;
	END Test.

positive: predefined basic huge integer type

	MODULE Test;
	TYPE BasicType = HUGEINT;
	END Test.

positive: predefined basic real type

	MODULE Test;
	TYPE BasicType = REAL;
	END Test.

positive: predefined basic long real type

	MODULE Test;
	TYPE BasicType = LONGREAL;
	END Test.

positive: predefined basic set type

	MODULE Test;
	TYPE BasicType = SET;
	END Test.


# arrays

positive: open array type definition

	MODULE Test;
	TYPE Array = ARRAY OF RECORD END;
	END Test.

negative: array with negative size

	MODULE Test;
	TYPE Array = ARRAY -1 OF RECORD END;
	END Test.

negative: multidimensional array with negative size

	MODULE Test;
	TYPE Array = ARRAY 5, 3, -1 OF RECORD END;
	END Test.

negative: array with size zero

	MODULE Test;
	TYPE Array = ARRAY 0 OF RECORD END;
	END Test.

negative: multidimensional array with size zero

	MODULE Test;
	TYPE Array = ARRAY 2, 7, 0 OF RECORD END;
	END Test.

positive: array with positive size

	MODULE Test;
	TYPE Array = ARRAY 5 OF RECORD END;
	END Test.

positive: multidimensional array with positive size

	MODULE Test;
	TYPE Array = ARRAY 2, 4, 6 OF RECORD END;
	END Test.

negative: array with size of type real

	MODULE Test;
	TYPE Array = ARRAY 5.4 OF RECORD END;
	END Test.

negative: array with constant base type

	MODULE Test;
	CONST Base = 5;
	TYPE Array = ARRAY 5 OF Base;
	END Test.

positive: fixed size array of open array

	MODULE Test;
	TYPE Array = ARRAY 10 OF ARRAY OF RECORD END;
	END Test.

positive: open array of fixed size array

	MODULE Test;
	TYPE Array = ARRAY OF ARRAY 10 OF RECORD END;
	END Test.

negative: self referencing array type

	MODULE Test;
	TYPE Array = ARRAY 10 OF Array;
	END Test.

negative: indirectly self referencing array type

	MODULE Test;
	TYPE A = ARRAY 10 OF B;
	TYPE B = ARRAY 10 OF A;
	END Test.

positive: self referencing array type with pointer

	MODULE Test;
	TYPE A = ARRAY 10 OF POINTER TO A;
	END Test.

positive: indirectly self referencing array type with pointer

	MODULE Test;
	TYPE A = ARRAY 10 OF B;
	TYPE B = ARRAY 10 OF POINTER TO A;
	END Test.

positive: array of basic character type

	MODULE Test;
	TYPE Array = ARRAY 10 OF CHAR;
	END Test.

positive: array of basic boolean type

	MODULE Test;
	TYPE Array = ARRAY 10 OF BOOLEAN;
	END Test.

positive: array of basic short integer type

	MODULE Test;
	TYPE Array = ARRAY 10 OF SHORTINT;
	END Test.

positive: array of basic integer type

	MODULE Test;
	TYPE Array = ARRAY 10 OF INTEGER;
	END Test.

positive: array of basic long integer type

	MODULE Test;
	TYPE Array = ARRAY 10 OF LONGINT;
	END Test.

positive: array of basic huge integer type

	MODULE Test;
	TYPE Array = ARRAY 10 OF HUGEINT;
	END Test.

positive: array of basic real type

	MODULE Test;
	TYPE Array = ARRAY 10 OF REAL;
	END Test.

positive: array of basic long real type

	MODULE Test;
	TYPE Array = ARRAY 10 OF LONGREAL;
	END Test.

positive: array of basic set type

	MODULE Test;
	TYPE Array = ARRAY 10 OF SET;
	END Test.

positive: array of records

	MODULE Test;
	TYPE Array = ARRAY 10 OF RECORD END;
	END Test.

positive: array of objects

	MODULE Test;
	TYPE Array = ARRAY 10 OF OBJECT;
	END Test.

positive: array of pointers

	MODULE Test;
	TYPE Array = ARRAY 10 OF POINTER TO RECORD END;
	END Test.

positive: array of procedures

	MODULE Test;
	TYPE Array = ARRAY 10 OF PROCEDURE;
	END Test.


# records

negative: record extending itself

	MODULE Test;
	TYPE Record = RECORD (Record) END;
	END Test.

negative: record extending itself indirectly

	MODULE Test;
	TYPE A = RECORD (B) END; B = RECORD (A) END;
	END Test.

negative: record extending a constant

	MODULE Test;
	CONST Constant = 5;
	TYPE Record = RECORD (Constant) END;
	END Test.

negative: record extending a variable

	MODULE Test;
	TYPE Record = RECORD (Variable) END;
	VAR variable: Record;
	END Test.

negative: record extending a basic type

	MODULE Test;
	TYPE Record = RECORD (LONGINT) END;
	END Test.

negative: record extending an array

	MODULE Test;
	TYPE Array = ARRAY 10 OF OBJECT; Record = RECORD (Array) END;
	END Test.

positive: record extending a record

	MODULE Test;
	TYPE A = RECORD END; B = RECORD (A) END;
	END Test.

negative: record extending an object

	MODULE Test;
	TYPE Object = OBJECT; Record = RECORD (Object) END;
	END Test.

negative: record extending a pointer

	MODULE Test;
	TYPE Pointer = POINTER TO RECORD END; Record = RECORD (Pointer) END;
	END Test.

negative: record extending a procedure

	MODULE Test;
	TYPE Procedure = PROCEDURE; Record = RECORD (Procedure) END;
	END Test.

negative: record containing itself

	MODULE Test;
	TYPE Record = RECORD r: Record END;
	END Test.

positive: record containing pointer to itself

	MODULE Test;
	TYPE Record = RECORD r: POINTER TO Record END;
	END Test.

negative: record containing itself indirectly

	MODULE Test;
	TYPE A = RECORD b: B END;
	TYPE B = RECORD a: A END;
	END Test.

positive: record containing pointer to itself indirectly

	MODULE Test;
	TYPE A = RECORD b: POINTER TO B END;
	TYPE B = RECORD a: A END;
	END Test.

positive: record containing pointer in declaration to itself indirectly

	MODULE Test;
	TYPE A = RECORD b: B END;
	TYPE B = POINTER TO RECORD a: A END;
	END Test.

positive: record containing backward referenced type

	MODULE Test;
	TYPE A = RECORD END;
	TYPE B = RECORD a: A END;
	END Test.

positive: record containing forward referenced type

	MODULE Test;
	TYPE A = RECORD b: B END;
	TYPE B = OBJECT;
	END Test.

positive: record containing anonymous records

	MODULE Test;
	TYPE Record = RECORD r: RECORD r: RECORD r: RECORD END END END END;
	END Test.

positive: deeply nested records

	MODULE Test;
	TYPE A = RECORD b: B END;
	TYPE F = RECORD END;
	TYPE B = RECORD c: C END;
	TYPE E = RECORD f: F END;
	TYPE D = RECORD e: E END;
	TYPE C = RECORD d: D END;
	END Test.

negative: record containing itself deeply indirectly

	MODULE Test;
	TYPE A = RECORD b: B END;
	TYPE F = RECORD a: A END;
	TYPE B = RECORD c: C END;
	TYPE E = RECORD f: F END;
	TYPE D = RECORD e: E END;
	TYPE C = RECORD d: D END;
	END Test.

negative: nested record containing itself indirectly

	MODULE Test;
	TYPE A = RECORD b: B END;
	TYPE B = RECORD c: C END;
	TYPE C = RECORD d: D END;
	TYPE D = RECORD b: B END;
	END Test.

positive: record containing pointer to record

	MODULE Test;
	TYPE Record = RECORD p: POINTER TO RECORD END END;
	END Test.

positive: record containing pointer to record containing the first record

	MODULE Test;
	TYPE Record = RECORD p: POINTER TO RECORD r: Record END END;
	END Test.

positive: record containing record containing pointer to record containing the first record

	MODULE Test;
	TYPE A = RECORD b: B END;
	TYPE B = RECORD p: POINTER TO RECORD a: A END END;
	END Test.

positive: pointer to record containing record containing record containing the pointer

	MODULE Test;
	TYPE A = POINTER TO RECORD b: B END;
	TYPE B = RECORD r: RECORD a: A END END;
	END Test.

positive: record containing basic types

	MODULE Test;
	TYPE Record = RECORD i: INTEGER; s: SET; b: BOOLEAN END;
	END Test.

positive: record containing array

	MODULE Test;
	TYPE Record = RECORD a: ARRAY 10 OF OBJECT; END;
	END Test.

negative: record containing open array

	MODULE Test;
	TYPE Record = RECORD a: ARRAY OF RECORD END END;
	END Test.

positive: record containing object

	MODULE Test;
	TYPE Record = RECORD o: OBJECT; END;
	END Test.

positive: record containing procedure

	MODULE Test;
	TYPE Record = RECORD p: PROCEDURE END;
	END Test.


# pointers

negative: pointer to basic character type

	MODULE Test;
	TYPE Pointer = POINTER TO CHAR;
	END Test.

negative: pointer to basic boolean type

	MODULE Test;
	TYPE Pointer = POINTER TO BOOLEAN;
	END Test.

negative: pointer to basic short integer type

	MODULE Test;
	TYPE Pointer = POINTER TO SHORTINT;
	END Test.

negative: pointer to basic integer type

	MODULE Test;
	TYPE Pointer = POINTER TO INTEGER;
	END Test.

negative: pointer to basic long integer type

	MODULE Test;
	TYPE Pointer = POINTER TO LONGINT;
	END Test.

negative: pointer to basic huge integer type

	MODULE Test;
	TYPE Pointer = POINTER TO HUGEINT;
	END Test.

negative: pointer to basic real type

	MODULE Test;
	TYPE Pointer = POINTER TO REAL;
	END Test.

negative: pointer to basic long real type

	MODULE Test;
	TYPE Pointer = POINTER TO LONGREAL;
	END Test.

negative: pointer to basic set type

	MODULE Test;
	TYPE Pointer = POINTER TO SET;
	END Test.

positive: pointer to record

	MODULE Test;
	TYPE Pointer = POINTER TO RECORD END;
	END Test.

positive: pointer to array

	MODULE Test;
	TYPE Pointer = POINTER TO ARRAY 10 OF RECORD END;
	END Test.

positive: pointer to open array

	MODULE Test;
	TYPE Pointer = POINTER TO ARRAY OF RECORD END;
	END Test.

negative: pointer to pointer

	MODULE Test;
	TYPE Pointer = POINTER TO POINTER TO RECORD END;
	END Test.

negative: pointer to object

	MODULE Test;
	TYPE Pointer = POINTER TO OBJECT;
	END Test.

negative: pointer to procedure

	MODULE Test;
	TYPE Pointer = POINTER TO PROCEDURE;
	END Test.


# variables

positive: variable of basic character type

	MODULE Test;
	VAR variable: CHAR;
	END Test.

positive: variable of basic boolean type

	MODULE Test;
	VAR variable: BOOLEAN;
	END Test.

positive: variable of basic short integer type

	MODULE Test;
	VAR variable: SHORTINT;
	END Test.

positive: variable of basic integer type

	MODULE Test;
	VAR variable: INTEGER;
	END Test.

positive: variable of basic long integer type

	MODULE Test;
	VAR variable: LONGINT;
	END Test.

positive: variable of basic huge integer type

	MODULE Test;
	VAR variable: HUGEINT;
	END Test.

positive: variable of basic real type

	MODULE Test;
	VAR variable: REAL;
	END Test.

positive: variable of basic long real type

	MODULE Test;
	VAR variable: LONGREAL;
	END Test.

positive: variable of basic set type

	MODULE Test;
	VAR variable: SET;
	END Test.

positive: variable of record type

	MODULE Test;
	TYPE Record = RECORD END;
	VAR variable: Record;
	END Test.

positive: variables of record type

	MODULE Test;
	TYPE Record = RECORD END;
	VAR a, b, c: Record;
	END Test.

positive: variable of anonymous record type

	MODULE Test;
	VAR variable: RECORD END;
	END Test.

positive: variables of anonymous record type

	MODULE Test;
	VAR a, b, c: RECORD END;
	END Test.

positive: variable of array type

	MODULE Test;
	TYPE Array = ARRAY 10 OF RECORD END;
	VAR variable: Array;
	END Test.

positive: variables of array type

	MODULE Test;
	TYPE Array = ARRAY 10 OF RECORD END;
	VAR a, b, c: Array;
	END Test.

positive: variable of anonymous array type

	MODULE Test;
	VAR variable: ARRAY 10 OF RECORD END;
	END Test.

positive: variables of anonymous array type

	MODULE Test;
	VAR a, b, c: ARRAY 10 OF RECORD END;
	END Test.

negative: variable of open array type

	MODULE Test;
	TYPE Array = ARRAY OF RECORD END;
	VAR variable: Array;
	END Test.

negative: variables of anonymous oepn array type

	MODULE Test;
	VAR variable: ARRAY OF RECORD END;
	END Test.

positive: variable of object type

	MODULE Test;
	TYPE Object = OBJECT;
	VAR variable: Object;
	END Test.

positive: variables of object type

	MODULE Test;
	TYPE Object = OBJECT;
	VAR a, b, c: Object;
	END Test.

positive: variable of anonymous object type

	MODULE Test;
	VAR variable: OBJECT;
	END Test.

positive: variables of anonymous object type

	MODULE Test;
	VAR a, b, c: OBJECT;
	END Test.

positive: variable of pointer type

	MODULE Test;
	TYPE Pointer = POINTER TO RECORD END;
	VAR variable: Pointer;
	END Test.

positive: variables of pointer type

	MODULE Test;
	TYPE Pointer = POINTER TO RECORD END;
	VAR a, b, c: Pointer;
	END Test.

positive: variable of anonymous pointer type

	MODULE Test;
	VAR variable: POINTER TO RECORD END;
	END Test.

positive: variables of anonymous pointer type

	MODULE Test;
	VAR a, b, c: POINTER TO RECORD END;
	END Test.

positive: variable of procedure type

	MODULE Test;
	TYPE Procedure = PROCEDURE;
	VAR variable: Procedure;
	END Test.

positive: variables of procedure type

	MODULE Test;
	TYPE Procedure = PROCEDURE;
	VAR a, b, c: Procedure;
	END Test.

positive: variable of anonymous procedure type

	MODULE Test;
	VAR variable: PROCEDURE;
	END Test.

positive: variables of anonymous procedure type

	MODULE Test;
	VAR a, b, c: PROCEDURE;
	END Test.
