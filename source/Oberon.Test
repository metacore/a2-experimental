# Oberon language test and validation suite


# Syntax tests
# =====================================


# plain modules

negative: missing module name

	MODULE END.

negative: unmatched module name

	MODULE Test; END tseT.

negative: missing semicolon in module definition

	MODULE Test END Test.

negative: missing END in module definition

	MODULE Test; Test.

negative: missing concluding dot

	MODULE Test; END Test

positive: empty module

	MODULE Test; END Test.

negative: module named system

	MODULE SYSTEM; END SYSTEM.


# identifiers

negative: number as identifier

	MODULE Test;
	CONST 007 = 0;
	END Test.

negative: keyword as identifier

	MODULE Test;
	CONST THEN = 0;
	END Test.

negative: string as identifier

	MODULE Test;
	CONST "Test" = 0;
	END Test.

positive: single character identifier

	MODULE Test;
	CONST T = 0;
	END Test.

positive: long identifiers

	MODULE Test;
	CONST IncrediblyLongModuleNameLikeSupercalifragilisticexpialidocious = 0;
	END Test.

positive: underscore in identifier

	MODULE Test;
	CONST Test_Module = 0;
	END Test.


# comments

negative: comment only

	(* MODULE *)

positive: comment in front of module definition

	(* comment *)
	MODULE Test; END Test.

positive: comment within module definition

	MODULE Test;
	(* comment *)
	END Test.

positive: comment after module definition

	MODULE Test;
	END Test.
	(* comment *)

positive: plain text after module definition

	MODULE Test;
	END Test.

	plain text

negative: invalid closing of comment

	MODULE Test; *) END Test.

negative: missing closing of comment

	MODULE Test; (* END Test.

positive: comment spanning several lines

	MODULE Test;
	(*
		this comment spans
		several text lines
	*)
	END Test.

positive: comment as whitespace

	MODULE(*whitespace*)Test;END(*whitespace*)Test.


# nested comments

positive: nested comment

	(* (* nested comment *) *)
	MODULE Test; END Test.

negative: invalid closing of nested comment

	(* nested comment *) *)
	MODULE Test; END Test.

negative: missing closing of nested comment

	(* (* nested comment *)
	MODULE Test; END Test.

positive: double nested comments

	(* (* extremely (* nested comment *) *) *)
	MODULE Test; END Test.

positive: multiple nested comments

	MODULE Test;
	(* (* multiple *) nested (* comments (* over (* four *) levels *) *) *)
	END Test.

negative: invalid multiple nested comments

	MODULE Test;
	(* invalid (* multiple *) nested (* comments (* over *) (* four *) levels *) *) *)
	END Test.


# import section

positive: dummy module for import section tests

	MODULE A; END A.

negative: empty import list

	MODULE Test;
	IMPORT;
	END Test.

negative: single module import without concluding semicolon

	MODULE Test;
	IMPORT A
	END Test.

positive: single module import

	MODULE Test;
	IMPORT A;
	END Test.

positive: single module import with alias

	MODULE Test;
	IMPORT B := A;
	END Test.

negative: double module import missing second module name

	MODULE Test;
	IMPORT A, ;
	END Test.

negative: double module import without separating comma

	MODULE Test;
	IMPORT B := A C := A;
	END Test.

negative: double module import with separating semicolon

	MODULE Test;
	IMPORT B := A; C := A;
	END Test.

negative: double module import without concluding semicolon

	MODULE Test;
	IMPORT B := A, C := A
	END Test.

positive: double module import

	MODULE Test;
	IMPORT B := A, C := A;
	END Test.

positive: multiple module import

	MODULE Test;
	IMPORT B := A, C := A, D := A, E := A;
	END Test.

negative: multiple import lists

	MODULE Test;
	IMPORT B := A;
	IMPORT C := A;
	END Test.


# const section

positive: empty const section

	MODULE Test;
	CONST
	END Test.

positive: const section without declarations

	MODULE Test;
	CONST ;;;;
	END Test.

positive: repeated empty const sections

	MODULE Test;
	CONST CONST CONST
	CONST ; CONST ; CONST
	END Test.

negative: single constant declaration missing equal sign

	MODULE Test;
	CONST Constant 5;
	END Test.

negative: single constant declaration missing value

	MODULE Test;
	CONST Constant =
	END Test.

positive: single constant declaration

	MODULE Test;
	CONST Constant = 5
	END Test.

negative: double constant declaration without separating semicolon

	MODULE Test;
	CONST A = 5 B = 10
	END Test.

positive: double constant declaration

	MODULE Test;
	CONST A = 5; B = 10
	END Test.


# literals

positive: boolean literal FALSE

	MODULE Test;
	CONST Boolean = TRUE
	END Test.

positive: boolean literal TRUE

	MODULE Test;
	CONST Boolean = FALSE
	END Test.

# legacy behaviour
positive: character literal using '

	MODULE Test;
	CONST Character = 'a'
	END Test.

# legacy behaviour
positive: character literal using "

	MODULE Test;
	CONST Character = "b"
	END Test.

negative: unclosed character literal

	MODULE Test;
	CONST Character = 't
	END Test.

positive: uppercase hexadecimal character literal

	MODULE Test;
	CONST Character = 0ABX
	END Test.

negative: lowercase hexadecimal character literal

	MODULE Test;
	CONST Character = 0efX
	END Test.

negative: hexadecimal character literal beginning with letter

	MODULE Test;
	CONST Character = CDX
	END Test.

negative: hexadecimal character literal missing concluding X

	MODULE Test;
	CONST Character = 9A
	END Test.

negative: hexadecimal character literal with concluding x

	MODULE Test;
	CONST Character = CAx
	END Test.

positive: integer literal

	MODULE Test;
	CONST Integer = 25
	END Test.

positive: uppercase hexadecimal integer literal

	MODULE Test;
	CONST Integer = 1EDH
	END Test.

negative: lowercase hexadecimal integer literal

	MODULE Test;
	CONST Integer = 4faH
	END Test.

negative: hexadecimal integer literal beginning with letter

	MODULE Test;
	CONST Integer = EFH
	END Test.

negative: hexadecimal integer literal missing concluding H

	MODULE Test;
	CONST Integer = 42F
	END Test.

negative: hexadecimal integer literal with concluding h

	MODULE Test;
	CONST Integer = 89h
	END Test.

positive: real literal

	MODULE Test;
	CONST Real = 25.3
	END Test.

positive: real literal with concluding dot

	MODULE Test;
	CONST Real = 7.
	END Test.

negative: real literal beginning with dot

	MODULE Test;
	CONST Real = .4
	END Test.

negative: real literal with comma instead of dot

	MODULE Test;
	CONST Real = 12,1
	END Test.

positive: real literal with scale factor

	MODULE Test;
	CONST Real = 1.2E5
	END Test.

positive: real literal with positive scale factor

	MODULE Test;
	CONST Real = 0.3E+8
	END Test.

negative: real literal with positive too large scale factor

	MODULE Test; 
	CONST Real= 0.3E+80;
	END Test.

positive: real literal with negative scale factor

	MODULE Test;
	CONST Real = 0.E-30
	END Test.

negative: real literal with too small negative scale factor

	MODULE Test;
	CONST Real = 0.E-54
	END Test.

negative: real literal with scale factor without number

	MODULE Test;
	CONST Real = 6354.9E+
	END Test.

negative: real literal with scale factor without number and sign

	MODULE Test;
	CONST Real = 9.1E
	END Test.

negative: real literal with lowercase scale factor

	MODULE Test;
	CONST Real = 24.e97
	END Test.

negative: real literal with hexadecimal scale factor

	MODULE Test;
	CONST Real = 1.97E1AB
	END Test.

negative: real literal with whitespace sepatared scale factor

	MODULE Test;
	CONST Real = 12.3 E-4
	END Test.

negative: real literal with scale factor with whitespace sepatared number

	MODULE Test;
	CONST Real = 0.1E 2
	END Test.

negative: real literal with scale factor without decimal point

	MODULE Test;
	CONST Real = 5E+2
	END Test.

positive: long real literal with scale factor

	MODULE Test;
	CONST Real = 0.77D24
	END Test.

positive: long real literal with positive scale factor

	MODULE Test;
	CONST Real = 0.1D+9
	END Test.

positive: long real literal with negative scale factor

	MODULE Test;
	CONST Real = 1.D-14
	END Test.

negative: long real literal with lowercase scale factor

	MODULE Test;
	CONST Real = 24.d97
	END Test.

positive: set literal

	MODULE Test;
	CONST Set = {}
	END Test.

negative: unclosed set literal

	MODULE Test;
	CONST Set = {
	END Test.

negative: unopened set literal

	MODULE Test;
	CONST Set = }
	END Test.

# legacy behaviour
negative: string literal using '

	MODULE Test;
	CONST String = 'abc'
	END Test.

positive: string literal using "

	MODULE Test;
	CONST String = "ABC"
	END Test.

negative: unclosed string literal

	MODULE Test;
	CONST Character = "string
	END Test.

positive: string literal holding printable ASCII character set

	MODULE Test;
	CONST String = " !#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~"
	END Test.


# type section

positive: empty type section

	MODULE Test;
	TYPE
	END Test.

positive: type section without declarations

	MODULE Test;
	TYPE ;;;;
	END Test.

positive: repeated empty type sections

	MODULE Test;
	TYPE TYPE TYPE
	TYPE ; TYPE ; TYPE
	END Test.

negative: single type declaration missing equal sign

	MODULE Test;
	TYPE Type RECORD END;
	END Test.

negative: single type declaration missing type

	MODULE Test;
	TYPE Type =
	END Test.

positive: single type declaration

	MODULE Test;
	TYPE Type = OBJECT;
	END Test.

negative: double type declaration without separating semicolon

	MODULE Test;
	TYPE A = RECORD END B = OBJECT;
	END Test.

positive: double type declaration

	MODULE Test;
	TYPE A = OBJECT; B = RECORD END
	END Test.


# types

negative: array without of

	MODULE Test;
	TYPE Array = ARRAY 10 OBJECT;
	END Test.

negative: array without base type

	MODULE Test;
	TYPE Array = ARRAY 15 OF;
	END Test.

positive: basic array of objects

	MODULE Test;
	TYPE Array = ARRAY 5 OF OBJECT;
	END Test.

negative: record without end

	MODULE Test;
	TYPE Record = RECORD;
	END Test.

positive: simple record

	MODULE Test;
	TYPE Record = RECORD END;
	END Test.

negative: record with empty base record

	MODULE Test;
	TYPE Record = RECORD () END;
	END Test.

negative: record with explicitly defined base record

	MODULE Test;
	TYPE Record = RECORD (RECORD END) END;
	END Test.

negative: record with variable declaration

	MODULE Test;
	TYPE Record = RECORD VAR f: OBJECT; END;
	END Test.

negative: missing matching object name

	MODULE Test;
	TYPE Object = OBJECT END;
	END Test;

negative: unmatched object name

	MODULE Test;
	TYPE Object = OBJECT END tcejbO;
	END Test;

negative: object without end

	MODULE Test;
	TYPE Object = OBJECT Object;
	END Test.

positive: simple object

	MODULE Test;
	TYPE Object = OBJECT END Object;
	END Test.

negative: object with empty base object

	MODULE Test;
	TYPE Object = OBJECT () END;
	END Test.

negative: record with explicitly defined base object

	MODULE Test;
	TYPE Record = RECORD (OBJECT END) END;
	END Test.

negative: object with field declaration

	MODULE Test;
	TYPE Object = OBJECT f: OBJECT; END Object;
	END Test.

negative: pointer missing pointer keyword

	MODULE Test;
	TYPE Pointer = TO RECORD END;
	END Test.

negative: pointer missing to

	MODULE Test;
	TYPE Pointer = POINTER RECORD END;
	END Test.

negative: pointer missing base type

	MODULE Test;
	TYPE Pointer = POINTER TO;
	END Test.

positive: plain procedure type without parantheses

	MODULE Test;
	TYPE Procedure = PROCEDURE;
	END Test.

positive: plain procedure type with parantheses

	MODULE Test;
	TYPE Procedure = PROCEDURE ();
	END Test.

negative: procedure type missing return type

	MODULE Test;
	TYPE Procedure = PROCEDURE ():;
	END Test.

negative: procedure type with return type missing parantheses

	MODULE Test;
	TYPE Procedure = PROCEDURE : BOOLEAN;
	END Test.

negative: procedure type with return type missing colon

	MODULE Test;
	TYPE Procedure = PROCEDURE () BOOLEAN;
	END Test.

positive: procedure type with empty parameter list

	MODULE Test;
	TYPE Procedure = PROCEDURE ();
	END Test.

negative: procedure type with parameter list missing parameter section

	MODULE Test;
	TYPE Procedure = PROCEDURE (;);
	END Test.

negative: procedure type with parameter missing name

	MODULE Test;
	TYPE Procedure = PROCEDURE (: SET);
	END Test.

negative: procedure type with parameter missing colon

	MODULE Test;
	TYPE Procedure = PROCEDURE (parameter SET);
	END Test.

negative: procedure type with parameter missing type

	MODULE Test;
	TYPE Procedure = PROCEDURE (parameter:);
	END Test.


# var section

positive: empty var section

	MODULE Test;
	VAR
	END Test.

positive: var section without declarations

	MODULE Test;
	VAR ;;;;
	END Test.

positive: repeated empty var sections

	MODULE Test;
	VAR VAR VAR
	VAR ; VAR ; VAR
	END Test.

negative: single variable declaration missing colon

	MODULE Test;
	VAR variable RECORD END;
	END Test.

negative: single variable declaration missing type

	MODULE Test;
	VAR variable: ;
	END Test.

positive: single variable declaration

	MODULE Test;
	VAR variable: RECORD END;
	END Test.

negative: double variable declaration without separating semicolon

	MODULE Test;
	VAR a: RECORD END b: OBJECT;
	END Test.

positive: double variable declaration

	MODULE Test;
	VAR a: ARRAY 10 OF CHAR; b: RECORD END;
	END Test.


# procedure section

positive: plain procedure without parantheses

	MODULE Test;
	PROCEDURE Procedure;
	END Procedure;
	END Test.

negative: procedure missing name

	MODULE Test;
	PROCEDURE;
	END Procedure;
	END Test.

negative: procedure missing separating semicolon

	MODULE Test;
	PROCEDURE Procedure
	END Procedure;
	END Test.

negative: procedure missing end

	MODULE Test;
	PROCEDURE Procedure;
	Procedure;
	END Test.

negative: procedure missing matching name

	MODULE Test;
	PROCEDURE Procedure;
	END;
	END Test.

negative: unmatched procedure name

	MODULE Test;
	PROCEDURE Procedure;
	END erudecorP;
	END Test.

positive: procedure missing concluding semicolon

	MODULE Test;
	PROCEDURE Procedure;
	END Procedure
	END Test.

positive: plain procedure with parantheses

	MODULE Test;
	PROCEDURE Procedure ();
	END Procedure;
	END Test.

negative: procedure missing return type

	MODULE Test;
	PROCEDURE Procedure ():;
	END Procedure;
	END Test.

negative: procedure with return type missing parantheses

	MODULE Test;
	PROCEDURE Procedure : BOOLEAN;
	END Procedure;
	END Test.

negative: procedure with return type missing colon

	MODULE Test;
	PROCEDURE Procedure () BOOLEAN;
	END Procedure;
	END Test.

positive: procedure with empty parameter list

	MODULE Test;
	PROCEDURE Procedure ();
	END Procedure;
	END Test.

negative: procedure with parameter list missing parameter section

	MODULE Test;
	PROCEDURE Procedure (;);
	END Procedure;
	END Test.

negative: procedure with parameter missing name

	MODULE Test;
	PROCEDURE Procedure (: SET);
	END Procedure;
	END Test.

negative: procedure with parameter missing colon

	MODULE Test;
	PROCEDURE Procedure (parameter SET);
	END Procedure;
	END Test.

negative: procedure with parameter missing type

	MODULE Test;
	PROCEDURE Procedure (parameter:);
	END Procedure;
	END Test.


# intermixed section types

negative: import section before import section

	MODULE Test;
	IMPORT A := A;
	IMPORT B := A;
	END Test.

positive: import section before const section

	MODULE Test;
	IMPORT Import := A;
	CONST Constant = 0;
	END Test.

positive: import section before type section

	MODULE Test;
	IMPORT Import := A;
	TYPE Type = RECORD END;
	END Test.

positive: import section before var section

	MODULE Test;
	IMPORT Import := A;
	VAR variable: RECORD END;
	END Test.

positive: import section before procedure section

	MODULE Test;
	IMPORT Import := A;
	PROCEDURE Procedure; END Procedure;
	END Test.

negative: const section before import section

	MODULE Test;
	CONST Constant = 0;
	IMPORT Import := A;
	END Test.

positive: const section before const section

	MODULE Test;
	CONST A = 0;
	CONST B = 0;
	END Test.

positive: const section before type section

	MODULE Test;
	CONST Constant = 0;
	TYPE Type = RECORD END;
	END Test.

positive: const section before var section

	MODULE Test;
	CONST Constant = 0;
	VAR variable: RECORD END;
	END Test.

positive: const section before procedure section

	MODULE Test;
	CONST Constant = 0;
	PROCEDURE Procedure; END Procedure;
	END Test.

negative: type section before import section

	MODULE Test;
	TYPE Type = RECORD END;
	IMPORT Import := A;
	END Test.

positive: type section before const section

	MODULE Test;
	TYPE Type = RECORD END;
	CONST Constant = 0;
	END Test.

positive: type section before type section

	MODULE Test;
	TYPE A = RECORD END;
	TYPE B = RECORD END;
	END Test.

positive: type section before var section

	MODULE Test;
	TYPE Type = RECORD END;
	VAR variable: RECORD END;
	END Test.

positive: type section before procedure section

	MODULE Test;
	TYPE Type = RECORD END;
	PROCEDURE Procedure; END Procedure;
	END Test.

negative: var section before import section

	MODULE Test;
	VAR variable: RECORD END;
	IMPORT Import := A;
	END Test.

positive: var section before const section

	MODULE Test;
	VAR variable: RECORD END;
	CONST Constant = 0;
	END Test.

positive: var section before type section

	MODULE Test;
	VAR variable: RECORD END;
	TYPE Type = RECORD END;
	END Test.

positive: var section before var section

	MODULE Test;
	VAR a: RECORD END;
	VAR b: RECORD END;
	END Test.

positive: var section before procedure section

	MODULE Test;
	VAR variable: RECORD END;
	PROCEDURE Procedure; END Procedure;
	END Test.

negative: procedure section before import section

	MODULE Test;
	PROCEDURE Procedure; END Procedure;
	IMPORT Import := A;
	END Test.

negative: procedure section before const section

	MODULE Test;
	PROCEDURE Procedure; END Procedure;
	CONST Constant = 0;
	END Test.

negative: procedure section before type section

	MODULE Test;
	PROCEDURE Procedure; END Procedure;
	TYPE Type = RECORD END;
	END Test.

negative: procedure section before var section

	MODULE Test;
	PROCEDURE Procedure; END Procedure;
	VAR variable: RECORD END;
	END Test.

positive: procedure section before procedure section

	MODULE Test;
	PROCEDURE A; END A;
	PROCEDURE B; END B;
	END Test.


# bodies

positive: ommited module body

	MODULE Test;
	END Test.

positive: empty module body

	MODULE Test;
	BEGIN
	END Test.

positive: ommited procedure body

	MODULE Test;
	PROCEDURE Procedure;
	END Procedure;
	END Test.

positive: empty procedure body

	MODULE Test;
	PROCEDURE Procedure;
	BEGIN
	END Procedure;
	END Test.

positive: ommited object body

	MODULE Test;
	TYPE Object = OBJECT
	END Object;
	END Test.

positive: empty object body

	MODULE Test;
	TYPE Object = OBJECT
	BEGIN
	END Object;
	END Test.


# statements

positive: statement with semicolon

	MODULE Test;
	BEGIN BEGIN END;
	END Test.

positive: statement without semicolon

	MODULE Test;
	BEGIN BEGIN END
	END Test.

positive: empty statements at the beginning

	MODULE Test;
	BEGIN ;;;; BEGIN END
	END Test.

positive: empty statements between statements

	MODULE Test;
	BEGIN BEGIN END ;;;; BEGIN END
	END Test.

positive: empty statements at the end

	MODULE Test;
	BEGIN BEGIN END ;;;;
	END Test.

positive: nested empty statements at the beginning

	MODULE Test;
	BEGIN BEGIN ;;;; BEGIN END END
	END Test.

positive: nested empty statements between statements

	MODULE Test;
	BEGIN BEGIN BEGIN END ;;;; BEGIN END END
	END Test.

positive: nested empty statements at the end

	MODULE Test;
	BEGIN BEGIN BEGIN END ;;;; END
	END Test.

negative: two consecutive statements without semicolon

	MODULE Test;
	BEGIN BEGIN END BEGIN END
	END Test.

negative: two nested consecutive statements without semicolon

	MODULE Test;
	BEGIN BEGIN BEGIN END BEGIN END END
	END Test.

negative: three consecutive statements without semicolon

	MODULE Test;
	BEGIN BEGIN END BEGIN END BEGIN END
	END Test.

negative: three nested consecutive statements without semicolon

	MODULE Test;
	BEGIN BEGIN BEGIN END BEGIN END BEGIN END END
	END Test.

negative: unclosed block

	MODULE Test;
	BEGIN BEGIN
	END Test.

negative: unclosed nested block

	MODULE Test;
	BEGIN BEGIN BEGIN END
	END Test.

negative: unopened block

	MODULE Test;
	BEGIN END
	END Test.

negative: unopened nested block

	MODULE Test;
	BEGIN BEGIN END END
	END Test.

negative: empty block modifier

	MODULE Test;
	BEGIN {}
	END Test.

negative: empty nested block modifier

	MODULE Test;
	BEGIN BEGIN {} END
	END Test.

positive: single block modifier

	MODULE Test;
	BEGIN {EXCLUSIVE}
	END Test.

positive: multiple block modifiers

	MODULE Test;
	TYPE Object = OBJECT
	BEGIN {ACTIVE, EXCLUSIVE}
	END Object;
	END Test.

negative: multiple block modifiers missing separating comma

	MODULE Test;
	TYPE Object = OBJECT
	BEGIN {ACTIVE EXCLUSIVE}
	END Object;
	END Test.

negative: empty block modifier with separating comma

	MODULE Test;
	TYPE Object = OBJECT
	BEGIN {,}
	END Object;
	END Test.

negative: exported block modifier

	MODULE Test;
	BEGIN {EXCLUSIVE*}
	END Test.

negative: while statement missing while

	MODULE Test;
	VAR condition: BOOLEAN;
	BEGIN condition DO END
	END Test.

negative: while statement missing condition

	MODULE Test;
	BEGIN WHILE DO END
	END Test.

negative: while statement missing do

	MODULE Test;
	VAR condition: BOOLEAN;
	BEGIN WHILE condition END
	END Test.

negative: while statement missing end

	MODULE Test;
	VAR condition: BOOLEAN;
	BEGIN WHILE condition DO
	END Test.

positive: nested while statement

	MODULE Test;
	VAR condition: BOOLEAN;
	BEGIN WHILE condition DO WHILE condition DO END END
	END Test.

negative: repeat statement missing repeat

	MODULE Test;
	VAR condition: BOOLEAN;
	BEGIN UNTIL condition
	END Test.

negative: repeat statement missing until

	MODULE Test;
	VAR condition: BOOLEAN;
	BEGIN REPEAT condition
	END Test.

negative: repeat statement missing condition

	MODULE Test;
	BEGIN REPEAT UNTIL
	END Test.

positive: nested repeat statement

	MODULE Test;
	VAR condition: BOOLEAN;
	BEGIN REPEAT REPEAT UNTIL condition UNTIL condition
	END Test.

negative: loop statement missing loop

	MODULE Test;
	BEGIN END
	END Test.

negative: loop statement missing end

	MODULE Test;
	BEGIN LOOP
	END Test.

positive: nested loop statement

	MODULE Test;
	BEGIN LOOP LOOP END END
	END Test.

negative: await statement missing parantheses

	MODULE Test;
	VAR condition: BOOLEAN;
	BEGIN {EXCLUSIVE} AWAIT condition
	END Test;

negative: await statement missing closing paranthesis

	MODULE Test;
	VAR condition: BOOLEAN;
	BEGIN {EXCLUSIVE} AWAIT (condition
	END Test;

negative: await statement missing opening paranthesis

	MODULE Test;
	VAR condition: BOOLEAN;
	BEGIN {EXCLUSIVE} AWAIT condition)
	END Test;

negative: await statement missing condition with parantheses

	MODULE Test;
	VAR condition: BOOLEAN;
	BEGIN {EXCLUSIVE} AWAIT ()
	END Test;

negative: await statement missing condition without parantheses

	MODULE Test;
	VAR condition: BOOLEAN;
	BEGIN {EXCLUSIVE} AWAIT
	END Test;

negative: assignment missing left hand side

	MODULE Test;
	VAR variable: INTEGER;
	BEGIN := 0;
	END Test;

negative: assignment missing assign

	MODULE Test;
	VAR variable: INTEGER;
	BEGIN variable 0;
	END Test;

negative: assignment missing right hand side

	MODULE Test;
	VAR variable: INTEGER;
	BEGIN variable := ;
	END Test;

negative: cascaded assignment

	MODULE Test;
	VAR variable: INTEGER;
	BEGIN variable := variable := 5;
	END Test;

negative: for statement missing counter

	MODULE Test;
	BEGIN FOR := 0 TO 10 DO END
	END Test.

negative: for statement missing assignment

	MODULE Test;
	VAR i: INTEGER;
	BEGIN FOR i 0 TO 10 DO END
	END Test.

negative: for statement missing start counter

	MODULE Test;
	VAR i: INTEGER;
	BEGIN FOR i := TO 10 DO END
	END Test.

negative: for statement missing to

	MODULE Test;
	VAR i: INTEGER;
	BEGIN FOR i := 0 10 DO END
	END Test.

negative: for statement missing end counter

	MODULE Test;
	VAR i: INTEGER;
	BEGIN FOR i := 0 TO DO END
	END Test.

negative: for statement missing do

	MODULE Test;
	VAR i: INTEGER;
	BEGIN FOR i := 0 TO 10 END
	END Test.

negative: for statement missing end

	MODULE Test;
	VAR i: INTEGER;
	BEGIN FOR i := 0 TO 10 DO
	END Test.

positive: for statement without increment missing by

	MODULE Test;
	VAR i: INTEGER;
	BEGIN FOR i := 0 TO 10 DO END
	END Test.

negative: for statement with increment missing by

	MODULE Test;
	VAR i: INTEGER;
	BEGIN FOR i := 0 TO 10 1 DO END
	END Test.

negative: for statement with increment missing increment

	MODULE Test;
	VAR i: INTEGER;
	BEGIN FOR i := 0 TO 10 BY DO END
	END Test.


# Semantic tests
# =====================================


# imports

positive: dummy module

	MODULE A;
	END A.

positive: single import

	MODULE Test;
	IMPORT A;
	END Test.

negative: import marked as exported

	MODULE Test;
	IMPORT A*;
	END Test.

negative: import marked as read-only

	MODULE Test;
	IMPORT A-;
	END Test.

positive: single import with different alias

	MODULE Test;
	IMPORT B := A;
	END Test.

positive: single import with same alias

	MODULE Test;
	IMPORT A := A;
	END Test.

negative: duplicated import

	MODULE Test;
	IMPORT A, A;
	END Test.

positive: duplicated import with different alias

	MODULE Test;
	IMPORT B := A, C := A;
	END Test.

negative: duplicated import with same alias

	MODULE Test;
	IMPORT B := A, B := A;
	END Test.

negative: import within procedure

	MODULE Test;
	PROCEDURE Procedure;
		IMPORT Import := A;
	END Procedure;
	END Test.

negative: import within nested procedure

	MODULE Test;
	PROCEDURE Procedure;
		PROCEDURE Procedure;
			IMPORT Import := A;
		END Procedure;
	END Procedure;
	END Test.

negative: import within object

	MODULE Test;
	TYPE Object = OBJECT
		IMPORT Import := A;
	END Object;
	END Test.

negative: import within object in procedure

	MODULE Test;
	PROCEDURE Procedure;
		TYPE Object = OBJECT
			IMPORT Import := A;
		END Object;
	END Object;
	END Test.

negative: import within procedure in object

	MODULE Test;
	TYPE Object = OBJECT
		PROCEDURE Procedure;
			IMPORT Import := A;
		END Procedure;
	END Object;
	END Test.

positive: dummy empty module

	MODULE Test;
	END Test.

positive: dummy module with import

	MODULE A;
	IMPORT Test;
	END A.

negative: module importing itself directly

	MODULE Test;
	IMPORT Test;
	END Test.

negative: module importing itself directly with alias

	MODULE Test;
	IMPORT Import := Test;
	END Test.

negative: module importing itself indirectly

	MODULE Test;
	IMPORT A;
	END Test.

negative: module importing itself indirectly with alias

	MODULE Test;
	IMPORT Import := A;
	END Test.


# constants

positive: constant marked as exported

	MODULE Test;
	CONST Constant* = 54;
	END Test.

negative: constant marked as exported within procedure

	MODULE Test;
	PROCEDURE Procedure;
		CONST Constant* = 54;
	END Procedure;
	END Test.

negative: constant marked as exported within nested procedure

	MODULE Test;
	PROCEDURE Procedure;
		PROCEDURE Procedure;
			CONST Constant* = 54;
		END Procedure;
	END Procedure;
	END Test.

positive: constant marked as exported within object

	MODULE Test;
	TYPE Object = OBJECT
		CONST Constant* = 54;
	END Object;
	END Test.

negative: constant marked as exported within object in procedure

	MODULE Test;
	PROCEDURE Procedure;
		TYPE Object = OBJECT
			CONST Constant* = 54;
		END Object;
	END Procedure;
	END Test.

negative: constant marked as exported within procedure in object

	MODULE Test;
	TYPE Object = OBJECT
		PROCEDURE Procedure;
			CONST Constant* = 54;
		END Procedure;
	END Object;
	END Test.

negative: constant marked as read-only

	MODULE Test;
	CONST Constant- = TRUE;
	END Test.

negative: constant marked as read-only within procedure

	MODULE Test;
	PROCEDURE Procedure;
		CONST Constant- = TRUE;
	END Procedure;
	END Test.

negative: constant marked as read-only within nested procedure

	MODULE Test;
	PROCEDURE Procedure;
		PROCEDURE Procedure;
			CONST Constant- = TRUE;
		END Procedure;
	END Procedure;
	END Test.

negative: constant marked as read-only within object

	MODULE Test;
	TYPE Object = OBJECT
		CONST Constant- = TRUE;
	END Object;
	END Test.

negative: constant marked as read-only within object in procedure

	MODULE Test;
	PROCEDURE Procedure;
		TYPE Object = OBJECT
			CONST Constant- = TRUE;
		END Object;
	END Procedure;
	END Test.

negative: constant marked as read-only within procedure in object

	MODULE Test;
	TYPE Object = OBJECT
		PROCEDURE Procedure;
			CONST Constant- = TRUE;
		END Procedure;
	END Object;
	END Test.

negative: duplicated constant

	MODULE Test;
	CONST Constant = TRUE;
	CONST Constant = FALSE;
	END Test.

negative: duplicated constant within procedure

	MODULE Test;
	PROCEDURE Procedure;
		CONST Constant = TRUE;
		CONST Constant = FALSE;
	END Procedure;
	END Test.

negative: duplicated constant within nested procedure

	MODULE Test;
	PROCEDURE Procedure;
		PROCEDURE Procedure;
			CONST Constant = TRUE;
			CONST Constant = FALSE;
		END Procedure;
	END Procedure;
	END Test.

negative: duplicated constant within object

	MODULE Test;
	TYPE Object = OBJECT
		CONST Constant = TRUE;
		CONST Constant = FALSE;
	END Object;
	END Test.

negative: duplicated constant within object in procedure

	MODULE Test;
	TYPE Object = OBJECT
		PROCEDURE Procedure;
			CONST Constant = TRUE;
			CONST Constant = FALSE;
		END Procedure;
	END Object;
	END Test.

negative: duplicated constant within procedure in object

	MODULE Test;
	PROCEDURE Procedure;
		TYPE Object = OBJECT
			CONST Constant = TRUE;
			CONST Constant = FALSE;
		END Object;
	END Procedure;
	END Test.

positive: backwards referencing constant

	MODULE Test;
	CONST A = 0; B = A;
	END Test.

positive: backwards referencing constant within procedure

	MODULE Test;
	PROCEDURE Procedure;
		CONST A = 0; B = A;
	END Procedure;
	END Test.

positive: backwards referencing constant within nested procedure

	MODULE Test;
	PROCEDURE Procedure;
		PROCEDURE Procedure;
			CONST A = 0; B = A;
		END Procedure;
	END Procedure;
	END Test.

positive: backwards referencing constant within object

	MODULE Test;
	TYPE Object = OBJECT
		CONST A = 0; B = A;
	END Object;
	END Test.

positive: backwards referencing constant within object in procedure

	MODULE Test;
	PROCEDURE Procedure;
		TYPE Object = OBJECT
			CONST A = 0; B = A;
		END Object;
	END Procedure;
	END Test.

positive: backwards referencing constant within procedure in object

	MODULE Test;
	TYPE Object = OBJECT
		PROCEDURE Procedure;
			CONST A = 0; B = A;
		END Procedure;
	END Object;
	END Test.

positive: forwards referencing constant

	MODULE Test;
	CONST A = B; B = 0;
	END Test.

positive: forwards referencing constant within procedure

	MODULE Test;
	PROCEDURE Procedure;
		CONST A = B; B = 0;
	END Procedure;
	END Test.

positive: forwards referencing constant within nested procedure

	MODULE Test;
	PROCEDURE Procedure;
		PROCEDURE Procedure;
			CONST A = B; B = 0;
		END Procedure;
	END Procedure;
	END Test.

positive: forwards referencing constant within object

	MODULE Test;
	TYPE Object = OBJECT
		CONST A = B; B = 0;
	END Object;
	END Test.

positive: forwards referencing constant within object in procedure

	MODULE Test;
	PROCEDURE Procedure;
		TYPE Object = OBJECT
			CONST A = B; B = 0;
		END Object;
	END Procedure;
	END Test.

positive: forwards referencing constant within procedure in object

	MODULE Test;
	TYPE Object = OBJECT
		PROCEDURE Procedure;
			CONST A = B; B = 0;
		END Procedure;
	END Object;
	END Test.

negative: cyclic referencing constants

	MODULE Test;
	CONST A = B; B = A;
	END Test.

negative: cyclic referencing constants within procedure

	MODULE Test;
	PROCEDURE Procedure;
		CONST A = B; B = A;
	END Procedure;
	END Test.

negative: cyclic referencing constants within nested procedure

	MODULE Test;
	PROCEDURE Procedure;
		PROCEDURE Procedure;
			CONST A = B; B = A;
		END Procedure;
	END Procedure;
	END Test.

negative: cyclic referencing constants within object

	MODULE Test;
	TYPE Object = OBJECT
		CONST A = B; B = A;
	END Object;
	END Test.

negative: cyclic referencing constants within object in procedure

	MODULE Test;
	PROCEDURE Procedure;
		TYPE Object = OBJECT
			CONST A = B; B = A;
		END Object;
	END Procedure;
	END Test.

negative: cyclic referencing constants within procedure in object

	MODULE Test;
	TYPE Object = OBJECT
		PROCEDURE Procedure;
			CONST A = B; B = A;
		END Procedure;
	END Object;
	END Test.

negative: self referencing constant

	MODULE Test;
	CONST Constant = Constant;
	END Test.

negative: self referencing constant within procedure

	MODULE Test;
	PROCEDURE Procedure;
		CONST Constant = Constant;
	END Procedure;
	END Test.

negative: self referencing constant within nested procedure

	MODULE Test;
	PROCEDURE Procedure;
		PROCEDURE Procedure;
			CONST Constant = Constant;
		PROCEDURE Procedure;
	END Procedure;
	END Test.

negative: self referencing constant within object

	MODULE Test;
	TYPE Object = OBJECT
		CONST Constant = Constant;
	END Object;
	END Test.

negative: self referencing constant within object in procedure

	MODULE Test;
	TYPE Object = OBJECT
		PROCEDURE Procedure;
			CONST Constant = Constant;
		END Procedure;
	END Object;
	END Test.

negative: self referencing constant within procedure in object

	MODULE Test;
	PROCEDURE Procedure;
		TYPE Object = OBJECT
			CONST Constant = Constant;
		END Object;
	END Procedure;
	END Test.


# constant booleans

negative: arithmetic negation on constant boolean

	MODULE Test;
	CONST Result = -TRUE;
	END Test.

positive: logical negation on constant boolean

	MODULE Test;
	CONST Result = ~FALSE;
	END Test.

positive: multiple logical negations on constant boolean

	MODULE Test;
	CONST Result = ~~~~FALSE;
	END Test.

negative: addition on constant booleans

	MODULE Test;
	CONST Result = TRUE + FALSE;
	END Test.

negative: subtraction on constant booleans

	MODULE Test;
	CONST Result = FALSE - TRUE
	END Test.

negative: multiplication on constant booleans

	MODULE Test;
	CONST Result = FALSE * TRUE
	END Test.

negative: integer division on constant booleans

	MODULE Test;
	CONST Result = TRUE DIV TRUE
	END Test.

negative: real division on constant booleans

	MODULE Test;
	CONST Result = TRUE / FALSE
	END Test.

negative: modulo on constant booleans

	MODULE Test;
	CONST Result = FALSE MOD TRUE
	END Test.

positive: equal relation on constant booleans

	MODULE Test;
	CONST Result = TRUE = FALSE
	END Test.

positive: unequal relation on constant booleans

	MODULE Test;
	CONST Result = TRUE # TRUE
	END Test.

negative: less relation on constant booleans

	MODULE Test;
	CONST Result = TRUE < FALSE
	END Test.

negative: less or equal relation on constant booleans

	MODULE Test;
	CONST Result = FALSE <= FALSE
	END Test.

negative: greater relation on constant booleans

	MODULE Test;
	CONST Result = FALSE > TRUE
	END Test.

negative: greater or equal relation on constant booleans

	MODULE Test;
	CONST Result = FALSE >= TRUE
	END Test.

negative: set membership on constant booleans

	MODULE Test;
	CONST Result = TRUE IN FALSE
	END Test.

negative: type test on constant booleans

	MODULE Test;
	CONST Result = TRUE IS FALSE
	END Test.

positive: logical and on constant booleans

	MODULE Test;
	CONST Result = TRUE & FALSE
	END Test.

positive: logical or on constant booleans

	MODULE Test;
	CONST Result = TRUE OR TRUE
	END Test.


# constant characters

negative: constant character exceeding valid range

	MODULE Test;
	CONST Result = 1234X;
	END Test.

negative: arithmetic negation on constant character

	MODULE Test;
	CONST Result = -'a';
	END Test.

negative: logical negation on constant character

	MODULE Test;
	CONST Result = ~5X;
	END Test.

negative: addition on constant characters

	MODULE Test;
	CONST Result = 45X + 'r';
	END Test.

negative: subtraction on constant characters

	MODULE Test;
	CONST Result = '3' - 'a'
	END Test.

negative: multiplication on constant characters

	MODULE Test;
	CONST Result = '9' * 4FX
	END Test.

negative: integer division on constant characters

	MODULE Test;
	CONST Result = '@' DIV 'g'
	END Test.

negative: real division on constant characters

	MODULE Test;
	CONST Result = 'a' / 'b'
	END Test.

negative: modulo on constant characters

	MODULE Test;
	CONST Result = 8X MOD 2X
	END Test.

positive: equal relation on constant characters

	MODULE Test;
	CONST Result = 'r' = 'l'
	END Test.

positive: unequal relation on constant characters

	MODULE Test;
	CONST Result = 4AX # 'z'
	END Test.

positive: less relation on constant characters

	MODULE Test;
	CONST Result = 's' < 64X
	END Test.

positive: less or equal relation on constant characters

	MODULE Test;
	CONST Result = 'e' <= 9X
	END Test.

positive: greater relation on constant characters

	MODULE Test;
	CONST Result = 'r' > 'a'
	END Test.

positive: greater or equal relation on constant characters

	MODULE Test;
	CONST Result = 'h' >= 9DX
	END Test.

negative: set membership on constant characters

	MODULE Test;
	CONST Result = 1DX IN 'z'
	END Test.

negative: type test on constant characters

	MODULE Test;
	CONST Result = '0' IS 0X
	END Test.

negative: logical and on constant characters

	MODULE Test;
	CONST Result = 'A' & 't'
	END Test.

negative: logical or on constant characters

	MODULE Test;
	CONST Result = 0X OR 1X
	END Test.


# constant integers

negative: constant integer exceeding valid range

	MODULE Test;
	CONST Result = 123456789012345678901234567890;
	END Test.

positive: arithmetic negation on constant integer

	MODULE Test;
	CONST Result = -5;
	END Test.

positive: multiple arithmetic negations on constant integer

	MODULE Test;
	CONST Result = -(-(-9));
	END Test.

negative: logical negation on constant integer

	MODULE Test;
	CONST Result = ~788;
	END Test.

positive: addition on constant integers

	MODULE Test;
	CONST Result = 1 + 057H;
	END Test.

positive: subtraction on constant integers

	MODULE Test;
	CONST Result = 0 - 1
	END Test.

positive: multiplication on constant integers

	MODULE Test;
	CONST Result = 1AH * 10
	END Test.

positive: integer division on constant integers

	MODULE Test;
	CONST Result = 9 DIV 6
	END Test.

negative: integer division on constant integers by zero

	MODULE Test;
	CONST Result = 10 DIV 0
	END Test.

positive: real division on constant integers

	MODULE Test;
	CONST Result = 688 / 87
	END Test.

negative: real division on constant integers by zero

	MODULE Test;
	CONST Result = 1ACH / 0
	END Test.

positive: modulo on constant integers

	MODULE Test;
	CONST Result = 20 MOD 4
	END Test.

negative: modulo on constant integers by zero

	MODULE Test;
	CONST Result = 15H MOD 0
	END Test.

positive: equal relation on constant integers

	MODULE Test;
	CONST Result = 54 = 8
	END Test.

positive: unequal relation on constant integers

	MODULE Test;
	CONST Result = 0 # 9
	END Test.

positive: less relation on constant integers

	MODULE Test;
	CONST Result = 5 < 687H
	END Test.

positive: less or equal relation on constant integers

	MODULE Test;
	CONST Result = 0 <= 1321
	END Test.

positive: greater relation on constant integers

	MODULE Test;
	CONST Result = 0EFH > 54
	END Test.

positive: greater or equal relation on constant integers

	MODULE Test;
	CONST Result = 131 >= 9
	END Test.

negative: set membership on constant integers

	MODULE Test;
	CONST Result = 5 IN 9
	END Test.

negative: type test on constant integers

	MODULE Test;
	CONST Result = 4 IS 0
	END Test.

negative: logical and on constant integers

	MODULE Test;
	CONST Result = 123 & 3AH
	END Test.

negative: logical or on constant integers

	MODULE Test;
	CONST Result = 0 OR 685
	END Test.


# constant reals

positive: constant real in valid real range

	MODULE Test;
	CONST Result = 1.E10;
	END Test.

positive: constant long real in valid long real range

	MODULE Test;
	CONST Result = 1.D10;
	END Test.

negative: constant real exceeding valid real range

	MODULE Test;
	CONST Result = 1.E100;
	END Test.

positive: constant long real exceeding valid real range

	MODULE Test;
	CONST Result = 1.D100;
	END Test.

negative: constant real exceeding valid long range

	MODULE Test;
	CONST Result = 1.E500;
	END Test.

negative: constant long real exceeding valid long real range

	MODULE Test;
	CONST Result = 1.D500;
	END Test.

positive: arithmetic negation on constant real

	MODULE Test;
	CONST Result = -1.0;
	END Test.

positive: multiple arithmetic negations on constant real

	MODULE Test;
	CONST Result = -(-(-1.0));
	END Test.

negative: logical negation on constant real

	MODULE Test;
	CONST Result = ~1.D4;
	END Test.

positive: addition on constant reals

	MODULE Test;
	CONST Result = 1.9 + 87.1;
	END Test.

positive: subtraction on constant reals

	MODULE Test;
	CONST Result = 4.E-8 - 0.44
	END Test.

positive: multiplication on constant reals

	MODULE Test;
	CONST Result = 15.1 * 3.14
	END Test.

negative: integer division on constant reals

	MODULE Test;
	CONST Result = 3.E9 DIV 1.
	END Test.

positive: real division on constant reals

	MODULE Test;
	CONST Result = 54.5 / 4.1
	END Test.

negative: real division on constant reals by zero

	MODULE Test;
	CONST Result = 0.5 / 0.0
	END Test.

negative: modulo on constant reals

	MODULE Test;
	CONST Result = 8.9 MOD 7.1
	END Test.

positive: equal relation on constant reals

	MODULE Test;
	CONST Result = 1.0 = 5.E32
	END Test.

positive: unequal relation on constant reals

	MODULE Test;
	CONST Result = 0.001 # 9.
	END Test.

positive: less relation on constant reals

	MODULE Test;
	CONST Result = 1.0 < 97.4
	END Test.

positive: less or equal relation on constant reals

	MODULE Test;
	CONST Result = 464.1 <= 9.E+7
	END Test.

positive: greater relation on constant reals

	MODULE Test;
	CONST Result = 0.1 > 1.54
	END Test.

positive: greater or equal relation on constant reals

	MODULE Test;
	CONST Result = 9.E9 >= 0.0
	END Test.

negative: set membership on constant reals

	MODULE Test;
	CONST Result = 9.1 IN 1.0
	END Test.

negative: type test on constant reals

	MODULE Test;
	CONST Result = 4.E9 IS 1.
	END Test.

negative: logical and on constant reals

	MODULE Test;
	CONST Result = 9.D54 & 1.974D+9
	END Test.

negative: logical or on constant reals

	MODULE Test;
	CONST Result = 0.4 OR 0.
	END Test.


# constant set

positive: empty constant set

	MODULE Test;
	CONST Result = {};
	END Test.

negative: constant boolean as set element

	MODULE Test;
	CONST Result = {FALSE};
	END Test.

negative: constant character as set element

	MODULE Test;
	CONST Result = {'a'};
	END Test.

positive: constant integer constant as set element

	MODULE Test;
	CONST Result = {10};
	END Test.

negative: constant real as set element

	MODULE Test;
	CONST Result = {45.4};
	END Test.

negative: constant set as set element

	MODULE Test;
	CONST Result = {{}};
	END Test.

negative: constant string as set element

	MODULE Test;
	CONST Result = {"string"};
	END Test.

negative: constant set element exceeding valid range

	MODULE Test;
	CONST Result = {100};
	END Test.

negative: negative constant set element

	MODULE Test;
	CONST Result = {-1};
	END Test.

positive: several equal constant set elements

	MODULE Test;
	CONST Result = {0, 0, 0};
	END Test.

positive: several different constant set elements

	MODULE Test;
	CONST Result = {0, 1, 2};
	END Test.

positive: constant set element range

	MODULE Test;
	CONST Result = {5..6};
	END Test.

positive: constant set element range with single element

	MODULE Test;
	CONST Result = {6..6};
	END Test.

positive: empty constant set element range

	MODULE Test;
	CONST Result = {3..2};
	END Test.

negative: empty constant set element range with negative start element

	MODULE Test;
	CONST Result = {-1..2};
	END Test.

negative: empty constant set element range with negative end element

	MODULE Test;
	CONST Result = {3..-4};
	END Test.

positive: complement on constant set

	MODULE Test;
	CONST Result = -{4, 9};
	END Test.

positive: multiple complements on constant set

	MODULE Test;
	CONST Result = -(-(-{5}));
	END Test.

negative: logical negation on constant set

	MODULE Test;
	CONST Result = ~{};
	END Test.

positive: union on constant sets

	MODULE Test;
	CONST Result = {4, 6} + {9};
	END Test.

positive: difference on constant sets

	MODULE Test;
	CONST Result = {7, 2} - {2..1}
	END Test.

positive: intersection on constant sets

	MODULE Test;
	CONST Result = {9} * {6..7}
	END Test.

negative: integer division on constant sets

	MODULE Test;
	CONST Result = {8} DIV {}
	END Test.

positive: symmetric difference on constant sets

	MODULE Test;
	CONST Result = {4..9} / {5,4,3,2,1}
	END Test.

negative: modulo on constant sets

	MODULE Test;
	CONST Result = {7} MOD {0}
	END Test.

positive: equal relation on constant sets

	MODULE Test;
	CONST Result = {4} = {}
	END Test.

positive: unequal relation on constant sets

	MODULE Test;
	CONST Result = {9, 5} # {0..5}
	END Test.

negative: less relation on constant sets

	MODULE Test;
	CONST Result = {9} < {7}
	END Test.

negative: less or equal relation on constant sets

	MODULE Test;
	CONST Result = {} <= {8}
	END Test.

negative: greater relation on constant sets

	MODULE Test;
	CONST Result = {9} > {0..2}
	END Test.

negative: greater or equal relation on constant sets

	MODULE Test;
	CONST Result = {4} >= {}
	END Test.

negative: set membership on constant sets

	MODULE Test;
	CONST Result = {9} IN {1}
	END Test.

positive: set membership on integer and constant set

	MODULE Test;
	CONST Result = 3 IN {2}
	END Test.

negative: type test on constant sets

	MODULE Test;
	CONST Result = {7} IS {}
	END Test.

negative: logical and on constant sets

	MODULE Test;
	CONST Result = {0..7} & {7}
	END Test.

negative: logical or on constant sets

	MODULE Test;
	CONST Result = {8} OR {}
	END Test.


# constant strings

positive: empty constant string

	MODULE Test;
	CONST Result = "";
	END Test.

negative: arithmetic negation on constant string

	MODULE Test;
	CONST Result = -"123";
	END Test.

negative: logical negation on constant string

	MODULE Test;
	CONST Result = ~"invalid";
	END Test.

negative: addition on constant strings

	MODULE Test;
	CONST Result = "hello" + "world";
	END Test.

negative: subtraction on constant strings

	MODULE Test;
	CONST Result = "nice" - "try"
	END Test.

negative: multiplication on constant strings

	MODULE Test;
	CONST Result = "multiplication" * "disallowed"
	END Test.

negative: integer division on constant strings

	MODULE Test;
	CONST Result = "abc" DIV "ABC"
	END Test.

negative: real division on constant strings

	MODULE Test;
	CONST Result = "007" / "008"
	END Test.

negative: modulo on constant strings

	MODULE Test;
	CONST Result = "one" MOD "two"
	END Test.

positive: equal relation on constant strings

	MODULE Test;
	CONST Result = "string" = "gnirts"
	END Test.

positive: unequal relation on constant strings

	MODULE Test;
	CONST Result = "qwerty" # "ytrewq"
	END Test.

positive: less relation on constant strings

	MODULE Test;
	CONST Result = "av" < "bv"
	END Test.

positive: less or equal relation on constant strings

	MODULE Test;
	CONST Result = "word1" <= "word2"
	END Test.

positive: greater relation on constant strings

	MODULE Test;
	CONST Result = "lower" > "UPPER"
	END Test.

positive: greater or equal relation on constant strings

	MODULE Test;
	CONST Result = "number" >= "text"
	END Test.

negative: set membership on constant strings

	MODULE Test;
	CONST Result = "name" IN "ninety"
	END Test.

negative: type test on constant strings

	MODULE Test;
	CONST Result = "not" IS "supported"
	END Test.

negative: logical and on constant strings

	MODULE Test;
	CONST Result = "oh" & "dear"
	END Test.

negative: logical or on constant strings

	MODULE Test;
	CONST Result = "last" OR "one"
	END Test.


# constant nil pointers

negative: arithmetic negation on nil

	MODULE Test;
	CONST Result = -NIL;
	END Test.

negative: logical negation on nil

	MODULE Test;
	CONST Result = ~NIL;
	END Test.

negative: multiple logical negations on nil

	MODULE Test;
	CONST Result = ~~~~NIL;
	END Test.

negative: addition on nil

	MODULE Test;
	CONST Result = NIL + NIL;
	END Test.

negative: subtraction on nil

	MODULE Test;
	CONST Result = NIL - NIL
	END Test.

negative: multiplication on nil

	MODULE Test;
	CONST Result = NIL * NIL
	END Test.

negative: integer division on nil

	MODULE Test;
	CONST Result = NIL DIV NIL
	END Test.

negative: real division on nil

	MODULE Test;
	CONST Result = NIL / NIL
	END Test.

negative: modulo on nil

	MODULE Test;
	CONST Result = NIL MOD NIL
	END Test.

positive: equal relation on nil

	MODULE Test;
	CONST Result = NIL = NIL
	END Test.

positive: unequal relation on nil

	MODULE Test;
	CONST Result = NIL # NIL
	END Test.

negative: less relation on nil

	MODULE Test;
	CONST Result = NIL < NIL
	END Test.

negative: less or equal relation on nil

	MODULE Test;
	CONST Result = NIL <= NIL
	END Test.

negative: greater relation on nil

	MODULE Test;
	CONST Result = NIL > NIL
	END Test.

negative: greater or equal relation on nil

	MODULE Test;
	CONST Result = NIL >= NIL
	END Test.

negative: set membership on nil

	MODULE Test;
	CONST Result = NIL IN NIL
	END Test.

negative: type test on nil

	MODULE Test;
	CONST Result = NIL IS NIL
	END Test.

negative: logical and on nil

	MODULE Test;
	CONST Result = NIL & NIL
	END Test.

negative: logical or on nil

	MODULE Test;
	CONST Result = NIL OR NIL
	END Test.


# implicit constant conversions

positive: implicit constant short to integer conversion

	MODULE Test;
	CONST Result = 10H + 1000H
	END Test.

positive: implicit constant short to long integer conversion

	MODULE Test;
	CONST Result = 10H * 100000H
	END Test.

positive: implicit constant short to huge integer conversion

	MODULE Test;
	CONST Result = 10H DIV 100000000H
	END Test.

positive: implicit constant integer to long integer conversion

	MODULE Test;
	CONST Result = 1000H - 100000H
	END Test.

positive: implicit constant integer to huge integer conversion

	MODULE Test;
	CONST Result = 1000H * 100000000H
	END Test.

positive: implicit constant long to huge integer conversion

	MODULE Test;
	CONST Result = 100000H + 100000000H
	END Test.

positive: implicit constant integer to real conversion

	MODULE Test;
	CONST Result = 4 + 5.0
	END Test.

positive: implicit constant integer to long real conversion

	MODULE Test;
	CONST Result = 4.5D127 / 54
	END Test.

positive: implicit constant real to long real conversion

	MODULE Test;
	CONST Result = 1.2 * 1.7D247
	END Test.

negative: implicit conversion between constant boolean and character

	MODULE Test;
	CONST Result = TRUE = 's'
	END Test.

negative: implicit conversion between constant boolean and integer

	MODULE Test;
	CONST Result = TRUE # 5
	END Test.

negative: implicit conversion between constant boolean and real

	MODULE Test;
	CONST Result = FALSE = 1.0E4
	END Test.

negative: implicit conversion between constant boolean and set

	MODULE Test;
	CONST Result = TRUE = {3}
	END Test.

negative: implicit conversion between constant boolean and string

	MODULE Test;
	CONST Result = TRUE = "adsf"
	END Test.

negative: implicit conversion between constant character and integer

	MODULE Test;
	CONST Result = 's' # 2
	END Test.

negative: implicit conversion between constant character and real

	MODULE Test;
	CONST Result = 't' # 1.0
	END Test.

negative: implicit conversion between constant character and set

	MODULE Test;
	CONST Result = 0X = {}
	END Test.

negative: implicit conversion between constant character and string

	MODULE Test;
	CONST Result = 'A' # "string"
	END Test.

positive: implicit conversion between constant integer and real

	MODULE Test;
	CONST Result = 54 # 2.0
	END Test.

negative: implicit conversion between constant integer and set

	MODULE Test;
	CONST Result = 0 = {5}
	END Test.

negative: implicit conversion between constant integer and string

	MODULE Test;
	CONST Result = 9 # "text"
	END Test.

negative: implicit conversion between constant real and set

	MODULE Test;
	CONST Result = 54.1 = {0..4}
	END Test.

negative: implicit conversion between constant real and string

	MODULE Test;
	CONST Result = 0.0 = "zero"
	END Test.

negative: implicit conversion between constant set and string

	MODULE Test;
	CONST Result = {9} # "value"
	END Test.


# types

positive: type marked as exported

	MODULE Test;
	TYPE Type* = RECORD END;
	END Test.

negative: type marked as exported within procedure

	MODULE Test;
	PROCEDURE Procedure;
		TYPE Type* = RECORD END;
	END Procedure;
	END Test.

negative: type marked as exported within nested procedure

	MODULE Test;
	PROCEDURE Procedure;
		PROCEDURE Procedure;
			TYPE Type* = RECORD END;
		END Procedure;
	END Procedure;
	END Test.

positive: type marked as exported within object

	MODULE Test;
	TYPE Object = OBJECT
		TYPE Type* = RECORD END;
	END Object;
	END Test.

negative: type marked as exported within object in procedure

	MODULE Test;
	PROCEDURE Procedure;
		TYPE Object = OBJECT
			TYPE Type* = RECORD END;
		END Object;
	END Procedure;
	END Test.

negative: type marked as exported within procedure in object

	MODULE Test;
	TYPE Object = OBJECT
		PROCEDURE Procedure;
			TYPE Type* = RECORD END;
		END Procedure;
	END Object;
	END Test.

negative: type marked as read-only

	MODULE Test;
	TYPE Type- = OBJECT;
	END Test.

negative: type marked as read-only within procedure

	MODULE Test;
	PROCEDURE Procedure;
		TYPE Type- = OBJECT;
	END Procedure;
	END Test.

negative: type marked as read-only within nested procedure

	MODULE Test;
	PROCEDURE Procedure;
		PROCEDURE Procedure;
			TYPE Type- = OBJECT;
		END Procedure;
	END Procedure;
	END Test.

negative: type marked as read-only within object

	MODULE Test;
	TYPE Object = OBJECT
		TYPE Type- = OBJECT;
	END Object;
	END Test.

negative: type marked as read-only within object in procedure

	MODULE Test;
	PROCEDURE Procedure;
		TYPE Object = OBJECT
			TYPE Type- = OBJECT;
		END Object;
	END Procedure;
	END Test.

negative: type marked as read-only within procedure in object

	MODULE Test;
	TYPE Object = OBJECT
		PROCEDURE Procedure;
			TYPE Type- = OBJECT;
		END Procedure;
	END Object;
	END Test.

negative: duplicated type

	MODULE Test;
	TYPE Type = RECORD END;
	TYPE Type = OBJECT END Type;
	END Test.

negative: duplicated type within procedure

	MODULE Test;
	PROCEDURE Procedure;
		TYPE Type = RECORD END;
		TYPE Type = OBJECT END Type;
	END Procedure;
	END Test.

negative: duplicated type within nested procedure

	MODULE Test;
	PROCEDURE Procedure;
		PROCEDURE Procedure;
			TYPE Type = RECORD END;
			TYPE Type = OBJECT END Type;
		END Procedure;
	END Procedure;
	END Test.

negative: duplicated type within object

	MODULE Test;
	TYPE Object = OBJECT
		TYPE Type = RECORD END;
		TYPE Type = OBJECT END Type;
	END Object;
	END Test.

negative: duplicated type within object in procedure

	MODULE Test;
	PROCEDURE Procedure;
		TYPE Object = OBJECT
			TYPE Type = RECORD END;
			TYPE Type = OBJECT END Type;
		END Object;
	END Procedure;
	END Test.

negative: duplicated type within procedure in object

	MODULE Test;
	TYPE Object = OBJECT
		PROCEDURE Procedure;
			TYPE Type = RECORD END;
			TYPE Type = OBJECT END Type;
		END Procedure;
	END Object;
	END Test.

positive: backwards referencing type

	MODULE Test;
	TYPE A = RECORD END; B = A;
	END Test.

positive: backwards referencing type within procedure

	MODULE Test;
	PROCEDURE Procedure;
		TYPE A = RECORD END; B = A;
	END Procedure;
	END Test.

positive: backwards referencing type within nested procedure

	MODULE Test;
	PROCEDURE Procedure;
		PROCEDURE Procedure;
			TYPE A = RECORD END; B = A;
		END Procedure;
	END Procedure;
	END Test.

positive: backwards referencing type within object

	MODULE Test;
	TYPE Object = OBJECT
		TYPE A = RECORD END; B = A;
	END Object;
	END Test.

positive: backwards referencing type within object in procedure

	MODULE Test;
	PROCEDURE Procedure;
		TYPE Object = OBJECT
			TYPE A = RECORD END; B = A;
		END Object;
	END Procedure;
	END Test.

positive: backwards referencing type within procedure in object

	MODULE Test;
	TYPE Object = OBJECT
		PROCEDURE Procedure;
			TYPE A = RECORD END; B = A;
		END Procedure;
	END Object;
	END Test.

positive: forwards referencing type

	MODULE Test;
	TYPE A = B; B = RECORD END;
	END Test.

positive: forwards referencing type within procedure

	MODULE Test;
	PROCEDURE Procedure;
		TYPE A = B; B = RECORD END;
	END Procedure;
	END Test.

positive: forwards referencing type within nested procedure

	MODULE Test;
	PROCEDURE Procedure;
		PROCEDURE Procedure;
			TYPE A = B; B = RECORD END;
		END Procedure;
	END Procedure;
	END Test.

positive: forwards referencing type within object

	MODULE Test;
	TYPE Object = OBJECT
		TYPE A = B; B = RECORD END;
	END Object;
	END Test.

positive: forwards referencing type within object in procedure

	MODULE Test;
	PROCEDURE Procedure;
		TYPE Object = OBJECT
			TYPE A = B; B = RECORD END;
		END Object;
	END Procedure;
	END Test.

positive: forwards referencing type within procedure in object

	MODULE Test;
	TYPE Object = OBJECT
		PROCEDURE Procedure;
			TYPE A = B; B = RECORD END;
		END Procedure;
	END Object;
	END Test.

negative: cyclic referencing types

	MODULE Test;
	TYPE A = B; B = A;
	END Test.

negative: cyclic referencing types within procedure

	MODULE Test;
	PROCEDURE Procedure;
		TYPE A = B; B = A;
	END Procedure;
	END Test.

negative: cyclic referencing types within nested procedure

	MODULE Test;
	PROCEDURE Procedure;
		PROCEDURE Procedure;
			TYPE A = B; B = A;
		END Procedure;
	END Procedure;
	END Test.

negative: cyclic referencing types within object

	MODULE Test;
	TYPE Object = OBJECT
		TYPE A = B; B = A;
	END Object;
	END Test.

negative: cyclic referencing types within object in procedure

	MODULE Test;
	PROCEDURE Procedure;
		TYPE Object = OBJECT
			TYPE A = B; B = A;
		END Object;
	END Procedure;
	END Test.

negative: cyclic referencing types within procedure in object

	MODULE Test;
	TYPE Object = OBJECT
		PROCEDURE Procedure;
			TYPE A = B; B = A;
		END Procedure;
	END Object;
	END Test.

negative: self referencing type

	MODULE Test;
	TYPE Type = Type;
	END Test.

negative: self referencing type within procedure

	MODULE Test;
	PROCEDURE Procedure;
		TYPE Type = Type;
	END Procedure;
	END Test.

negative: self referencing type within nested procedure

	MODULE Test;
	PROCEDURE Procedure;
		PROCEDURE Procedure;
			TYPE Type = Type;
		END Procedure;
	END Procedure;
	END Test.

negative: self referencing type within object

	MODULE Test;
	TYPE Object = OBJECT
		TYPE Type = Type;
	END Object;
	END Test.

negative: self referencing type within object in procedure

	MODULE Test;
	PROCEDURE Procedure;
		TYPE Object = OBJECT
			TYPE Type = Type;
		END Object;
	END Procedure;
	END Test.

negative: self referencing type within procedure in object

	MODULE Test;
	TYPE Object = OBJECT
		PROCEDURE Procedure;
			TYPE Type = Type;
		END Procedure;
	END Object;
	END Test.


# basic types

positive: predefined basic character type

	MODULE Test;
	TYPE BasicType = CHAR;
	END Test.

positive: predefined basic boolean type

	MODULE Test;
	TYPE BasicType = BOOLEAN;
	END Test.

positive: predefined basic short integer type

	MODULE Test;
	TYPE BasicType = SHORTINT;
	END Test.

positive: predefined basic integer type

	MODULE Test;
	TYPE BasicType = INTEGER;
	END Test.

positive: predefined basic long integer type

	MODULE Test;
	TYPE BasicType = LONGINT;
	END Test.

positive: predefined basic huge integer type

	MODULE Test;
	TYPE BasicType = HUGEINT;
	END Test.

positive: predefined basic real type

	MODULE Test;
	TYPE BasicType = REAL;
	END Test.

positive: predefined basic long real type

	MODULE Test;
	TYPE BasicType = LONGREAL;
	END Test.

positive: predefined basic set type

	MODULE Test;
	TYPE BasicType = SET;
	END Test.


# arrays

positive: open array type definition

	MODULE Test;
	TYPE Array = ARRAY OF RECORD END;
	END Test.

negative: array with negative size

	MODULE Test;
	TYPE Array = ARRAY -1 OF RECORD END;
	END Test.

negative: multidimensional array with negative size

	MODULE Test;
	TYPE Array = ARRAY 5, 3, -1 OF RECORD END;
	END Test.

negative: array with size zero

	MODULE Test;
	TYPE Array = ARRAY 0 OF RECORD END;
	END Test.

negative: multidimensional array with size zero

	MODULE Test;
	TYPE Array = ARRAY 2, 7, 0 OF RECORD END;
	END Test.

positive: array with positive size

	MODULE Test;
	TYPE Array = ARRAY 5 OF RECORD END;
	END Test.

positive: multidimensional array with positive size

	MODULE Test;
	TYPE Array = ARRAY 2, 4, 6 OF RECORD END;
	END Test.

negative: array with size of type real

	MODULE Test;
	TYPE Array = ARRAY 5.4 OF RECORD END;
	END Test.

negative: array with constant base type

	MODULE Test;
	CONST Base = 5;
	TYPE Array = ARRAY 5 OF Base;
	END Test.

negative: fixed size array of open array

	MODULE Test;
	TYPE Array = ARRAY 10 OF ARRAY OF RECORD END;
	END Test.

positive: open array of fixed size array

	MODULE Test;
	TYPE Array = ARRAY OF ARRAY 10 OF RECORD END;
	END Test.

negative: self referencing array type

	MODULE Test;
	TYPE Array = ARRAY 10 OF Array;
	END Test.

negative: indirectly self referencing array type

	MODULE Test;
	TYPE A = ARRAY 10 OF B;
	TYPE B = ARRAY 10 OF A;
	END Test.

positive: self referencing array type with pointer

	MODULE Test;
	TYPE A = ARRAY 10 OF POINTER TO A;
	END Test.

positive: indirectly self referencing array type with pointer

	MODULE Test;
	TYPE A = ARRAY 10 OF B;
	TYPE B = ARRAY 10 OF POINTER TO A;
	END Test.

positive: array of basic character type

	MODULE Test;
	TYPE Array = ARRAY 10 OF CHAR;
	END Test.

positive: array of basic boolean type

	MODULE Test;
	TYPE Array = ARRAY 10 OF BOOLEAN;
	END Test.

positive: array of basic short integer type

	MODULE Test;
	TYPE Array = ARRAY 10 OF SHORTINT;
	END Test.

positive: array of basic integer type

	MODULE Test;
	TYPE Array = ARRAY 10 OF INTEGER;
	END Test.

positive: array of basic long integer type

	MODULE Test;
	TYPE Array = ARRAY 10 OF LONGINT;
	END Test.

positive: array of basic huge integer type

	MODULE Test;
	TYPE Array = ARRAY 10 OF HUGEINT;
	END Test.

positive: array of basic real type

	MODULE Test;
	TYPE Array = ARRAY 10 OF REAL;
	END Test.

positive: array of basic long real type

	MODULE Test;
	TYPE Array = ARRAY 10 OF LONGREAL;
	END Test.

positive: array of basic set type

	MODULE Test;
	TYPE Array = ARRAY 10 OF SET;
	END Test.

positive: array of records

	MODULE Test;
	TYPE Array = ARRAY 10 OF RECORD END;
	END Test.

positive: array of objects

	MODULE Test;
	TYPE Array = ARRAY 10 OF OBJECT;
	END Test.

positive: array of pointers

	MODULE Test;
	TYPE Array = ARRAY 10 OF POINTER TO RECORD END;
	END Test.

positive: array of procedures

	MODULE Test;
	TYPE Array = ARRAY 10 OF PROCEDURE;
	END Test.


# records

negative: record extending itself

	MODULE Test;
	TYPE Record = RECORD (Record) END;
	END Test.

negative: record extending itself indirectly

	MODULE Test;
	TYPE A = RECORD (B) END; B = RECORD (A) END;
	END Test.

negative: record extending a constant

	MODULE Test;
	CONST Constant = 5;
	TYPE Record = RECORD (Constant) END;
	END Test.

negative: record extending a variable

	MODULE Test;
	TYPE Record = RECORD (Variable) END;
	VAR variable: Record;
	END Test.

negative: record extending a basic type

	MODULE Test;
	TYPE Record = RECORD (LONGINT) END;
	END Test.

negative: record extending an array

	MODULE Test;
	TYPE Array = ARRAY 10 OF OBJECT; Record = RECORD (Array) END;
	END Test.

positive: record extending a record

	MODULE Test;
	TYPE A = RECORD END; B = RECORD (A) END;
	END Test.

positive: record extending a record from outer scope

	MODULE Test;
	TYPE Outer = RECORD END;
	PROCEDURE Procedure;
		TYPE Inner = RECORD (Outer) END;
	END Procedure;
	END Test.

negative: record extending a record from inner scope

	MODULE Test;
	TYPE Outer = RECORD (Inner) END;
	PROCEDURE Procedure;
		TYPE Inner = RECORD END;
	END Procedure;
	END Test.

negative: record extending an object

	MODULE Test;
	TYPE Object = OBJECT; Record = RECORD (Object) END;
	END Test.

negative: record extending a pointer

	MODULE Test;
	TYPE Pointer = POINTER TO RECORD END; Record = RECORD (Pointer) END;
	END Test.

negative: record extending a procedure

	MODULE Test;
	TYPE Procedure = PROCEDURE; Record = RECORD (Procedure) END;
	END Test.

negative: record containing itself

	MODULE Test;
	TYPE Record = RECORD r: Record END;
	END Test.

positive: record containing pointer to itself

	MODULE Test;
	TYPE Record = RECORD r: POINTER TO Record END;
	END Test.

negative: record containing itself indirectly

	MODULE Test;
	TYPE A = RECORD b: B END;
	TYPE B = RECORD a: A END;
	END Test.

positive: record containing pointer to itself indirectly

	MODULE Test;
	TYPE A = RECORD b: POINTER TO B END;
	TYPE B = RECORD a: A END;
	END Test.

positive: record containing pointer in declaration to itself indirectly

	MODULE Test;
	TYPE A = RECORD b: B END;
	TYPE B = POINTER TO RECORD a: A END;
	END Test.

positive: record containing backward referenced type

	MODULE Test;
	TYPE A = RECORD END;
	TYPE B = RECORD a: A END;
	END Test.

positive: record containing forward referenced type

	MODULE Test;
	TYPE A = RECORD b: B END;
	TYPE B = OBJECT;
	END Test.

positive: record containing anonymous records

	MODULE Test;
	TYPE Record = RECORD r: RECORD r: RECORD r: RECORD END END END END;
	END Test.

positive: deeply nested records

	MODULE Test;
	TYPE A = RECORD b: B END;
	TYPE F = RECORD END;
	TYPE B = RECORD c: C END;
	TYPE E = RECORD f: F END;
	TYPE D = RECORD e: E END;
	TYPE C = RECORD d: D END;
	END Test.

negative: record containing itself deeply indirectly

	MODULE Test;
	TYPE A = RECORD b: B END;
	TYPE F = RECORD a: A END;
	TYPE B = RECORD c: C END;
	TYPE E = RECORD f: F END;
	TYPE D = RECORD e: E END;
	TYPE C = RECORD d: D END;
	END Test.

negative: nested record containing itself indirectly

	MODULE Test;
	TYPE A = RECORD b: B END;
	TYPE B = RECORD c: C END;
	TYPE C = RECORD d: D END;
	TYPE D = RECORD b: B END;
	END Test.

positive: record containing pointer to record

	MODULE Test;
	TYPE Record = RECORD p: POINTER TO RECORD END END;
	END Test.

positive: record containing pointer to record containing the first record

	MODULE Test;
	TYPE Record = RECORD p: POINTER TO RECORD r: Record END END;
	END Test.

positive: record containing record containing pointer to record containing the first record

	MODULE Test;
	TYPE A = RECORD b: B END;
	TYPE B = RECORD p: POINTER TO RECORD a: A END END;
	END Test.

positive: pointer to record containing record containing record containing the pointer

	MODULE Test;
	TYPE A = POINTER TO RECORD b: B END;
	TYPE B = RECORD r: RECORD a: A END END;
	END Test.

positive: record containing basic types

	MODULE Test;
	TYPE Record = RECORD i: INTEGER; s: SET; b: BOOLEAN END;
	END Test.

positive: record containing an array

	MODULE Test;
	TYPE Record = RECORD a: ARRAY 10 OF OBJECT; END;
	END Test.

negative: record containing an open array

	MODULE Test;
	TYPE Record = RECORD a: ARRAY OF RECORD END END;
	END Test.

positive: record containing an object

	MODULE Test;
	TYPE Record = RECORD o: OBJECT; END;
	END Test.

positive: record containing a procedure

	MODULE Test;
	TYPE Record = RECORD p: PROCEDURE END;
	END Test.

negative: record with variable with same name as its type

	MODULE Test;
	TYPE Type = RECORD END;
	TYPE Record = RECORD Type: Type END;
	END Test.


# objects

negative: object extending itself

	MODULE Test;
	TYPE Object = OBJECT (Object) END Object;
	END Test.

negative: object extending itself indirectly

	MODULE Test;
	TYPE A = OBJECT (B) END A; B = OBJECT (A) END B;
	END Test.

negative: object extending a constant

	MODULE Test;
	CONST Constant = 5;
	TYPE Object = OBJECT (Constant) END Object;
	END Test.

negative: object extending a variable

	MODULE Test;
	TYPE Object = OBJECT (variable) END Object;
	VAR variable: Object;
	END Test.

negative: object extending a basic type

	MODULE Test;
	TYPE Object = OBJECT (LONGINT) END Object;
	END Test.

negative: object extending an array

	MODULE Test;
	TYPE Array = ARRAY 10 OF OBJECT; Object = OBJECT (Array) END Object;
	END Test.

negative: object extending a record

	MODULE Test;
	TYPE Record = RECORD END; Object = OBJECT (Record) END Object;
	END Test.

positive: object extending an object

	MODULE Test;
	TYPE A = OBJECT; B = OBJECT (A) END B;
	END Test.

negative: object extending a pointer

	MODULE Test;
	TYPE Pointer = POINTER TO RECORD END; Object = OBJECT (Pointer) END Object;
	END Test.

negative: object extending a procedure

	MODULE Test;
	TYPE Procedure = PROCEDURE; Object = OBJECT (Procedure) END Object;
	END Test.

positive: object containing itself

	MODULE Test;
	TYPE Object = OBJECT VAR o: Object END Object;
	END Test.

positive: object containing itself indirectly

	MODULE Test;
	TYPE A = OBJECT VAR b: B END A;
	TYPE B = OBJECT VAR a: A END B;
	END Test.

positive: object containing backward referenced type

	MODULE Test;
	TYPE A = OBJECT;
	TYPE B = OBJECT VAR a: A END B;
	END Test.

positive: object containing forward referenced type

	MODULE Test;
	TYPE A = OBJECT VAR b: B END A;
	TYPE B = OBJECT;
	END Test.

positive: object containing anonymous records

	MODULE Test;
	TYPE Object = OBJECT VAR r: RECORD r: RECORD r: RECORD END END END END Object;
	END Test.

positive: deeply nested objects

	MODULE Test;
	TYPE A = OBJECT VAR b: B END A;
	TYPE F = OBJECT;
	TYPE B = OBJECT VAR c: C END B;
	TYPE E = OBJECT VAR f: F END E;
	TYPE D = OBJECT VAR e: E END D;
	TYPE C = OBJECT VAR d: D END C;
	END Test.

positive: object containing itself deeply indirectly

	MODULE Test;
	TYPE A = OBJECT VAR b: B END A;
	TYPE F = OBJECT VAR a: A END F;
	TYPE B = OBJECT VAR c: C END B;
	TYPE E = OBJECT VAR f: F END E;
	TYPE D = OBJECT VAR e: E END D;
	TYPE C = OBJECT VAR d: D END C;
	END Test.

positive: nested object containing itself indirectly

	MODULE Test;
	TYPE A = OBJECT VAR b: B END A;
	TYPE B = OBJECT VAR c: C END B;
	TYPE C = OBJECT VAR d: D END C;
	TYPE D = OBJECT VAR b: B END D;
	END Test.

positive: object containing basic types

	MODULE Test;
	TYPE Object = OBJECT VAR i: INTEGER; s: SET; b: BOOLEAN END Object;
	END Test.

positive: object containing an array

	MODULE Test;
	TYPE Object = OBJECT VAR a: ARRAY 10 OF OBJECT; END Object;
	END Test.

negative: object containing an open array

	MODULE Test;
	TYPE Object = OBJECT VAR a: ARRAY OF OBJECT; END Object;
	END Test.

positive: object containing an object

	MODULE Test;
	TYPE Object = OBJECT VAR o: OBJECT; END Object;
	END Test.

positive: object containing a procedure

	MODULE Test;
	TYPE Object = OBJECT VAR p: PROCEDURE END Object;
	END Test.


# pointers

negative: pointer to basic character type

	MODULE Test;
	TYPE Pointer = POINTER TO CHAR;
	END Test.

negative: pointer to basic boolean type

	MODULE Test;
	TYPE Pointer = POINTER TO BOOLEAN;
	END Test.

negative: pointer to basic short integer type

	MODULE Test;
	TYPE Pointer = POINTER TO SHORTINT;
	END Test.

negative: pointer to basic integer type

	MODULE Test;
	TYPE Pointer = POINTER TO INTEGER;
	END Test.

negative: pointer to basic long integer type

	MODULE Test;
	TYPE Pointer = POINTER TO LONGINT;
	END Test.

negative: pointer to basic huge integer type

	MODULE Test;
	TYPE Pointer = POINTER TO HUGEINT;
	END Test.

negative: pointer to basic real type

	MODULE Test;
	TYPE Pointer = POINTER TO REAL;
	END Test.

negative: pointer to basic long real type

	MODULE Test;
	TYPE Pointer = POINTER TO LONGREAL;
	END Test.

negative: pointer to basic set type

	MODULE Test;
	TYPE Pointer = POINTER TO SET;
	END Test.

positive: pointer to record

	MODULE Test;
	TYPE Pointer = POINTER TO RECORD END;
	END Test.

positive: pointer to record from outer scope

	MODULE Test;
	TYPE Record = RECORD END;
	PROCEDURE Procedure;
		TYPE Pointer = POINTER TO Record;
	END Procedure;
	END Test.

positive: pointer to record from with variable of nested type

	MODULE Test;
	PROCEDURE Procedure;
		TYPE Pointer = POINTER TO RECORD pointer: Pointer END;
	END Procedure;
	END Test.

negative: pointer to record inside object

	MODULE Test;
	TYPE Pointer = POINTER TO Record;
	TYPE Oject = OBJECT
		TYPE Record = RECORD END;
	END Object;
	END Test.

negative: pointer to record inside procedure

	MODULE Test;
	TYPE Pointer = POINTER TO Record;
	PROCEDURE Procedure;
		TYPE Record = RECORD END;
	END Procedure;
	END Test.

positive: pointer to array

	MODULE Test;
	TYPE Pointer = POINTER TO ARRAY 10 OF RECORD END;
	END Test.

positive: pointer to open array

	MODULE Test;
	TYPE Pointer = POINTER TO ARRAY OF RECORD END;
	END Test.

positive: pointer to array of same pointer

	MODULE Test;
	TYPE Pointer = POINTER TO ARRAY 10 OF Pointer;
	END Test.

positive: pointers to array of same pointer

	MODULE Test;
	TYPE A = POINTER TO ARRAY 10 OF B;
	TYPE B = POINTER TO ARRAY 10 OF A;
	END Test.

positive: pointer to open array of same pointer

	MODULE Test;
	TYPE Pointer = POINTER TO ARRAY OF Pointer;
	END Test.

positive: pointers to open array of same pointer

	MODULE Test;
	TYPE A = POINTER TO ARRAY OF B;
	TYPE B = POINTER TO ARRAY OF A;
	END Test.

negative: pointer to pointer

	MODULE Test;
	TYPE Pointer = POINTER TO POINTER TO RECORD END;
	END Test.

negative: pointer to object

	MODULE Test;
	TYPE Pointer = POINTER TO OBJECT;
	END Test.

negative: pointer to procedure

	MODULE Test;
	TYPE Pointer = POINTER TO PROCEDURE;
	END Test.


# procedure types

positive: plain procedure type

	MODULE Test;
	TYPE Procedure = PROCEDURE;
	END Test.

positive: procedure type returning basic character type

	MODULE Test;
	TYPE Procedure = PROCEDURE (): CHAR;
	END Test.

positive: procedure type returning basic boolean type

	MODULE Test;
	TYPE Procedure = PROCEDURE (): BOOLEAN;
	END Test.

positive: procedure type returning basic short integer type

	MODULE Test;
	TYPE Procedure = PROCEDURE (): SHORTINT;
	END Test.

positive: procedure type returning basic integer type

	MODULE Test;
	TYPE Procedure = PROCEDURE (): INTEGER;
	END Test.

positive: procedure type returning basic long integer type

	MODULE Test;
	TYPE Procedure = PROCEDURE (): LONGINT;
	END Test.

positive: procedure type returning basic huge integer type

	MODULE Test;
	TYPE Procedure = PROCEDURE (): HUGEINT;
	END Test.

positive: procedure type returning basic real type

	MODULE Test;
	TYPE Procedure = PROCEDURE (): REAL;
	END Test.

positive: procedure type returning basic long real type

	MODULE Test;
	TYPE Procedure = PROCEDURE (): LONGREAL;
	END Test.

positive: procedure type returning basic set type

	MODULE Test;
	TYPE Procedure = PROCEDURE (): SET;
	END Test.

positive: procedure type returning record type

	MODULE Test;
	TYPE Record = RECORD END;
	TYPE Procedure = PROCEDURE (): Record;
	END Test.

positive: procedure type returning anonymous record type

	MODULE Test;
	TYPE Procedure = PROCEDURE (): RECORD END;
	END Test.

positive: procedure type returning array type

	MODULE Test;
	TYPE Array = ARRAY 10 OF RECORD END;
	TYPE Procedure = PROCEDURE (): Array;
	END Test.

positive: procedure type returning anonymous array type

	MODULE Test;
	TYPE Procedure = PROCEDURE (): ARRAY 10 OF RECORD END;
	END Test.

negative: procedure type returning open array type

	MODULE Test;
	TYPE Array = ARRAY OF RECORD END;
	TYPE Procedure = PROCEDURE (): Array;
	END Test.

negative: procedure type returning anonymous open array type

	MODULE Test;
	TYPE Procedure = PROCEDURE (): ARRAY OF RECORD END;
	END Test.

positive: procedure type returning object type

	MODULE Test;
	TYPE Object = OBJECT;
	TYPE Procedure = PROCEDURE (): Object;
	END Test.

positive: procedure type returning anonymous object type

	MODULE Test;
	TYPE Procedure = PROCEDURE (): OBJECT;
	END Test.

positive: procedure type returning pointer type

	MODULE Test;
	TYPE Pointer = POINTER TO RECORD END;
	TYPE Procedure = PROCEDURE (): Pointer;
	END Test.

positive: procedure type returning anonymous pointer type

	MODULE Test;
	TYPE Procedure = PROCEDURE (): POINTER TO RECORD END;
	END Test.

positive: procedure type returning procedure type

	MODULE Test;
	TYPE Proc = PROCEDURE;
	TYPE Procedure = PROCEDURE (): Proc;
	END Test.

positive: procedure type returning anonymous procedure type

	MODULE Test;
	TYPE Procedure = PROCEDURE (): PROCEDURE;
	END Test.

positive: procedure type returning anonymous procedure returning anonymous procedure

	MODULE Test;
	TYPE Procedure = PROCEDURE (): PROCEDURE () : PROCEDURE;
	END Test.

positive: procedure type returning itself

	MODULE Test;
	TYPE Procedure = PROCEDURE (): Procedure;
	END Test.

positive: procedure type with parameter of same type

	MODULE Test;
	TYPE Procedure = PROCEDURE (procedure: Procedure);
	END Test.

negative: procedure type with multiple variable parameter

	MODULE Test;
	TYPE Procedure = PROCEDURE (VAR VAR parameter: SET);
	END Test.

negative: procedure type with multiple constant parameter

	MODULE Test;
	TYPE Procedure = PROCEDURE (CONST CONST parameter: SET);
	END Test.

negative: procedure type with variable and constant parameter

	MODULE Test;
	TYPE Procedure = PROCEDURE (VAR CONST parameter: SET);
	END Test.

negative: procedure type with constant and variable parameter

	MODULE Test;
	TYPE Procedure = PROCEDURE (VAR CONST parameter: SET);
	END Test.

negative: procedure type with parameter marked as exported

	MODULE Test;
	TYPE Procedure = PROCEDURE (parameter*: CHAR);
	END Test.

negative: procedure type with parameter marked as read-only

	MODULE Test;
	TYPE Procedure = PROCEDURE (parameter-: CHAR);
	END Test.

positive: procedure type with a parameter of basic character type

	MODULE Test;
	TYPE Procedure = PROCEDURE (parameter: CHAR);
	END Test.

positive: procedure type with parameters of basic character type

	MODULE Test;
	TYPE Procedure = PROCEDURE (a, b, c: CHAR);
	END Test.

positive: procedure type with a parameter of variable character type

	MODULE Test;
	TYPE Procedure = PROCEDURE (VAR parameter: CHAR);
	END Test.

positive: procedure type with parameters of variable character type

	MODULE Test;
	TYPE Procedure = PROCEDURE (VAR a, b, c: CHAR);
	END Test.

positive: procedure type with a parameter of constant character type

	MODULE Test;
	TYPE Procedure = PROCEDURE (CONST parameter: CHAR);
	END Test.

positive: procedure type with parameters of constant character type

	MODULE Test;
	TYPE Procedure = PROCEDURE (CONST a, b, c: CHAR);
	END Test.

positive: procedure type with intermixed parameters of character type

	MODULE Test;
	TYPE Procedure = PROCEDURE (a: CHAR; VAR b: CHAR; CONST c: CHAR);
	END Test.

positive: procedure type with a parameter of basic boolean type

	MODULE Test;
	TYPE Procedure = PROCEDURE (parameter: BOOLEAN);
	END Test.

positive: procedure type with parameters of basic boolean type

	MODULE Test;
	TYPE Procedure = PROCEDURE (a, b, c: BOOLEAN);
	END Test.

positive: procedure type with a parameter of variable boolean type

	MODULE Test;
	TYPE Procedure = PROCEDURE (VAR parameter: BOOLEAN);
	END Test.

positive: procedure type with parameters of variable boolean type

	MODULE Test;
	TYPE Procedure = PROCEDURE (VAR a, b, c: BOOLEAN);
	END Test.

positive: procedure type with a parameter of constant boolean type

	MODULE Test;
	TYPE Procedure = PROCEDURE (CONST parameter: BOOLEAN);
	END Test.

positive: procedure type with parameters of constant boolean type

	MODULE Test;
	TYPE Procedure = PROCEDURE (CONST a, b, c: BOOLEAN);
	END Test.

positive: procedure type with intermixed parameters of boolean type

	MODULE Test;
	TYPE Procedure = PROCEDURE (a: BOOLEAN; VAR b: BOOLEAN; CONST c: BOOLEAN);
	END Test.

positive: procedure type with a parameter of basic short integer type

	MODULE Test;
	TYPE Procedure = PROCEDURE (parameter: SHORTINT);
	END Test.

positive: procedure type with parameters of basic short integer type

	MODULE Test;
	TYPE Procedure = PROCEDURE (a, b, c: SHORTINT);
	END Test.

positive: procedure type with a parameter of variable short integer type

	MODULE Test;
	TYPE Procedure = PROCEDURE (VAR parameter: SHORTINT);
	END Test.

positive: procedure type with parameters of variable short integer type

	MODULE Test;
	TYPE Procedure = PROCEDURE (VAR a, b, c: SHORTINT);
	END Test.

positive: procedure type with a parameter of constant short integer type

	MODULE Test;
	TYPE Procedure = PROCEDURE (CONST parameter: SHORTINT);
	END Test.

positive: procedure type with parameters of constant short integer type

	MODULE Test;
	TYPE Procedure = PROCEDURE (CONST a, b, c: SHORTINT);
	END Test.

positive: procedure type with intermixed parameters of short integer type

	MODULE Test;
	TYPE Procedure = PROCEDURE (a: SHORTINT; VAR b: SHORTINT; CONST c: SHORTINT);
	END Test.

positive: procedure type with a parameter of basic integer type

	MODULE Test;
	TYPE Procedure = PROCEDURE (parameter: INTEGER);
	END Test.

positive: procedure type with parameters of basic integer type

	MODULE Test;
	TYPE Procedure = PROCEDURE (a, b, c: INTEGER);
	END Test.

positive: procedure type with a parameter of variable integer type

	MODULE Test;
	TYPE Procedure = PROCEDURE (VAR parameter: INTEGER);
	END Test.

positive: procedure type with parameters of variable integer type

	MODULE Test;
	TYPE Procedure = PROCEDURE (VAR a, b, c: INTEGER);
	END Test.

positive: procedure type with a parameter of constant integer type

	MODULE Test;
	TYPE Procedure = PROCEDURE (CONST parameter: INTEGER);
	END Test.

positive: procedure type with parameters of constant integer type

	MODULE Test;
	TYPE Procedure = PROCEDURE (CONST a, b, c: INTEGER);
	END Test.

positive: procedure type with intermixed parameters of integer type

	MODULE Test;
	TYPE Procedure = PROCEDURE (a: INTEGER; VAR b: INTEGER; CONST c: INTEGER);
	END Test.

positive: procedure type with a parameter of basic long integer type

	MODULE Test;
	TYPE Procedure = PROCEDURE (parameter: LONGINT);
	END Test.

positive: procedure type with parameters of basic long integer type

	MODULE Test;
	TYPE Procedure = PROCEDURE (a, b, c: LONGINT);
	END Test.

positive: procedure type with a parameter of variable long integer type

	MODULE Test;
	TYPE Procedure = PROCEDURE (VAR parameter: LONGINT);
	END Test.

positive: procedure type with parameters of variable long integer type

	MODULE Test;
	TYPE Procedure = PROCEDURE (VAR a, b, c: LONGINT);
	END Test.

positive: procedure type with a parameter of constant long integer type

	MODULE Test;
	TYPE Procedure = PROCEDURE (CONST parameter: LONGINT);
	END Test.

positive: procedure type with parameters of constant long integer type

	MODULE Test;
	TYPE Procedure = PROCEDURE (CONST a, b, c: LONGINT);
	END Test.

positive: procedure type with intermixed parameters of long integer type

	MODULE Test;
	TYPE Procedure = PROCEDURE (a: LONGINT; VAR b: LONGINT; CONST c: LONGINT);
	END Test.

positive: procedure type with a parameter of basic huge integer type

	MODULE Test;
	TYPE Procedure = PROCEDURE (parameter: HUGEINT);
	END Test.

positive: procedure type with parameters of basic huge integer type

	MODULE Test;
	TYPE Procedure = PROCEDURE (a, b, c: HUGEINT);
	END Test.

positive: procedure type with a parameter of variable huge integer type

	MODULE Test;
	TYPE Procedure = PROCEDURE (VAR parameter: HUGEINT);
	END Test.

positive: procedure type with parameters of variable huge integer type

	MODULE Test;
	TYPE Procedure = PROCEDURE (VAR a, b, c: HUGEINT);
	END Test.

positive: procedure type with a parameter of constant huge integer type

	MODULE Test;
	TYPE Procedure = PROCEDURE (CONST parameter: HUGEINT);
	END Test.

positive: procedure type with parameters of constant huge integer type

	MODULE Test;
	TYPE Procedure = PROCEDURE (CONST a, b, c: HUGEINT);
	END Test.

positive: procedure type with intermixed parameters of huge integer type

	MODULE Test;
	TYPE Procedure = PROCEDURE (a: HUGEINT; VAR b: HUGEINT; CONST c: HUGEINT);
	END Test.

positive: procedure type with a parameter of basic real type

	MODULE Test;
	TYPE Procedure = PROCEDURE (parameter: REAL);
	END Test.

positive: procedure type with parameters of basic real type

	MODULE Test;
	TYPE Procedure = PROCEDURE (a, b, c: REAL);
	END Test.

positive: procedure type with a parameter of variable real type

	MODULE Test;
	TYPE Procedure = PROCEDURE (VAR parameter: REAL);
	END Test.

positive: procedure type with parameters of variable real type

	MODULE Test;
	TYPE Procedure = PROCEDURE (VAR a, b, c: REAL);
	END Test.

positive: procedure type with a parameter of constant real type

	MODULE Test;
	TYPE Procedure = PROCEDURE (CONST parameter: REAL);
	END Test.

positive: procedure type with parameters of constant real type

	MODULE Test;
	TYPE Procedure = PROCEDURE (CONST a, b, c: REAL);
	END Test.

positive: procedure type with intermixed parameters of real type

	MODULE Test;
	TYPE Procedure = PROCEDURE (a: REAL; VAR b: REAL; CONST c: REAL);
	END Test.

positive: procedure type with a parameter of basic long real type

	MODULE Test;
	TYPE Procedure = PROCEDURE (parameter: LONGREAL);
	END Test.

positive: procedure type with parameters of basic long real type

	MODULE Test;
	TYPE Procedure = PROCEDURE (a, b, c: LONGREAL);
	END Test.

positive: procedure type with a parameter of variable long real type

	MODULE Test;
	TYPE Procedure = PROCEDURE (VAR parameter: LONGREAL);
	END Test.

positive: procedure type with parameters of variable long real type

	MODULE Test;
	TYPE Procedure = PROCEDURE (VAR a, b, c: LONGREAL);
	END Test.

positive: procedure type with a parameter of constant long real type

	MODULE Test;
	TYPE Procedure = PROCEDURE (CONST parameter: LONGREAL);
	END Test.

positive: procedure type with parameters of constant long real type

	MODULE Test;
	TYPE Procedure = PROCEDURE (CONST a, b, c: LONGREAL);
	END Test.

positive: procedure type with intermixed parameters of long real type

	MODULE Test;
	TYPE Procedure = PROCEDURE (a: LONGREAL; VAR b: LONGREAL; CONST c: LONGREAL);
	END Test.

positive: procedure type with a parameter of basic set type

	MODULE Test;
	TYPE Procedure = PROCEDURE (parameter: SET);
	END Test.

positive: procedure type with parameters of basic set type

	MODULE Test;
	TYPE Procedure = PROCEDURE (a, b, c: SET);
	END Test.

positive: procedure type with a parameter of variable set type

	MODULE Test;
	TYPE Procedure = PROCEDURE (VAR parameter: SET);
	END Test.

positive: procedure type with parameters of variable set type

	MODULE Test;
	TYPE Procedure = PROCEDURE (VAR a, b, c: SET);
	END Test.

positive: procedure type with a parameter of constant set type

	MODULE Test;
	TYPE Procedure = PROCEDURE (CONST parameter: SET);
	END Test.

positive: procedure type with parameters of constant set type

	MODULE Test;
	TYPE Procedure = PROCEDURE (CONST a, b, c: SET);
	END Test.

positive: procedure type with intermixed parameters of set type

	MODULE Test;
	TYPE Procedure = PROCEDURE (a: SET; VAR b: SET; CONST c: SET);
	END Test.

positive: procedure type with a parameter of record type

	MODULE Test;
	TYPE Record = RECORD END;
	TYPE Procedure = PROCEDURE (parameter: Record);
	END Test.

positive: procedure type with parameters of record type

	MODULE Test;
	TYPE Record = RECORD END;
	TYPE Procedure = PROCEDURE (a, b, c: Record);
	END Test.

positive: procedure type with a parameter of variable record type

	MODULE Test;
	TYPE Record = RECORD END;
	TYPE Procedure = PROCEDURE (VAR parameter: Record);
	END Test.

positive: procedure type with parameters of variable record type

	MODULE Test;
	TYPE Record = RECORD END;
	TYPE Procedure = PROCEDURE (VAR a, b, c: Record);
	END Test.

positive: procedure type with a parameter of constant record type

	MODULE Test;
	TYPE Record = RECORD END;
	TYPE Procedure = PROCEDURE (CONST parameter: Record);
	END Test.

positive: procedure type with parameters of constant record type

	MODULE Test;
	TYPE Record = RECORD END;
	TYPE Procedure = PROCEDURE (CONST a, b, c: Record);
	END Test.

positive: procedure type with intermixed parameters of record type

	MODULE Test;
	TYPE Record = RECORD END;
	TYPE Procedure = PROCEDURE (a: Record; VAR b: Record; CONST c: Record);
	END Test.

positive: procedure type with a parameter of anonymous record type

	MODULE Test;
	TYPE Record = RECORD END;
	TYPE Procedure = PROCEDURE (parameter: RECORD END);
	END Test.

positive: procedure type with parameters of anonymous record type

	MODULE Test;
	TYPE Procedure = PROCEDURE (a, b, c: RECORD END);
	END Test.

positive: procedure type with a parameter of variable anonymous record type

	MODULE Test;
	TYPE Procedure = PROCEDURE (VAR parameter: RECORD END);
	END Test.

positive: procedure type with parameters of variable anonymous record type

	MODULE Test;
	TYPE Procedure = PROCEDURE (VAR a, b, c: RECORD END);
	END Test.

positive: procedure type with a parameter of constant anonymous record type

	MODULE Test;
	TYPE Procedure = PROCEDURE (CONST parameter: RECORD END);
	END Test.

positive: procedure type with parameters of constant anonymous record type

	MODULE Test;
	TYPE Procedure = PROCEDURE (CONST a, b, c: RECORD END);
	END Test.

positive: procedure type with intermixed parameters of anonymous record type

	MODULE Test;
	TYPE Procedure = PROCEDURE (a: RECORD END; VAR b: RECORD END; CONST c: RECORD END);
	END Test.

positive: procedure type with a parameter of array type

	MODULE Test;
	TYPE Array = ARRAY 10 OF RECORD END;
	TYPE Procedure = PROCEDURE (parameter: Array);
	END Test.

positive: procedure type with parameters of array type

	MODULE Test;
	TYPE Array = ARRAY 10 OF RECORD END;
	TYPE Procedure = PROCEDURE (a, b, c: Array);
	END Test.

positive: procedure type with a parameter of variable array type

	MODULE Test;
	TYPE Array = ARRAY 10 OF RECORD END;
	TYPE Procedure = PROCEDURE (VAR parameter: Array);
	END Test.

positive: procedure type with parameters of variable array type

	MODULE Test;
	TYPE Array = ARRAY 10 OF RECORD END;
	TYPE Procedure = PROCEDURE (VAR a, b, c: Array);
	END Test.

positive: procedure type with a parameter of constant array type

	MODULE Test;
	TYPE Array = ARRAY 10 OF RECORD END;
	TYPE Procedure = PROCEDURE (CONST parameter: Array);
	END Test.

positive: procedure type with parameters of constant array type

	MODULE Test;
	TYPE Array = ARRAY 10 OF RECORD END;
	TYPE Procedure = PROCEDURE (CONST a, b, c: Array);
	END Test.

positive: procedure type with intermixed parameters of array type

	MODULE Test;
	TYPE Array = ARRAY 10 OF RECORD END;
	TYPE Procedure = PROCEDURE (a: Array; VAR b: Array; CONST c: Array);
	END Test.

positive: procedure type with a parameter of anonymous array type

	MODULE Test;
	TYPE Procedure = PROCEDURE (parameter: ARRAY 10 OF RECORD END);
	END Test.

positive: procedure type with parameters of anonymous array type

	MODULE Test;
	TYPE Procedure = PROCEDURE (a, b, c: ARRAY 10 OF RECORD END);
	END Test.

positive: procedure type with a parameter of variable anonymous array type

	MODULE Test;
	TYPE Procedure = PROCEDURE (VAR parameter: ARRAY 10 OF RECORD END);
	END Test.

positive: procedure type with parameters of variable anonymous array type

	MODULE Test;
	TYPE Procedure = PROCEDURE (VAR a, b, c: ARRAY 10 OF RECORD END);
	END Test.

positive: procedure type with a parameter of constant anonymous array type

	MODULE Test;
	TYPE Procedure = PROCEDURE (CONST parameter: ARRAY 10 OF RECORD END);
	END Test.

positive: procedure type with parameters of constant anonymous array type

	MODULE Test;
	TYPE Procedure = PROCEDURE (CONST a, b, c: ARRAY 10 OF RECORD END);
	END Test.

positive: procedure type with intermixed parameters of anonymous array type

	MODULE Test;
	TYPE Procedure = PROCEDURE (a: ARRAY 10 OF RECORD END; VAR b: ARRAY 10 OF RECORD END; CONST c: ARRAY 10 OF RECORD END);
	END Test.

positive: procedure type with a parameter of open array type

	MODULE Test;
	TYPE Array = ARRAY OF RECORD END;
	TYPE Procedure = PROCEDURE (parameter: Array);
	END Test.

positive: procedure type with parameters of open array type

	MODULE Test;
	TYPE Array = ARRAY OF RECORD END;
	TYPE Procedure = PROCEDURE (a, b, c: Array);
	END Test.

positive: procedure type with a parameter of variable open array type

	MODULE Test;
	TYPE Array = ARRAY OF RECORD END;
	TYPE Procedure = PROCEDURE (VAR parameter: Array);
	END Test.

positive: procedure type with parameters of variable open array type

	MODULE Test;
	TYPE Array = ARRAY OF RECORD END;
	TYPE Procedure = PROCEDURE (VAR a, b, c: Array);
	END Test.

positive: procedure type with a parameter of constant open array type

	MODULE Test;
	TYPE Array = ARRAY OF RECORD END;
	TYPE Procedure = PROCEDURE (CONST parameter: Array);
	END Test.

positive: procedure type with parameters of constant open array type

	MODULE Test;
	TYPE Array = ARRAY OF RECORD END;
	TYPE Procedure = PROCEDURE (CONST a, b, c: Array);
	END Test.

positive: procedure type with intermixed parameters of open array type

	MODULE Test;
	TYPE Array = ARRAY OF RECORD END;
	TYPE Procedure = PROCEDURE (a: Array; VAR b: Array; CONST c: Array);
	END Test.

positive: procedure type with a parameter of anonymous open array type

	MODULE Test;
	TYPE Procedure = PROCEDURE (parameter: ARRAY OF RECORD END);
	END Test.

positive: procedure type with parameters of anonymous open array type

	MODULE Test;
	TYPE Procedure = PROCEDURE (a, b, c: ARRAY OF RECORD END);
	END Test.

positive: procedure type with a parameter of variable anonymous open array type

	MODULE Test;
	TYPE Procedure = PROCEDURE (VAR parameter: ARRAY OF RECORD END);
	END Test.

positive: procedure type with parameters of variable anonymous open array type

	MODULE Test;
	TYPE Procedure = PROCEDURE (VAR a, b, c: ARRAY OF RECORD END);
	END Test.

positive: procedure type with a parameter of constant anonymous open array type

	MODULE Test;
	TYPE Procedure = PROCEDURE (CONST parameter: ARRAY OF RECORD END);
	END Test.

positive: procedure type with parameters of constant anonymous open array type

	MODULE Test;
	TYPE Procedure = PROCEDURE (CONST a, b, c: ARRAY OF RECORD END);
	END Test.

positive: procedure type with intermixed parameters of anonymous open array type

	MODULE Test;
	TYPE Procedure = PROCEDURE (a: ARRAY OF RECORD END; VAR b: ARRAY OF RECORD END; CONST c: ARRAY OF RECORD END);
	END Test.

positive: procedure type with a parameter of object type

	MODULE Test;
	TYPE Object = OBJECT END Object;
	TYPE Procedure = PROCEDURE (parameter: Object);
	END Test.

positive: procedure type with parameters of object type

	MODULE Test;
	TYPE Object = OBJECT END Object;
	TYPE Procedure = PROCEDURE (a, b, c: Object);
	END Test.

positive: procedure type with a parameter of variable object type

	MODULE Test;
	TYPE Object = OBJECT END Object;
	TYPE Procedure = PROCEDURE (VAR parameter: Object);
	END Test.

positive: procedure type with parameters of variable object type

	MODULE Test;
	TYPE Object = OBJECT END Object;
	TYPE Procedure = PROCEDURE (VAR a, b, c: Object);
	END Test.

positive: procedure type with a parameter of constant object type

	MODULE Test;
	TYPE Object = OBJECT END Object;
	TYPE Procedure = PROCEDURE (CONST parameter: Object);
	END Test.

positive: procedure type with parameters of constant object type

	MODULE Test;
	TYPE Object = OBJECT END Object;
	TYPE Procedure = PROCEDURE (CONST a, b, c: Object);
	END Test.

positive: procedure type with intermixed parameters of object type

	MODULE Test;
	TYPE Object = OBJECT END Object;
	TYPE Procedure = PROCEDURE (a: Object; VAR b: Object; CONST c: Object);
	END Test.

positive: procedure type with a parameter of anonymous object type

	MODULE Test;
	TYPE Procedure = PROCEDURE (parameter: OBJECT END);
	END Test.

positive: procedure type with parameters of anonymous object type

	MODULE Test;
	TYPE Procedure = PROCEDURE (a, b, c: OBJECT END);
	END Test.

positive: procedure type with a parameter of variable anonymous object type

	MODULE Test;
	TYPE Procedure = PROCEDURE (VAR parameter: OBJECT END);
	END Test.

positive: procedure type with parameters of variable anonymous object type

	MODULE Test;
	TYPE Procedure = PROCEDURE (VAR a, b, c: OBJECT END);
	END Test.

positive: procedure type with a parameter of constant anonymous object type

	MODULE Test;
	TYPE Procedure = PROCEDURE (CONST parameter: OBJECT END);
	END Test.

positive: procedure type with parameters of constant anonymous object type

	MODULE Test;
	TYPE Procedure = PROCEDURE (CONST a, b, c: OBJECT END);
	END Test.

positive: procedure type with intermixed parameters of anonymous object type

	MODULE Test;
	TYPE Procedure = PROCEDURE (a: OBJECT END; VAR b: OBJECT END; CONST c: OBJECT END);
	END Test.

positive: procedure type with a parameter of pointer type

	MODULE Test;
	TYPE Pointer = POINTER TO RECORD END;
	TYPE Procedure = PROCEDURE (parameter: Pointer);
	END Test.

positive: procedure type with parameters of pointer type

	MODULE Test;
	TYPE Pointer = POINTER TO RECORD END;
	TYPE Procedure = PROCEDURE (a, b, c: Pointer);
	END Test.

positive: procedure type with a parameter of variable pointer type

	MODULE Test;
	TYPE Pointer = POINTER TO RECORD END;
	TYPE Procedure = PROCEDURE (VAR parameter: Pointer);
	END Test.

positive: procedure type with parameters of variable pointer type

	MODULE Test;
	TYPE Pointer = POINTER TO RECORD END;
	TYPE Procedure = PROCEDURE (VAR a, b, c: Pointer);
	END Test.

positive: procedure type with a parameter of constant pointer type

	MODULE Test;
	TYPE Pointer = POINTER TO RECORD END;
	TYPE Procedure = PROCEDURE (CONST parameter: Pointer);
	END Test.

positive: procedure type with parameters of constant pointer type

	MODULE Test;
	TYPE Pointer = POINTER TO RECORD END;
	TYPE Procedure = PROCEDURE (CONST a, b, c: Pointer);
	END Test.

positive: procedure type with intermixed parameters of pointer type

	MODULE Test;
	TYPE Pointer = POINTER TO RECORD END;
	TYPE Procedure = PROCEDURE (a: Pointer; VAR b: Pointer; CONST c: Pointer);
	END Test.

positive: procedure type with a parameter of anonymous pointer type

	MODULE Test;
	TYPE Procedure = PROCEDURE (parameter: POINTER TO RECORD END);
	END Test.

positive: procedure type with parameters of anonymous pointer type

	MODULE Test;
	TYPE Procedure = PROCEDURE (a, b, c: POINTER TO RECORD END);
	END Test.

positive: procedure type with a parameter of variable anonymous pointer type

	MODULE Test;
	TYPE Procedure = PROCEDURE (VAR parameter: POINTER TO RECORD END);
	END Test.

positive: procedure type with parameters of variable anonymous pointer type

	MODULE Test;
	TYPE Procedure = PROCEDURE (VAR a, b, c: POINTER TO RECORD END);
	END Test.

positive: procedure type with a parameter of constant anonymous pointer type

	MODULE Test;
	TYPE Procedure = PROCEDURE (CONST parameter: OBJECT END);
	END Test.

positive: procedure type with parameters of constant anonymous pointer type

	MODULE Test;
	TYPE Procedure = PROCEDURE (CONST a, b, c: POINTER TO RECORD END);
	END Test.

positive: procedure type with intermixed parameters of anonymous pointer type

	MODULE Test;
	TYPE Procedure = PROCEDURE (a: POINTER TO RECORD END; VAR b: POINTER TO RECORD END; CONST c: POINTER TO RECORD END);
	END Test.

positive: procedure type with a parameter of procedure type

	MODULE Test;
	TYPE Procedure = PROCEDURE (parameter: Procedure);
	END Test.

positive: procedure type with parameters of procedure type

	MODULE Test;
	TYPE Procedure = PROCEDURE (a, b, c: Procedure);
	END Test.

positive: procedure type with a parameter of variable procedure type

	MODULE Test;
	TYPE Procedure = PROCEDURE (VAR parameter: Procedure);
	END Test.

positive: procedure type with parameters of variable procedure type

	MODULE Test;
	TYPE Procedure = PROCEDURE (VAR a, b, c: Procedure);
	END Test.

positive: procedure type with a parameter of constant procedure type

	MODULE Test;
	TYPE Procedure = PROCEDURE (CONST parameter: Procedure);
	END Test.

positive: procedure type with parameters of constant procedure type

	MODULE Test;
	TYPE Procedure = PROCEDURE (CONST a, b, c: Procedure);
	END Test.

positive: procedure type with intermixed parameters of procedure type

	MODULE Test;
	TYPE Procedure = PROCEDURE (a: Procedure; VAR b: Procedure; CONST c: Procedure);
	END Test.

positive: procedure type with a parameter of anonymous procedure type

	MODULE Test;
	TYPE Procedure = PROCEDURE (parameter: PROCEDURE);
	END Test.

positive: procedure type with parameters of anonymous procedure type

	MODULE Test;
	TYPE Procedure = PROCEDURE (a, b, c: PROCEDURE);
	END Test.

positive: procedure type with a parameter of variable anonymous procedure type

	MODULE Test;
	TYPE Procedure = PROCEDURE (VAR parameter: PROCEDURE);
	END Test.

positive: procedure type with parameters of variable anonymous procedure type

	MODULE Test;
	TYPE Procedure = PROCEDURE (VAR a, b, c: PROCEDURE);
	END Test.

positive: procedure type with a parameter of constant anonymous procedure type

	MODULE Test;
	TYPE Procedure = PROCEDURE (CONST parameter: PROCEDURE);
	END Test.

positive: procedure type with parameters of constant anonymous procedure type

	MODULE Test;
	TYPE Procedure = PROCEDURE (CONST a, b, c: PROCEDURE);
	END Test.

positive: procedure type with intermixed parameters of anonymous procedure type

	MODULE Test;
	TYPE Procedure = PROCEDURE (a: PROCEDURE; VAR b: PROCEDURE; CONST c: PROCEDURE);
	END Test.


# variables

positive: variable marked as exported

	MODULE Test;
	VAR variable*: RECORD END;
	END Test.

negative: variable marked as exported within procedure

	MODULE Test;
	PROCEDURE Procedure;
		VAR variable*: RECORD END;
	END Procedure;
	END Test.

negative: variable marked as exported within nested procedure

	MODULE Test;
	PROCEDURE Procedure;
		PROCEDURE Procedure;
			VAR variable*: RECORD END;
		END Procedure;
	END Procedure;
	END Test.

positive: variable marked as exported within record

	MODULE Test;
	TYPE Record = RECORD
		variable*: RECORD END;
	END;
	END Test.

positive: variable marked as exported within object

	MODULE Test;
	TYPE Object = OBJECT
		VAR variable*: RECORD END;
	END Object;
	END Test.

negative: variable marked as exported within record in procedure

	MODULE Test;
	PROCEDURE Procedure;
		TYPE Record = RECORD
			variable*: RECORD END;
		END;
	END Procedure;
	END Test.

negative: variable marked as exported within object in procedure

	MODULE Test;
	PROCEDURE Procedure;
		TYPE Object = OBJECT
			VAR variable*: RECORD END;
		END Object;
	END Procedure;
	END Test.

negative: variable marked as exported within procedure in object

	MODULE Test;
	TYPE Object = OBJECT
		PROCEDURE Procedure;
			VAR variable*: RECORD END;
		END Procedure;
	END Object;
	END Test.

positive: variable marked as read-only

	MODULE Test;
	VAR variable-: RECORD END;
	END Test.

negative: variable marked as read-only within procedure

	MODULE Test;
	PROCEDURE Procedure;
		VAR variable-: RECORD END;
	END Procedure;
	END Test.

negative: variable marked as read-only within nested procedure

	MODULE Test;
	PROCEDURE Procedure;
		PROCEDURE Procedure;
			VAR variable-: RECORD END;
		END Procedure;
	END Procedure;
	END Test.

positive: variable marked as read-only within record

	MODULE Test;
	TYPE Record = RECORD
		variable-: RECORD END;
	END;
	END Test.

positive: variable marked as read-only within object

	MODULE Test;
	TYPE Object = OBJECT
		VAR variable-: RECORD END;
	END Object;
	END Test.

negative: variable marked as read-only within record in procedure

	MODULE Test;
	PROCEDURE Procedure;
		TYPE Record = RECORD
			variable-: RECORD END;
		END;
	END Procedure;
	END Test.

negative: variable marked as read-only within object in procedure

	MODULE Test;
	PROCEDURE Procedure;
		TYPE Object = OBJECT
			VAR variable-: RECORD END;
		END Object;
	END Procedure;
	END Test.

negative: variable marked as read-only within procedure in object

	MODULE Test;
	TYPE Object = OBJECT
		PROCEDURE Procedure;
			VAR variable-: RECORD END;
		END Procedure;
	END Object;
	END Test.

negative: duplicated variable

	MODULE Test;
	VAR variable: LONGINT;
	VAR variable: RECORD END;
	END Test.

negative: duplicated variable within procedure

	MODULE Test;
	PROCEDURE Procedure;
		VAR variable: LONGINT;
		VAR variable: RECORD END;
	END Procedure;
	END Test.

negative: duplicated variable within nested procedure

	MODULE Test;
	PROCEDURE Procedure;
		PROCEDURE Procedure;
			VAR variable: LONGINT;
			VAR variable: RECORD END;
		END Procedure;
	END Procedure;
	END Test.

negative: duplicated variable within record

	MODULE Test;
	TYPE Record = RECORD
		variable: LONGINT;
		variable: RECORD END;
	END;
	END Test.

negative: duplicated variable within object

	MODULE Test;
	TYPE Object = OBJECT
		VAR variable: LONGINT;
		VAR variable: RECORD END;
	END Object;
	END Test.

negative: duplicated variable within record in procedure

	MODULE Test;
	PROCEDURE Procedure;
		TYPE Record = RECORD
			variable: LONGINT;
			variable: RECORD END;
		END;
	END Procedure;
	END Test.

negative: duplicated variable within object in procedure

	MODULE Test;
	PROCEDURE Procedure;
		TYPE Object = OBJECT
			VAR variable: LONGINT;
			VAR variable: RECORD END;
		END Object;
	END Procedure;
	END Test.

negative: duplicated variable within procedure in object

	MODULE Test;
	TYPE Object = OBJECT
		PROCEDURE Procedure;
			VAR variable: LONGINT;
			VAR variable: RECORD END;
		END Procedure;
	END Object;
	END Test.

negative: duplicated variable in same declaration

	MODULE Test;
	VAR variable, variable: LONGINT;
	END Test.

negative: duplicated variable in same declaration within procedure

	MODULE Test;
	PROCEDURE Procedure;
		VAR variable, variable: LONGINT;
	END Procedure;
	END Test.

negative: duplicated variable in same declaration within nested procedure

	MODULE Test;
	PROCEDURE Procedure;
		PROCEDURE Procedure;
			VAR variable, variable: LONGINT;
		END Procedure;
	END Procedure;
	END Test.

negative: duplicated variable in same declaration within record

	MODULE Test;
	TYPE Record = RECORD
		variable, variable: LONGINT;
	END;
	END Test.

negative: duplicated variable in same declaration within object

	MODULE Test;
	TYPE Object = OBJECT
		VAR variable, variable: LONGINT;
	END Object;
	END Test.

negative: duplicated variable in same declaration within record in procedure

	MODULE Test;
	PROCEDURE Procedure;
		TYPE Record = RECORD
			variable, variable: LONGINT;
		END;
	END Procedure;
	END Test.

negative: duplicated variable in same declaration within object in procedure

	MODULE Test;
	PROCEDURE Procedure;
		TYPE Object = OBJECT
			VAR variable, variable: LONGINT;
		END Object;
	END Procedure;
	END Test.

negative: duplicated variable in same declaration within procedure in object

	MODULE Test;
	TYPE Object = OBJECT
		PROCEDURE Procedure;
			VAR variable, variable: LONGINT;
		END Procedure;
	END Object;
	END Test.

positive: variable of basic character type

	MODULE Test;
	VAR variable: CHAR;
	END Test.

positive: variable of basic boolean type

	MODULE Test;
	VAR variable: BOOLEAN;
	END Test.

positive: variable of basic short integer type

	MODULE Test;
	VAR variable: SHORTINT;
	END Test.

positive: variable of basic integer type

	MODULE Test;
	VAR variable: INTEGER;
	END Test.

positive: variable of basic long integer type

	MODULE Test;
	VAR variable: LONGINT;
	END Test.

positive: variable of basic huge integer type

	MODULE Test;
	VAR variable: HUGEINT;
	END Test.

positive: variable of basic real type

	MODULE Test;
	VAR variable: REAL;
	END Test.

positive: variable of basic long real type

	MODULE Test;
	VAR variable: LONGREAL;
	END Test.

positive: variable of basic set type

	MODULE Test;
	VAR variable: SET;
	END Test.

positive: variable of record type

	MODULE Test;
	TYPE Record = RECORD END;
	VAR variable: Record;
	END Test.

positive: variables of record type

	MODULE Test;
	TYPE Record = RECORD END;
	VAR a, b, c: Record;
	END Test.

positive: variable of anonymous record type

	MODULE Test;
	VAR variable: RECORD END;
	END Test.

positive: variables of anonymous record type

	MODULE Test;
	VAR a, b, c: RECORD END;
	END Test.

positive: variable of array type

	MODULE Test;
	TYPE Array = ARRAY 10 OF RECORD END;
	VAR variable: Array;
	END Test.

positive: variables of array type

	MODULE Test;
	TYPE Array = ARRAY 10 OF RECORD END;
	VAR a, b, c: Array;
	END Test.

positive: variable of anonymous array type

	MODULE Test;
	VAR variable: ARRAY 10 OF RECORD END;
	END Test.

positive: variables of anonymous array type

	MODULE Test;
	VAR a, b, c: ARRAY 10 OF RECORD END;
	END Test.

negative: variable of open array type

	MODULE Test;
	TYPE Array = ARRAY OF RECORD END;
	VAR variable: Array;
	END Test.

negative: variables of open array type

	MODULE Test;
	TYPE Array = ARRAY OF RECORD END;
	VAR a, v, c: Array;
	END Test.

negative: variable of anonymous open array type

	MODULE Test;
	VAR variable: ARRAY OF RECORD END;
	END Test.

negative: variables of anonymous open array type

	MODULE Test;
	VAR a, b, c: ARRAY OF RECORD END;
	END Test.

positive: variable of object type

	MODULE Test;
	TYPE Object = OBJECT;
	VAR variable: Object;
	END Test.

positive: variables of object type

	MODULE Test;
	TYPE Object = OBJECT;
	VAR a, b, c: Object;
	END Test.

positive: variable of anonymous object type

	MODULE Test;
	VAR variable: OBJECT;
	END Test.

positive: variables of anonymous object type

	MODULE Test;
	VAR a, b, c: OBJECT;
	END Test.

positive: variable of pointer type

	MODULE Test;
	TYPE Pointer = POINTER TO RECORD END;
	VAR variable: Pointer;
	END Test.

positive: variables of pointer type

	MODULE Test;
	TYPE Pointer = POINTER TO RECORD END;
	VAR a, b, c: Pointer;
	END Test.

positive: variable of anonymous pointer type

	MODULE Test;
	VAR variable: POINTER TO RECORD END;
	END Test.

positive: variables of anonymous pointer type

	MODULE Test;
	VAR a, b, c: POINTER TO RECORD END;
	END Test.

positive: variable of procedure type

	MODULE Test;
	TYPE Procedure = PROCEDURE;
	VAR variable: Procedure;
	END Test.

positive: variables of procedure type

	MODULE Test;
	TYPE Procedure = PROCEDURE;
	VAR a, b, c: Procedure;
	END Test.

positive: variable of anonymous procedure type

	MODULE Test;
	VAR variable: PROCEDURE;
	END Test.

positive: variables of anonymous procedure type

	MODULE Test;
	VAR a, b, c: PROCEDURE;
	END Test.

negative: definition of self in module

	MODULE Test;
	VAR SELF: OBJECT;
	END Test.

negative: definition of self in procedure

	MODULE Test;
	PROCEDURE Procedure;
	VAR SELF: OBJECT;
	END Procedure;
	END Test.

negative: definition of self in object

	MODULE Test;
	TYPE Object = OBJECT
		PROCEDURE Procedure;
		VAR SELF: OBJECT;
		END Procedure;
	END Object;
	END Test.

negative: definition of self in procedure in object

	MODULE Test;
	TYPE Object = OBJECT
		PROCEDURE Procedure;
		VAR SELF: OBJECT;
		END Procedure;
	END Object;
	END Test.

negative: definition of self in nested procedure in object

	MODULE Test;
	TYPE Object = OBJECT
		PROCEDURE Procedure;
			PROCEDURE Procedure;
			VAR SELF: OBJECT;
			END Procedure;
		END Procedure;
	END Object;
	END Test.

negative: modification of self in object

	MODULE Test;
	TYPE Object = OBJECT
		PROCEDURE Procedure;
		BEGIN SELF := NIL;
		END Procedure;
	END Object;
	END Test.

negative: modification of self in procedure in object

	MODULE Test;
	TYPE Object = OBJECT
		PROCEDURE Procedure;
		BEGIN SELF := NIL;
		END Procedure;
	END Object;
	END Test.

negative: modification of self in nested procedure in object

	MODULE Test;
	TYPE Object = OBJECT
		PROCEDURE Procedure;
			PROCEDURE Procedure;
			BEGIN SELF := NIL;
			END Procedure;
		END Procedure;
	END Object;
	END Test.


# procedures

positive: plain procedure

	MODULE Test;
	PROCEDURE Procedure;
	END Procedure;
	END Test.

positive: procedure marked as exported

	MODULE Test;
	PROCEDURE Procedure*;
	END Procedure;
	END Test.

negative: procedure marked as exported within procedure

	MODULE Test;
	PROCEDURE Procedure;
		PROCEDURE Procedure*;
		END Procedure;
	END Procedure;
	END Test.

negative: procedure marked as exported within nested procedure

	MODULE Test;
	PROCEDURE Procedure;
		PROCEDURE Procedure;
			PROCEDURE Procedure*;
			END Procedure;
		END Procedure;
	END Procedure;
	END Test.

positive: procedure marked as exported within object

	MODULE Test;
	TYPE Object = OBJECT
		PROCEDURE Procedure*;
		END Procedure;
	END Object;
	END Test.

negative: procedure marked as exported within object in procedure

	MODULE Test;
	PROCEDURE Procedure;
		TYPE Object = OBJECT
			PROCEDURE Procedure*;
			END Procedure;
		END Object;
	END Procedure;
	END Test.

negative: procedure marked as exported within procedure in object

	MODULE Test;
	TYPE Object = OBJECT
		PROCEDURE Procedure;
			PROCEDURE Procedure*;
			END Procedure;
		END Procedure;
	END Object;
	END Test.

negative: procedure marked as read-only

	MODULE Test;
	PROCEDURE Procedure-;
	END Procedure;
	END Test.

negative: procedure marked as read-only within procedure

	MODULE Test;
	PROCEDURE Procedure;
		PROCEDURE Procedure-;
		END Procedure;
	END Procedure;
	END Test.

negative: procedure marked as read-only within nested procedure

	MODULE Test;
	PROCEDURE Procedure;
		PROCEDURE Procedure;
			PROCEDURE Procedure-;
			END Procedure;
		END Procedure;
	END Procedure;
	END Test.

negative: procedure marked as read-only within object

	MODULE Test;
	TYPE Object = OBJECT
		PROCEDURE Procedure-;
		END Procedure;
	END Object;
	END Test.

negative: procedure marked as read-only within object in procedure

	MODULE Test;
	PROCEDURE Procedure;
		TYPE Object = OBJECT
			PROCEDURE Procedure-;
			END Procedure;
		END Object;
	END Procedure;
	END Test.

negative: procedure marked as read-only within procedure in object

	MODULE Test;
	TYPE Object = OBJECT
		PROCEDURE Procedure;
			PROCEDURE Procedure-;
			END Procedure;
		END Procedure;
	END Object;
	END Test.

negative: duplicated procedure

	MODULE Test;
	PROCEDURE Procedure; END Procedure;
	PROCEDURE Procedure; END Procedure;
	END Test.

negative: duplicated procedure within procedure

	MODULE Test;
	PROCEDURE Procedure;
		PROCEDURE Procedure; END Procedure;
		PROCEDURE Procedure; END Procedure;
	END Procedure;
	END Test.

negative: duplicated procedure within nested procedure

	MODULE Test;
	PROCEDURE Procedure;
		PROCEDURE Procedure;
			PROCEDURE Procedure; END Procedure;
			PROCEDURE Procedure; END Procedure;
		END Procedure;
	END Procedure;
	END Test.

negative: duplicated procedure within object

	MODULE Test;
	TYPE Object = OBJECT
		PROCEDURE Procedure; END Procedure;
		PROCEDURE Procedure; END Procedure;
	END Object;
	END Test.

negative: duplicated procedure within object in procedure

	MODULE Test;
	PROCEDURE Procedure;
		TYPE Object = OBJECT
			PROCEDURE Procedure; END Procedure;
			PROCEDURE Procedure; END Procedure;
		END Object;
	END Procedure;
	END Test.

negative: duplicated procedure within procedure in object

	MODULE Test;
	TYPE Object = OBJECT
		PROCEDURE Procedure;
			PROCEDURE Procedure; END Procedure;
			PROCEDURE Procedure; END Procedure;
		END Procedure;
	END Object;
	END Test.


#procedure return types

positive: procedure returning basic character type

	MODULE Test;
	PROCEDURE Procedure (): CHAR;
	END Procedure;
	END Test.

positive: procedure returning basic boolean type

	MODULE Test;
	PROCEDURE Procedure (): BOOLEAN;
	END Procedure;
	END Test.

positive: procedure returning basic short integer type

	MODULE Test;
	PROCEDURE Procedure (): SHORTINT;
	END Procedure;
	END Test.

positive: procedure returning basic integer type

	MODULE Test;
	PROCEDURE Procedure (): INTEGER;
	END Procedure;
	END Test.

positive: procedure returning basic long integer type

	MODULE Test;
	PROCEDURE Procedure (): LONGINT;
	END Procedure;
	END Test.

positive: procedure returning basic huge integer type

	MODULE Test;
	PROCEDURE Procedure (): HUGEINT;
	END Procedure;
	END Test.

positive: procedure returning basic real type

	MODULE Test;
	PROCEDURE Procedure (): REAL;
	END Procedure;
	END Test.

positive: procedure returning basic long real type

	MODULE Test;
	PROCEDURE Procedure (): LONGREAL;
	END Procedure;
	END Test.

positive: procedure returning basic set type

	MODULE Test;
	PROCEDURE Procedure (): SET;
	END Procedure;
	END Test.

positive: procedure returning record type

	MODULE Test;
	TYPE Record = RECORD END;
	PROCEDURE Procedure (): Record;
	END Procedure;
	END Test.

positive: procedure returning anonymous record type

	MODULE Test;
	PROCEDURE Procedure (): RECORD END;
	END Procedure;
	END Test.

positive: procedure returning array type

	MODULE Test;
	TYPE Array = ARRAY 10 OF RECORD END;
	PROCEDURE Procedure (): Array;
	END Procedure;
	END Test.

positive: procedure returning anonymous array type

	MODULE Test;
	PROCEDURE Procedure (): ARRAY 10 OF RECORD END;
	END Procedure;
	END Test.

negative: procedure returning open array type

	MODULE Test;
	TYPE Array = ARRAY OF RECORD END;
	PROCEDURE Procedure (): Array;
	END Procedure;
	END Test.

negative: procedure returning anonymous open array type

	MODULE Test;
	PROCEDURE Procedure (): ARRAY OF RECORD END;
	END Procedure;
	END Test.

positive: procedure returning object type

	MODULE Test;
	TYPE Object = OBJECT;
	PROCEDURE Procedure (): Object;
	END Procedure;
	END Test.

positive: procedure returning anonymous object type

	MODULE Test;
	PROCEDURE Procedure (): OBJECT;
	END Procedure;
	END Test.

positive: procedure returning pointer type

	MODULE Test;
	TYPE Pointer = POINTER TO RECORD END;
	PROCEDURE Procedure (): Pointer;
	END Procedure;
	END Test.

positive: procedure returning anonymous pointer type

	MODULE Test;
	PROCEDURE Procedure (): POINTER TO RECORD END;
	END Procedure;
	END Test.

positive: procedure returning procedure type

	MODULE Test;
	TYPE Proc = PROCEDURE;
	PROCEDURE Procedure (): Proc;
	END Procedure;
	END Test.

positive: procedure returning anonymous procedure type

	MODULE Test;
	PROCEDURE Procedure (): PROCEDURE;
	END Procedure;
	END Test.

positive: procedure returning anonymous procedure returning anonymous procedure

	MODULE Test;
	PROCEDURE Procedure (): PROCEDURE () : PROCEDURE;
	END Procedure;
	END Test.

negative: procedure returning itself

	MODULE Test;
	PROCEDURE Procedure (): Procedure;
	END Procedure;
	END Test.

negative: procedure with returning local type

	MODULE Test;
	PROCEDURE Procedure (): Type;
	TYPE Type = RECORD END;
	END Procedure;
	END Test.


# procedure parameters

negative: parameter marked as exported

	MODULE Test;
	PROCEDURE Procedure (parameter*: OBJECT);
	END Procedure;
	END Test.

negative: parameter marked as read-only

	MODULE Test;
	PROCEDURE Procedure (parameter*: OBJECT);
	END Procedure;
	END Test.

negative: duplicated parameters

	MODULE Test;
	PROCEDURE Procedure (parameter: LONGINT; parameter: LONGINT);
	END Procedure;
	END Test.

negative: duplicated parameters in same declaration

	MODULE Test;
	PROCEDURE Procedure (parameter, parameter: LONGINT);
	END Procedure;
	END Test.

positive: procedure with parameter of same type

	MODULE Test;
	TYPE Proc = PROCEDURE;
	PROCEDURE Procedure (procedure: Proc);
	END Procedure;
	END Test.

negative: procedure with multiple variable parameter

	MODULE Test;
	PROCEDURE Procedure (VAR VAR parameter: SET);
	END Procedure;
	END Test.

negative: procedure with multiple constant parameter

	MODULE Test;
	PROCEDURE Procedure (CONST CONST parameter: SET);
	END Procedure;
	END Test.

negative: procedure with variable and constant parameter

	MODULE Test;
	PROCEDURE Procedure (VAR CONST parameter: SET);
	END Procedure;
	END Test.

negative: procedure with constant and variable parameter

	MODULE Test;
	PROCEDURE Procedure (VAR CONST parameter: SET);
	END Procedure;
	END Test.

negative: procedure with parameter marked as exported

	MODULE Test;
	PROCEDURE Procedure (parameter*: CHAR);
	END Procedure;
	END Test.

negative: procedure with parameter marked as read-only

	MODULE Test;
	PROCEDURE Procedure (parameter-: CHAR);
	END Procedure;
	END Test.

positive: procedure with a parameter of basic character type

	MODULE Test;
	PROCEDURE Procedure (parameter: CHAR);
	END Procedure;
	END Test.

positive: procedure with parameters of basic character type

	MODULE Test;
	PROCEDURE Procedure (a, b, c: CHAR);
	END Procedure;
	END Test.

positive: procedure with a parameter of variable character type

	MODULE Test;
	PROCEDURE Procedure (VAR parameter: CHAR);
	END Procedure;
	END Test.

positive: procedure with parameters of variable character type

	MODULE Test;
	PROCEDURE Procedure (VAR a, b, c: CHAR);
	END Procedure;
	END Test.

positive: procedure with a parameter of constant character type

	MODULE Test;
	PROCEDURE Procedure (CONST parameter: CHAR);
	END Procedure;
	END Test.

positive: procedure with parameters of constant character type

	MODULE Test;
	PROCEDURE Procedure (CONST a, b, c: CHAR);
	END Procedure;
	END Test.

positive: procedure with intermixed parameters of character type

	MODULE Test;
	PROCEDURE Procedure (a: CHAR; VAR b: CHAR; CONST c: CHAR);
	END Procedure;
	END Test.

positive: procedure with a parameter of basic boolean type

	MODULE Test;
	PROCEDURE Procedure (parameter: BOOLEAN);
	END Procedure;
	END Test.

positive: procedure with parameters of basic boolean type

	MODULE Test;
	PROCEDURE Procedure (a, b, c: BOOLEAN);
	END Procedure;
	END Test.

positive: procedure with a parameter of variable boolean type

	MODULE Test;
	PROCEDURE Procedure (VAR parameter: BOOLEAN);
	END Procedure;
	END Test.

positive: procedure with parameters of variable boolean type

	MODULE Test;
	PROCEDURE Procedure (VAR a, b, c: BOOLEAN);
	END Procedure;
	END Test.

positive: procedure with a parameter of constant boolean type

	MODULE Test;
	PROCEDURE Procedure (CONST parameter: BOOLEAN);
	END Procedure;
	END Test.

positive: procedure with parameters of constant boolean type

	MODULE Test;
	PROCEDURE Procedure (CONST a, b, c: BOOLEAN);
	END Procedure;
	END Test.

positive: procedure with intermixed parameters of boolean type

	MODULE Test;
	PROCEDURE Procedure (a: BOOLEAN; VAR b: BOOLEAN; CONST c: BOOLEAN);
	END Procedure;
	END Test.

positive: procedure with a parameter of basic short integer type

	MODULE Test;
	PROCEDURE Procedure (parameter: SHORTINT);
	END Procedure;
	END Test.

positive: procedure with parameters of basic short integer type

	MODULE Test;
	PROCEDURE Procedure (a, b, c: SHORTINT);
	END Procedure;
	END Test.

positive: procedure with a parameter of variable short integer type

	MODULE Test;
	PROCEDURE Procedure (VAR parameter: SHORTINT);
	END Procedure;
	END Test.

positive: procedure with parameters of variable short integer type

	MODULE Test;
	PROCEDURE Procedure (VAR a, b, c: SHORTINT);
	END Procedure;
	END Test.

positive: procedure with a parameter of constant short integer type

	MODULE Test;
	PROCEDURE Procedure (CONST parameter: SHORTINT);
	END Procedure;
	END Test.

positive: procedure with parameters of constant short integer type

	MODULE Test;
	PROCEDURE Procedure (CONST a, b, c: SHORTINT);
	END Procedure;
	END Test.

positive: procedure with intermixed parameters of short integer type

	MODULE Test;
	PROCEDURE Procedure (a: SHORTINT; VAR b: SHORTINT; CONST c: SHORTINT);
	END Procedure;
	END Test.

positive: procedure with a parameter of basic integer type

	MODULE Test;
	PROCEDURE Procedure (parameter: INTEGER);
	END Procedure;
	END Test.

positive: procedure with parameters of basic integer type

	MODULE Test;
	PROCEDURE Procedure (a, b, c: INTEGER);
	END Procedure;
	END Test.

positive: procedure with a parameter of variable integer type

	MODULE Test;
	PROCEDURE Procedure (VAR parameter: INTEGER);
	END Procedure;
	END Test.

positive: procedure with parameters of variable integer type

	MODULE Test;
	PROCEDURE Procedure (VAR a, b, c: INTEGER);
	END Procedure;
	END Test.

positive: procedure with a parameter of constant integer type

	MODULE Test;
	PROCEDURE Procedure (CONST parameter: INTEGER);
	END Procedure;
	END Test.

positive: procedure with parameters of constant integer type

	MODULE Test;
	PROCEDURE Procedure (CONST a, b, c: INTEGER);
	END Procedure;
	END Test.

positive: procedure with intermixed parameters of integer type

	MODULE Test;
	PROCEDURE Procedure (a: INTEGER; VAR b: INTEGER; CONST c: INTEGER);
	END Procedure;
	END Test.

positive: procedure with a parameter of basic long integer type

	MODULE Test;
	PROCEDURE Procedure (parameter: LONGINT);
	END Procedure;
	END Test.

positive: procedure with parameters of basic long integer type

	MODULE Test;
	PROCEDURE Procedure (a, b, c: LONGINT);
	END Procedure;
	END Test.

positive: procedure with a parameter of variable long integer type

	MODULE Test;
	PROCEDURE Procedure (VAR parameter: LONGINT);
	END Procedure;
	END Test.

positive: procedure with parameters of variable long integer type

	MODULE Test;
	PROCEDURE Procedure (VAR a, b, c: LONGINT);
	END Procedure;
	END Test.

positive: procedure with a parameter of constant long integer type

	MODULE Test;
	PROCEDURE Procedure (CONST parameter: LONGINT);
	END Procedure;
	END Test.

positive: procedure with parameters of constant long integer type

	MODULE Test;
	PROCEDURE Procedure (CONST a, b, c: LONGINT);
	END Procedure;
	END Test.

positive: procedure with intermixed parameters of long integer type

	MODULE Test;
	PROCEDURE Procedure (a: LONGINT; VAR b: LONGINT; CONST c: LONGINT);
	END Procedure;
	END Test.

positive: procedure with a parameter of basic huge integer type

	MODULE Test;
	PROCEDURE Procedure (parameter: HUGEINT);
	END Procedure;
	END Test.

positive: procedure with parameters of basic huge integer type

	MODULE Test;
	PROCEDURE Procedure (a, b, c: HUGEINT);
	END Procedure;
	END Test.

positive: procedure with a parameter of variable huge integer type

	MODULE Test;
	PROCEDURE Procedure (VAR parameter: HUGEINT);
	END Procedure;
	END Test.

positive: procedure with parameters of variable huge integer type

	MODULE Test;
	PROCEDURE Procedure (VAR a, b, c: HUGEINT);
	END Procedure;
	END Test.

positive: procedure with a parameter of constant huge integer type

	MODULE Test;
	PROCEDURE Procedure (CONST parameter: HUGEINT);
	END Procedure;
	END Test.

positive: procedure with parameters of constant huge integer type

	MODULE Test;
	PROCEDURE Procedure (CONST a, b, c: HUGEINT);
	END Procedure;
	END Test.

positive: procedure with intermixed parameters of huge integer type

	MODULE Test;
	PROCEDURE Procedure (a: HUGEINT; VAR b: HUGEINT; CONST c: HUGEINT);
	END Procedure;
	END Test.

positive: procedure with a parameter of basic real type

	MODULE Test;
	PROCEDURE Procedure (parameter: REAL);
	END Procedure;
	END Test.

positive: procedure with parameters of basic real type

	MODULE Test;
	PROCEDURE Procedure (a, b, c: REAL);
	END Procedure;
	END Test.

positive: procedure with a parameter of variable real type

	MODULE Test;
	PROCEDURE Procedure (VAR parameter: REAL);
	END Procedure;
	END Test.

positive: procedure with parameters of variable real type

	MODULE Test;
	PROCEDURE Procedure (VAR a, b, c: REAL);
	END Procedure;
	END Test.

positive: procedure with a parameter of constant real type

	MODULE Test;
	PROCEDURE Procedure (CONST parameter: REAL);
	END Procedure;
	END Test.

positive: procedure with parameters of constant real type

	MODULE Test;
	PROCEDURE Procedure (CONST a, b, c: REAL);
	END Procedure;
	END Test.

positive: procedure with intermixed parameters of real type

	MODULE Test;
	PROCEDURE Procedure (a: REAL; VAR b: REAL; CONST c: REAL);
	END Procedure;
	END Test.

positive: procedure with a parameter of basic long real type

	MODULE Test;
	PROCEDURE Procedure (parameter: LONGREAL);
	END Procedure;
	END Test.

positive: procedure with parameters of basic long real type

	MODULE Test;
	PROCEDURE Procedure (a, b, c: LONGREAL);
	END Procedure;
	END Test.

positive: procedure with a parameter of variable long real type

	MODULE Test;
	PROCEDURE Procedure (VAR parameter: LONGREAL);
	END Procedure;
	END Test.

positive: procedure with parameters of variable long real type

	MODULE Test;
	PROCEDURE Procedure (VAR a, b, c: LONGREAL);
	END Procedure;
	END Test.

positive: procedure with a parameter of constant long real type

	MODULE Test;
	PROCEDURE Procedure (CONST parameter: LONGREAL);
	END Procedure;
	END Test.

positive: procedure with parameters of constant long real type

	MODULE Test;
	PROCEDURE Procedure (CONST a, b, c: LONGREAL);
	END Procedure;
	END Test.

positive: procedure with intermixed parameters of long real type

	MODULE Test;
	PROCEDURE Procedure (a: LONGREAL; VAR b: LONGREAL; CONST c: LONGREAL);
	END Procedure;
	END Test.

positive: procedure with a parameter of basic set type

	MODULE Test;
	PROCEDURE Procedure (parameter: SET);
	END Procedure;
	END Test.

positive: procedure with parameters of basic set type

	MODULE Test;
	PROCEDURE Procedure (a, b, c: SET);
	END Procedure;
	END Test.

positive: procedure with a parameter of variable set type

	MODULE Test;
	PROCEDURE Procedure (VAR parameter: SET);
	END Procedure;
	END Test.

positive: procedure with parameters of variable set type

	MODULE Test;
	PROCEDURE Procedure (VAR a, b, c: SET);
	END Procedure;
	END Test.

positive: procedure with a parameter of constant set type

	MODULE Test;
	PROCEDURE Procedure (CONST parameter: SET);
	END Procedure;
	END Test.

positive: procedure with parameters of constant set type

	MODULE Test;
	PROCEDURE Procedure (CONST a, b, c: SET);
	END Procedure;
	END Test.

positive: procedure with intermixed parameters of set type

	MODULE Test;
	PROCEDURE Procedure (a: SET; VAR b: SET; CONST c: SET);
	END Procedure;
	END Test.

positive: procedure with a parameter of record type

	MODULE Test;
	TYPE Record = RECORD END;
	PROCEDURE Procedure (parameter: Record);
	END Procedure;
	END Test.

positive: procedure with parameters of record type

	MODULE Test;
	TYPE Record = RECORD END;
	PROCEDURE Procedure (a, b, c: Record);
	END Procedure;
	END Test.

positive: procedure with a parameter of variable record type

	MODULE Test;
	TYPE Record = RECORD END;
	PROCEDURE Procedure (VAR parameter: Record);
	END Procedure;
	END Test.

positive: procedure with parameters of variable record type

	MODULE Test;
	TYPE Record = RECORD END;
	PROCEDURE Procedure (VAR a, b, c: Record);
	END Procedure;
	END Test.

positive: procedure with a parameter of constant record type

	MODULE Test;
	TYPE Record = RECORD END;
	PROCEDURE Procedure (CONST parameter: Record);
	END Procedure;
	END Test.

positive: procedure with parameters of constant record type

	MODULE Test;
	TYPE Record = RECORD END;
	PROCEDURE Procedure (CONST a, b, c: Record);
	END Procedure;
	END Test.

positive: procedure with intermixed parameters of record type

	MODULE Test;
	TYPE Record = RECORD END;
	PROCEDURE Procedure (a: Record; VAR b: Record; CONST c: Record);
	END Procedure;
	END Test.

positive: procedure with a parameter of anonymous record type

	MODULE Test;
	TYPE Record = RECORD END;
	PROCEDURE Procedure (parameter: RECORD END);
	END Procedure;
	END Test.

positive: procedure with parameters of anonymous record type

	MODULE Test;
	PROCEDURE Procedure (a, b, c: RECORD END);
	END Procedure;
	END Test.

positive: procedure with a parameter of variable anonymous record type

	MODULE Test;
	PROCEDURE Procedure (VAR parameter: RECORD END);
	END Procedure;
	END Test.

positive: procedure with parameters of variable anonymous record type

	MODULE Test;
	PROCEDURE Procedure (VAR a, b, c: RECORD END);
	END Procedure;
	END Test.

positive: procedure with a parameter of constant anonymous record type

	MODULE Test;
	PROCEDURE Procedure (CONST parameter: RECORD END);
	END Procedure;
	END Test.

positive: procedure with parameters of constant anonymous record type

	MODULE Test;
	PROCEDURE Procedure (CONST a, b, c: RECORD END);
	END Procedure;
	END Test.

positive: procedure with intermixed parameters of anonymous record type

	MODULE Test;
	PROCEDURE Procedure (a: RECORD END; VAR b: RECORD END; CONST c: RECORD END);
	END Procedure;
	END Test.

positive: procedure with a parameter of array type

	MODULE Test;
	TYPE Array = ARRAY 10 OF RECORD END;
	PROCEDURE Procedure (parameter: Array);
	END Procedure;
	END Test.

positive: procedure with parameters of array type

	MODULE Test;
	TYPE Array = ARRAY 10 OF RECORD END;
	PROCEDURE Procedure (a, b, c: Array);
	END Procedure;
	END Test.

positive: procedure with a parameter of variable array type

	MODULE Test;
	TYPE Array = ARRAY 10 OF RECORD END;
	PROCEDURE Procedure (VAR parameter: Array);
	END Procedure;
	END Test.

positive: procedure with parameters of variable array type

	MODULE Test;
	TYPE Array = ARRAY 10 OF RECORD END;
	PROCEDURE Procedure (VAR a, b, c: Array);
	END Procedure;
	END Test.

positive: procedure with a parameter of constant array type

	MODULE Test;
	TYPE Array = ARRAY 10 OF RECORD END;
	PROCEDURE Procedure (CONST parameter: Array);
	END Procedure;
	END Test.

positive: procedure with parameters of constant array type

	MODULE Test;
	TYPE Array = ARRAY 10 OF RECORD END;
	PROCEDURE Procedure (CONST a, b, c: Array);
	END Procedure;
	END Test.

positive: procedure with intermixed parameters of array type

	MODULE Test;
	TYPE Array = ARRAY 10 OF RECORD END;
	PROCEDURE Procedure (a: Array; VAR b: Array; CONST c: Array);
	END Procedure;
	END Test.

positive: procedure with a parameter of anonymous array type

	MODULE Test;
	PROCEDURE Procedure (parameter: ARRAY 10 OF RECORD END);
	END Procedure;
	END Test.

positive: procedure with parameters of anonymous array type

	MODULE Test;
	PROCEDURE Procedure (a, b, c: ARRAY 10 OF RECORD END);
	END Procedure;
	END Test.

positive: procedure with a parameter of variable anonymous array type

	MODULE Test;
	PROCEDURE Procedure (VAR parameter: ARRAY 10 OF RECORD END);
	END Procedure;
	END Test.

positive: procedure with parameters of variable anonymous array type

	MODULE Test;
	PROCEDURE Procedure (VAR a, b, c: ARRAY 10 OF RECORD END);
	END Procedure;
	END Test.

positive: procedure with a parameter of constant anonymous array type

	MODULE Test;
	PROCEDURE Procedure (CONST parameter: ARRAY 10 OF RECORD END);
	END Procedure;
	END Test.

positive: procedure with parameters of constant anonymous array type

	MODULE Test;
	PROCEDURE Procedure (CONST a, b, c: ARRAY 10 OF RECORD END);
	END Procedure;
	END Test.

positive: procedure with intermixed parameters of anonymous array type

	MODULE Test;
	PROCEDURE Procedure (a: ARRAY 10 OF RECORD END; VAR b: ARRAY 10 OF RECORD END; CONST c: ARRAY 10 OF RECORD END);
	END Procedure;
	END Test.

positive: procedure with a parameter of open array type

	MODULE Test;
	TYPE Array = ARRAY OF RECORD END;
	PROCEDURE Procedure (parameter: Array);
	END Procedure;
	END Test.

positive: procedure with parameters of open array type

	MODULE Test;
	TYPE Array = ARRAY OF RECORD END;
	PROCEDURE Procedure (a, b, c: Array);
	END Procedure;
	END Test.

positive: procedure with a parameter of variable open array type

	MODULE Test;
	TYPE Array = ARRAY OF RECORD END;
	PROCEDURE Procedure (VAR parameter: Array);
	END Procedure;
	END Test.

positive: procedure with parameters of variable open array type

	MODULE Test;
	TYPE Array = ARRAY OF RECORD END;
	PROCEDURE Procedure (VAR a, b, c: Array);
	END Procedure;
	END Test.

positive: procedure with a parameter of constant open array type

	MODULE Test;
	TYPE Array = ARRAY OF RECORD END;
	PROCEDURE Procedure (CONST parameter: Array);
	END Procedure;
	END Test.

positive: procedure with parameters of constant open array type

	MODULE Test;
	TYPE Array = ARRAY OF RECORD END;
	PROCEDURE Procedure (CONST a, b, c: Array);
	END Procedure;
	END Test.

positive: procedure with intermixed parameters of open array type

	MODULE Test;
	TYPE Array = ARRAY OF RECORD END;
	PROCEDURE Procedure (a: Array; VAR b: Array; CONST c: Array);
	END Procedure;
	END Test.

positive: procedure with a parameter of anonymous open array type

	MODULE Test;
	PROCEDURE Procedure (parameter: ARRAY OF RECORD END);
	END Procedure;
	END Test.

positive: procedure with parameters of anonymous open array type

	MODULE Test;
	PROCEDURE Procedure (a, b, c: ARRAY OF RECORD END);
	END Procedure;
	END Test.

positive: procedure with a parameter of variable anonymous open array type

	MODULE Test;
	PROCEDURE Procedure (VAR parameter: ARRAY OF RECORD END);
	END Procedure;
	END Test.

positive: procedure with parameters of variable anonymous open array type

	MODULE Test;
	PROCEDURE Procedure (VAR a, b, c: ARRAY OF RECORD END);
	END Procedure;
	END Test.

positive: procedure with a parameter of constant anonymous open array type

	MODULE Test;
	PROCEDURE Procedure (CONST parameter: ARRAY OF RECORD END);
	END Procedure;
	END Test.

positive: procedure with parameters of constant anonymous open array type

	MODULE Test;
	PROCEDURE Procedure (CONST a, b, c: ARRAY OF RECORD END);
	END Procedure;
	END Test.

positive: procedure with intermixed parameters of anonymous open array type

	MODULE Test;
	PROCEDURE Procedure (a: ARRAY OF RECORD END; VAR b: ARRAY OF RECORD END; CONST c: ARRAY OF RECORD END);
	END Procedure;
	END Test.

positive: procedure with a parameter of object type

	MODULE Test;
	TYPE Object = OBJECT END Object;
	PROCEDURE Procedure (parameter: Object);
	END Procedure;
	END Test.

positive: procedure with a parameter of plain object type

	MODULE Test;
	TYPE Object = OBJECT;
	PROCEDURE Procedure (parameter: Object);
	END Procedure;
	END Test.

positive: procedure with parameters of object type

	MODULE Test;
	TYPE Object = OBJECT END Object;
	PROCEDURE Procedure (a, b, c: Object);
	END Procedure;
	END Test.

positive: procedure with a parameter of variable object type

	MODULE Test;
	TYPE Object = OBJECT END Object;
	PROCEDURE Procedure (VAR parameter: Object);
	END Procedure;
	END Test.

positive: procedure with parameters of variable object type

	MODULE Test;
	TYPE Object = OBJECT END Object;
	PROCEDURE Procedure (VAR a, b, c: Object);
	END Procedure;
	END Test.

positive: procedure with a parameter of constant object type

	MODULE Test;
	TYPE Object = OBJECT END Object;
	PROCEDURE Procedure (CONST parameter: Object);
	END Procedure;
	END Test.

positive: procedure with parameters of constant object type

	MODULE Test;
	TYPE Object = OBJECT END Object;
	PROCEDURE Procedure (CONST a, b, c: Object);
	END Procedure;
	END Test.

positive: procedure with intermixed parameters of object type

	MODULE Test;
	TYPE Object = OBJECT END Object;
	PROCEDURE Procedure (a: Object; VAR b: Object; CONST c: Object);
	END Procedure;
	END Test.

positive: procedure with intermixed parameters of plain object type

	MODULE Test;
	TYPE Object = OBJECT;
	PROCEDURE Procedure (a: Object; VAR b: Object; CONST c: Object);
	END Procedure;
	END Test.

positive: procedure with a parameter of anonymous object type

	MODULE Test;
	PROCEDURE Procedure (parameter: OBJECT END);
	END Procedure;
	END Test.

positive: procedure with a parameter of anonymous plain object type

	MODULE Test;
	PROCEDURE Procedure (parameter: OBJECT);
	END Procedure;
	END Test.

positive: procedure with parameters of anonymous object type

	MODULE Test;
	PROCEDURE Procedure (a, b, c: OBJECT END);
	END Procedure;
	END Test.

positive: procedure with a parameter of variable anonymous object type

	MODULE Test;
	PROCEDURE Procedure (VAR parameter: OBJECT END);
	END Procedure;
	END Test.

positive: procedure with parameters of variable anonymous object type

	MODULE Test;
	PROCEDURE Procedure (VAR a, b, c: OBJECT END);
	END Procedure;
	END Test.

positive: procedure with a parameter of constant anonymous object type

	MODULE Test;
	PROCEDURE Procedure (CONST parameter: OBJECT END);
	END Procedure;
	END Test.

positive: procedure with parameters of constant anonymous object type

	MODULE Test;
	PROCEDURE Procedure (CONST a, b, c: OBJECT END);
	END Procedure;
	END Test.

positive: procedure with intermixed parameters of anonymous object type

	MODULE Test;
	PROCEDURE Procedure (a: OBJECT END; VAR b: OBJECT END; CONST c: OBJECT END);
	END Procedure;
	END Test.

positive: procedure with intermixed parameters of anonymous plain object type

	MODULE Test;
	PROCEDURE Procedure (a: OBJECT; VAR b: OBJECT; CONST c: OBJECT);
	END Procedure;
	END Test.

positive: procedure with a parameter of pointer type

	MODULE Test;
	TYPE Pointer = POINTER TO RECORD END;
	PROCEDURE Procedure (parameter: Pointer);
	END Procedure;
	END Test.

positive: procedure with parameters of pointer type

	MODULE Test;
	TYPE Pointer = POINTER TO RECORD END;
	PROCEDURE Procedure (a, b, c: Pointer);
	END Procedure;
	END Test.

positive: procedure with a parameter of variable pointer type

	MODULE Test;
	TYPE Pointer = POINTER TO RECORD END;
	PROCEDURE Procedure (VAR parameter: Pointer);
	END Procedure;
	END Test.

positive: procedure with parameters of variable pointer type

	MODULE Test;
	TYPE Pointer = POINTER TO RECORD END;
	PROCEDURE Procedure (VAR a, b, c: Pointer);
	END Procedure;
	END Test.

positive: procedure with a parameter of constant pointer type

	MODULE Test;
	TYPE Pointer = POINTER TO RECORD END;
	PROCEDURE Procedure (CONST parameter: Pointer);
	END Procedure;
	END Test.

positive: procedure with parameters of constant pointer type

	MODULE Test;
	TYPE Pointer = POINTER TO RECORD END;
	PROCEDURE Procedure (CONST a, b, c: Pointer);
	END Procedure;
	END Test.

positive: procedure with intermixed parameters of pointer type

	MODULE Test;
	TYPE Pointer = POINTER TO RECORD END;
	PROCEDURE Procedure (a: Pointer; VAR b: Pointer; CONST c: Pointer);
	END Procedure;
	END Test.

positive: procedure with a parameter of anonymous pointer type

	MODULE Test;
	PROCEDURE Procedure (parameter: POINTER TO RECORD END);
	END Procedure;
	END Test.

positive: procedure with parameters of anonymous pointer type

	MODULE Test;
	PROCEDURE Procedure (a, b, c: POINTER TO RECORD END);
	END Procedure;
	END Test.

positive: procedure with a parameter of variable anonymous pointer type

	MODULE Test;
	PROCEDURE Procedure (VAR parameter: POINTER TO RECORD END);
	END Procedure;
	END Test.

positive: procedure with parameters of variable anonymous pointer type

	MODULE Test;
	PROCEDURE Procedure (VAR a, b, c: POINTER TO RECORD END);
	END Procedure;
	END Test.

positive: procedure with a parameter of constant anonymous pointer type

	MODULE Test;
	PROCEDURE Procedure (CONST parameter: OBJECT END);
	END Procedure;
	END Test.

positive: procedure with parameters of constant anonymous pointer type

	MODULE Test;
	PROCEDURE Procedure (CONST a, b, c: POINTER TO RECORD END);
	END Procedure;
	END Test.

positive: procedure with intermixed parameters of anonymous pointer type

	MODULE Test;
	PROCEDURE Procedure (a: POINTER TO RECORD END; VAR b: POINTER TO RECORD END; CONST c: POINTER TO RECORD END);
	END Procedure;
	END Test.

positive: procedure with a parameter of procedure type

	MODULE Test;
	TYPE Proc = PROCEDURE;
	PROCEDURE Procedure (parameter: Proc);
	END Procedure;
	END Test.

positive: procedure with parameters of procedure type

	MODULE Test;
	TYPE Proc = PROCEDURE;
	PROCEDURE Procedure (a, b, c: Proc);
	END Procedure;
	END Test.

positive: procedure with a parameter of variable procedure type

	MODULE Test;
	TYPE Proc = PROCEDURE;
	PROCEDURE Procedure (VAR parameter: Proc);
	END Procedure;
	END Test.

positive: procedure with parameters of variable procedure type

	MODULE Test;
	TYPE Proc = PROCEDURE;
	PROCEDURE Procedure (VAR a, b, c: Proc);
	END Procedure;
	END Test.

positive: procedure with a parameter of constant procedure type

	MODULE Test;
	TYPE Proc = PROCEDURE;
	PROCEDURE Procedure (CONST parameter: Proc);
	END Procedure;
	END Test.

positive: procedure with parameters of constant procedure type

	MODULE Test;
	TYPE Proc = PROCEDURE;
	PROCEDURE Procedure (CONST a, b, c: Proc);
	END Procedure;
	END Test.

positive: procedure with intermixed parameters of procedure type

	MODULE Test;
	TYPE Proc = PROCEDURE;
	PROCEDURE Procedure (a: Proc; VAR b: Proc; CONST c: Proc);
	END Procedure;
	END Test.

positive: procedure with a parameter of anonymous procedure type

	MODULE Test;
	PROCEDURE Procedure (parameter: PROCEDURE);
	END Procedure;
	END Test.

positive: procedure with parameters of anonymous procedure type

	MODULE Test;
	PROCEDURE Procedure (a, b, c: PROCEDURE);
	END Procedure;
	END Test.

positive: procedure with a parameter of variable anonymous procedure type

	MODULE Test;
	PROCEDURE Procedure (VAR parameter: PROCEDURE);
	END Procedure;
	END Test.

positive: procedure with parameters of variable anonymous procedure type

	MODULE Test;
	PROCEDURE Procedure (VAR a, b, c: PROCEDURE);
	END Procedure;
	END Test.

positive: procedure with a parameter of constant anonymous procedure type

	MODULE Test;
	PROCEDURE Procedure (CONST parameter: PROCEDURE);
	END Procedure;
	END Test.

positive: procedure with parameters of constant anonymous procedure type

	MODULE Test;
	PROCEDURE Procedure (CONST a, b, c: PROCEDURE);
	END Procedure;
	END Test.

positive: procedure with intermixed parameters of anonymous procedure type

	MODULE Test;
	PROCEDURE Procedure (a: PROCEDURE; VAR b: PROCEDURE; CONST c: PROCEDURE);
	END Procedure;
	END Test.

negative: procedure with parameters of local type

	MODULE Test;
	PROCEDURE Procedure (parameter: Type);
	TYPE Type = RECORD END;
	END Procedure;
	END Test.

negative: procedure with parameter and local constant with same name

	MODULE Test;
	PROCEDURE Procedure (parameter: SET);
	CONST parameter = 10;
	END Procedure;
	END Test.

negative: procedure with parameter and local type with same name

	MODULE Test;
	PROCEDURE Procedure (parameter: SET);
	TYPE parameter = RECORD END;
	END Procedure;
	END Test.

negative: procedure with parameter and local variable with same name

	MODULE Test;
	PROCEDURE Procedure (parameter: SET);
	VAR parameter: LONGINT;
	END Procedure;
	END Test.

negative: procedure with parameter and nested procedure with same name

	MODULE Test;
	PROCEDURE Procedure (parameter: SET);
		PROCEDURE parameter; END parameter;
	END Procedure;
	END Test.


# initializers

negative: initializer within module

	MODULE Test;
	PROCEDURE &Initializer; END Initializer;
	END Test.

negative: initializer within procedure

	MODULE Test;
	PROCEDURE Procedure;
		PROCEDURE &Initializer; END Initializer;
	END Procedure;
	END Test.

negative: initializer within nested procedure

	MODULE Test;
	PROCEDURE Procedure;
		PROCEDURE Procedure;
			PROCEDURE &Initializer; END Initializer;
		END Procedure;
	END Procedure;
	END Test.

positive: initializer within object

	MODULE Test;
	TYPE Object = OBJECT
		PROCEDURE &Initializer; END Initializer;
	END Object;
	END Test.

positive: initializer within object in procedure

	MODULE Test;
	PROCEDURE Procedure;
		TYPE Object = OBJECT
			PROCEDURE &Initializer; END Initializer;
		END Object;
	END Procedure;
	END Test.

negative: initializer within procedure in object

	MODULE Test;
	TYPE Object = OBJECT
		PROCEDURE Procedure;
			PROCEDURE &Initializer; END Initializer;
		END Procedure;
	END Object;
	END Test.

negative: initializer within nested procedure in object

	MODULE Test;
	TYPE Object = OBJECT
		PROCEDURE Procedure;
			PROCEDURE Procedure;
				PROCEDURE &Initializer; END Initializer;
			END Procedure;
		END Procedure;
	END Object;
	END Test.

negative: two initializers in object

	MODULE Test;
	TYPE Object = OBJECT
		PROCEDURE &Initializer1; END Initializer1;
		PROCEDURE &Initializer2; END Initializer2;
	END Object;
	END Test.

negative: two initializers in object with same name

	MODULE Test;
	TYPE Object = OBJECT
		PROCEDURE &Initializer; END Initializer;
		PROCEDURE &Initializer; END Initializer;
	END Object;
	END Test.


# statement blocks

negative: invalid block modifier notag

	MODULE Test;
	BEGIN {NOTAG};
	END Test.

negative: invalid block modifier delegate

	MODULE Test;
	BEGIN {DELEGATE};
	END Test.

negative: repeated exclusive block modifier

	MODULE Test;
	BEGIN {EXCLUSIVE, EXCLUSIVE};
	END Test.

negative: repeated active block modifier

	MODULE Test;
	BEGIN {ACTIVE, ACTIVE};
	END Test.

positive: exclusive module body

	MODULE Test;
	BEGIN {EXCLUSIVE}
	END Test.

positive: nested exclusive module body

	MODULE Test;
	BEGIN BEGIN {EXCLUSIVE} END
	END Test.

negative: exclusive block in exclusive module body

	MODULE Test;
	BEGIN {EXCLUSIVE} BEGIN {EXCLUSIVE} END
	END Test.

negative: exclusive block in active module body

	MODULE Test;
	BEGIN {ACTIVE} BEGIN {EXCLUSIVE} END
	END Test.

positive: exclusive object body

	MODULE Test;
	TYPE Object = OBJECT
	BEGIN {EXCLUSIVE}
	END Object;
	END Test.

positive: nested exclusive object body

	MODULE Test;
	TYPE Object = OBJECT
	BEGIN BEGIN {EXCLUSIVE} END
	END Object;
	END Test.

negative: exclusive block in exclusive object body

	MODULE Test;
	TYPE Object = OBJECT
	BEGIN {EXCLUSIVE} BEGIN {EXCLUSIVE} END
	END Object;
	END Test.

positive: exclusive block in active object body

	MODULE Test;
	TYPE Object = OBJECT
	BEGIN {ACTIVE} BEGIN {EXCLUSIVE} END
	END Object;
	END Test.

positive: exclusive procedure body within module

	MODULE Test;
	PROCEDURE Procedure;
	BEGIN {EXCLUSIVE}
	END Procedure;
	END Test.

positive: nested exclusive procedure body within module

	MODULE Test;
	PROCEDURE Procedure;
	BEGIN BEGIN {EXCLUSIVE} END
	END Procedure;
	END Test.

negative: exclusive block in exclusive procedure body within module

	MODULE Test;
	PROCEDURE Procedure;
	BEGIN {EXCLUSIVE} BEGIN {EXCLUSIVE} END
	END Procedure;
	END Test.

negative: exclusive block in active procedure body within module

	MODULE Test;
	PROCEDURE Procedure;
	BEGIN {ACTIVE} BEGIN {EXCLUSIVE} END
	END Procedure;
	END Test.

positive: exclusive procedure body within object

	MODULE Test;
	TYPE Object = OBJECT
		PROCEDURE Procedure;
		BEGIN {EXCLUSIVE}
		END Procedure;
	END Object;
	END Test.

positive: exclusive nested procedure body within object

	MODULE Test;
	TYPE Object = OBJECT
		PROCEDURE Procedure;
		BEGIN BEGIN {EXCLUSIVE} END
		END Procedure;
	END Object;
	END Test.

negative: exclusive block in exclusive procedure body within object

	MODULE Test;
	TYPE Object = OBJECT
		PROCEDURE Procedure;
		BEGIN {EXCLUSIVE} BEGIN {EXCLUSIVE} END
		END Procedure;
	END Object;
	END Test.

negative: exclusive block in active procedure body within object

	MODULE Test;
	TYPE Object = OBJECT
		PROCEDURE Procedure;
		BEGIN {ACTIVE} BEGIN {EXCLUSIVE} END
		END Procedure;
	END Object;
	END Test.

negative: active module body

	MODULE Test;
	BEGIN {ACTIVE}
	END Test.

negative: nested active module body

	MODULE Test;
	BEGIN BEGIN {ACTIVE} END
	END Test.

negative: active block in active module body

	MODULE Test;
	BEGIN {ACTIVE} BEGIN {ACTIVE} END
	END Test.

negative: active block in exclusive module body

	MODULE Test;
	BEGIN {EXCLUSIVE} BEGIN {ACTIVE} END
	END Test.

positive: active object body

	MODULE Test;
	TYPE Object = OBJECT
	BEGIN {ACTIVE}
	END Object;
	END Test.

negative: nested active object body

	MODULE Test;
	TYPE Object = OBJECT
	BEGIN BEGIN {ACTIVE} END
	END Object;
	END Test.

negative: active block in active object body

	MODULE Test;
	TYPE Object = OBJECT
	BEGIN {ACTIVE} BEGIN {ACTIVE} END
	END Object;
	END Test.

negative: active block in exclusive object body

	MODULE Test;
	TYPE Object = OBJECT
	BEGIN {EXCLUSIVE} BEGIN {ACTIVE} END
	END Object;
	END Test.

negative: active procedure body within module

	MODULE Test;
	PROCEDURE Procedure;
	BEGIN {ACTIVE}
	END Procedure;
	END Test.

negative: nested active procedure body within module

	MODULE Test;
	PROCEDURE Procedure;
	BEGIN BEGIN {ACTIVE} END
	END Procedure;
	END Test.

negative: active block in active procedure body within module

	MODULE Test;
	PROCEDURE Procedure;
	BEGIN {ACTIVE} BEGIN {ACTIVE} END
	END Procedure;
	END Test.

negative: active block in exclusive procedure body within module

	MODULE Test;
	PROCEDURE Procedure;
	BEGIN {EXCLUSIVE} BEGIN {ACTIVE} END
	END Procedure;
	END Test.

negative: active procedure body within object

	MODULE Test;
	TYPE Object = OBJECT
		PROCEDURE Procedure;
		BEGIN {ACTIVE}
		END Procedure;
	END Object;
	END Test.

negative: active nested procedure body within object

	MODULE Test;
	TYPE Object = OBJECT
		PROCEDURE Procedure;
		BEGIN BEGIN {ACTIVE} END
		END Procedure;
	END Object;
	END Test.

negative: active block in active procedure body within object

	MODULE Test;
	TYPE Object = OBJECT
		PROCEDURE Procedure;
		BEGIN {ACTIVE} BEGIN {ACTIVE} END
		END Procedure;
	END Object;
	END Test.

negative: active block in exclusive procedure body within object

	MODULE Test;
	TYPE Object = OBJECT
		PROCEDURE Procedure;
		BEGIN {EXCLUSIVE} BEGIN {ACTIVE} END
		END Procedure;
	END Object;
	END Test.

negative: exclusive and active module body

	MODULE Test;
	BEGIN {EXCLUSIVE, ACTIVE}
	END Test.

negative: nested exclusive and active module body

	MODULE Test;
	BEGIN BEGIN {EXCLUSIVE, ACTIVE} END
	END Test.

negative: exclusive and active block in exclusive and active module body

	MODULE Test;
	BEGIN {EXCLUSIVE, ACTIVE} BEGIN {EXCLUSIVE, ACTIVE} END
	END Test.

positive: exclusive and active object body

	MODULE Test;
	TYPE Object = OBJECT
	BEGIN {EXCLUSIVE, ACTIVE}
	END Object;
	END Test.

negative: nested exclusive and active object body

	MODULE Test;
	TYPE Object = OBJECT
	BEGIN BEGIN {EXCLUSIVE, ACTIVE} END
	END Object;
	END Test.

negative: exclusive and active block in exclusive and active object body

	MODULE Test;
	TYPE Object = OBJECT
	BEGIN {EXCLUSIVE, ACTIVE} BEGIN {EXCLUSIVE, ACTIVE} END
	END Object;
	END Test.

negative: exclusive and active procedure body within module

	MODULE Test;
	PROCEDURE Procedure;
	BEGIN {EXCLUSIVE, ACTIVE}
	END Procedure;
	END Test.

negative: nested exclusive and active procedure body within module

	MODULE Test;
	PROCEDURE Procedure;
	BEGIN BEGIN {EXCLUSIVE, ACTIVE} END
	END Procedure;
	END Test.

negative: exclusive and active block in exclusive and active procedure body within module

	MODULE Test;
	PROCEDURE Procedure;
	BEGIN {EXCLUSIVE, ACTIVE} BEGIN {EXCLUSIVE, ACTIVE} END
	END Procedure;
	END Test.

negative: exclusive and active procedure body within object

	MODULE Test;
	TYPE Object = OBJECT
		PROCEDURE Procedure;
		BEGIN {EXCLUSIVE, ACTIVE}
		END Procedure;
	END Object;
	END Test.

negative: exclusive and active nested procedure body within object

	MODULE Test;
	TYPE Object = OBJECT
		PROCEDURE Procedure;
		BEGIN BEGIN {EXCLUSIVE, ACTIVE} END
		END Procedure;
	END Object;
	END Test.

negative: exclusive and active block in exclusive and active procedure body within object

	MODULE Test;
	TYPE Object = OBJECT
		PROCEDURE Procedure;
		BEGIN {EXCLUSIVE, ACTIVE} BEGIN {EXCLUSIVE, ACTIVE} END
		END Procedure;
	END Object;
	END Test.


# while statement

positive: while statement with true condition

	MODULE Test;
	BEGIN WHILE TRUE DO END;
	END Test.

positive: while statement with false condition

	MODULE Test;
	BEGIN WHILE FALSE DO END;
	END Test.

negative: while statement with constant condition of type character

	MODULE Test;
	BEGIN WHILE 'a' DO END;
	END Test.

negative: while statement with constant condition of type integer

	MODULE Test;
	BEGIN WHILE 5 DO END;
	END Test.

negative: while statement with constant condition of type real

	MODULE Test;
	BEGIN WHILE 4.5 DO END;
	END Test.

negative: while statement with constant condition of type set

	MODULE Test;
	BEGIN WHILE {5} DO END;
	END Test.

negative: while statement with constant condition of type string

	MODULE Test;
	BEGIN WHILE "condition" DO END;
	END Test.

negative: while statement with constant condition of type nil

	MODULE Test;
	BEGIN WHILE NIL DO END;
	END Test.

positive: while statement with condition of type boolean

	MODULE Test;
	VAR condition: BOOLEAN;
	BEGIN WHILE condition DO END;
	END Test.

negative: while statement with condition of type character

	MODULE Test;
	VAR condition: CHAR;
	BEGIN WHILE condition DO END;
	END Test.

negative: while statement with condition of type short integer

	MODULE Test;
	VAR condition: SHORTINT;
	BEGIN WHILE condition DO END;
	END Test.

negative: while statement with condition of type integer

	MODULE Test;
	VAR condition: INTEGER;
	BEGIN WHILE condition DO END;
	END Test.

negative: while statement with condition of type long integer

	MODULE Test;
	VAR condition: LONGINT;
	BEGIN WHILE condition DO END;
	END Test.

negative: while statement with condition of huge integer

	MODULE Test;
	VAR condition: HUGEINT;
	BEGIN WHILE condition DO END;
	END Test.

negative: while statement with condition of type real

	MODULE Test;
	VAR condition: REAL;
	BEGIN WHILE condition DO END;
	END Test.

negative: while statement with condition of type long real

	MODULE Test;
	VAR condition: LONGREAL;
	BEGIN WHILE condition DO END;
	END Test.

negative: while statement with condition of type set

	MODULE Test;
	VAR condition: SET;
	BEGIN WHILE condition DO END;
	END Test.

negative: while statement with condition of type array

	MODULE Test;
	VAR condition: ARRAY 10 OF CHAR;
	BEGIN WHILE condition DO END;
	END Test.

negative: while statement with condition of type record

	MODULE Test;
	VAR condition: RECORD END;
	BEGIN WHILE condition DO END;
	END Test.

negative: while statement with condition of type object

	MODULE Test;
	VAR condition: OBJECT;
	BEGIN WHILE condition DO END;
	END Test.

negative: while statement with condition of type pointer

	MODULE Test;
	VAR condition: POINTER TO RECORD END;
	BEGIN WHILE condition DO END;
	END Test.

negative: while statement with condition of type procedure

	MODULE Test;
	VAR condition: PROCEDURE;
	BEGIN WHILE condition DO END;
	END Test.

negative: while statement with condition of type import

	MODULE Test;
	IMPORT condition := A;
	BEGIN WHILE condition DO END;
	END Test.


# repeat statement

positive: repeat statement with true condition

	MODULE Test;
	BEGIN REPEAT UNTIL TRUE;
	END Test.

positive: repeat statement with false condition

	MODULE Test;
	BEGIN REPEAT UNTIL FALSE;
	END Test.

negative: repeat statement with constant condition of type character

	MODULE Test;
	BEGIN REPEAT UNTIL 'a';
	END Test.

negative: repeat statement with constant condition of type integer

	MODULE Test;
	BEGIN REPEAT UNTIL 5;
	END Test.

negative: repeat statement with constant condition of type real

	MODULE Test;
	BEGIN REPEAT UNTIL 4.5;
	END Test.

negative: repeat statement with constant condition of type set

	MODULE Test;
	BEGIN REPEAT UNTIL {5};
	END Test.

negative: repeat statement with constant condition of type string

	MODULE Test;
	BEGIN REPEAT UNTIL "condition";
	END Test.

negative: repeat statement with constant condition of type nil

	MODULE Test;
	BEGIN REPEAT UNTIL NIL;
	END Test.

positive: repeat statement with condition of type boolean

	MODULE Test;
	VAR condition: BOOLEAN;
	BEGIN REPEAT UNTIL condition;
	END Test.

negative: repeat statement with condition of type character

	MODULE Test;
	VAR condition: CHAR;
	BEGIN REPEAT UNTIL condition;
	END Test.

negative: repeat statement with condition of type short integer

	MODULE Test;
	VAR condition: SHORTINT;
	BEGIN REPEAT UNTIL condition;
	END Test.

negative: repeat statement with condition of type integer

	MODULE Test;
	VAR condition: INTEGER;
	BEGIN REPEAT UNTIL condition;
	END Test.

negative: repeat statement with condition of type long integer

	MODULE Test;
	VAR condition: LONGINT;
	BEGIN REPEAT UNTIL condition;
	END Test.

negative: repeat statement with condition of huge integer

	MODULE Test;
	VAR condition: HUGEINT;
	BEGIN REPEAT UNTIL condition;
	END Test.

negative: repeat statement with condition of type real

	MODULE Test;
	VAR condition: REAL;
	BEGIN REPEAT UNTIL condition;
	END Test.

negative: repeat statement with condition of type long real

	MODULE Test;
	VAR condition: LONGREAL;
	BEGIN REPEAT UNTIL condition;
	END Test.

negative: repeat statement with condition of type set

	MODULE Test;
	VAR condition: SET;
	BEGIN REPEAT UNTIL condition;
	END Test.

negative: repeat statement with condition of type array

	MODULE Test;
	VAR condition: ARRAY 10 OF CHAR;
	BEGIN REPEAT UNTIL condition;
	END Test.

negative: repeat statement with condition of type record

	MODULE Test;
	VAR condition: RECORD END;
	BEGIN REPEAT UNTIL condition;
	END Test.

negative: repeat statement with condition of type object

	MODULE Test;
	VAR condition: OBJECT;
	BEGIN REPEAT UNTIL condition;
	END Test.

negative: repeat statement with condition of type pointer

	MODULE Test;
	VAR condition: POINTER TO RECORD END;
	BEGIN REPEAT UNTIL condition;
	END Test.

negative: repeat statement with condition of type procedure

	MODULE Test;
	VAR condition: PROCEDURE;
	BEGIN REPEAT UNTIL condition;
	END Test.

negative: repeat statement with condition of type import

	MODULE Test;
	IMPORT condition := A;
	BEGIN REPEAT UNTIL condition;
	END Test.


# await statement

negative: await statement in non-exclusive block

	MODULE Test;
	VAR condition: BOOLEAN;
	BEGIN AWAIT (condition);
	END Test.

negative: await statement in nested non-exclusive block

	MODULE Test;
	VAR condition: BOOLEAN;
	BEGIN BEGIN AWAIT (condition) END;
	END Test.

positive: await statement in exclusive block

	MODULE Test;
	VAR condition: BOOLEAN;
	BEGIN {EXCLUSIVE} AWAIT (condition);
	END Test.

positive: await statement in nested exclusive block

	MODULE Test;
	VAR condition: BOOLEAN;
	BEGIN BEGIN {EXCLUSIVE} AWAIT (condition) END;
	END Test.

positive: await statement within nested exclusive block

	MODULE Test;
	VAR condition: BOOLEAN;
	BEGIN {EXCLUSIVE} BEGIN AWAIT (condition) END;
	END Test.

negative: await statement with true condition

	MODULE Test;
	BEGIN {EXCLUSIVE} AWAIT (TRUE);
	END Test.

negative: await statement with false condition

	MODULE Test;
	BEGIN {EXCLUSIVE} AWAIT (FALSE);
	END Test.

negative: await statement with constant condition of type character

	MODULE Test;
	BEGIN {EXCLUSIVE} AWAIT ('a');
	END Test.

negative: await statement with constant condition of type integer

	MODULE Test;
	BEGIN {EXCLUSIVE} AWAIT (5);
	END Test.

negative: await statement with constant condition of type real

	MODULE Test;
	BEGIN {EXCLUSIVE} AWAIT (4.5);
	END Test.

negative: await statement with constant condition of type set

	MODULE Test;
	BEGIN {EXCLUSIVE} AWAIT ({5});
	END Test.

negative: await statement with constant condition of type string

	MODULE Test;
	BEGIN {EXCLUSIVE} AWAIT ("condition");
	END Test.

negative: await statement with constant condition of type nil

	MODULE Test;
	BEGIN {EXCLUSIVE} AWAIT (NIL);
	END Test.

positive: await statement with condition of type boolean

	MODULE Test;
	VAR condition: BOOLEAN;
	BEGIN {EXCLUSIVE} AWAIT (condition);
	END Test.

negative: await statement with condition of type character

	MODULE Test;
	VAR condition: CHAR;
	BEGIN {EXCLUSIVE} AWAIT (condition);
	END Test.

negative: await statement with condition of type short integer

	MODULE Test;
	VAR condition: SHORTINT;
	BEGIN {EXCLUSIVE} AWAIT (condition);
	END Test.

negative: await statement with condition of type integer

	MODULE Test;
	VAR condition: INTEGER;
	BEGIN {EXCLUSIVE} AWAIT (condition);
	END Test.

negative: await statement with condition of type long integer

	MODULE Test;
	VAR condition: LONGINT;
	BEGIN {EXCLUSIVE} AWAIT (condition);
	END Test.

negative: await statement with condition of huge integer

	MODULE Test;
	VAR condition: HUGEINT;
	BEGIN {EXCLUSIVE} AWAIT (condition);
	END Test.

negative: await statement with condition of type real

	MODULE Test;
	VAR condition: REAL;
	BEGIN {EXCLUSIVE} AWAIT (condition);
	END Test.

negative: await statement with condition of type long real

	MODULE Test;
	VAR condition: LONGREAL;
	BEGIN {EXCLUSIVE} AWAIT (condition);
	END Test.

negative: await statement with condition of type set

	MODULE Test;
	VAR condition: SET;
	BEGIN {EXCLUSIVE} AWAIT (condition);
	END Test.

negative: await statement with condition of type array

	MODULE Test;
	VAR condition: ARRAY 10 OF CHAR;
	BEGIN {EXCLUSIVE} AWAIT (condition);
	END Test.

negative: await statement with condition of type record

	MODULE Test;
	VAR condition: RECORD END;
	BEGIN {EXCLUSIVE} AWAIT (condition);
	END Test.

negative: await statement with condition of type object

	MODULE Test;
	VAR condition: OBJECT;
	BEGIN {EXCLUSIVE} AWAIT (condition);
	END Test.

negative: await statement with condition of type pointer

	MODULE Test;
	VAR condition: POINTER TO RECORD END;
	BEGIN {EXCLUSIVE} AWAIT (condition);
	END Test.

negative: await statement with condition of type procedure

	MODULE Test;
	VAR condition: PROCEDURE;
	BEGIN {EXCLUSIVE} AWAIT (condition);
	END Test.

negative: await statement with condition of type import

	MODULE Test;
	IMPORT condition := A;
	BEGIN {EXCLUSIVE} AWAIT (condition);
	END Test.


# assignment statement

positive: constant boolean to variable boolean assignment

	MODULE Test;
	VAR result: BOOLEAN;
	BEGIN result := TRUE;
	END Test.

negative: constant character to variable boolean assignment

	MODULE Test;
	VAR result: BOOLEAN;
	BEGIN result := 'f';
	END Test.

negative: constant short integer to variable boolean assignment

	MODULE Test;
	VAR result: BOOLEAN;
	BEGIN result := 10H;
	END Test.

negative: constant integer to variable boolean assignment

	MODULE Test;
	VAR result: BOOLEAN;
	BEGIN result := 1000H;
	END Test.

negative: constant long integer to variable boolean assignment

	MODULE Test;
	VAR result: BOOLEAN;
	BEGIN result := 100000H;
	END Test.

negative: constant huge integer to variable boolean assignment

	MODULE Test;
	VAR result: BOOLEAN;
	BEGIN result := 10000000000H;
	END Test.

negative: constant real to variable boolean assignment

	MODULE Test;
	VAR result: BOOLEAN;
	BEGIN result := 5.4;
	END Test.

negative: constant long real to variable boolean assignment

	MODULE Test;
	VAR result: BOOLEAN;
	BEGIN result := 5.4D10;
	END Test.

negative: constant set to variable boolean assignment

	MODULE Test;
	VAR result: BOOLEAN;
	BEGIN result := {5};
	END Test.

negative: string to variable boolean assignment

	MODULE Test;
	VAR result: BOOLEAN;
	BEGIN result := "string";
	END Test.

negative: nil to variable boolean assignment

	MODULE Test;
	VAR result: BOOLEAN;
	BEGIN result := NIL;
	END Test.

negative: procedure to variable boolean assignment

	MODULE Test;
	VAR result: BOOLEAN;
	PROCEDURE Procedure; END Procedure;
	BEGIN result := Procedure;
	END Test.

negative: constant boolean to variable character assignment

	MODULE Test;
	VAR result: CHAR;
	BEGIN result := TRUE;
	END Test.

positive: constant character to variable character assignment

	MODULE Test;
	VAR result: CHAR;
	BEGIN result := 'f';
	END Test.

negative: constant short integer to variable character assignment

	MODULE Test;
	VAR result: CHAR;
	BEGIN result := 10H;
	END Test.

negative: constant integer to variable character assignment

	MODULE Test;
	VAR result: CHAR;
	BEGIN result := 1000H;
	END Test.

negative: constant long integer to variable character assignment

	MODULE Test;
	VAR result: CHAR;
	BEGIN result := 100000H;
	END Test.

negative: constant huge integer to variable character assignment

	MODULE Test;
	VAR result: CHAR;
	BEGIN result := 10000000000H;
	END Test.

negative: constant real to variable character assignment

	MODULE Test;
	VAR result: CHAR;
	BEGIN result := 5.4;
	END Test.

negative: constant long real to variable character assignment

	MODULE Test;
	VAR result: CHAR;
	BEGIN result := 5.4D10;
	END Test.

negative: constant set to variable character assignment

	MODULE Test;
	VAR result: CHAR;
	BEGIN result := {5};
	END Test.

negative: string to variable character assignment

	MODULE Test;
	VAR result: CHAR;
	BEGIN result := "string";
	END Test.

negative: nil to variable character assignment

	MODULE Test;
	VAR result: CHAR;
	BEGIN result := NIL;
	END Test.

negative: procedure to variable character assignment

	MODULE Test;
	VAR result: CHAR;
	PROCEDURE Procedure; END Procedure;
	BEGIN result := Procedure;
	END Test.

negative: constant boolean to variable short integer assignment

	MODULE Test;
	VAR result: SHORTINT;
	BEGIN result := TRUE;
	END Test.

negative: constant character to variable short integer assignment

	MODULE Test;
	VAR result: SHORTINT;
	BEGIN result := 'f';
	END Test.

positive: constant short integer to variable short integer assignment

	MODULE Test;
	VAR result: SHORTINT;
	BEGIN result := 10H;
	END Test.

negative: constant integer to variable short integer assignment

	MODULE Test;
	VAR result: SHORTINT;
	BEGIN result := 1000H;
	END Test.

negative: constant long integer to variable short integer assignment

	MODULE Test;
	VAR result: SHORTINT;
	BEGIN result := 100000H;
	END Test.

negative: constant huge integer to variable short integer assignment

	MODULE Test;
	VAR result: SHORTINT;
	BEGIN result := 10000000000H;
	END Test.

negative: constant real to variable short integer assignment

	MODULE Test;
	VAR result: SHORTINT;
	BEGIN result := 5.4;
	END Test.

negative: constant long real to variable short integer assignment

	MODULE Test;
	VAR result: SHORTINT;
	BEGIN result := 5.4D10;
	END Test.

negative: constant set to variable short integer assignment

	MODULE Test;
	VAR result: SHORTINT;
	BEGIN result := {5};
	END Test.

negative: string to variable short integer assignment

	MODULE Test;
	VAR result: SHORTINT;
	BEGIN result := "string";
	END Test.

negative: nil to variable short integer assignment

	MODULE Test;
	VAR result: SHORTINT;
	BEGIN result := NIL;
	END Test.

negative: procedure to variable short integer assignment

	MODULE Test;
	VAR result: SHORTINT;
	PROCEDURE Procedure; END Procedure;
	BEGIN result := Procedure;
	END Test.

negative: constant boolean to variable integer assignment

	MODULE Test;
	VAR result: INTEGER;
	BEGIN result := TRUE;
	END Test.

negative: constant character to variable integer assignment

	MODULE Test;
	VAR result: INTEGER;
	BEGIN result := 'f';
	END Test.

positive: constant short integer to variable integer assignment

	MODULE Test;
	VAR result: INTEGER;
	BEGIN result := 10H;
	END Test.

positive: constant integer to variable integer assignment

	MODULE Test;
	VAR result: INTEGER;
	BEGIN result := 1000H;
	END Test.

negative: constant long integer to variable integer assignment

	MODULE Test;
	VAR result: INTEGER;
	BEGIN result := 100000H;
	END Test.

negative: constant huge integer to variable integer assignment

	MODULE Test;
	VAR result: INTEGER;
	BEGIN result := 10000000000H;
	END Test.

negative: constant real to variable integer assignment

	MODULE Test;
	VAR result: INTEGER;
	BEGIN result := 5.4;
	END Test.

negative: constant long real to variable integer assignment

	MODULE Test;
	VAR result: INTEGER;
	BEGIN result := 5.4D10;
	END Test.

negative: constant set to variable integer assignment

	MODULE Test;
	VAR result: INTEGER;
	BEGIN result := {5};
	END Test.

negative: string to variable integer assignment

	MODULE Test;
	VAR result: INTEGER;
	BEGIN result := "string";
	END Test.

negative: nil to variable integer assignment

	MODULE Test;
	VAR result: INTEGER;
	BEGIN result := NIL;
	END Test.

negative: procedure to variable integer assignment

	MODULE Test;
	VAR result: INTEGER;
	PROCEDURE Procedure; END Procedure;
	BEGIN result := Procedure;
	END Test.

negative: constant boolean to variable long integer assignment

	MODULE Test;
	VAR result: LONGINT;
	BEGIN result := TRUE;
	END Test.

negative: constant character to variable long integer assignment

	MODULE Test;
	VAR result: LONGINT;
	BEGIN result := 'f';
	END Test.

positive: constant short integer to variable long integer assignment

	MODULE Test;
	VAR result: LONGINT;
	BEGIN result := 10H;
	END Test.

positive: constant integer to variable long integer assignment

	MODULE Test;
	VAR result: LONGINT;
	BEGIN result := 1000H;
	END Test.

positive: constant long integer to variable long integer assignment

	MODULE Test;
	VAR result: LONGINT;
	BEGIN result := 100000H;
	END Test.

negative: constant huge integer to variable long integer assignment

	MODULE Test;
	VAR result: LONGINT;
	BEGIN result := 10000000000H;
	END Test.

negative: constant real to variable long integer assignment

	MODULE Test;
	VAR result: LONGINT;
	BEGIN result := 5.4;
	END Test.

negative: constant long real to variable long integer assignment

	MODULE Test;
	VAR result: LONGINT;
	BEGIN result := 5.4D10;
	END Test.

negative: constant set to variable long integer assignment

	MODULE Test;
	VAR result: LONGINT;
	BEGIN result := {5};
	END Test.

negative: string to variable long integer assignment

	MODULE Test;
	VAR result: LONGINT;
	BEGIN result := "string";
	END Test.

negative: nil to variable long integer assignment

	MODULE Test;
	VAR result: LONGINT;
	BEGIN result := NIL;
	END Test.

negative: procedure to variable long integer assignment

	MODULE Test;
	VAR result: LONGINT;
	PROCEDURE Procedure; END Procedure;
	BEGIN result := Procedure;
	END Test.

negative: constant boolean to variable huge integer assignment

	MODULE Test;
	VAR result: HUGEINT;
	BEGIN result := TRUE;
	END Test.

negative: constant character to variable huge integer assignment

	MODULE Test;
	VAR result: HUGEINT;
	BEGIN result := 'f';
	END Test.

positive: constant short integer to variable huge integer assignment

	MODULE Test;
	VAR result: HUGEINT;
	BEGIN result := 10H;
	END Test.

positive: constant integer to variable huge integer assignment

	MODULE Test;
	VAR result: HUGEINT;
	BEGIN result := 1000H;
	END Test.

positive: constant long integer to variable huge integer assignment

	MODULE Test;
	VAR result: HUGEINT;
	BEGIN result := 100000H;
	END Test.

positive: constant huge integer to variable huge integer assignment

	MODULE Test;
	VAR result: HUGEINT;
	BEGIN result := 10000000000H;
	END Test.

negative: constant real to variable huge integer assignment

	MODULE Test;
	VAR result: HUGEINT;
	BEGIN result := 5.4;
	END Test.

negative: constant long real to variable huge integer assignment

	MODULE Test;
	VAR result: HUGEINT;
	BEGIN result := 5.4D10;
	END Test.

negative: constant set to variable huge integer assignment

	MODULE Test;
	VAR result: HUGEINT;
	BEGIN result := {5};
	END Test.

negative: string to variable huge integer assignment

	MODULE Test;
	VAR result: HUGEINT;
	BEGIN result := "string";
	END Test.

negative: nil to variable huge integer assignment

	MODULE Test;
	VAR result: HUGEINT;
	BEGIN result := NIL;
	END Test.

negative: procedure to variable huge integer assignment

	MODULE Test;
	VAR result: HUGEINT;
	PROCEDURE Procedure; END Procedure;
	BEGIN result := Procedure;
	END Test.

negative: constant boolean to variable real assignment

	MODULE Test;
	VAR result: REAL;
	BEGIN result := TRUE;
	END Test.

negative: constant character to variable real assignment

	MODULE Test;
	VAR result: REAL;
	BEGIN result := 'f';
	END Test.

positive: constant short integer to variable real assignment

	MODULE Test;
	VAR result: REAL;
	BEGIN result := 10H;
	END Test.

positive: constant integer to variable real assignment

	MODULE Test;
	VAR result: REAL;
	BEGIN result := 1000H;
	END Test.

positive: constant long integer to variable real assignment

	MODULE Test;
	VAR result: REAL;
	BEGIN result := 100000H;
	END Test.

positive: constant huge integer to variable real assignment

	MODULE Test;
	VAR result: REAL;
	BEGIN result := 10000000000H;
	END Test.

positive: constant real to variable real assignment

	MODULE Test;
	VAR result: REAL;
	BEGIN result := 5.4;
	END Test.

negative: constant long real to variable real assignment

	MODULE Test;
	VAR result: REAL;
	BEGIN result := 5.4D10;
	END Test.

negative: constant set to variable real assignment

	MODULE Test;
	VAR result: REAL;
	BEGIN result := {5};
	END Test.

negative: string to variable real assignment

	MODULE Test;
	VAR result: REAL;
	BEGIN result := "string";
	END Test.

negative: nil to variable real assignment

	MODULE Test;
	VAR result: REAL;
	BEGIN result := NIL;
	END Test.

negative: procedure to variable real assignment

	MODULE Test;
	VAR result: REAL;
	PROCEDURE Procedure; END Procedure;
	BEGIN result := Procedure;
	END Test.

negative: constant boolean to variable long real assignment

	MODULE Test;
	VAR result: LONGREAL;
	BEGIN result := TRUE;
	END Test.

negative: constant character to variable long real assignment

	MODULE Test;
	VAR result: LONGREAL;
	BEGIN result := 'f';
	END Test.

positive: constant short integer to variable long real assignment

	MODULE Test;
	VAR result: LONGREAL;
	BEGIN result := 10H;
	END Test.

positive: constant integer to variable long real assignment

	MODULE Test;
	VAR result: LONGREAL;
	BEGIN result := 1000H;
	END Test.

positive: constant long integer to variable long real assignment

	MODULE Test;
	VAR result: LONGREAL;
	BEGIN result := 100000H;
	END Test.

positive: constant huge integer to variable long real assignment

	MODULE Test;
	VAR result: LONGREAL;
	BEGIN result := 10000000000H;
	END Test.

positive: constant real to variable long real assignment

	MODULE Test;
	VAR result: LONGREAL;
	BEGIN result := 5.4;
	END Test.

positive: constant long real to variable long real assignment

	MODULE Test;
	VAR result: LONGREAL;
	BEGIN result := 5.4D10;
	END Test.

negative: constant set to variable long real assignment

	MODULE Test;
	VAR result: LONGREAL;
	BEGIN result := {5};
	END Test.

negative: string to variable long real assignment

	MODULE Test;
	VAR result: LONGREAL;
	BEGIN result := "string";
	END Test.

negative: nil to variable long real assignment

	MODULE Test;
	VAR result: LONGREAL;
	BEGIN result := NIL;
	END Test.

negative: procedure to variable long real assignment

	MODULE Test;
	VAR result: LONGREAL;
	PROCEDURE Procedure; END Procedure;
	BEGIN result := Procedure;
	END Test.

negative: constant boolean to variable set assignment

	MODULE Test;
	VAR result: SET;
	BEGIN result := TRUE;
	END Test.

negative: constant character to variable set assignment

	MODULE Test;
	VAR result: SET;
	BEGIN result := 'f';
	END Test.

negative: constant short integer to variable set assignment

	MODULE Test;
	VAR result: SET;
	BEGIN result := 10H;
	END Test.

negative: constant integer to variable set assignment

	MODULE Test;
	VAR result: SET;
	BEGIN result := 1000H;
	END Test.

negative: constant long integer to variable set assignment

	MODULE Test;
	VAR result: SET;
	BEGIN result := 100000H;
	END Test.

negative: constant huge integer to variable set assignment

	MODULE Test;
	VAR result: SET;
	BEGIN result := 10000000000H;
	END Test.

negative: constant real to variable set assignment

	MODULE Test;
	VAR result: SET;
	BEGIN result := 5.4;
	END Test.

negative: constant long real to variable set assignment

	MODULE Test;
	VAR result: SET;
	BEGIN result := 5.4D10;
	END Test.

positive: constant set to variable set assignment

	MODULE Test;
	VAR result: SET;
	BEGIN result := {5};
	END Test.

negative: string to variable set assignment

	MODULE Test;
	VAR result: SET;
	BEGIN result := "string";
	END Test.

negative: nil to variable set assignment

	MODULE Test;
	VAR result: SET;
	BEGIN result := NIL;
	END Test.

negative: procedure to variable set assignment

	MODULE Test;
	VAR result: SET;
	PROCEDURE Procedure; END Procedure;
	BEGIN result := Procedure;
	END Test.

negative: constant boolean to variable array assignment

	MODULE Test;
	VAR result: ARRAY 10 OF CHAR;
	BEGIN result := TRUE;
	END Test.

negative: constant character to variable array assignment

	MODULE Test;
	VAR result: ARRAY 10 OF CHAR;
	BEGIN result := 'f';
	END Test.

negative: constant short integer to variable array assignment

	MODULE Test;
	VAR result: ARRAY 10 OF CHAR;
	BEGIN result := 10H;
	END Test.

negative: constant integer to variable array assignment

	MODULE Test;
	VAR result: ARRAY 10 OF CHAR;
	BEGIN result := 1000H;
	END Test.

negative: constant long integer to variable array assignment

	MODULE Test;
	VAR result: ARRAY 10 OF CHAR;
	BEGIN result := 100000H;
	END Test.

negative: constant huge integer to variable array assignment

	MODULE Test;
	VAR result: ARRAY 10 OF CHAR;
	BEGIN result := 10000000000H;
	END Test.

negative: constant real to variable array assignment

	MODULE Test;
	VAR result: ARRAY 10 OF CHAR;
	BEGIN result := 5.4;
	END Test.

negative: constant long real to variable array assignment

	MODULE Test;
	VAR result: ARRAY 10 OF CHAR;
	BEGIN result := 5.4D10;
	END Test.

negative: constant set to variable array assignment

	MODULE Test;
	VAR result: ARRAY 10 OF CHAR;
	BEGIN result := {5};
	END Test.

negative: string to variable array of boolean assignment

	MODULE Test;
	VAR result: ARRAY 10 OF BOOLEAN;
	BEGIN result := "string";
	END Test.

positive: string to longer variable array of character assignment

	MODULE Test;
	VAR result: ARRAY 10 OF CHAR;
	BEGIN result := "string";
	END Test.

positive: string to variable array of character of equal size assignment

	MODULE Test;
	VAR result: ARRAY 7 OF CHAR;
	BEGIN result := "string";
	END Test.

negative: string to shorter variable array of character assignment

	MODULE Test;
	VAR result: ARRAY 6 OF CHAR;
	BEGIN result := "string";
	END Test.

negative: string to variable array of short integer assignment

	MODULE Test;
	VAR result: ARRAY 10 OF SHORTINT;
	BEGIN result := "string";
	END Test.

negative: string to variable array of integer assignment

	MODULE Test;
	VAR result: ARRAY 10 OF INTEGER;
	BEGIN result := "string";
	END Test.

negative: string to variable array of long integer assignment

	MODULE Test;
	VAR result: ARRAY 10 OF LONGINT;
	BEGIN result := "string";
	END Test.

negative: string to variable array of huge integer assignment

	MODULE Test;
	VAR result: ARRAY 10 OF HUGEINT;
	BEGIN result := "string";
	END Test.

negative: string to variable array of real assignment

	MODULE Test;
	VAR result: ARRAY 10 OF REAL;
	BEGIN result := "string";
	END Test.

negative: string to variable array of long real assignment

	MODULE Test;
	VAR result: ARRAY 10 OF LONGREAL;
	BEGIN result := "string";
	END Test.

negative: string to variable array of set assignment

	MODULE Test;
	VAR result: ARRAY 10 OF SET;
	BEGIN result := "string";
	END Test.

negative: string to variable array of array assignment

	MODULE Test;
	VAR result: ARRAY 10 OF ARRAY 10 OF CHAR;
	BEGIN result := "string";
	END Test.

negative: string to variable array of record assignment

	MODULE Test;
	VAR result: ARRAY 10 OF RECORD END;
	BEGIN result := "string";
	END Test.

negative: string to variable array of object assignment

	MODULE Test;
	VAR result: ARRAY 10 OF OBJECT END;
	BEGIN result := "string";
	END Test.

negative: string to variable array of pointer assignment

	MODULE Test;
	VAR result: ARRAY 10 OF POINTER TO RECORD END;
	BEGIN result := "string";
	END Test.

negative: string to variable array of procedure assignment

	MODULE Test;
	VAR result: ARRAY 10 OF PROCEDURE;
	BEGIN result := "string";
	END Test.

negative: nil to variable array assignment

	MODULE Test;
	VAR result: ARRAY 10 OF CHAR;
	BEGIN result := NIL;
	END Test.

negative: procedure to variable array assignment

	MODULE Test;
	VAR result: ARRAY 10 OF PROCEDURE;
	PROCEDURE Procedure; END Procedure;
	BEGIN result := Procedure;
	END Test.

negative: constant boolean to record assignment

	MODULE Test;
	VAR result: RECORD END;
	BEGIN result := TRUE;
	END Test.

negative: constant character to record assignment

	MODULE Test;
	VAR result: RECORD END;
	BEGIN result := 'f';
	END Test.

negative: constant short integer to record assignment

	MODULE Test;
	VAR result: RECORD END;
	BEGIN result := 10H;
	END Test.

negative: constant integer to record assignment

	MODULE Test;
	VAR result: RECORD END;
	BEGIN result := 1000H;
	END Test.

negative: constant long integer to record assignment

	MODULE Test;
	VAR result: RECORD END;
	BEGIN result := 100000H;
	END Test.

negative: constant huge integer to record assignment

	MODULE Test;
	VAR result: RECORD END;
	BEGIN result := 10000000000H;
	END Test.

negative: constant real to record assignment

	MODULE Test;
	VAR result: RECORD END;
	BEGIN result := 5.4;
	END Test.

negative: constant long real to record assignment

	MODULE Test;
	VAR result: RECORD END;
	BEGIN result := 5.4D10;
	END Test.

negative: constant set to record assignment

	MODULE Test;
	VAR result: RECORD END;
	BEGIN result := {5};
	END Test.

negative: string to record assignment

	MODULE Test;
	VAR result: RECORD END;
	BEGIN result := "string";
	END Test.

negative: nil to record assignment

	MODULE Test;
	VAR result: RECORD END;
	BEGIN result := NIL;
	END Test.

negative: procedure to record assignment

	MODULE Test;
	VAR result: RECORD END;
	PROCEDURE Procedure; END Procedure;
	BEGIN result := Procedure;
	END Test.

negative: constant boolean to object assignment

	MODULE Test;
	VAR result: OBJECT END;
	BEGIN result := TRUE;
	END Test.

negative: constant character to object assignment

	MODULE Test;
	VAR result: OBJECT END;
	BEGIN result := 'f';
	END Test.

negative: constant short integer to object assignment

	MODULE Test;
	VAR result: OBJECT END;
	BEGIN result := 10H;
	END Test.

negative: constant integer to object assignment

	MODULE Test;
	VAR result: OBJECT END;
	BEGIN result := 1000H;
	END Test.

negative: constant long integer to object assignment

	MODULE Test;
	VAR result: OBJECT END;
	BEGIN result := 100000H;
	END Test.

negative: constant huge integer to object assignment

	MODULE Test;
	VAR result: OBJECT END;
	BEGIN result := 10000000000H;
	END Test.

negative: constant real to object assignment

	MODULE Test;
	VAR result: OBJECT END;
	BEGIN result := 5.4;
	END Test.

negative: constant long real to object assignment

	MODULE Test;
	VAR result: OBJECT END;
	BEGIN result := 5.4D10;
	END Test.

negative: constant set to object assignment

	MODULE Test;
	VAR result: OBJECT END;
	BEGIN result := {5};
	END Test.

negative: string to object assignment

	MODULE Test;
	VAR result: OBJECT END;
	BEGIN result := "string";
	END Test.

positive: nil to object assignment

	MODULE Test;
	VAR result: OBJECT END;
	BEGIN result := NIL;
	END Test.

negative: procedure to object assignment

	MODULE Test;
	VAR result: OBJECT END;
	PROCEDURE Procedure; END Procedure;
	BEGIN result := Procedure;
	END Test.

negative: constant boolean to pointer assignment

	MODULE Test;
	VAR result: POINTER TO RECORD END;
	BEGIN result := TRUE;
	END Test.

negative: constant character to pointer assignment

	MODULE Test;
	VAR result: POINTER TO RECORD END;
	BEGIN result := 'f';
	END Test.

negative: constant short integer to pointer assignment

	MODULE Test;
	VAR result: POINTER TO RECORD END;
	BEGIN result := 10H;
	END Test.

negative: constant integer to pointer assignment

	MODULE Test;
	VAR result: POINTER TO RECORD END;
	BEGIN result := 1000H;
	END Test.

negative: constant long integer to pointer assignment

	MODULE Test;
	VAR result: POINTER TO RECORD END;
	BEGIN result := 100000H;
	END Test.

negative: constant huge integer to pointer assignment

	MODULE Test;
	VAR result: POINTER TO RECORD END;
	BEGIN result := 10000000000H;
	END Test.

negative: constant real to pointer assignment

	MODULE Test;
	VAR result: POINTER TO RECORD END;
	BEGIN result := 5.4;
	END Test.

negative: constant long real to pointer assignment

	MODULE Test;
	VAR result: POINTER TO RECORD END;
	BEGIN result := 5.4D10;
	END Test.

negative: constant set to pointer assignment

	MODULE Test;
	VAR result: POINTER TO RECORD END;
	BEGIN result := {5};
	END Test.

negative: string to pointer assignment

	MODULE Test;
	VAR result: POINTER TO RECORD END;
	BEGIN result := "string";
	END Test.

positive: nil to pointer assignment

	MODULE Test;
	VAR result: POINTER TO RECORD END;
	BEGIN result := NIL;
	END Test.

negative: procedure to pointer assignment

	MODULE Test;
	VAR result: POINTER TO RECORD;
	PROCEDURE Procedure; END Procedure;
	BEGIN result := Procedure;
	END Test.

negative: constant boolean to procedure assignment

	MODULE Test;
	VAR result: PROCEDURE;
	BEGIN result := TRUE;
	END Test.

negative: constant character to procedure assignment

	MODULE Test;
	VAR result: PROCEDURE;
	BEGIN result := 'f';
	END Test.

negative: constant short integer to procedure assignment

	MODULE Test;
	VAR result: PROCEDURE;
	BEGIN result := 10H;
	END Test.

negative: constant integer to procedure assignment

	MODULE Test;
	VAR result: PROCEDURE;
	BEGIN result := 1000H;
	END Test.

negative: constant long integer to procedure assignment

	MODULE Test;
	VAR result: PROCEDURE;
	BEGIN result := 100000H;
	END Test.

negative: constant huge integer to procedure assignment

	MODULE Test;
	VAR result: PROCEDURE;
	BEGIN result := 10000000000H;
	END Test.

negative: constant real to procedure assignment

	MODULE Test;
	VAR result: PROCEDURE;
	BEGIN result := 5.4;
	END Test.

negative: constant long real to procedure assignment

	MODULE Test;
	VAR result: PROCEDURE;
	BEGIN result := 5.4D10;
	END Test.

negative: constant set to procedure assignment

	MODULE Test;
	VAR result: PROCEDURE;
	BEGIN result := {5};
	END Test.

negative: string to procedure assignment

	MODULE Test;
	VAR result: PROCEDURE;
	BEGIN result := "string";
	END Test.

positive: nil to procedure assignment

	MODULE Test;
	VAR result: PROCEDURE;
	BEGIN result := NIL;
	END Test.

positive: procedure to procedure assignment

	MODULE Test;
	VAR result: PROCEDURE;
	PROCEDURE Procedure; END Procedure;
	BEGIN result := Procedure;
	END Test.

positive: procedure with one equal parameter to procedure assignment

	MODULE Test;
	VAR result: PROCEDURE (a: INTEGER);
	PROCEDURE Procedure (b: INTEGER); END Procedure;
	BEGIN result := Procedure;
	END Test.

negative: procedure with one compatible parameter to procedure assignment

	MODULE Test;
	VAR result: PROCEDURE (a: INTEGER);
	PROCEDURE Procedure (b: LONGINT); END Procedure;
	BEGIN result := Procedure;
	END Test.

negative: procedure with one incompatible parameter to procedure assignment

	MODULE Test;
	VAR result: PROCEDURE (a: SET);
	PROCEDURE Procedure (b: LONGINT); END Procedure;
	BEGIN result := Procedure;
	END Test.

negative: procedure with one equal variable parameter to procedure assignment

	MODULE Test;
	VAR result: PROCEDURE (VAR a: INTEGER);
	PROCEDURE Procedure (b: INTEGER); END Procedure;
	BEGIN result := Procedure;
	END Test.

negative: procedure with one equal constant parameter to procedure assignment

	MODULE Test;
	VAR result: PROCEDURE (CONST a: INTEGER);
	PROCEDURE Procedure (b: INTEGER); END Procedure;
	BEGIN result := Procedure;
	END Test.

positive: procedure with two equal parameters to procedure assignment

	MODULE Test;
	VAR result: PROCEDURE (a, b: INTEGER);
	PROCEDURE Procedure (c, d: INTEGER); END Procedure;
	BEGIN result := Procedure;
	END Test.

negative: procedure with two compatible parameters to procedure assignment

	MODULE Test;
	VAR result: PROCEDURE (a, b: INTEGER);
	PROCEDURE Procedure (c, d: LONGINT); END Procedure;
	BEGIN result := Procedure;
	END Test.

negative: procedure with two incompatible parameters to procedure assignment

	MODULE Test;
	VAR result: PROCEDURE (a, b: SET);
	PROCEDURE Procedure (c, d: LONGINT); END Procedure;
	BEGIN result := Procedure;
	END Test.

negative: procedure with two equal variable parameters to procedure assignment

	MODULE Test;
	VAR result: PROCEDURE (VAR a, b: INTEGER);
	PROCEDURE Procedure (c, d: INTEGER); END Procedure;
	BEGIN result := Procedure;
	END Test.

negative: procedure with two equal constant parameters to procedure assignment

	MODULE Test;
	VAR result: PROCEDURE (CONST a, b: INTEGER);
	PROCEDURE Procedure (c, d: INTEGER); END Procedure;
	BEGIN result := Procedure;
	END Test.

positive: procedure with several equal parameters to procedure assignment

	MODULE Test;
	VAR result: PROCEDURE (CONST a: SET; VAR i: INTEGER; o: OBJECT);
	PROCEDURE Procedure (CONST a: SET; VAR i: INTEGER; o: OBJECT); END Procedure;
	BEGIN result := Procedure;
	END Test.

positive: procedure with equal return type to procedure assignment

	MODULE Test;
	VAR result: PROCEDURE (): INTEGER;
	PROCEDURE Procedure (): INTEGER; BEGIN RETURN 0 END Procedure;
	BEGIN result := Procedure;
	END Test.

negative: procedure with compatible return type to procedure assignment

	MODULE Test;
	VAR result: PROCEDURE (): LONGINT;
	PROCEDURE Procedure (): INTEGER; BEGIN RETURN 0 END Procedure;
	BEGIN result := Procedure;
	END Test.

negative: procedure with incompatible return type to procedure assignment

	MODULE Test;
	VAR result: PROCEDURE (): SET;
	PROCEDURE Procedure (): INTEGER; BEGIN RETURN 0 END Procedure;
	BEGIN result := Procedure;
	END Test.

positive: procedure with several equal parameters and equal return type to procedure assignment

	MODULE Test;
	TYPE Record = RECORD END;
	VAR result: PROCEDURE (CONST a: SET; VAR i: INTEGER; o: OBJECT): POINTER TO Record;
	PROCEDURE Procedure (CONST a: SET; VAR i: INTEGER; o: OBJECT): POINTER TO Record; END Procedure;
	BEGIN result := Procedure;
	END Test.

positive: dummy module for import assignments

	MODULE A;
	END A.

negative: constant boolean to import assignment

	MODULE Test;
	IMPORT result := A;
	BEGIN result := TRUE;
	END Test.

negative: constant character to import assignment

	MODULE Test;
	IMPORT result := A;
	BEGIN result := 'f';
	END Test.

negative: constant short integer to import assignment

	MODULE Test;
	IMPORT result := A;
	BEGIN result := 10H;
	END Test.

negative: constant integer to import assignment

	MODULE Test;
	IMPORT result := A;
	BEGIN result := 1000H;
	END Test.

negative: constant long integer to import assignment

	MODULE Test;
	IMPORT result := A;
	BEGIN result := 100000H;
	END Test.

negative: constant huge integer to import assignment

	MODULE Test;
	IMPORT result := A;
	BEGIN result := 10000000000H;
	END Test.

negative: constant real to import assignment

	MODULE Test;
	IMPORT result := A;
	BEGIN result := 5.4;
	END Test.

negative: constant long real to import assignment

	MODULE Test;
	IMPORT result := A;
	BEGIN result := 5.4D10;
	END Test.

negative: constant set to import assignment

	MODULE Test;
	IMPORT result := A;
	BEGIN result := {5};
	END Test.

negative: string to import assignment

	MODULE Test;
	IMPORT result := A;
	BEGIN result := "string";
	END Test.

negative: nil to import assignment

	MODULE Test;
	IMPORT result := A;
	BEGIN result := NIL;
	END Test.

negative: procedure to import assignment

	MODULE Test;
	IMPORT result := A;
	PROCEDURE Procedure; END Procedure;
	BEGIN result := Procedure;
	END Test.

positive: variable boolean to variable boolean assignment

	MODULE Test;
	VAR variable, result: BOOLEAN;
	BEGIN result := variable;
	END Test.

negative: variable character to variable boolean assignment

	MODULE Test;
	VAR variable: CHAR; result: BOOLEAN;
	BEGIN result := variable;
	END Test.

negative: variable short integer to variable boolean assignment

	MODULE Test;
	VAR variable: SHORTINT; result: BOOLEAN;
	BEGIN result := variable;
	END Test.

negative: variable integer to variable boolean assignment

	MODULE Test;
	VAR variable: INTEGER; result: BOOLEAN;
	BEGIN result := variable;
	END Test.

negative: variable long integer to variable boolean assignment

	MODULE Test;
	VAR variable: LONGINT; result: BOOLEAN;
	BEGIN result := variable;
	END Test.

negative: variable huge integer to variable boolean assignment

	MODULE Test;
	VAR variable: HUGEINT; result: BOOLEAN;
	BEGIN result := variable;
	END Test.

negative: variable real to variable boolean assignment

	MODULE Test;
	VAR variable: REAL; result: BOOLEAN;
	BEGIN result := variable;
	END Test.

negative: variable long real to variable boolean assignment

	MODULE Test;
	VAR variable: LONGREAL; result: BOOLEAN;
	BEGIN result := variable;
	END Test.

negative: variable set to variable boolean assignment

	MODULE Test;
	VAR variable: SET; result: BOOLEAN;
	BEGIN result := variable;
	END Test.

negative: array to variable boolean assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF CHAR; result: BOOLEAN;
	BEGIN result := variable;
	END Test.

negative: record to variable boolean assignment

	MODULE Test;
	VAR variable: RECORD END; result: BOOLEAN;
	BEGIN result := variable;
	END Test.

negative: object to variable boolean assignment

	MODULE Test;
	VAR variable: OBJECT; result: BOOLEAN;
	BEGIN result := variable;
	END Test.

negative: pointer to variable boolean assignment

	MODULE Test;
	VAR variable: POINTER TO RECORD END; result: BOOLEAN;
	BEGIN result := variable;
	END Test.

negative: variable procedure to variable boolean assignment

	MODULE Test;
	VAR variable: PROCEDURE; result: BOOLEAN;
	BEGIN result := variable;
	END Test.

negative: import to variable boolean assignment

	MODULE Test;
	IMPORT variable := A; VAR result: BOOLEAN;
	BEGIN result := variable;
	END Test.

negative: variable boolean to variable character assignment

	MODULE Test;
	VAR variable: BOOLEAN; result: CHAR;
	BEGIN result := variable;
	END Test.

positive: variable character to variable character assignment

	MODULE Test;
	VAR variable, result: CHAR;
	BEGIN result := variable;
	END Test.

negative: variable short integer to variable character assignment

	MODULE Test;
	VAR variable: SHORTINT; result: CHAR;
	BEGIN result := variable;
	END Test.

negative: variable integer to variable character assignment

	MODULE Test;
	VAR variable: INTEGER; result: CHAR;
	BEGIN result := variable;
	END Test.

negative: variable long integer to variable character assignment

	MODULE Test;
	VAR variable: LONGINT; result: CHAR;
	BEGIN result := variable;
	END Test.

negative: variable huge integer to variable character assignment

	MODULE Test;
	VAR variable: HUGEINT; result: CHAR;
	BEGIN result := variable;
	END Test.

negative: variable real to variable character assignment

	MODULE Test;
	VAR variable: REAL; result: CHAR;
	BEGIN result := variable;
	END Test.

negative: variable long real to variable character assignment

	MODULE Test;
	VAR variable: LONGREAL; result: CHAR;
	BEGIN result := variable;
	END Test.

negative: variable set to variable character assignment

	MODULE Test;
	VAR variable: SET; result: CHAR;
	BEGIN result := variable;
	END Test.

negative: array to variable character assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF CHAR; result: CHAR;
	BEGIN result := variable;
	END Test.

negative: record to variable character assignment

	MODULE Test;
	VAR variable: RECORD END; result: CHAR;
	BEGIN result := variable;
	END Test.

negative: object to variable character assignment

	MODULE Test;
	VAR variable: OBJECT; result: CHAR;
	BEGIN result := variable;
	END Test.

negative: pointer to variable character assignment

	MODULE Test;
	VAR variable: POINTER TO RECORD END; result: CHAR;
	BEGIN result := variable;
	END Test.

negative: variable procedure to variable character assignment

	MODULE Test;
	VAR variable: PROCEDURE; result: CHAR;
	BEGIN result := variable;
	END Test.

negative: import to variable character assignment

	MODULE Test;
	IMPORT variable := A; VAR result: CHAR;
	BEGIN result := variable;
	END Test.

negative: variable boolean to variable short integer assignment

	MODULE Test;
	VAR variable: BOOLEAN; result: SHORTINT;
	BEGIN result := variable;
	END Test.

negative: variable character to variable short integer assignment

	MODULE Test;
	VAR variable: CHAR; result: SHORTINT;
	BEGIN result := variable;
	END Test.

positive: variable short integer to variable short integer assignment

	MODULE Test;
	VAR variable, result: SHORTINT;
	BEGIN result := variable;
	END Test.

negative: variable integer to variable short integer assignment

	MODULE Test;
	VAR variable: INTEGER; result: SHORTINT;
	BEGIN result := variable;
	END Test.

negative: variable long integer to variable short integer assignment

	MODULE Test;
	VAR variable: LONGINT; result: SHORTINT;
	BEGIN result := variable;
	END Test.

negative: variable huge integer to variable short integer assignment

	MODULE Test;
	VAR variable: HUGEINT; result: SHORTINT;
	BEGIN result := variable;
	END Test.

negative: variable real to variable short integer assignment

	MODULE Test;
	VAR variable: REAL; result: SHORTINT;
	BEGIN result := variable;
	END Test.

negative: variable long real to variable short integer assignment

	MODULE Test;
	VAR variable: LONGREAL; result: SHORTINT;
	BEGIN result := variable;
	END Test.

negative: variable set to variable short integer assignment

	MODULE Test;
	VAR variable: SET; result: SHORTINT;
	BEGIN result := variable;
	END Test.

negative: array to variable short integer assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF CHAR; result: SHORTINT;
	BEGIN result := variable;
	END Test.

negative: record to variable short integer assignment

	MODULE Test;
	VAR variable: RECORD END; result: SHORTINT;
	BEGIN result := variable;
	END Test.

negative: object to variable short integer assignment

	MODULE Test;
	VAR variable: OBJECT; result: SHORTINT;
	BEGIN result := variable;
	END Test.

negative: pointer to variable short integer assignment

	MODULE Test;
	VAR variable: POINTER TO RECORD END; result: SHORTINT;
	BEGIN result := variable;
	END Test.

negative: variable procedure to variable short integer assignment

	MODULE Test;
	VAR variable: PROCEDURE; result: SHORTINT;
	BEGIN result := variable;
	END Test.

negative: import to variable short integer assignment

	MODULE Test;
	IMPORT variable := A; VAR result: SHORTINT;
	BEGIN result := variable;
	END Test.

negative: variable boolean to variable integer assignment

	MODULE Test;
	VAR variable: BOOLEAN; result: INTEGER;
	BEGIN result := variable;
	END Test.

negative: variable character to variable integer assignment

	MODULE Test;
	VAR variable: CHAR; result: INTEGER;
	BEGIN result := variable;
	END Test.

positive: variable short integer to variable integer assignment

	MODULE Test;
	VAR variable: SHORTINT; result: INTEGER;
	BEGIN result := variable;
	END Test.

positive: variable integer to variable integer assignment

	MODULE Test;
	VAR variable, result: INTEGER;
	BEGIN result := variable;
	END Test.

negative: variable long integer to variable integer assignment

	MODULE Test;
	VAR variable: LONGINT; result: INTEGER;
	BEGIN result := variable;
	END Test.

negative: variable huge integer to variable integer assignment

	MODULE Test;
	VAR variable: HUGEINT; result: INTEGER;
	BEGIN result := variable;
	END Test.

negative: variable real to variable integer assignment

	MODULE Test;
	VAR variable: REAL; result: INTEGER;
	BEGIN result := variable;
	END Test.

negative: variable long real to variable integer assignment

	MODULE Test;
	VAR variable: LONGREAL; result: INTEGER;
	BEGIN result := variable;
	END Test.

negative: variable set to variable integer assignment

	MODULE Test;
	VAR variable: SET; result: INTEGER;
	BEGIN result := variable;
	END Test.

negative: array to variable integer assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF CHAR; result: INTEGER;
	BEGIN result := variable;
	END Test.

negative: record to variable integer assignment

	MODULE Test;
	VAR variable: RECORD END; result: INTEGER;
	BEGIN result := variable;
	END Test.

negative: object to variable integer assignment

	MODULE Test;
	VAR variable: OBJECT; result: INTEGER;
	BEGIN result := variable;
	END Test.

negative: pointer to variable integer assignment

	MODULE Test;
	VAR variable: POINTER TO RECORD END; result: INTEGER;
	BEGIN result := variable;
	END Test.

negative: variable procedure to variable integer assignment

	MODULE Test;
	VAR variable: PROCEDURE; result: INTEGER;
	BEGIN result := variable;
	END Test.

negative: import to variable integer assignment

	MODULE Test;
	IMPORT variable := A; VAR result: INTEGER;
	BEGIN result := variable;
	END Test.

negative: variable boolean to variable long integer assignment

	MODULE Test;
	VAR variable: BOOLEAN; result: LONGINT;
	BEGIN result := variable;
	END Test.

negative: variable character to variable long integer assignment

	MODULE Test;
	VAR variable: CHAR; result: LONGINT;
	BEGIN result := variable;
	END Test.

positive: variable short integer to variable long integer assignment

	MODULE Test;
	VAR variable: SHORTINT; result: LONGINT;
	BEGIN result := variable;
	END Test.

positive: variable integer to variable long integer assignment

	MODULE Test;
	VAR variable: INTEGER; result: LONGINT;
	BEGIN result := variable;
	END Test.

positive: variable long integer to variable long integer assignment

	MODULE Test;
	VAR variable, result: LONGINT;
	BEGIN result := variable;
	END Test.

negative: variable huge integer to variable long integer assignment

	MODULE Test;
	VAR variable: HUGEINT; result: LONGINT;
	BEGIN result := variable;
	END Test.

negative: variable real to variable long integer assignment

	MODULE Test;
	VAR variable: REAL; result: LONGINT;
	BEGIN result := variable;
	END Test.

negative: variable long real to variable long integer assignment

	MODULE Test;
	VAR variable: LONGREAL; result: LONGINT;
	BEGIN result := variable;
	END Test.

negative: variable set to variable long integer assignment

	MODULE Test;
	VAR variable: SET; result: LONGINT;
	BEGIN result := variable;
	END Test.

negative: array to variable long integer assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF CHAR; result: LONGINT;
	BEGIN result := variable;
	END Test.

negative: record to variable long integer assignment

	MODULE Test;
	VAR variable: RECORD END; result: LONGINT;
	BEGIN result := variable;
	END Test.

negative: object to variable long integer assignment

	MODULE Test;
	VAR variable: OBJECT; result: LONGINT;
	BEGIN result := variable;
	END Test.

negative: pointer to variable long integer assignment

	MODULE Test;
	VAR variable: POINTER TO RECORD END; result: LONGINT;
	BEGIN result := variable;
	END Test.

negative: variable procedure to variable long integer assignment

	MODULE Test;
	VAR variable: PROCEDURE; result: LONGINT;
	BEGIN result := variable;
	END Test.

negative: import to variable long integer assignment

	MODULE Test;
	IMPORT variable := A; VAR result: LONGINT;
	BEGIN result := variable;
	END Test.

negative: variable boolean to variable huge integer assignment

	MODULE Test;
	VAR variable: BOOLEAN; result: HUGEINT;
	BEGIN result := variable;
	END Test.

negative: variable character to variable huge integer assignment

	MODULE Test;
	VAR variable: CHAR; result: HUGEINT;
	BEGIN result := variable;
	END Test.

positive: variable short integer to variable huge integer assignment

	MODULE Test;
	VAR variable: SHORTINT; result: HUGEINT;
	BEGIN result := variable;
	END Test.

positive: variable integer to variable huge integer assignment

	MODULE Test;
	VAR variable: INTEGER; result: HUGEINT;
	BEGIN result := variable;
	END Test.

positive: variable long integer to variable huge integer assignment

	MODULE Test;
	VAR variable: LONGINT; result: HUGEINT;
	BEGIN result := variable;
	END Test.

positive: variable huge integer to variable huge integer assignment

	MODULE Test;
	VAR variable, result: HUGEINT;
	BEGIN result := variable;
	END Test.

negative: variable real to variable huge integer assignment

	MODULE Test;
	VAR variable: REAL; result: HUGEINT;
	BEGIN result := variable;
	END Test.

negative: variable long real to variable huge integer assignment

	MODULE Test;
	VAR variable: LONGREAL; result: HUGEINT;
	BEGIN result := variable;
	END Test.

negative: variable set to variable huge integer assignment

	MODULE Test;
	VAR variable: SET; result: HUGEINT;
	BEGIN result := variable;
	END Test.

negative: array to variable huge integer assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF CHAR; result: HUGEINT;
	BEGIN result := variable;
	END Test.

negative: record to variable huge integer assignment

	MODULE Test;
	VAR variable: RECORD END; result: HUGEINT;
	BEGIN result := variable;
	END Test.

negative: object to variable huge integer assignment

	MODULE Test;
	VAR variable: OBJECT; result: HUGEINT;
	BEGIN result := variable;
	END Test.

negative: pointer to variable huge integer assignment

	MODULE Test;
	VAR variable: POINTER TO RECORD END; result: HUGEINT;
	BEGIN result := variable;
	END Test.

negative: variable procedure to variable huge integer assignment

	MODULE Test;
	VAR variable: PROCEDURE; result: HUGEINT;
	BEGIN result := variable;
	END Test.

negative: import to variable huge integer assignment

	MODULE Test;
	IMPORT variable := A; VAR result: HUGEINT;
	BEGIN result := variable;
	END Test.

negative: variable boolean to variable real assignment

	MODULE Test;
	VAR variable: BOOLEAN; result: REAL;
	BEGIN result := variable;
	END Test.

negative: variable character to variable real assignment

	MODULE Test;
	VAR variable: CHAR; result: REAL;
	BEGIN result := variable;
	END Test.

positive: variable short integer to variable real assignment

	MODULE Test;
	VAR variable: SHORTINT; result: REAL;
	BEGIN result := variable;
	END Test.

positive: variable integer to variable real assignment

	MODULE Test;
	VAR variable: INTEGER; result: REAL;
	BEGIN result := variable;
	END Test.

positive: variable long integer to variable real assignment

	MODULE Test;
	VAR variable: LONGINT; result: REAL;
	BEGIN result := variable;
	END Test.

positive: variable huge integer to variable real assignment

	MODULE Test;
	VAR variable: HUGEINT; result: REAL;
	BEGIN result := variable;
	END Test.

positive: variable real to variable real assignment

	MODULE Test;
	VAR variable, result: REAL;
	BEGIN result := variable;
	END Test.

negative: variable long real to variable real assignment

	MODULE Test;
	VAR variable: LONGREAL; result: REAL;
	BEGIN result := variable;
	END Test.

negative: variable set to variable real assignment

	MODULE Test;
	VAR variable: SET; result: REAL;
	BEGIN result := variable;
	END Test.

negative: array to variable real assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF CHAR; result: REAL;
	BEGIN result := variable;
	END Test.

negative: record to variable real assignment

	MODULE Test;
	VAR variable: RECORD END; result: REAL;
	BEGIN result := variable;
	END Test.

negative: object to variable real assignment

	MODULE Test;
	VAR variable: OBJECT; result: REAL;
	BEGIN result := variable;
	END Test.

negative: pointer to variable real assignment

	MODULE Test;
	VAR variable: POINTER TO RECORD END; result: REAL;
	BEGIN result := variable;
	END Test.

negative: variable procedure to variable real assignment

	MODULE Test;
	VAR variable: PROCEDURE; result: REAL;
	BEGIN result := variable;
	END Test.

negative: import to variable real assignment

	MODULE Test;
	IMPORT variable := A; VAR result: REAL;
	BEGIN result := variable;
	END Test.

negative: variable boolean to variable long real assignment

	MODULE Test;
	VAR variable: BOOLEAN; result: LONGREAL;
	BEGIN result := variable;
	END Test.

negative: variable character to variable long real assignment

	MODULE Test;
	VAR variable: CHAR; result: LONGREAL;
	BEGIN result := variable;
	END Test.

positive: variable short integer to variable long real assignment

	MODULE Test;
	VAR variable: SHORTINT; result: LONGREAL;
	BEGIN result := variable;
	END Test.

positive: variable integer to variable long real assignment

	MODULE Test;
	VAR variable: INTEGER; result: LONGREAL;
	BEGIN result := variable;
	END Test.

positive: variable long integer to variable long real assignment

	MODULE Test;
	VAR variable: LONGINT; result: LONGREAL;
	BEGIN result := variable;
	END Test.

positive: variable huge integer to variable long real assignment

	MODULE Test;
	VAR variable: HUGEINT; result: LONGREAL;
	BEGIN result := variable;
	END Test.

positive: variable real to variable long real assignment

	MODULE Test;
	VAR variable: REAL; result: LONGREAL;
	BEGIN result := variable;
	END Test.

positive: variable long real to variable long real assignment

	MODULE Test;
	VAR variable, result: LONGREAL;
	BEGIN result := variable;
	END Test.

negative: variable set to variable long real assignment

	MODULE Test;
	VAR variable: SET; result: LONGREAL;
	BEGIN result := variable;
	END Test.

negative: array to variable long real assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF CHAR; result: LONGREAL;
	BEGIN result := variable;
	END Test.

negative: record to variable long real assignment

	MODULE Test;
	VAR variable: RECORD END; result: LONGREAL;
	BEGIN result := variable;
	END Test.

negative: object to variable long real assignment

	MODULE Test;
	VAR variable: OBJECT; result: LONGREAL;
	BEGIN result := variable;
	END Test.

negative: pointer to variable long real assignment

	MODULE Test;
	VAR variable: POINTER TO RECORD END; result: LONGREAL;
	BEGIN result := variable;
	END Test.

negative: variable procedure to variable long real assignment

	MODULE Test;
	VAR variable: PROCEDURE; result: LONGREAL;
	BEGIN result := variable;
	END Test.

negative: import to variable long real assignment

	MODULE Test;
	IMPORT variable := A; VAR result: LONGREAL;
	BEGIN result := variable;
	END Test.

negative: variable boolean to variable set assignment

	MODULE Test;
	VAR variable: BOOLEAN; result: SET;
	BEGIN result := variable;
	END Test.

negative: variable character to variable set assignment

	MODULE Test;
	VAR variable: CHAR; result: SET;
	BEGIN result := variable;
	END Test.

negative: variable short integer to variable set assignment

	MODULE Test;
	VAR variable: SHORTINT; result: SET;
	BEGIN result := variable;
	END Test.

negative: variable integer to variable set assignment

	MODULE Test;
	VAR variable: INTEGER; result: SET;
	BEGIN result := variable;
	END Test.

negative: variable long integer to variable set assignment

	MODULE Test;
	VAR variable: LONGINT; result: SET;
	BEGIN result := variable;
	END Test.

negative: variable huge integer to variable set assignment

	MODULE Test;
	VAR variable: HUGEINT; result: SET;
	BEGIN result := variable;
	END Test.

negative: variable real to variable set assignment

	MODULE Test;
	VAR variable: REAL; result: SET;
	BEGIN result := variable;
	END Test.

negative: variable long real to variable set assignment

	MODULE Test;
	VAR variable: LONGREAL; result: SET;
	BEGIN result := variable;
	END Test.

positive: variable set to variable set assignment

	MODULE Test;
	VAR variable, result: SET;
	BEGIN result := variable;
	END Test.

negative: array to variable set assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF CHAR; result: SET;
	BEGIN result := variable;
	END Test.

negative: record to variable set assignment

	MODULE Test;
	VAR variable: RECORD END; result: SET;
	BEGIN result := variable;
	END Test.

negative: object to variable set assignment

	MODULE Test;
	VAR variable: OBJECT; result: SET;
	BEGIN result := variable;
	END Test.

negative: pointer to variable set assignment

	MODULE Test;
	VAR variable: POINTER TO RECORD END; result: SET;
	BEGIN result := variable;
	END Test.

negative: variable procedure to variable set assignment

	MODULE Test;
	VAR variable: PROCEDURE; result: SET;
	BEGIN result := variable;
	END Test.

negative: import to variable set assignment

	MODULE Test;
	IMPORT variable := A; VAR result: SET;
	BEGIN result := variable;
	END Test.

negative: variable boolean to array assignment

	MODULE Test;
	VAR variable: BOOLEAN; result: ARRAY 10 OF CHAR;
	BEGIN result := variable;
	END Test.

negative: variable character to array assignment

	MODULE Test;
	VAR variable: CHAR; result: ARRAY 10 OF CHAR;
	BEGIN result := variable;
	END Test.

negative: variable short integer to array assignment

	MODULE Test;
	VAR variable: SHORTINT; result: ARRAY 10 OF CHAR;
	BEGIN result := variable;
	END Test.

negative: variable integer to array assignment

	MODULE Test;
	VAR variable: INTEGER; result: ARRAY 10 OF CHAR;
	BEGIN result := variable;
	END Test.

negative: variable long integer to array assignment

	MODULE Test;
	VAR variable: LONGINT; result: ARRAY 10 OF CHAR;
	BEGIN result := variable;
	END Test.

negative: variable huge integer to array assignment

	MODULE Test;
	VAR variable: HUGEINT; result: ARRAY 10 OF CHAR;
	BEGIN result := variable;
	END Test.

negative: variable real to array assignment

	MODULE Test;
	VAR variable: REAL; result: ARRAY 10 OF CHAR;
	BEGIN result := variable;
	END Test.

negative: variable long real to array assignment

	MODULE Test;
	VAR variable: LONGREAL; result: ARRAY 10 OF CHAR;
	BEGIN result := variable;
	END Test.

negative: variable set to array assignment

	MODULE Test;
	VAR variable: SET; result: ARRAY 10 OF CHAR;
	BEGIN result := variable;
	END Test.

positive: array of boolean to array of boolean assignment

	MODULE Test;
	VAR variable, result: ARRAY 10 OF BOOLEAN;
	BEGIN result := variable;
	END Test.

positive: array of boolean to longer array of boolean assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF BOOLEAN; result: ARRAY 20 OF BOOLEAN;
	BEGIN result := variable;
	END Test.

negative: array of boolean to shorter array of boolean assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF BOOLEAN; result: ARRAY 5 OF BOOLEAN;
	BEGIN result := variable;
	END Test.

positive: array of boolean to open array of boolean assignment

	MODULE Test;
	PROCEDURE Procedure (VAR result: ARRAY OF BOOLEAN);
	VAR variable: ARRAY 10 OF BOOLEAN;
	BEGIN result := variable;
	END Procedure;
	END Test.

negative: array of character to array of boolean assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF CHAR; result: ARRAY 10 OF BOOLEAN;
	BEGIN result := variable;
	END Test.

negative: array of short integer to array of boolean assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF SHORTINT; result: ARRAY 10 OF BOOLEAN;
	BEGIN result := variable;
	END Test.

negative: array of integer to array of boolean assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF INTEGER; result: ARRAY 10 OF BOOLEAN;
	BEGIN result := variable;
	END Test.

negative: array of long integer to array of boolean assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF LONGINT; result: ARRAY 10 OF BOOLEAN;
	BEGIN result := variable;
	END Test.

negative: array of huge integer to array of boolean assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF HUGEINT; result: ARRAY 10 OF BOOLEAN;
	BEGIN result := variable;
	END Test.

negative: array of real to array of boolean assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF REAL; result: ARRAY 10 OF BOOLEAN;
	BEGIN result := variable;
	END Test.

negative: array of long real to array of boolean assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF LONGREAL; result: ARRAY 10 OF BOOLEAN;
	BEGIN result := variable;
	END Test.

negative: array of set to array of boolean assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF SET; result: ARRAY 10 OF BOOLEAN;
	BEGIN result := variable;
	END Test.

negative: array of array to array of boolean assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF ARRAY 10 OF SET; result: ARRAY 10 OF BOOLEAN;
	BEGIN result := variable;
	END Test.

negative: array of record to array of boolean assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF RECORD END; result: ARRAY 10 OF BOOLEAN;
	BEGIN result := variable;
	END Test.

negative: array of object to array of boolean assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF OBJECT; result: ARRAY 10 OF BOOLEAN;
	BEGIN result := variable;
	END Test.

negative: array of pointer to array of boolean assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF POINTER TO RECORD END; result: ARRAY 10 OF BOOLEAN;
	BEGIN result := variable;
	END Test.

negative: array of procedure to array of boolean assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF PROCEDURE; result: ARRAY 10 OF BOOLEAN;
	BEGIN result := variable;
	END Test.

negative: array of boolean to array of character assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF BOOLEAN; result: ARRAY 10 OF CHAR;
	BEGIN result := variable;
	END Test.

positive: array of character to array of character assignment

	MODULE Test;
	VAR variable, result: ARRAY 10 OF CHAR;
	BEGIN result := variable;
	END Test.

positive: array of character to longer array of character assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF CHAR; result: ARRAY 20 OF CHAR;
	BEGIN result := variable;
	END Test.

negative: array of character to shorter array of character assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF CHAR; result: ARRAY 5 OF CHAR;
	BEGIN result := variable;
	END Test.

positive: array of character to open array of character assignment

	MODULE Test;
	PROCEDURE Procedure (VAR result: ARRAY OF CHAR);
	VAR variable: ARRAY 10 OF CHAR;
	BEGIN result := variable;
	END Procedure;
	END Test.

negative: array of short integer to array of character assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF SHORTINT; result: ARRAY 10 OF CHAR;
	BEGIN result := variable;
	END Test.

negative: array of integer to array of character assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF INTEGER; result: ARRAY 10 OF CHAR;
	BEGIN result := variable;
	END Test.

negative: array of long integer to array of character assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF LONGINT; result: ARRAY 10 OF CHAR;
	BEGIN result := variable;
	END Test.

negative: array of huge integer to array of character assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF HUGEINT; result: ARRAY 10 OF CHAR;
	BEGIN result := variable;
	END Test.

negative: array of real to array of character assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF REAL; result: ARRAY 10 OF CHAR;
	BEGIN result := variable;
	END Test.

negative: array of long real to array of character assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF LONGREAL; result: ARRAY 10 OF CHAR;
	BEGIN result := variable;
	END Test.

negative: array of set to array of character assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF SET; result: ARRAY 10 OF CHAR;
	BEGIN result := variable;
	END Test.

negative: array of array to array of character assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF ARRAY 10 OF SET; result: ARRAY 10 OF CHAR;
	BEGIN result := variable;
	END Test.

negative: array of record to array of character assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF RECORD END; result: ARRAY 10 OF CHAR;
	BEGIN result := variable;
	END Test.

negative: array of object to array of character assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF OBJECT; result: ARRAY 10 OF CHAR;
	BEGIN result := variable;
	END Test.

negative: array of pointer to array of character assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF POINTER TO RECORD END; result: ARRAY 10 OF CHAR;
	BEGIN result := variable;
	END Test.

negative: array of procedure to array of character assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF PROCEDURE; result: ARRAY 10 OF CHAR;
	BEGIN result := variable;
	END Test.

negative: array of boolean to array of short integer assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF BOOLEAN; result: ARRAY 10 OF SHORTINT;
	BEGIN result := variable;
	END Test.

negative: array of character to array of short integer assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF CHAR; result: ARRAY 10 OF SHORTINT;
	BEGIN result := variable;
	END Test.

positive: array of short integer to array of short integer assignment

	MODULE Test;
	VAR variable, result: ARRAY 10 OF SHORTINT;
	BEGIN result := variable;
	END Test.

positive: array of short integer to longer array of short integer assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF SHORTINT; result: ARRAY 20 OF SHORTINT;
	BEGIN result := variable;
	END Test.

negative: array of short integer to shorter array of short integer assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF SHORTINT; result: ARRAY 5 OF SHORTINT;
	BEGIN result := variable;
	END Test.

positive: array of short integer to open array of short integer assignment

	MODULE Test;
	PROCEDURE Procedure (VAR result: ARRAY OF SHORTINT);
	VAR variable: ARRAY 10 OF SHORTINT;
	BEGIN result := variable;
	END Procedure;
	END Test.

negative: array of integer to array of short integer assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF INTEGER; result: ARRAY 10 OF SHORTINT;
	BEGIN result := variable;
	END Test.

negative: array of long integer to array of short integer assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF LONGINT; result: ARRAY 10 OF SHORTINT;
	BEGIN result := variable;
	END Test.

negative: array of huge integer to array of short integer assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF HUGEINT; result: ARRAY 10 OF SHORTINT;
	BEGIN result := variable;
	END Test.

negative: array of real to array of short integer assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF REAL; result: ARRAY 10 OF SHORTINT;
	BEGIN result := variable;
	END Test.

negative: array of long real to array of short integer assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF LONGREAL; result: ARRAY 10 OF SHORTINT;
	BEGIN result := variable;
	END Test.

negative: array of set to array of short integer assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF SET; result: ARRAY 10 OF SHORTINT;
	BEGIN result := variable;
	END Test.

negative: array of array to array of short integer assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF ARRAY 10 OF SET; result: ARRAY 10 OF SHORTINT;
	BEGIN result := variable;
	END Test.

negative: array of record to array of short integer assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF RECORD END; result: ARRAY 10 OF SHORTINT;
	BEGIN result := variable;
	END Test.

negative: array of object to array of short integer assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF OBJECT; result: ARRAY 10 OF SHORTINT;
	BEGIN result := variable;
	END Test.

negative: array of pointer to array of short integer assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF POINTER TO RECORD END; result: ARRAY 10 OF SHORTINT;
	BEGIN result := variable;
	END Test.

negative: array of procedure to array of short integer assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF PROCEDURE; result: ARRAY 10 OF SHORTINT;
	BEGIN result := variable;
	END Test.

negative: array of boolean to array of integer assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF BOOLEAN; result: ARRAY 10 OF INTEGER;
	BEGIN result := variable;
	END Test.

negative: array of character to array of integer assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF CHAR; result: ARRAY 10 OF INTEGER;
	BEGIN result := variable;
	END Test.

negative: array of short integer to array of integer assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF SHORTINT; result: ARRAY 10 OF INTEGER;
	BEGIN result := variable;
	END Test.

positive: array of integer to array of integer assignment

	MODULE Test;
	VAR variable, result: ARRAY 10 OF INTEGER;
	BEGIN result := variable;
	END Test.

positive: array of integer to longer array of integer assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF INTEGER; result: ARRAY 20 OF INTEGER;
	BEGIN result := variable;
	END Test.

negative: array of integer to shorter array of integer assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF INTEGER; result: ARRAY 5 OF INTEGER;
	BEGIN result := variable;
	END Test.

positive: array of integer to open array of integer assignment

	MODULE Test;
	PROCEDURE Procedure (VAR result: ARRAY OF INTEGER);
	VAR variable: ARRAY 10 OF INTEGER;
	BEGIN result := variable;
	END Procedure;
	END Test.

negative: array of long integer to array of integer assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF LONGINT; result: ARRAY 10 OF INTEGER;
	BEGIN result := variable;
	END Test.

negative: array of huge integer to array of integer assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF HUGEINT; result: ARRAY 10 OF INTEGER;
	BEGIN result := variable;
	END Test.

negative: array of real to array of integer assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF REAL; result: ARRAY 10 OF INTEGER;
	BEGIN result := variable;
	END Test.

negative: array of long real to array of integer assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF LONGREAL; result: ARRAY 10 OF INTEGER;
	BEGIN result := variable;
	END Test.

negative: array of set to array of integer assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF SET; result: ARRAY 10 OF INTEGER;
	BEGIN result := variable;
	END Test.

negative: array of array to array of integer assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF ARRAY 10 OF SET; result: ARRAY 10 OF INTEGER;
	BEGIN result := variable;
	END Test.

negative: array of record to array of integer assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF RECORD END; result: ARRAY 10 OF INTEGER;
	BEGIN result := variable;
	END Test.

negative: array of object to array of integer assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF OBJECT; result: ARRAY 10 OF INTEGER;
	BEGIN result := variable;
	END Test.

negative: array of pointer to array of integer assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF POINTER TO RECORD END; result: ARRAY 10 OF INTEGER;
	BEGIN result := variable;
	END Test.

negative: array of procedure to array of integer assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF PROCEDURE; result: ARRAY 10 OF INTEGER;
	BEGIN result := variable;
	END Test.

negative: array of boolean to array of long integer assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF BOOLEAN; result: ARRAY 10 OF LONGINT;
	BEGIN result := variable;
	END Test.

negative: array of character to array of long integer assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF CHAR; result: ARRAY 10 OF LONGINT;
	BEGIN result := variable;
	END Test.

negative: array of short integer to array of long integer assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF SHORTINT; result: ARRAY 10 OF LONGINT;
	BEGIN result := variable;
	END Test.

negative: array of integer to array of long integer assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF INTEGER; result: ARRAY 10 OF LONGINT;
	BEGIN result := variable;
	END Test.

positive: array of long integer to array of long integer assignment

	MODULE Test;
	VAR variable, result: ARRAY 10 OF LONGINT;
	BEGIN result := variable;
	END Test.

positive: array of long integer to longer array of long integer assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF LONGINT; result: ARRAY 20 OF LONGINT;
	BEGIN result := variable;
	END Test.

negative: array of long integer to shorter array of long integer assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF LONGINT; result: ARRAY 5 OF LONGINT;
	BEGIN result := variable;
	END Test.

positive: array of long integer to open array of long integer assignment

	MODULE Test;
	PROCEDURE Procedure (VAR result: ARRAY OF LONGINT);
	VAR variable: ARRAY 10 OF LONGINT;
	BEGIN result := variable;
	END Procedure;
	END Test.

negative: array of huge integer to array of long integer assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF HUGEINT; result: ARRAY 10 OF LONGINT;
	BEGIN result := variable;
	END Test.

negative: array of real to array of long integer assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF REAL; result: ARRAY 10 OF LONGINT;
	BEGIN result := variable;
	END Test.

negative: array of long real to array of long integer assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF LONGREAL; result: ARRAY 10 OF LONGINT;
	BEGIN result := variable;
	END Test.

negative: array of set to array of long integer assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF SET; result: ARRAY 10 OF LONGINT;
	BEGIN result := variable;
	END Test.

negative: array of array to array of long integer assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF ARRAY 10 OF SET; result: ARRAY 10 OF LONGINT;
	BEGIN result := variable;
	END Test.

negative: array of record to array of long integer assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF RECORD END; result: ARRAY 10 OF LONGINT;
	BEGIN result := variable;
	END Test.

negative: array of object to array of long integer assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF OBJECT; result: ARRAY 10 OF LONGINT;
	BEGIN result := variable;
	END Test.

negative: array of pointer to array of long integer assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF POINTER TO RECORD END; result: ARRAY 10 OF LONGINT;
	BEGIN result := variable;
	END Test.

negative: array of procedure to array of long integer assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF PROCEDURE; result: ARRAY 10 OF LONGINT;
	BEGIN result := variable;
	END Test.

negative: array of boolean to array of huge integer assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF BOOLEAN; result: ARRAY 10 OF HUGEINT;
	BEGIN result := variable;
	END Test.

negative: array of character to array of huge integer assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF CHAR; result: ARRAY 10 OF HUGEINT;
	BEGIN result := variable;
	END Test.

negative: array of short integer to array of huge integer assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF SHORTINT; result: ARRAY 10 OF HUGEINT;
	BEGIN result := variable;
	END Test.

negative: array of integer to array of huge integer assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF INTEGER; result: ARRAY 10 OF HUGEINT;
	BEGIN result := variable;
	END Test.

negative: array of long integer to array of huge integer assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF LONGINT; result: ARRAY 10 OF HUGEINT;
	BEGIN result := variable;
	END Test.

positive: array of huge integer to array of huge integer assignment

	MODULE Test;
	VAR variable, result: ARRAY 10 OF HUGEINT;
	BEGIN result := variable;
	END Test.

positive: array of huge integer to longer array of huge integer assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF HUGEINT; result: ARRAY 20 OF HUGEINT;
	BEGIN result := variable;
	END Test.

negative: array of huge integer to shorter array of huge integer assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF HUGEINT; result: ARRAY 5 OF HUGEINT;
	BEGIN result := variable;
	END Test.

positive: array of huge integer to open array of huge integer assignment

	MODULE Test;
	PROCEDURE Procedure (VAR result: ARRAY OF HUGEINT);
	VAR variable: ARRAY 10 OF HUGEINT;
	BEGIN result := variable;
	END Procedure;
	END Test.

negative: array of real to array of huge integer assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF REAL; result: ARRAY 10 OF HUGEINT;
	BEGIN result := variable;
	END Test.

negative: array of long real to array of huge integer assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF LONGREAL; result: ARRAY 10 OF HUGEINT;
	BEGIN result := variable;
	END Test.

negative: array of set to array of huge integer assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF SET; result: ARRAY 10 OF HUGEINT;
	BEGIN result := variable;
	END Test.

negative: array of array to array of huge integer assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF ARRAY 10 OF SET; result: ARRAY 10 OF HUGEINT;
	BEGIN result := variable;
	END Test.

negative: array of record to array of huge integer assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF RECORD END; result: ARRAY 10 OF HUGEINT;
	BEGIN result := variable;
	END Test.

negative: array of object to array of huge integer assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF OBJECT; result: ARRAY 10 OF HUGEINT;
	BEGIN result := variable;
	END Test.

negative: array of pointer to array of huge integer assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF POINTER TO RECORD END; result: ARRAY 10 OF HUGEINT;
	BEGIN result := variable;
	END Test.

negative: array of procedure to array of huge integer assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF PROCEDURE; result: ARRAY 10 OF HUGEINT;
	BEGIN result := variable;
	END Test.

negative: array of boolean to array of real assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF BOOLEAN; result: ARRAY 10 OF REAL;
	BEGIN result := variable;
	END Test.

negative: array of character to array of real assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF CHAR; result: ARRAY 10 OF REAL;
	BEGIN result := variable;
	END Test.

negative: array of short integer to array of real assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF SHORTINT; result: ARRAY 10 OF REAL;
	BEGIN result := variable;
	END Test.

negative: array of integer to array of real assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF INTEGER; result: ARRAY 10 OF REAL;
	BEGIN result := variable;
	END Test.

negative: array of long integer to array of real assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF LONGINT; result: ARRAY 10 OF REAL;
	BEGIN result := variable;
	END Test.

negative: array of huge integer to array of real assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF HUGEINT; result: ARRAY 10 OF REAL;
	BEGIN result := variable;
	END Test.

positive: array of real to array of real assignment

	MODULE Test;
	VAR variable, result: ARRAY 10 OF REAL;
	BEGIN result := variable;
	END Test.

positive: array of real to longer array of real assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF REAL; result: ARRAY 20 OF REAL;
	BEGIN result := variable;
	END Test.

negative: array of real to shorter array of real assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF REAL; result: ARRAY 5 OF REAL;
	BEGIN result := variable;
	END Test.

positive: array of real to open array of real assignment

	MODULE Test;
	PROCEDURE Procedure (VAR result: ARRAY OF REAL);
	VAR variable: ARRAY 10 OF REAL;
	BEGIN result := variable;
	END Procedure;
	END Test.

negative: array of long real to array of real assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF LONGREAL; result: ARRAY 10 OF REAL;
	BEGIN result := variable;
	END Test.

negative: array of set to array of real assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF SET; result: ARRAY 10 OF REAL;
	BEGIN result := variable;
	END Test.

negative: array of array to array of real assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF ARRAY 10 OF SET; result: ARRAY 10 OF REAL;
	BEGIN result := variable;
	END Test.

negative: array of record to array of real assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF RECORD END; result: ARRAY 10 OF REAL;
	BEGIN result := variable;
	END Test.

negative: array of object to array of real assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF OBJECT; result: ARRAY 10 OF REAL;
	BEGIN result := variable;
	END Test.

negative: array of pointer to array of real assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF POINTER TO RECORD END; result: ARRAY 10 OF REAL;
	BEGIN result := variable;
	END Test.

negative: array of procedure to array of real assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF PROCEDURE; result: ARRAY 10 OF REAL;
	BEGIN result := variable;
	END Test.

negative: array of boolean to array of long real assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF BOOLEAN; result: ARRAY 10 OF LONGREAL;
	BEGIN result := variable;
	END Test.

negative: array of character to array of long real assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF CHAR; result: ARRAY 10 OF LONGREAL;
	BEGIN result := variable;
	END Test.

negative: array of short integer to array of long real assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF SHORTINT; result: ARRAY 10 OF LONGREAL;
	BEGIN result := variable;
	END Test.

negative: array of integer to array of long real assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF INTEGER; result: ARRAY 10 OF LONGREAL;
	BEGIN result := variable;
	END Test.

negative: array of long integer to array of long real assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF LONGINT; result: ARRAY 10 OF LONGREAL;
	BEGIN result := variable;
	END Test.

negative: array of huge integer to array of long real assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF HUGEINT; result: ARRAY 10 OF LONGREAL;
	BEGIN result := variable;
	END Test.

negative: array of real to array of long real assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF REAL; result: ARRAY 10 OF LONGREAL;
	BEGIN result := variable;
	END Test.

positive: array of long real to array of long real assignment

	MODULE Test;
	VAR variable, result: ARRAY 10 OF LONGREAL;
	BEGIN result := variable;
	END Test.

positive: array of long real to longer array of long real assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF LONGREAL; result: ARRAY 20 OF LONGREAL;
	BEGIN result := variable;
	END Test.

negative: array of long real to shorter array of long real assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF LONGREAL; result: ARRAY 5 OF LONGREAL;
	BEGIN result := variable;
	END Test.

positive: array of long real to open array of long real assignment

	MODULE Test;
	PROCEDURE Procedure (VAR result: ARRAY OF LONGREAL);
	VAR variable: ARRAY 10 OF LONGREAL;
	BEGIN result := variable;
	END Procedure;
	END Test.

negative: array of set to array of long real assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF SET; result: ARRAY 10 OF LONGREAL;
	BEGIN result := variable;
	END Test.

negative: array of array to array of long real assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF ARRAY 10 OF SET; result: ARRAY 10 OF LONGREAL;
	BEGIN result := variable;
	END Test.

negative: array of record to array of long real assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF RECORD END; result: ARRAY 10 OF LONGREAL;
	BEGIN result := variable;
	END Test.

negative: array of object to array of long real assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF OBJECT; result: ARRAY 10 OF LONGREAL;
	BEGIN result := variable;
	END Test.

negative: array of pointer to array of long real assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF POINTER TO RECORD END; result: ARRAY 10 OF LONGREAL;
	BEGIN result := variable;
	END Test.

negative: array of procedure to array of long real assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF PROCEDURE; result: ARRAY 10 OF LONGREAL;
	BEGIN result := variable;
	END Test.

negative: array of boolean to array of set assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF BOOLEAN; result: ARRAY 10 OF SET;
	BEGIN result := variable;
	END Test.

negative: array of character to array of set assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF CHAR; result: ARRAY 10 OF SET;
	BEGIN result := variable;
	END Test.

negative: array of short integer to array of set assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF SHORTINT; result: ARRAY 10 OF SET;
	BEGIN result := variable;
	END Test.

negative: array of integer to array of set assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF INTEGER; result: ARRAY 10 OF SET;
	BEGIN result := variable;
	END Test.

negative: array of long integer to array of set assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF LONGINT; result: ARRAY 10 OF SET;
	BEGIN result := variable;
	END Test.

negative: array of huge integer to array of set assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF HUGEINT; result: ARRAY 10 OF SET;
	BEGIN result := variable;
	END Test.

negative: array of real to array of set assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF REAL; result: ARRAY 10 OF SET;
	BEGIN result := variable;
	END Test.

negative: array of long real to array of set assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF LONGREAL; result: ARRAY 10 OF SET;
	BEGIN result := variable;
	END Test.

positive: array of set to array of set assignment

	MODULE Test;
	VAR variable, result: ARRAY 10 OF SET;
	BEGIN result := variable;
	END Test.

positive: array of set to longer array of set assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF SET; result: ARRAY 20 OF SET;
	BEGIN result := variable;
	END Test.

negative: array of set to shorter array of set assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF SET; result: ARRAY 5 OF SET;
	BEGIN result := variable;
	END Test.

positive: array of set to open array of set assignment

	MODULE Test;
	PROCEDURE Procedure (VAR result: ARRAY OF SET);
	VAR variable: ARRAY 10 OF SET;
	BEGIN result := variable;
	END Procedure;
	END Test.

negative: array of array to array of set assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF ARRAY 10 OF BOOLEAN; result: ARRAY 10 OF SET;
	BEGIN result := variable;
	END Test.

negative: array of record to array of set assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF RECORD END; result: ARRAY 10 OF SET;
	BEGIN result := variable;
	END Test.

negative: array of object to array of set assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF OBJECT; result: ARRAY 10 OF SET;
	BEGIN result := variable;
	END Test.

negative: array of pointer to array of set assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF POINTER TO RECORD END; result: ARRAY 10 OF SET;
	BEGIN result := variable;
	END Test.

negative: array of procedure to array of set assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF PROCEDURE; result: ARRAY 10 OF SET;
	BEGIN result := variable;
	END Test.

negative: array of boolean to array of array assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF BOOLEAN; result: ARRAY 10 OF ARRAY 10 OF SET;
	BEGIN result := variable;
	END Test.

negative: array of character to array of array assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF CHAR; result: ARRAY 10 OF ARRAY 10 OF SET;
	BEGIN result := variable;
	END Test.

negative: array of short integer to array of array assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF SHORTINT; result: ARRAY 10 OF ARRAY 10 OF SET;
	BEGIN result := variable;
	END Test.

negative: array of integer to array of array assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF INTEGER; result: ARRAY 10 OF ARRAY 10 OF SET;
	BEGIN result := variable;
	END Test.

negative: array of long integer to array of array assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF LONGINT; result: ARRAY 10 OF ARRAY 10 OF SET;
	BEGIN result := variable;
	END Test.

negative: array of huge integer to array of array assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF HUGEINT; result: ARRAY 10 OF ARRAY 10 OF SET;
	BEGIN result := variable;
	END Test.

negative: array of real to array of array assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF REAL; result: ARRAY 10 OF ARRAY 10 OF SET;
	BEGIN result := variable;
	END Test.

negative: array of long real to array of array assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF LONGREAL; result: ARRAY 10 OF ARRAY 10 OF SET;
	BEGIN result := variable;
	END Test.

negative: array of set of array assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF SET; result: ARRAY 10 OF ARRAY 10 OF SET;
	BEGIN result := variable;
	END Test.

positive: array of array to array of array assignment

	MODULE Test;
	VAR variable, result: ARRAY 10 OF ARRAY 10 OF SET;
	BEGIN result := variable;
	END Test.

positive: array of array to longer array of array assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF ARRAY 10 OF SET; result: ARRAY 20 OF ARRAY 10 OF SET;
	BEGIN result := variable;
	END Test.

negative: array of array to shorter array of array assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF ARRAY 10 OF SET; result: ARRAY 5 OF ARRAY 10 OF SET;
	BEGIN result := variable;
	END Test.

positive: array of array to open array of array assignment

	MODULE Test;
	PROCEDURE Procedure (VAR result: ARRAY OF ARRAY 10 OF SET);
	VAR variable: ARRAY 10 OF ARRAY 10 OF SET;
	BEGIN result := variable;
	END Procedure;
	END Test.

negative: array of record to array of array assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF RECORD END; result: ARRAY 10 OF ARRAY 10 OF SET;
	BEGIN result := variable;
	END Test.

negative: array of object to array of array assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF OBJECT; result: ARRAY 10 OF ARRAY 10 OF SET;
	BEGIN result := variable;
	END Test.

negative: array of pointer to array of array assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF POINTER TO RECORD END; result: ARRAY 10 OF ARRAY 10 OF SET;
	BEGIN result := variable;
	END Test.

negative: array of procedure to array of array assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF PROCEDURE; result: ARRAY 10 OF ARRAY 10 OF SET;
	BEGIN result := variable;
	END Test.

negative: array of boolean to array of record assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF BOOLEAN; result: ARRAY 10 OF RECORD END;
	BEGIN result := variable;
	END Test.

negative: array of character to array of record assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF CHAR; result: ARRAY 10 OF RECORD END;
	BEGIN result := variable;
	END Test.

negative: array of short integer to array of record assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF SHORTINT; result: ARRAY 10 OF RECORD END;
	BEGIN result := variable;
	END Test.

negative: array of integer to array of record assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF INTEGER; result: ARRAY 10 OF RECORD END;
	BEGIN result := variable;
	END Test.

negative: array of long integer to array of record assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF LONGINT; result: ARRAY 10 OF RECORD END;
	BEGIN result := variable;
	END Test.

negative: array of huge integer to array of record assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF HUGEINT; result: ARRAY 10 OF RECORD END;
	BEGIN result := variable;
	END Test.

negative: array of real to array of record assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF REAL; result: ARRAY 10 OF RECORD END;
	BEGIN result := variable;
	END Test.

negative: array of long real to array of record assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF LONGREAL; result: ARRAY 10 OF RECORD END;
	BEGIN result := variable;
	END Test.

negative: array of set to array of record assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF SET; result: ARRAY 10 OF RECORD END;
	BEGIN result := variable;
	END Test.

negative: array of array to array of record assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF ARRAY 10 OF SET; result: ARRAY 10 OF RECORD END;
	BEGIN result := variable;
	END Test.

positive: array of record to array of record assignment

	MODULE Test;
	VAR variable, result: ARRAY 10 OF RECORD END;
	BEGIN result := variable;
	END Test.

positive: array of record to longer array of record assignment

	MODULE Test;
	TYPE Record = RECORD END;
	VAR variable: ARRAY 10 OF Record; result: ARRAY 20 OF Record;
	BEGIN result := variable;
	END Test.

negative: array of record to shorter array of record assignment

	MODULE Test;
	TYPE Record = RECORD END;
	VAR variable: ARRAY 10 OF Record; result: ARRAY 5 OF Record;
	BEGIN result := variable;
	END Test.

positive: array of record to open array of record assignment

	MODULE Test;
	TYPE Record = RECORD END;
	PROCEDURE Procedure (VAR result: ARRAY OF Record);
	VAR variable: ARRAY 10 OF Record;
	BEGIN result := variable;
	END Procedure;
	END Test.

negative: array of object to array of record assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF OBJECT; result: ARRAY 10 OF RECORD END;
	BEGIN result := variable;
	END Test.

negative: array of pointer to array of record assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF POINTER TO RECORD END; result: ARRAY 10 OF RECORD END;
	BEGIN result := variable;
	END Test.

negative: array of procedure to array of record assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF PROCEDURE; result: ARRAY 10 OF RECORD END;
	BEGIN result := variable;
	END Test.

negative: array of boolean to array of object assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF BOOLEAN; result: ARRAY 10 OF OBJECT END;
	BEGIN result := variable;
	END Test.

negative: array of character to array of object assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF CHAR; result: ARRAY 10 OF OBJECT END;
	BEGIN result := variable;
	END Test.

negative: array of short integer to array of object assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF SHORTINT; result: ARRAY 10 OF OBJECT END;
	BEGIN result := variable;
	END Test.

negative: array of integer to array of object assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF INTEGER; result: ARRAY 10 OF OBJECT END;
	BEGIN result := variable;
	END Test.

negative: array of long integer to array of object assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF LONGINT; result: ARRAY 10 OF OBJECT END;
	BEGIN result := variable;
	END Test.

negative: array of huge integer to array of object assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF HUGEINT; result: ARRAY 10 OF OBJECT END;
	BEGIN result := variable;
	END Test.

negative: array of real to array of object assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF REAL; result: ARRAY 10 OF OBJECT END;
	BEGIN result := variable;
	END Test.

negative: array of long real to array of object assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF LONGREAL; result: ARRAY 10 OF OBJECT END;
	BEGIN result := variable;
	END Test.

negative: array of set to array of object assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF SET; result: ARRAY 10 OF OBJECT END;
	BEGIN result := variable;
	END Test.

negative: array of array to array of object assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF ARRAY 10 OF SET; result: ARRAY 10 OF OBJECT END;
	BEGIN result := variable;
	END Test.

negative: array of record to array of object assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF RECORD END; result: ARRAY 10 OF OBJECT END;
	BEGIN result := variable;
	END Test.

positive: array of object to array of object assignment

	MODULE Test;
	VAR variable, result: ARRAY 10 OF OBJECT END;
	BEGIN result := variable;
	END Test.

positive: array of object to longer array of object assignment

	MODULE Test;
	TYPE Object = OBJECT END Object;
	VAR variable: ARRAY 10 OF Object; result: ARRAY 20 OF Object;
	BEGIN result := variable;
	END Test.

negative: array of object to shorter array of object assignment

	MODULE Test;
	TYPE Object = OBJECT END Object;
	VAR variable: ARRAY 10 OF Object; result: ARRAY 5 OF Object;
	BEGIN result := variable;
	END Test.

positive: array of object to open array of object assignment

	MODULE Test;
	TYPE Object = OBJECT END Object;
	PROCEDURE Procedure (VAR result: ARRAY OF Object);
	VAR variable: ARRAY 10 OF Object;
	BEGIN result := variable;
	END Procedure;
	END Test.

negative: array of pointer to array of object assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF POINTER TO RECORD END; result: ARRAY 10 OF OBJECT END;
	BEGIN result := variable;
	END Test.

negative: array of procedure to array of object assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF PROCEDURE; result: ARRAY 10 OF OBJECT END;
	BEGIN result := variable;
	END Test.

negative: array of boolean to array of pointer assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF BOOLEAN; result: ARRAY 10 OF POINTER TO RECORD END;
	BEGIN result := variable;
	END Test.

negative: array of character to array of pointer assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF CHAR; result: ARRAY 10 OF POINTER TO RECORD END;
	BEGIN result := variable;
	END Test.

negative: array of short integer to array of pointer assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF SHORTINT; result: ARRAY 10 OF POINTER TO RECORD END;
	BEGIN result := variable;
	END Test.

negative: array of integer to array of pointer assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF INTEGER; result: ARRAY 10 OF POINTER TO RECORD END;
	BEGIN result := variable;
	END Test.

negative: array of long integer to array of pointer assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF LONGINT; result: ARRAY 10 OF POINTER TO RECORD END;
	BEGIN result := variable;
	END Test.

negative: array of huge integer to array of pointer assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF HUGEINT; result: ARRAY 10 OF POINTER TO RECORD END;
	BEGIN result := variable;
	END Test.

negative: array of real to array of pointer assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF REAL; result: ARRAY 10 OF POINTER TO RECORD END;
	BEGIN result := variable;
	END Test.

negative: array of long real to array of pointer assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF LONGREAL; result: ARRAY 10 OF POINTER TO RECORD END;
	BEGIN result := variable;
	END Test.

negative: array of set to array of pointer assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF SET; result: ARRAY 10 OF POINTER TO RECORD END;
	BEGIN result := variable;
	END Test.

negative: array of array to array of pointer assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF ARRAY 10 OF SET; result: ARRAY 10 OF POINTER TO RECORD END;
	BEGIN result := variable;
	END Test.

negative: array of record to array of pointer assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF RECORD END; result: ARRAY 10 OF POINTER TO RECORD END;
	BEGIN result := variable;
	END Test.

negative: array of object to array of pointer assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF OBJECT END; result: ARRAY 10 OF POINTER TO RECORD END;
	BEGIN result := variable;
	END Test.

positive: array of pointer to array of pointer assignment

	MODULE Test;
	VAR variable, result: ARRAY 10 OF POINTER TO RECORD END;
	BEGIN result := variable;
	END Test.

positive: array of pointer to longer array of pointer assignment

	MODULE Test;
	TYPE Pointer = POINTER TO RECORD END;
	VAR variable: ARRAY 10 OF Pointer; result: ARRAY 20 OF Pointer;
	BEGIN result := variable;
	END Test.

negative: array of pointer to shorter array of pointer assignment

	MODULE Test;
	TYPE Pointer = POINTER TO RECORD END;
	VAR variable: ARRAY 10 OF Pointer; result: ARRAY 5 OF Pointer;
	BEGIN result := variable;
	END Test.

positive: array of pointer to open array of pointer assignment

	MODULE Test;
	TYPE Pointer = POINTER TO RECORD END;
	PROCEDURE Procedure (VAR result: ARRAY OF Pointer);
	VAR variable: ARRAY 10 OF Pointer;
	BEGIN result := variable;
	END Procedure;
	END Test.

negative: array of procedure to array of pointer assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF PROCEDURE; result: ARRAY 10 OF POINTER TO RECORD END;
	BEGIN result := variable;
	END Test.

negative: array of boolean to array of procedure assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF BOOLEAN; result: ARRAY 10 OF PROCEDURE;
	BEGIN result := variable;
	END Test.

negative: array of character to array of procedure assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF CHAR; result: ARRAY 10 OF PROCEDURE;
	BEGIN result := variable;
	END Test.

negative: array of short integer to array of procedure assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF SHORTINT; result: ARRAY 10 OF PROCEDURE;
	BEGIN result := variable;
	END Test.

negative: array of integer to array of procedure assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF INTEGER; result: ARRAY 10 OF PROCEDURE;
	BEGIN result := variable;
	END Test.

negative: array of long integer to array of procedure assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF LONGINT; result: ARRAY 10 OF PROCEDURE;
	BEGIN result := variable;
	END Test.

negative: array of huge integer to array of procedure assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF HUGEINT; result: ARRAY 10 OF PROCEDURE;
	BEGIN result := variable;
	END Test.

negative: array of real to array of procedure assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF REAL; result: ARRAY 10 OF PROCEDURE;
	BEGIN result := variable;
	END Test.

negative: array of long real to array of procedure assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF LONGREAL; result: ARRAY 10 OF PROCEDURE;
	BEGIN result := variable;
	END Test.

negative: array of set to array of procedure assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF SET; result: ARRAY 10 OF PROCEDURE;
	BEGIN result := variable;
	END Test.

negative: array of array to array of procedure assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF ARRAY 10 OF SET; result: ARRAY 10 OF PROCEDURE;
	BEGIN result := variable;
	END Test.

negative: array of record to array of procedure assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF RECORD END; result: ARRAY 10 OF PROCEDURE;
	BEGIN result := variable;
	END Test.

negative: array of object to array of procedure assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF OBJECT END; result: ARRAY 10 OF PROCEDURE;
	BEGIN result := variable;
	END Test.

negative: array of pointer to array of procedure assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF POINTER TO RECORD END; result: ARRAY 10 OF PROCEDURE;
	BEGIN result := variable;
	END Test.

positive: array of procedure to array of procedure assignment

	MODULE Test;
	VAR variable, result: ARRAY 10 OF PROCEDURE;
	BEGIN result := variable;
	END Test.

positive: array of procedure to longer array of procedure assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF PROCEDURE; result: ARRAY 20 OF PROCEDURE;
	BEGIN result := variable;
	END Test.

negative: array of procedure to shorter array of procedure assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF PROCEDURE; result: ARRAY 5 OF PROCEDURE;
	BEGIN result := variable;
	END Test.

positive: array of procedure to open array of procedure assignment

	MODULE Test;
	PROCEDURE Procedure (VAR result: ARRAY OF PROCEDURE);
	VAR variable: ARRAY 10 OF PROCEDURE;
	BEGIN result := variable;
	END Procedure;
	END Test.

negative: record to array assignment

	MODULE Test;
	VAR variable: RECORD END; result: ARRAY 10 OF CHAR;
	BEGIN result := variable;
	END Test.

negative: object to array assignment

	MODULE Test;
	VAR variable: OBJECT; result: ARRAY 10 OF CHAR;
	BEGIN result := variable;
	END Test.

negative: pointer to array assignment

	MODULE Test;
	VAR variable: POINTER TO RECORD END; result: ARRAY 10 OF CHAR;
	BEGIN result := variable;
	END Test.

negative: variable procedure to array assignment

	MODULE Test;
	VAR variable: PROCEDURE; result: ARRAY 10 OF CHAR;
	BEGIN result := variable;
	END Test.

negative: import to array assignment

	MODULE Test;
	IMPORT variable := A; VAR result: ARRAY 10 OF CHAR;
	BEGIN result := variable;
	END Test.

negative: variable boolean to record assignment

	MODULE Test;
	VAR variable: BOOLEAN; result: RECORD END;
	BEGIN result := variable;
	END Test.

negative: variable character to record assignment

	MODULE Test;
	VAR variable: CHAR; result: RECORD END;
	BEGIN result := variable;
	END Test.

negative: variable short integer to record assignment

	MODULE Test;
	VAR variable: SHORTINT; result: RECORD END;
	BEGIN result := variable;
	END Test.

negative: variable integer to record assignment

	MODULE Test;
	VAR variable: INTEGER; result: RECORD END;
	BEGIN result := variable;
	END Test.

negative: variable long integer to record assignment

	MODULE Test;
	VAR variable: LONGINT; result: RECORD END;
	BEGIN result := variable;
	END Test.

negative: variable huge integer to record assignment

	MODULE Test;
	VAR variable: HUGEINT; result: RECORD END;
	BEGIN result := variable;
	END Test.

negative: variable real to record assignment

	MODULE Test;
	VAR variable: REAL; result: RECORD END;
	BEGIN result := variable;
	END Test.

negative: variable long real to record assignment

	MODULE Test;
	VAR variable: LONGREAL; result: RECORD END;
	BEGIN result := variable;
	END Test.

negative: variable set to record assignment

	MODULE Test;
	VAR variable: LONGREAL; result: RECORD END;
	BEGIN result := variable;
	END Test.

negative: array to record assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF CHAR; result: RECORD END;
	BEGIN result := variable;
	END Test.

positive: record to same record assignment

	MODULE Test;
	VAR variable, result: RECORD END;
	BEGIN result := variable;
	END Test.

negative: record to different record assignment

	MODULE Test;
	VAR variable: RECORD END; result: RECORD END;
	BEGIN result := variable;
	END Test.

positive: extended record to base record assignment

	MODULE Test;
	TYPE Record = RECORD END;
	VAR variable: RECORD (Record) END; result: Record;
	BEGIN result := variable;
	END Test.

negative: base record to extended record assignment

	MODULE Test;
	TYPE Record = RECORD END;
	VAR variable: Record; result: RECORD (Record) END;
	BEGIN result := variable;
	END Test.

positive: record parameter to same record assignment

	MODULE Test;
	PROCEDURE Procedure (parameter, result: RECORD END);
	BEGIN result := parameter;
	END Procedure;
	END Test.

negative: record parameter to different record assignment

	MODULE Test;
	PROCEDURE Procedure (parameter: RECORD END; result: RECORD END);
	BEGIN result := parameter;
	END Procedure;
	END Test.

positive: extended record parameter to base record assignment

	MODULE Test;
	TYPE Record = RECORD END;
	PROCEDURE Procedure (parameter: RECORD (Record) END; result: Record);
	BEGIN result := parameter;
	END Procedure;
	END Test.

negative: base record parameter to extended record assignment

	MODULE Test;
	TYPE Record = RECORD END;
	PROCEDURE Procedure (parameter: Record; result: RECORD (Record) END);
	BEGIN result := parameter;
	END Procedure;
	END Test.

negative: object to record assignment

	MODULE Test;
	VAR variable: OBJECT; result: RECORD END;
	BEGIN result := variable;
	END Test.

negative: pointer to record assignment

	MODULE Test;
	TYPE Record = RECORD END;
	VAR variable: POINTER TO Record; result: Record;
	BEGIN result := variable;
	END Test.

negative: variable procedure to record assignment

	MODULE Test;
	VAR variable: PROCEDURE; result: RECORD END;
	BEGIN result := variable;
	END Test.

negative: import to record assignment

	MODULE Test;
	IMPORT variable := A; VAR result: RECORD END;
	BEGIN result := variable;
	END Test.

negative: variable boolean to object assignment

	MODULE Test;
	VAR variable: BOOLEAN; result: OBJECT END;
	BEGIN result := variable;
	END Test.

negative: variable character to object assignment

	MODULE Test;
	VAR variable: CHAR; result: OBJECT END;
	BEGIN result := variable;
	END Test.

negative: variable short integer to object assignment

	MODULE Test;
	VAR variable: SHORTINT; result: OBJECT END;
	BEGIN result := variable;
	END Test.

negative: variable integer to object assignment

	MODULE Test;
	VAR variable: INTEGER; result: OBJECT END;
	BEGIN result := variable;
	END Test.

negative: variable long integer to object assignment

	MODULE Test;
	VAR variable: LONGINT; result: OBJECT END;
	BEGIN result := variable;
	END Test.

negative: variable huge integer to object assignment

	MODULE Test;
	VAR variable: HUGEINT; result: OBJECT END;
	BEGIN result := variable;
	END Test.

negative: variable real to object assignment

	MODULE Test;
	VAR variable: REAL; result: OBJECT END;
	BEGIN result := variable;
	END Test.

negative: variable long real to object assignment

	MODULE Test;
	VAR variable: LONGREAL; result: OBJECT END;
	BEGIN result := variable;
	END Test.

negative: variable set to object assignment

	MODULE Test;
	VAR variable: LONGREAL; result: OBJECT END;
	BEGIN result := variable;
	END Test.

negative: array to object assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF CHAR; result: OBJECT END;
	BEGIN result := variable;
	END Test.

negative: record to object assignment

	MODULE Test;
	VAR variable: RECORD END; result: OBJECT END;
	BEGIN result := variable;
	END Test.

positive: object to same object assignment

	MODULE Test;
	VAR variable, result: OBJECT END;
	BEGIN result := variable;
	END Test.

negative: object to different object assignment

	MODULE Test;
	VAR variable: OBJECT END; result: OBJECT END;
	BEGIN result := variable;
	END Test.

positive: extended object to base object assignment

	MODULE Test;
	TYPE Object = OBJECT END Object;
	VAR variable: OBJECT (Object) END; result: Object;
	BEGIN result := variable;
	END Test.

negative: base object to extended object assignment

	MODULE Test;
	TYPE Object = OBJECT END Object;
	VAR variable: Object; result: OBJECT (Object) END;
	BEGIN result := variable;
	END Test.

positive: object to basic object assignment

	MODULE Test;
	VAR variable: OBJECT END; result: OBJECT;
	BEGIN result := variable;
	END Test.

negative: basic object to object assignment

	MODULE Test;
	VAR variable: OBJECT; result: OBJECT END;
	BEGIN result := variable;
	END Test.

negative: pointer to object assignment

	MODULE Test;
	VAR variable: POINTER TO RECORD END; result: OBJECT END;
	BEGIN result := variable;
	END Test.

negative: variable procedure to object assignment

	MODULE Test;
	VAR variable: PROCEDURE; result: OBJECT END;
	BEGIN result := variable;
	END Test.

negative: import to object assignment

	MODULE Test;
	IMPORT variable := A; VAR result: OBJECT END;
	BEGIN result := variable;
	END Test.

negative: variable boolean to pointer assignment

	MODULE Test;
	VAR variable: BOOLEAN; result: POINTER TO RECORD END;
	BEGIN result := variable;
	END Test.

negative: variable character to pointer assignment

	MODULE Test;
	VAR variable: CHAR; result: POINTER TO RECORD END;
	BEGIN result := variable;
	END Test.

negative: variable short integer to pointer assignment

	MODULE Test;
	VAR variable: SHORTINT; result: POINTER TO RECORD END;
	BEGIN result := variable;
	END Test.

negative: variable integer to pointer assignment

	MODULE Test;
	VAR variable: INTEGER; result: POINTER TO RECORD END;
	BEGIN result := variable;
	END Test.

negative: variable long integer to pointer assignment

	MODULE Test;
	VAR variable: LONGINT; result: POINTER TO RECORD END;
	BEGIN result := variable;
	END Test.

negative: variable huge integer to pointer assignment

	MODULE Test;
	VAR variable: HUGEINT; result: POINTER TO RECORD END;
	BEGIN result := variable;
	END Test.

negative: variable real to pointer assignment

	MODULE Test;
	VAR variable: REAL; result: POINTER TO RECORD END;
	BEGIN result := variable;
	END Test.

negative: variable long real to pointer assignment

	MODULE Test;
	VAR variable: LONGREAL; result: POINTER TO RECORD END;
	BEGIN result := variable;
	END Test.

negative: variable set to pointer assignment

	MODULE Test;
	VAR variable: LONGREAL; result: POINTER TO RECORD END;
	BEGIN result := variable;
	END Test.

negative: array to pointer assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF CHAR; result: POINTER TO RECORD END;
	BEGIN result := variable;
	END Test.

negative: record to pointer assignment

	MODULE Test;
	VAR variable: RECORD END; result: POINTER TO RECORD END;
	BEGIN result := variable;
	END Test.

negative: object to pointer assignment

	MODULE Test;
	VAR variable: OBJECT END; result: POINTER TO RECORD END;
	BEGIN result := variable;
	END Test.

positive: pointer to same pointer assignment

	MODULE Test;
	VAR variable, result: POINTER TO RECORD END;
	BEGIN result := variable;
	END Test.

positive: pointer to array of same pointer to same pointer assignment

	MODULE Test;
	TYPE Pointer = POINTER TO ARRAY 10 OF Pointer;
	VAR variable, result: Pointer;
	BEGIN result := variable;
	END Test.

positive: pointers to array of same pointer to same pointer assignment

	MODULE Test;
	TYPE A = POINTER TO ARRAY 10 OF B;
	TYPE B = POINTER TO ARRAY 10 OF A;
	VAR variable: A; result: B;
	BEGIN result := variable;
	END Test.

positive: pointer to open array of same pointer to same pointer assignment

	MODULE Test;
	TYPE Pointer = POINTER TO ARRAY OF Pointer;
	VAR variable, result: Pointer;
	BEGIN result := variable;
	END Test.

positive: pointers to open array of same pointer to same pointer assignment

	MODULE Test;
	TYPE A = POINTER TO ARRAY OF B;
	TYPE B = POINTER TO ARRAY OF A;
	VAR variable: A; result: B;
	BEGIN result := variable;
	END Test.

positive: pointer to different pointer assignment

	MODULE Test;
	TYPE Record = RECORD END;
	VAR variable: POINTER TO Record; result: POINTER TO Record;
	BEGIN result := variable;
	END Test.

positive: extended pointer to base pointer assignment

	MODULE Test;
	TYPE Record = RECORD END;
	VAR variable: POINTER TO RECORD (Record) END; result: POINTER TO Record;
	BEGIN result := variable;
	END Test.

negative: base pointer to extended pointer assignment

	MODULE Test;
	TYPE Record = RECORD END;
	VAR variable: POINTER TO Record; result: POINTER TO RECORD (Record) END;
	BEGIN result := variable;
	END Test.

negative: pointer to array to pointer to record assignment

	MODULE Test;
	VAR variable: POINTER TO ARRAY 10 OF CHAR; result: POINTER TO RECORD END;
	BEGIN result := variable;
	END Test.

negative: pointer to record to pointer to array assignment

	MODULE Test;
	VAR variable: POINTER TO RECORD END; result: POINTER TO ARRAY 10 OF CHAR;
	BEGIN result := variable;
	END Test.

positive: pointer to array to pointer to array assignment

	MODULE Test;
	VAR variable, result: POINTER TO ARRAY 10 OF CHAR;
	BEGIN result := variable;
	END Test.

positive: pointer to array to pointer to longer array assignment

	MODULE Test;
	VAR variable: POINTER TO ARRAY 10 OF CHAR; result: POINTER TO ARRAY 20 OF CHAR;
	BEGIN result := variable;
	END Test.

negative: pointer to array to pointer to shorter array assignment

	MODULE Test;
	VAR variable: POINTER TO ARRAY 10 OF CHAR; result: POINTER TO ARRAY 5 OF CHAR;
	BEGIN result := variable;
	END Test.

negative: variable procedure to pointer assignment

	MODULE Test;
	VAR variable: PROCEDURE; result: POINTER TO RECORD END;
	BEGIN result := variable;
	END Test.

negative: import to pointer assignment

	MODULE Test;
	IMPORT variable := A; VAR result: POINTER TO RECORD END;
	BEGIN result := variable;
	END Test.

negative: variable boolean to procedure assignment

	MODULE Test;
	VAR variable: BOOLEAN; result: PROCEDURE;
	BEGIN result := variable;
	END Test.

negative: variable character to procedure assignment

	MODULE Test;
	VAR variable: CHAR; result: PROCEDURE;
	BEGIN result := variable;
	END Test.

negative: variable short integer to procedure assignment

	MODULE Test;
	VAR variable: SHORTINT; result: PROCEDURE;
	BEGIN result := variable;
	END Test.

negative: variable integer to procedure assignment

	MODULE Test;
	VAR variable: INTEGER; result: PROCEDURE;
	BEGIN result := variable;
	END Test.

negative: variable long integer to procedure assignment

	MODULE Test;
	VAR variable: LONGINT; result: PROCEDURE;
	BEGIN result := variable;
	END Test.

negative: variable huge integer to procedure assignment

	MODULE Test;
	VAR variable: HUGEINT; result: PROCEDURE;
	BEGIN result := variable;
	END Test.

negative: variable real to procedure assignment

	MODULE Test;
	VAR variable: REAL; result: PROCEDURE;
	BEGIN result := variable;
	END Test.

negative: variable long real to procedure assignment

	MODULE Test;
	VAR variable: LONGREAL; result: PROCEDURE;
	BEGIN result := variable;
	END Test.

negative: variable set to procedure assignment

	MODULE Test;
	VAR variable: LONGREAL; result: PROCEDURE;
	BEGIN result := variable;
	END Test.

negative: array to procedure assignment

	MODULE Test;
	VAR variable: ARRAY 10 OF CHAR; result: PROCEDURE;
	BEGIN result := variable;
	END Test.

negative: record to procedure assignment

	MODULE Test;
	VAR variable: RECORD END; result: PROCEDURE;
	BEGIN result := variable;
	END Test.

negative: object to procedure assignment

	MODULE Test;
	VAR variable: OBJECT END; result: PROCEDURE;
	BEGIN result := variable;
	END Test.

negative: pointer to procedure assignment

	MODULE Test;
	VAR variable: POINTER TO RECORD END; result: PROCEDURE;
	BEGIN result := variable;
	END Test.

positive: variable procedure to procedure assignment

	MODULE Test;
	VAR variable, result: PROCEDURE;
	BEGIN result := variable;
	END Test.

negative: import to procedure assignment

	MODULE Test;
	IMPORT variable := A; VAR result: PROCEDURE;
	BEGIN result := variable;
	END Test.

negative: variable boolean to import assignment

	MODULE Test;
	IMPORT result := A;
	VAR variable: BOOLEAN;
	BEGIN result := variable;
	END Test.

negative: variable character to import assignment

	MODULE Test;
	IMPORT result := A;
	VAR variable: CHAR;
	BEGIN result := variable;
	END Test.

negative: variable short integer to import assignment

	MODULE Test;
	IMPORT result := A;
	VAR variable: SHORTINT;
	BEGIN result := variable;
	END Test.

negative: variable integer to import assignment

	MODULE Test;
	IMPORT result := A;
	VAR variable: INTEGER;
	BEGIN result := variable;
	END Test.

negative: variable long integer to import assignment

	MODULE Test;
	IMPORT result := A;
	VAR variable: LONGINT;
	BEGIN result := variable;
	END Test.

negative: variable huge integer to import assignment

	MODULE Test;
	IMPORT result := A;
	VAR variable: HUGEINT;
	BEGIN result := variable;
	END Test.

negative: variable real to import assignment

	MODULE Test;
	IMPORT result := A;
	VAR variable: REAL;
	BEGIN result := variable;
	END Test.

negative: variable long real to import assignment

	MODULE Test;
	IMPORT result := A;
	VAR variable: LONGREAL;
	BEGIN result := variable;
	END Test.

negative: variable set to import assignment

	MODULE Test;
	IMPORT result := A;
	VAR variable: LONGREAL;
	BEGIN result := variable;
	END Test.

negative: array to import assignment

	MODULE Test;
	IMPORT result := A;
	VAR variable: ARRAY 10 OF CHAR;
	BEGIN result := variable;
	END Test.

negative: record to import assignment

	MODULE Test;
	IMPORT result := A;
	VAR variable: RECORD END;
	BEGIN result := variable;
	END Test.

negative: object to import assignment

	MODULE Test;
	IMPORT result := A;
	VAR variable: OBJECT END;
	BEGIN result := variable;
	END Test.

negative: pointer to import assignment

	MODULE Test;
	IMPORT result := A;
	VAR variable: POINTER TO RECORD END;
	BEGIN result := variable;
	END Test.

negative: variable procedure to import assignment

	MODULE Test;
	IMPORT result := A;
	VAR variable: PROCEDURE;
	BEGIN result := variable;
	END Test.

negative: import to import assignment

	MODULE Test;
	IMPORT variable := A, result := A;
	BEGIN result := variable;
	END Test.


# variable booleans

negative: arithmetic negation on variable boolean

	MODULE Test;
	VAR boolean, result: BOOLEAN;
	BEGIN result := -boolean;
	END Test.

positive: logical negation on variable boolean

	MODULE Test;
	VAR boolean, result: BOOLEAN;
	BEGIN result := ~boolean;
	END Test.

positive: multiple logical negations on variable boolean

	MODULE Test;
	VAR boolean, result: BOOLEAN;
	BEGIN result := ~~~~boolean;
	END Test.

negative: addition on variable booleans

	MODULE Test;
	VAR boolean, result: BOOLEAN;
	BEGIN result := boolean + boolean;
	END Test.

negative: subtraction on variable booleans

	MODULE Test;
	VAR boolean, result: BOOLEAN;
	BEGIN result := boolean - boolean
	END Test.

negative: multiplication on variable booleans

	MODULE Test;
	VAR boolean, result: BOOLEAN;
	BEGIN result := boolean * boolean
	END Test.

negative: integer division on variable booleans

	MODULE Test;
	VAR boolean: BOOLEAN; result: INTEGER;
	BEGIN result := boolean DIV boolean
	END Test.

negative: real division on variable booleans

	MODULE Test;
	VAR boolean: BOOLEAN; result: REAL;
	BEGIN result := boolean / boolean
	END Test.

negative: modulo on variable booleans

	MODULE Test;
	VAR boolean: BOOLEAN; result: INTEGER;
	BEGIN result := boolean MOD boolean
	END Test.

positive: equal relation on variable booleans

	MODULE Test;
	VAR boolean, result: BOOLEAN;
	BEGIN result := boolean = boolean
	END Test.

positive: unequal relation on variable booleans

	MODULE Test;
	VAR boolean, result: BOOLEAN;
	BEGIN result := boolean # boolean
	END Test.

negative: less relation on variable booleans

	MODULE Test;
	VAR boolean, result: BOOLEAN;
	BEGIN result := boolean < boolean
	END Test.

negative: less or equal relation on variable booleans

	MODULE Test;
	VAR boolean, result: BOOLEAN;
	BEGIN result := boolean <= boolean
	END Test.

negative: greater relation on variable booleans

	MODULE Test;
	VAR boolean, result: BOOLEAN;
	BEGIN result := boolean > boolean
	END Test.

negative: greater or equal relation on variable booleans

	MODULE Test;
	VAR boolean, result: BOOLEAN;
	BEGIN result := boolean >= boolean
	END Test.

negative: set membership on variable booleans

	MODULE Test;
	VAR boolean, result: BOOLEAN;
	BEGIN result := boolean IN boolean
	END Test.

negative: type test on variable booleans

	MODULE Test;
	VAR boolean, result: BOOLEAN;
	BEGIN result := boolean IS boolean
	END Test.

positive: logical and on variable booleans

	MODULE Test;
	VAR boolean, result: BOOLEAN;
	BEGIN result := boolean & boolean
	END Test.

positive: logical or on variable booleans

	MODULE Test;
	VAR boolean, result: BOOLEAN;
	BEGIN result := boolean OR boolean
	END Test.


# variable characters

negative: arithmetic negation on variable character

	MODULE Test;
	VAR character, result: CHAR;
	BEGIN result := -character;
	END Test.

negative: logical negation on variable character

	MODULE Test;
	VAR character: CHAR; result: BOOLEAN;
	BEGIN result := ~character;
	END Test.

negative: addition on variable characters

	MODULE Test;
	VAR character, result: CHAR;
	BEGIN result := character + character;
	END Test.

negative: subtraction on variable characters

	MODULE Test;
	VAR character, result: CHAR;
	BEGIN result := character - character
	END Test.

negative: multiplication on variable characters

	MODULE Test;
	VAR character, result: CHAR;
	BEGIN result := character * character
	END Test.

negative: integer division on variable characters

	MODULE Test;
	VAR character: CHAR; result: INTEGER;
	BEGIN result := character DIV character
	END Test.

negative: real division on variable characters

	MODULE Test;
	VAR character: CHAR; result: REAL;
	BEGIN result := character / character
	END Test.

negative: modulo on variable characters

	MODULE Test;
	VAR character: CHAR; result: INTEGER;
	BEGIN result := character MOD character
	END Test.

positive: equal relation on variable characters

	MODULE Test;
	VAR character: CHAR; result: BOOLEAN;
	BEGIN result := character = character
	END Test.

positive: unequal relation on variable characters

	MODULE Test;
	VAR character: CHAR; result: BOOLEAN;
	BEGIN result := character # character
	END Test.

positive: less relation on variable characters

	MODULE Test;
	VAR character: CHAR; result: BOOLEAN;
	BEGIN result := character < character
	END Test.

positive: less or equal relation on variable characters

	MODULE Test;
	VAR character: CHAR; result: BOOLEAN;
	BEGIN result := character <= character
	END Test.

positive: greater relation on variable characters

	MODULE Test;
	VAR character: CHAR; result: BOOLEAN;
	BEGIN result := character > character
	END Test.

positive: greater or equal relation on variable characters

	MODULE Test;
	VAR character: CHAR; result: BOOLEAN;
	BEGIN result := character >= character
	END Test.

negative: set membership on variable characters

	MODULE Test;
	VAR character: CHAR; result: BOOLEAN;
	BEGIN result := character IN character
	END Test.

negative: type test on variable characters

	MODULE Test;
	VAR character: CHAR; result: BOOLEAN;
	BEGIN result := character IS character
	END Test.

negative: logical and on variable characters

	MODULE Test;
	VAR character: CHAR; result: BOOLEAN;
	BEGIN result := character & character
	END Test.

negative: logical or on variable characters

	MODULE Test;
	VAR character: CHAR; result: BOOLEAN;
	BEGIN result := character OR character
	END Test.


# variable integers

positive: arithmetic negation on variable integer

	MODULE Test;
	VAR integer, result: INTEGER;
	BEGIN result := -integer;
	END Test.

positive: multiple arithmetic negations on variable integer

	MODULE Test;
	VAR integer, result: INTEGER;
	BEGIN result := -(-(-integer));
	END Test.

negative: logical negation on variable integer

	MODULE Test;
	VAR integer: INTEGER; result: BOOLEAN;
	BEGIN result := ~integer;
	END Test.

positive: addition on variable integers

	MODULE Test;
	VAR integer, result: INTEGER;
	BEGIN result := integer + integer;
	END Test.

positive: subtraction on variable integers

	MODULE Test;
	VAR integer, result: INTEGER;
	BEGIN result := integer - integer
	END Test.

positive: multiplication on variable integers

	MODULE Test;
	VAR integer, result: INTEGER;
	BEGIN result := integer * integer
	END Test.

positive: integer division on variable integers

	MODULE Test;
	VAR integer, result: INTEGER;
	BEGIN result := integer DIV integer
	END Test.

positive: real division on variable integers

	MODULE Test;
	VAR integer: INTEGER; result: REAL;
	BEGIN result := integer / integer
	END Test.

positive: modulo on variable integers

	MODULE Test;
	VAR integer, result: INTEGER;
	BEGIN result := integer MOD integer
	END Test.

positive: equal relation on variable integers

	MODULE Test;
	VAR integer: INTEGER; result: BOOLEAN;
	BEGIN result := integer = integer
	END Test.

positive: unequal relation on variable integers

	MODULE Test;
	VAR integer: INTEGER; result: BOOLEAN;
	BEGIN result := integer # integer
	END Test.

positive: less relation on variable integers

	MODULE Test;
	VAR integer: INTEGER; result: BOOLEAN;
	BEGIN result := integer < integer
	END Test.

positive: less or equal relation on variable integers

	MODULE Test;
	VAR integer: INTEGER; result: BOOLEAN;
	BEGIN result := integer <= integer
	END Test.

positive: greater relation on variable integers

	MODULE Test;
	VAR integer: INTEGER; result: BOOLEAN;
	BEGIN result := integer > integer
	END Test.

positive: greater or equal relation on variable integers

	MODULE Test;
	VAR integer: INTEGER; result: BOOLEAN;
	BEGIN result := integer >= integer
	END Test.

negative: set membership on variable integers

	MODULE Test;
	VAR integer: INTEGER; result: BOOLEAN;
	BEGIN result := integer IN integer
	END Test.

negative: type test on variable integers

	MODULE Test;
	VAR integer: INTEGER; result: BOOLEAN;
	BEGIN result := integer IS integer
	END Test.

negative: logical and on variable integers

	MODULE Test;
	VAR integer: INTEGER; result: BOOLEAN;
	BEGIN result := integer & integer
	END Test.

negative: logical or on variable integers

	MODULE Test;
	VAR integer: INTEGER; result: BOOLEAN;
	BEGIN result := integer OR integer
	END Test.


# variable reals

positive: arithmetic negation on variable real

	MODULE Test;
	VAR real, result: REAL;
	BEGIN result := -real;
	END Test.

positive: multiple arithmetic negations on variable real

	MODULE Test;
	VAR real, result: REAL;
	BEGIN result := -(-(-real));
	END Test.

negative: logical negation on variable real

	MODULE Test;
	VAR real, result: REAL;
	BEGIN result := ~real;
	END Test.

positive: addition on variable reals

	MODULE Test;
	VAR real, result: REAL;
	BEGIN result := real + real;
	END Test.

positive: subtraction on variable reals

	MODULE Test;
	VAR real, result: REAL;
	BEGIN result := real - real
	END Test.

positive: multiplication on variable reals

	MODULE Test;
	VAR real, result: REAL;
	BEGIN result := real * real
	END Test.

negative: integer division on variable reals

	MODULE Test;
	VAR real: REAL; result: INTEGER;
	BEGIN result := real DIV real
	END Test.

positive: real division on variable reals

	MODULE Test;
	VAR real, result: REAL;
	BEGIN result := real / real
	END Test.

negative: modulo on variable reals

	MODULE Test;
	VAR real: REAL; result: INTEGER;
	BEGIN result := real MOD real
	END Test.

positive: equal relation on variable reals

	MODULE Test;
	VAR real: REAL; result: BOOLEAN;
	BEGIN result := real = real
	END Test.

positive: unequal relation on variable reals

	MODULE Test;
	VAR real: REAL; result: BOOLEAN;
	BEGIN result := real # real
	END Test.

positive: less relation on variable reals

	MODULE Test;
	VAR real: REAL; result: BOOLEAN;
	BEGIN result := real < real
	END Test.

positive: less or equal relation on variable reals

	MODULE Test;
	VAR real: REAL; result: BOOLEAN;
	BEGIN result := real <= real
	END Test.

positive: greater relation on variable reals

	MODULE Test;
	VAR real: REAL; result: BOOLEAN;
	BEGIN result := real > real
	END Test.

positive: greater or equal relation on variable reals

	MODULE Test;
	VAR real: REAL; result: BOOLEAN;
	BEGIN result := real >= real
	END Test.

negative: set membership on variable reals

	MODULE Test;
	VAR real: REAL; result: BOOLEAN;
	BEGIN result := real IN real
	END Test.

negative: type test on variable reals

	MODULE Test;
	VAR real: REAL; result: BOOLEAN;
	BEGIN result := real IS real
	END Test.

negative: logical and on variable reals

	MODULE Test;
	VAR real: REAL; result: BOOLEAN;
	BEGIN result := real & real
	END Test.

negative: logical or on variable reals

	MODULE Test;
	VAR real: REAL; result: BOOLEAN;
	BEGIN result := real OR real
	END Test.


# variable set

negative: variable boolean as set element

	MODULE Test;
	VAR boolean: BOOLEAN; result: SET;
	BEGIN result := {boolean};
	END Test.

negative: variable character as set element

	MODULE Test;
	VAR character: CHAR; result: SET;
	BEGIN result := {character};
	END Test.

positive: variable integer variable as set element

	MODULE Test;
	VAR integer: INTEGER; result: SET;
	BEGIN result := {integer};
	END Test.

negative: variable real as set element

	MODULE Test;
	VAR real: REAL; result: SET;
	BEGIN result := {real};
	END Test.

negative: variable set as set element

	MODULE Test;
	VAR set, result: SET;
	BEGIN result := {set};
	END Test.

positive: several equal variable set elements

	MODULE Test;
	VAR integer: INTEGER; result: SET;
	BEGIN result := {integer, integer, integer};
	END Test.

positive: several different variable set elements

	MODULE Test;
	VAR integer: INTEGER; result: SET;
	BEGIN result := {integer, integer, integer};
	END Test.

positive: variable set element range

	MODULE Test;
	VAR integer: INTEGER; result: SET;
	BEGIN result := {integer..integer};
	END Test.

positive: variable set element range with single element

	MODULE Test;
	VAR integer: INTEGER; result: SET;
	BEGIN result := {integer..integer};
	END Test.

positive: empty variable set element range

	MODULE Test;
	VAR integer: INTEGER; result: SET;
	BEGIN result := {integer..integer};
	END Test.

positive: complement on variable set

	MODULE Test;
	VAR set, result: SET;
	BEGIN result := -set;
	END Test.

positive: multiple complements on variable set

	MODULE Test;
	VAR set, result: SET;
	BEGIN result := -(-(-set));
	END Test.

negative: logical negation on variable set

	MODULE Test;
	VAR set: SET; result: BOOLEAN;
	BEGIN result := ~set;
	END Test.

positive: union on variable sets

	MODULE Test;
	VAR set, result: SET;
	BEGIN result := set + set;
	END Test.

positive: difference on variable sets

	MODULE Test;
	VAR set, result: SET;
	BEGIN result := set - set
	END Test.

positive: intersection on variable sets

	MODULE Test;
	VAR set, result: SET;
	BEGIN result := set * set
	END Test.

negative: integer division on variable sets

	MODULE Test;
	VAR set: SET; result: INTEGER;
	BEGIN result := set DIV set
	END Test.

positive: symmetric difference on variable sets

	MODULE Test;
	VAR set, result: SET;
	BEGIN result := set / set
	END Test.

negative: modulo on variable sets

	MODULE Test;
	VAR set: SET; result: INTEGER;
	BEGIN result := set MOD set
	END Test.

positive: equal relation on variable sets

	MODULE Test;
	VAR set: SET; result: BOOLEAN;
	BEGIN result := set = set
	END Test.

positive: unequal relation on variable sets

	MODULE Test;
	VAR set: SET; result: BOOLEAN;
	BEGIN result := set # set
	END Test.

negative: less relation on variable sets

	MODULE Test;
	VAR set: SET; result: BOOLEAN;
	BEGIN result := set < set
	END Test.

negative: less or equal relation on variable sets

	MODULE Test;
	VAR set: SET; result: BOOLEAN;
	BEGIN result := set <= set
	END Test.

negative: greater relation on variable sets

	MODULE Test;
	VAR set: SET; result: BOOLEAN;
	BEGIN result := set > set
	END Test.

negative: greater or equal relation on variable sets

	MODULE Test;
	VAR set: SET; result: BOOLEAN;
	BEGIN result := set >= set
	END Test.

negative: set membership on variable sets

	MODULE Test;
	VAR set: SET; result: BOOLEAN;
	BEGIN result := set IN set
	END Test.

positive: set membership on integer and variable set

	MODULE Test;
	VAR integer: INTEGER; set: SET; result: BOOLEAN;
	BEGIN result := integer IN set
	END Test.

negative: type test on variable sets

	MODULE Test;
	VAR set: SET; result: BOOLEAN;
	BEGIN result := set IS set
	END Test.

negative: logical and on variable sets

	MODULE Test;
	VAR set: SET; result: BOOLEAN;
	BEGIN result := set & set
	END Test.

negative: logical or on variable sets

	MODULE Test;
	VAR set: SET; result: BOOLEAN;
	BEGIN result := set OR set
	END Test.


# variable arrays

negative: arithmetic negation on variable array

	MODULE Test;
	VAR array, result: ARRAY 10 OF SET;
	BEGIN result := -array;
	END Test.

negative: logical negation on variable array

	MODULE Test;
	VAR array, result: ARRAY 10 OF SET;
	BEGIN result := ~array;
	END Test.

negative: multiple logical negations on variable array

	MODULE Test;
	VAR array, result: ARRAY 10 OF SET;
	BEGIN result := ~~~~array;
	END Test.

negative: addition on variable arrays

	MODULE Test;
	VAR array, result: ARRAY 10 OF SET;
	BEGIN result := array + array;
	END Test.

negative: subtraction on variable arrays

	MODULE Test;
	VAR array, result: ARRAY 10 OF SET;
	BEGIN result := array - array
	END Test.

negative: multiplication on variable arrays

	MODULE Test;
	VAR array, result: ARRAY 10 OF SET;
	BEGIN result := array * array
	END Test.

negative: integer division on variable arrays

	MODULE Test;
	VAR array: ARRAY 10 OF SET; result: INTEGER;
	BEGIN result := array DIV array
	END Test.

negative: real division on variable arrays

	MODULE Test;
	VAR array: ARRAY 10 OF SET; result: REAL;
	BEGIN result := array / array
	END Test.

negative: modulo on variable arrays

	MODULE Test;
	VAR array: ARRAY 10 OF SET; result: INTEGER;
	BEGIN result := array MOD array
	END Test.

positive: equal relation on variable arrays

	MODULE Test;
	VAR array: ARRAY 10 OF SET; result: BOOLEAN;
	BEGIN result := array = array
	END Test.

positive: equal relation on variable arrays of character

	MODULE Test;
	VAR array: ARRAY 10 OF CHAR; result: BOOLEAN;
	BEGIN result := array = array
	END Test.

positive: equal relation on variable array of character and string

	MODULE Test;
	VAR array: ARRAY 10 OF CHAR; result: BOOLEAN;
	BEGIN result := array = "string"
	END Test.

positive: unequal relation on variable arrays

	MODULE Test;
	VAR array: ARRAY 10 OF SET; result: BOOLEAN;
	BEGIN result := array # array
	END Test.

positive: unequal relation on variable arrays of character

	MODULE Test;
	VAR array: ARRAY 10 OF CHAR; result: BOOLEAN;
	BEGIN result := array # array
	END Test.

positive: unequal relation on variable array of character and string

	MODULE Test;
	VAR array: ARRAY 10 OF CHAR; result: BOOLEAN;
	BEGIN result := array # "string"
	END Test.

negative: less relation on variable arrays

	MODULE Test;
	VAR array: ARRAY 10 OF SET; result: BOOLEAN;
	BEGIN result := array < array
	END Test.

positive: less relation on variable arrays of character

	MODULE Test;
	VAR array: ARRAY 10 OF CHAR; result: BOOLEAN;
	BEGIN result := array < array
	END Test.

positive: less relation on variable array of character and string

	MODULE Test;
	VAR array: ARRAY 10 OF CHAR; result: BOOLEAN;
	BEGIN result := array < "string"
	END Test.

negative: less or equal relation on variable arrays

	MODULE Test;
	VAR array: ARRAY 10 OF SET; result: BOOLEAN;
	BEGIN result := array <= array
	END Test.

positive: less or equal relation on variable arrays of character

	MODULE Test;
	VAR array: ARRAY 10 OF CHAR; result: BOOLEAN;
	BEGIN result := array <= array
	END Test.

positive: less or equal relation on variable array of character and string

	MODULE Test;
	VAR array: ARRAY 10 OF CHAR; result: BOOLEAN;
	BEGIN result := array <= "string"
	END Test.

negative: greater relation on variable arrays

	MODULE Test;
	VAR array: ARRAY 10 OF SET; result: BOOLEAN;
	BEGIN result := array > array
	END Test.

positive: greater relation on variable arrays of character

	MODULE Test;
	VAR array: ARRAY 10 OF CHAR; result: BOOLEAN;
	BEGIN result := array > array
	END Test.

positive: greater relation on variable array of character and string

	MODULE Test;
	VAR array: ARRAY 10 OF CHAR; result: BOOLEAN;
	BEGIN result := array > "string"
	END Test.

negative: greater or equal relation on variable arrays

	MODULE Test;
	VAR array: ARRAY 10 OF SET; result: BOOLEAN;
	BEGIN result := array >= array
	END Test.

positive: greater or equal relation on variable arrays of character

	MODULE Test;
	VAR array: ARRAY 10 OF CHAR; result: BOOLEAN;
	BEGIN result := array >= array
	END Test.

positive: greater or equal relation on variable array of character and string

	MODULE Test;
	VAR array: ARRAY 10 OF CHAR; result: BOOLEAN;
	BEGIN result := array >= "string"
	END Test.

negative: set membership on variable arrays

	MODULE Test;
	VAR array: ARRAY 10 OF SET; result: BOOLEAN;
	BEGIN result := array IN array
	END Test.

negative: type test on variable arrays

	MODULE Test;
	VAR array: ARRAY 10 OF SET; result: BOOLEAN;
	BEGIN result := array IS array
	END Test.

negative: logical and on variable arrays

	MODULE Test;
	VAR array, result: ARRAY 10 OF SET;
	BEGIN result := array & array
	END Test.

negative: logical or on variable arrays

	MODULE Test;
	VAR array, result: ARRAY 10 OF SET;
	BEGIN result := array OR array
	END Test.


# implicit variable conversions

positive: implicit variable short to integer conversion

	MODULE Test;
	VAR shortint: SHORTINT; integer, result: INTEGER;
	BEGIN result := shortint + integer
	END Test.

positive: implicit variable short to long integer conversion

	MODULE Test;
	VAR shortint: SHORTINT; longint, result: LONGINT;
	BEGIN result := shortint * longint
	END Test.

positive: implicit variable short to huge integer conversion

	MODULE Test;
	VAR shortint: SHORTINT; hugeint, result: HUGEINT;
	BEGIN result := hugeint DIV shortint
	END Test.

positive: implicit variable integer to long integer conversion

	MODULE Test;
	VAR integer: INTEGER; longint, result: LONGINT;
	BEGIN result := integer - longint
	END Test.

positive: implicit variable integer to huge integer conversion

	MODULE Test;
	VAR integer: INTEGER; hugeint, result: HUGEINT;
	BEGIN result := integer * hugeint
	END Test.

positive: implicit variable long to huge integer conversion

	MODULE Test;
	VAR longint: INTEGER; hugeint, result: HUGEINT;
	BEGIN result := hugeint + longint
	END Test.

positive: implicit variable integer to real conversion

	MODULE Test;
	VAR integer: INTEGER; real, result: REAL;
	BEGIN result := real + integer
	END Test.

positive: implicit variable integer to long real conversion

	MODULE Test;
	VAR integer: INTEGER; longreal, result: LONGREAL;
	BEGIN result := integer / longreal
	END Test.

positive: implicit variable real to long real conversion

	MODULE Test;
	VAR real: REAL; longreal, result: LONGREAL;
	BEGIN result := longreal * real
	END Test.

negative: implicit conversion between variable boolean and character

	MODULE Test;
	VAR boolean, result: BOOLEAN; character: CHAR;
	BEGIN result := boolean = character
	END Test.

negative: implicit conversion between variable boolean and integer

	MODULE Test;
	VAR boolean, result: BOOLEAN; integer: INTEGER;
	BEGIN result := boolean # integer
	END Test.

negative: implicit conversion between variable boolean and real

	MODULE Test;
	VAR boolean, result: BOOLEAN; real: REAL;
	BEGIN result := boolean = real
	END Test.

negative: implicit conversion between variable boolean and set

	MODULE Test;
	VAR boolean, result: BOOLEAN; set: SET;
	BEGIN result := boolean = set
	END Test.

negative: implicit conversion between variable character and integer

	MODULE Test;
	VAR character: CHAR; integer: INTEGER; result: BOOLEAN;
	BEGIN result := character # integer
	END Test.

negative: implicit conversion between variable character and real

	MODULE Test;
	VAR character: CHAR; real: REAL; result: BOOLEAN;
	BEGIN result := 't' # real
	END Test.

negative: implicit conversion between variable character and set

	MODULE Test;
	VAR character: CHAR; set: SET; result: BOOLEAN;
	BEGIN result := character = set
	END Test.

positive: implicit conversion between variable integer and real

	MODULE Test;
	VAR integer: INTEGER; real: REAL; result: BOOLEAN;
	BEGIN result := integer # real
	END Test.

negative: implicit conversion between variable integer and set

	MODULE Test;
	VAR integer: INTEGER; set: SET; result: BOOLEAN;
	BEGIN result := integer = set
	END Test.

negative: implicit conversion between variable real and set

	MODULE Test;
	VAR real: REAL; set: SET; result: BOOLEAN;
	BEGIN result := real = set
	END Test.


# for statement

negative: for statement with unknown counter

	MODULE Test;
	BEGIN FOR i := 0 TO 10 DO END
	END Test.

negative: for statement with constant as counter

	MODULE Test;
	CONST i = 0;
	BEGIN FOR i := 0 TO 10 DO END
	END Test.

negative: for statement with type as counter

	MODULE Test;
	TYPE i = LONGINT;
	BEGIN FOR i := 0 TO 10 DO END
	END Test.

positive: for statement with variable as counter

	MODULE Test;
	VAR i: INTEGER;
	BEGIN FOR i := 0 TO 10 DO END
	END Test.

positive: for statement with parameter as counter

	MODULE Test;
	PROCEDURE Procedure (i: INTEGER);
	BEGIN FOR i := 0 TO 10 DO END
	END Procedure;
	END Test.

negative: for statement with procedure as counter

	MODULE Test;
	PROCEDURE i; END i;
	BEGIN FOR i := 0 TO 10 DO END
	END Test.

negative: for statement with constant counter

	MODULE Test;
	VAR s, e: INTEGER;
	BEGIN FOR 0 := s TO e DO END
	END Test.

positive: for statement with constant start counter

	MODULE Test;
	VAR i, e: INTEGER;
	BEGIN FOR i := 0 TO e DO END
	END Test.

positive: for statement with constant end counter

	MODULE Test;
	VAR i, s: INTEGER;
	BEGIN FOR i := s TO 0 DO END
	END Test.

positive: for statement with variable counter

	MODULE Test;
	VAR i: INTEGER;
	BEGIN FOR i := 0 TO 10 DO END
	END Test.

positive: for statement with variable start counter

	MODULE Test;
	VAR i, s: INTEGER;
	BEGIN FOR i := s TO 10 DO END
	END Test.

positive: for statement with variable end counter

	MODULE Test;
	VAR i, e: INTEGER;
	BEGIN FOR i := 0 TO e DO END
	END Test.

negative: for statement with variable increment

	MODULE Test;
	VAR i, s: INTEGER;
	BEGIN FOR i := 0 TO 10 BY s DO END
	END Test.

positive: for statement with positive constant increment

	MODULE Test;
	VAR i: INTEGER;
	BEGIN FOR i := 0 TO 10 BY 1 DO END
	END Test.

positive: for statement with negative constant increment

	MODULE Test;
	VAR i: INTEGER;
	BEGIN FOR i := 0 TO 10 BY -1 DO END
	END Test.

negative: for statement with zero increment

	MODULE Test;
	VAR i: INTEGER;
	BEGIN FOR i := 0 TO 10 BY 0 DO END
	END Test.

negative: for statement with counter of type boolean

	MODULE Test;
	VAR i, s, e: BOOLEAN;
	BEGIN FOR i := s TO e DO END
	END Test.

negative: for statement with counter of type character

	MODULE Test;
	VAR i, s, e: CHAR;
	BEGIN FOR i := s TO e DO END
	END Test.

positive: for statement with counter of type short integer

	MODULE Test;
	VAR i, s, e: SHORTINT;
	BEGIN FOR i := s TO e DO END
	END Test.

positive: for statement with counter of type integer

	MODULE Test;
	VAR i, s, e: INTEGER;
	BEGIN FOR i := s TO e DO END
	END Test.

positive: for statement with counter of type long integer

	MODULE Test;
	VAR i, s, e: LONGINT;
	BEGIN FOR i := s TO e DO END
	END Test.

positive: for statement with counter of type huge integer

	MODULE Test;
	VAR i, s, e: HUGEINT;
	BEGIN FOR i := s TO e DO END
	END Test.

negative: for statement with counter of type real

	MODULE Test;
	VAR i, s, e: REAL;
	BEGIN FOR i := s TO e DO END
	END Test.

negative: for statement with counter of type long real

	MODULE Test;
	VAR i, s, e: REAL;
	BEGIN FOR i := s TO e DO END
	END Test.

negative: for statement with counter of type set

	MODULE Test;
	VAR i, s, e: SET;
	BEGIN FOR i := s TO e DO END
	END Test.

negative: for statement with counter of type array

	MODULE Test;
	VAR i, s, e: ARRAY 10 OF CHAR;
	BEGIN FOR i := s TO e DO END
	END Test.

negative: for statement with counter of type record

	MODULE Test;
	VAR i, s, e: RECORD END;
	BEGIN FOR i := s TO e DO END
	END Test.

negative: for statement with counter of type object

	MODULE Test;
	VAR i, s, e: OBJECT END;
	BEGIN FOR i := s TO e DO END
	END Test.

negative: for statement with counter of type pointer

	MODULE Test;
	VAR i, s, e: POINTER TO RECORD;
	BEGIN FOR i := s TO e DO END
	END Test.

negative: for statement with counter of type procedure

	MODULE Test;
	VAR i, s, e: PROCEDURE;
	BEGIN FOR i := s TO e DO END
	END Test.

positive: for statement with short integer counter and short integer start counter

	MODULE Test;
	VAR i, s: SHORTINT;
	BEGIN FOR i := s TO 10 DO END
	END Test.

negative: for statement with short integer counter and integer start counter

	MODULE Test;
	VAR i: SHORTINT; s: INTEGER;
	BEGIN FOR i := s TO 10 DO END
	END Test.

negative: for statement with short integer counter and long integer start counter

	MODULE Test;
	VAR i: SHORTINT; s: LONGINT;
	BEGIN FOR i := s TO 10 DO END
	END Test.

negative: for statement with short integer counter and huge integer start counter

	MODULE Test;
	VAR i: SHORTINT; s: HUGEINT;
	BEGIN FOR i := s TO 10 DO END
	END Test.

positive: for statement with integer counter and short integer start counter

	MODULE Test;
	VAR i: INTEGER; s: SHORTINT;
	BEGIN FOR i := s TO 10 DO END
	END Test.

positive: for statement with integer counter and integer start counter

	MODULE Test;
	VAR i, s: INTEGER;
	BEGIN FOR i := s TO 10 DO END
	END Test.

negative: for statement with integer counter and long integer start counter

	MODULE Test;
	VAR i: INTEGER; s: LONGINT;
	BEGIN FOR i := s TO 10 DO END
	END Test.

negative: for statement with integer counter and huge integer start counter

	MODULE Test;
	VAR i: INTEGER; s: HUGEINT;
	BEGIN FOR i := s TO 10 DO END
	END Test.

positive: for statement with long integer counter and short integer start counter

	MODULE Test;
	VAR i: LONGINT; s: SHORTINT;
	BEGIN FOR i := s TO 10 DO END
	END Test.

positive: for statement with long integer counter and integer start counter

	MODULE Test;
	VAR i: LONGINT; s: INTEGER;
	BEGIN FOR i := s TO 10 DO END
	END Test.

positive: for statement with long integer counter and long integer start counter

	MODULE Test;
	VAR i, s: LONGINT;
	BEGIN FOR i := s TO 10 DO END
	END Test.

negative: for statement with long integer counter and huge integer start counter

	MODULE Test;
	VAR i: LONGINT; s: HUGEINT;
	BEGIN FOR i := s TO 10 DO END
	END Test.

positive: for statement with huge integer counter and short integer start counter

	MODULE Test;
	VAR i: HUGEINT; s: SHORTINT;
	BEGIN FOR i := s TO 10 DO END
	END Test.

positive: for statement with huge integer counter and integer start counter

	MODULE Test;
	VAR i: HUGEINT; s: INTEGER;
	BEGIN FOR i := s TO 10 DO END
	END Test.

positive: for statement with huge integer counter and long integer start counter

	MODULE Test;
	VAR i: HUGEINT; s: LONGINT;
	BEGIN FOR i := s TO 10 DO END
	END Test.

positive: for statement with huge integer counter and huge integer start counter

	MODULE Test;
	VAR i, s: HUGEINT;
	BEGIN FOR i := s TO 10 DO END
	END Test.

positive: for statement with short integer counter and short integer end counter

	MODULE Test;
	VAR i, e: SHORTINT;
	BEGIN FOR i := 0 TO e DO END
	END Test.

negative: for statement with short integer counter and integer end counter

	MODULE Test;
	VAR i: SHORTINT; e: INTEGER;
	BEGIN FOR i := 0 TO e DO END
	END Test.

negative: for statement with short integer counter and long integer end counter

	MODULE Test;
	VAR i: SHORTINT; e: LONGINT;
	BEGIN FOR i := 0 TO e DO END
	END Test.

negative: for statement with short integer counter and huge integer end counter

	MODULE Test;
	VAR i: SHORTINT; e: HUGEINT;
	BEGIN FOR i := 0 TO e DO END
	END Test.

positive: for statement with integer counter and short integer end counter

	MODULE Test;
	VAR i: INTEGER; e: SHORTINT;
	BEGIN FOR i := 0 TO e DO END
	END Test.

positive: for statement with integer counter and integer end counter

	MODULE Test;
	VAR i, e: INTEGER;
	BEGIN FOR i := 0 TO e DO END
	END Test.

negative: for statement with integer counter and long integer end counter

	MODULE Test;
	VAR i: INTEGER; e: LONGINT;
	BEGIN FOR i := 0 TO e DO END
	END Test.

negative: for statement with integer counter and huge integer end counter

	MODULE Test;
	VAR i: INTEGER; e: HUGEINT;
	BEGIN FOR i := 0 TO e DO END
	END Test.

positive: for statement with long integer counter and short integer end counter

	MODULE Test;
	VAR i: LONGINT; e: SHORTINT;
	BEGIN FOR i := 0 TO e DO END
	END Test.

positive: for statement with long integer counter and integer end counter

	MODULE Test;
	VAR i: LONGINT; e: INTEGER;
	BEGIN FOR i := 0 TO e DO END
	END Test.

positive: for statement with long integer counter and long integer end counter

	MODULE Test;
	VAR i, e: LONGINT;
	BEGIN FOR i := 0 TO e DO END
	END Test.

negative: for statement with long integer counter and huge integer end counter

	MODULE Test;
	VAR i: LONGINT; e: HUGEINT;
	BEGIN FOR i := 0 TO e DO END
	END Test.

positive: for statement with huge integer counter and short integer end counter

	MODULE Test;
	VAR i: HUGEINT; e: SHORTINT;
	BEGIN FOR i := 0 TO e DO END
	END Test.

positive: for statement with huge integer counter and integer end counter

	MODULE Test;
	VAR i: HUGEINT; e: INTEGER;
	BEGIN FOR i := 0 TO e DO END
	END Test.

positive: for statement with huge integer counter and long integer end counter

	MODULE Test;
	VAR i: HUGEINT; e: LONGINT;
	BEGIN FOR i := 0 TO e DO END
	END Test.

positive: for statement with huge integer counter and huge integer end counter

	MODULE Test;
	VAR i, e: HUGEINT;
	BEGIN FOR i := 0 TO e DO END
	END Test.


# return statement

negative: return statement with value in module body

	MODULE Test;
	BEGIN RETURN 0
	END Test.

positive: return statement without value in module body

	MODULE Test;
	BEGIN RETURN
	END Test.

negative: return statement with value in object body

	MODULE Test;
	TYPE Object = OBJECT
	BEGIN RETURN 0
	END Object;
	END Test.

positive: return statement without value in object body

	MODULE Test;
	TYPE Object = OBJECT
	BEGIN RETURN
	END Object;
	END Test.

positive: return statement with value in procedure with return type

	MODULE Test;
	PROCEDURE Procedure (): INTEGER;
	BEGIN RETURN 0
	END Procedure;
	END Test.

negative: return statement without value in procedure with return type

	MODULE Test;
	PROCEDURE Procedure (): INTEGER;;
	BEGIN RETURN
	END Procedure;
	END Test.

negative: return statement with value in procedure without return type

	MODULE Test;
	PROCEDURE Procedure;
	BEGIN RETURN 0
	END Procedure;
	END Test.

positive: return statement without value in procedure without return type

	MODULE Test;
	PROCEDURE Procedure;
	BEGIN RETURN
	END Procedure;
	END Test.


# exit statement

negative: unbounded exit statement

	MODULE Test;
	BEGIN EXIT
	END Test.

positive: exit statement within loop

	MODULE Test;
	BEGIN LOOP EXIT END
	END Test.

negative: exit statement before loop

	MODULE Test;
	BEGIN EXIT ; LOOP END
	END Test.

negative: exit statement after loop

	MODULE Test;
	BEGIN LOOP END ; EXIT
	END Test.

positive: exit statement within nested loop

	MODULE Test;
	BEGIN LOOP LOOP EXIT END END
	END Test.

positive: exit statement before nested loop

	MODULE Test;
	BEGIN LOOP EXIT ; LOOP END END
	END Test.

positive: exit statement after nested loop

	MODULE Test;
	BEGIN LOOP LOOP END ; EXIT END
	END Test.
